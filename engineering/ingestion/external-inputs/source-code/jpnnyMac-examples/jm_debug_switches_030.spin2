'' =================================================================================================
''
''   File........ jm_debug_switches_030.spin2
''   Purpose..... Experiments with P2 DEBUG Plot window
''   Cogs Used... 0
''   Author...... Jon "JonnyMac" McPhalen
''                Copyright (c) 2025 Jon McPhalen
''                -- see below for terms of use
''   E-mail...... jon.mcphalen@gmail.com
''   Started.....
''   Updated..... 16 FEB 2025
''
'' =================================================================================================

{Spin2_v50}

con

  VERSION = 0_3_0


con { timing }

  CLK_FREQ = 200_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000                               ' ticks in 1us

' _xtlfreq = 20_000_000                                         ' 19_200_000 for "irregular" Edge
  _clkfreq = CLK_FREQ                                           ' set system clock


con { download / debug }

' download_baud = 230_400
' debug_baud    = download_baud
' debug_main                                                    ' full debugger


con { terminal }

  BR_TERM  = 230_400                                            ' terminal baud rate


con { fixed io pins }

  PGM_RX   = 63  { I }                                          ' programming / debug
  PGM_TX   = 62  { O }

  SF_CS    = 61  { O }                                          ' flash storage
  SF_SCLK  = 60  { O }
  SF_MOSI  = 59  { O }
  SF_MISO  = 58  { I }

  LED2     = 57  { O }                                          ' Eval and Edge LEDs
  LED1     = 56  { O }


con { app io pins }


con { application constants }

  #true,  ON, OFF
  #false, NO, YES


obj

' main                                                          ' * master Spin cog
' * uses cog when loaded


dat { pre-initialized }


con

  struct rect(x1, y1, x2, y2)


var { globals }

  long  radix
  long  displayval
  long  dirty

  rect  rtype                                                   ' radix indicator zone

  long  key                                                     ' PC key

  long  xpos                                                    ' PC mouse
  long  ypos
  long  wheeldelta
  long  lbutton
  long  mbutton
  long  rbutton
  long  pixel


pub main()

  setup()

  displayval, dirty := 0, true

  repeat
    check_key()
    check_mouse()
    if (dirty)
      show_value(displayval, radix)
      debug(`switches update)
      dirty := false
      waitms(250)
    waitms(100)


pub check_key()

  debug(`switches `pc_key(@key))                                ' read PC keyboard

  if (key)
    case key
      "d", "D" : set_radix(10)
      "h", "H" : set_radix(16)
      "b", "B" : set_radix(02)
      "o", "O" : set_radix(08)                                  ' not native to Parallax
      " "      : reset_value()


pub check_mouse()

  debug(`switches `pc_mouse(@xpos))                             ' read PC mouse

  if (lbutton)
    if (in_zone(xpos, ypos, @rtype))
      next_radix()                                            ' bump
      lbutton := false
      rbutton := false
      return

' toggle switch if clicked

  if (lbutton)
    if (ypos >= 129) && (ypos <= 179)                           ' posible switch?
      case xpos
        265..285 : toggle_bit(0)
        232..252 : toggle_bit(1)
        199..219 : toggle_bit(2)
        166..186 : toggle_bit(3)
        133..153 : toggle_bit(4)
        100..120 : toggle_bit(5)
        067..087 : toggle_bit(6)
        034..064 : toggle_bit(7)
    return

  if (rbutton)
    next_radix()
    return

  if (mbutton)
    reset_value()


pub reset_value()

  displayval := 0
  debug(`switches crop 1 25 122 270 60)
  dirty := true


pub toggle_bit(b) | layer

  displayval ^= 1 << b

  layer := displayval.[b] + 1

  case b
    0 : debug(`switches crop `(layer) 265 129 21 51)
    1 : debug(`switches crop `(layer) 232 129 21 51)
    2 : debug(`switches crop `(layer) 199 129 21 51)
    3 : debug(`switches crop `(layer) 166 129 21 51)
    4 : debug(`switches crop `(layer) 133 129 21 51)
    5 : debug(`switches crop `(layer) 100 129 21 51)
    6 : debug(`switches crop `(layer)  67 129 21 51)
    7 : debug(`switches crop `(layer)  34 129 21 51)

  dirty := true


pub next_radix()

  case radix
    10 : set_radix(16)
    16 : set_radix(02)
    02 : set_radix(08)
    08 : set_radix(10)


pub set_radix(newbase)

  case newbase
    16 :
      if (radix <> 16)
        radix := 16
        debug(`switches crop 4 52 0 52 26 134 81)               ' show radix
        debug(`switches crop 5 0  5 252 5 34 186)               ' underline digit bits
        dirty := true

    02 :
      if (radix <> 2)
        radix := 2
        debug(`switches crop 4 104 0 52 26 134 81)
        debug(`switches crop 5 0 10 252 5 34 186)
        dirty := true

    08 :
      if (radix <> 8)
        radix := 8
        debug(`switches crop 4 156 0 52 26 134 81)
        debug(`switches crop 5 0 15 252 5 34 186)
        dirty := true

    other :                                                     ' default to decimal
      if (radix <> 10)
        radix := 10
        debug(`switches crop 4 0 0 52 26 134 81)
        debug(`switches crop 5 0 0 252 5 34 186)
        dirty := true


pub show_radix_bits()

  debug(`switches crop 5 0 0 252 5)                        ' clear bits indicators

  case radix
    16 :
    02 :
    08 :


pub show_value(value, base) : s | i, d, x1, x2

  case radix
    10 : value :=  -9999999 #> value <# 99999999
    16 : value &= $FFFFFFFF
    02 : value &= %11111111
    08 : value &= %111_111_111_111_111_111_111_111

  if (radix == 10) && (value < 0)
    s := true
    -= value

  debug(`switches crop 1 25 25 270 56)                          ' blank display

  repeat 8 with i
    d := value // radix                                         ' extract dight
    x1 := 259 - (33 * i)                                        ' locate in display
    if (i == 0) || (radix == 2) || (value)                      ' something to print?
      x2 := d * 33                                              ' locate digit in map
      debug(`switches crop 3 `(x2, 0, 33, 50, x1, 28))          ' place digit
      value /= radix                                            ' next digit
    else
      if (radix == 10) && (s)
        debug(`switches crop 3 `(528, 0, 33, 50, x1, 28))       ' sign if negative
      quit                                                      ' nothing else to print


pub in_zone(x, y, ^rect zone) : result

'' Return true if point x,y is located in zone

  if (x >= zone.x1) && (x <= zone.x2)
    if (y >= zone.y1) && (y <= zone.y2)
      return true


pub setup()

'' Setup IO and objects for application

  debug(`plot switches title 'Binary Switches' size 320 200 pos 650 200 hidexy update)

  debug(`switches cartesian 1)
  debug(`switches layer 1 'p2_debug_swtiches0.bmp')
  debug(`switches layer 2 'p2_debug_swtiches1.bmp')
  debug(`switches layer 3 'hex_digits.bmp')
  debug(`switches layer 4 'dhbo.bmp')
  debug(`switches layer 5 'radix_bits.bmp')
  debug(`switches crop 1)

  set_radix(10)

  debug(`switches update)

  rtype := 134, 81, 185, 106                                    ' radix indicator coordinates


pri reboot()

  hubset($1000_0000)


con { license }

{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}