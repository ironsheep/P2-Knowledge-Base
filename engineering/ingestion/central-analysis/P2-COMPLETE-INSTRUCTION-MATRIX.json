[
  {
    "order": "1",
    "mnemonic": "NOP",
    "group": "Miscellaneous",
    "encoding": "0000 0000000 000 000000000 000000000",
    "alias": ".",
    "description": "No operation.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "2",
    "mnemonic": "ROR     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate right.           D = [31:0]  of ({D[31:0], D[31:0]}     >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0].  *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "3",
    "mnemonic": "ROL     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate left.            D = [63:32] of ({D[31:0], D[31:0]}     << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "4",
    "mnemonic": "SHR     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Shift right.            D = [31:0]  of ({32'b0, D[31:0]}       >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0].  *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "5",
    "mnemonic": "SHL     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Shift left.             D = [63:32] of ({D[31:0], 32'b0}       << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "6",
    "mnemonic": "RCR     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate carry right.     D = [31:0]  of ({{32{C}}, D[31:0]}     >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0].  *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "7",
    "mnemonic": "RCL     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate carry left.      D = [63:32] of ({D[31:0], {32{C}}}     << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "8",
    "mnemonic": "SAR     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Shift arithmetic right. D = [31:0]  of ({{32{D[31]}}, D[31:0]} >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0].  *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "9",
    "mnemonic": "SAL     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0000111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Shift arithmetic left.  D = [63:32] of ({D[31:0], {32{D[0]}}}  << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "10",
    "mnemonic": "ADD     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Add S into D.                                  D = D + S.        C = carry of (D + S).               *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "11",
    "mnemonic": "ADDX    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Add (S + C) into D, extended.                  D = D + S + C.    C = carry of (D + S + C).           Z = Z AND (result == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "12",
    "mnemonic": "ADDS    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Add S into D, signed.                          D = D + S.        C = correct sign of (D + S).        *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "13",
    "mnemonic": "ADDSX   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Add (S + C) into D, signed and extended.       D = D + S + C.    C = correct sign of (D + S + C).    Z = Z AND (result == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "14",
    "mnemonic": "SUB     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Subtract S from D.                             D = D - S.        C = borrow of (D - S).              *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "15",
    "mnemonic": "SUBX    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Subtract (S + C) from D, extended.             D = D - (S + C).  C = borrow of (D - (S + C)).        Z = Z AND (result == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "16",
    "mnemonic": "SUBS    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Subtract S from D, signed.                     D = D - S.        C = correct sign of (D - S).        *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "17",
    "mnemonic": "SUBSX   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0001111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Subtract (S + C) from D, signed and extended.  D = D - (S + C).  C = correct sign of (D - (S + C)).  Z = Z AND (result == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "18",
    "mnemonic": "CMP     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare D to S.                                                  C = borrow of (D - S).              Z = (D == S).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "19",
    "mnemonic": "CMPX    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare D to (S + C), extended.                                  C = borrow of (D - (S + C)).        Z = Z AND (D == S + C).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "20",
    "mnemonic": "CMPS    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare D to S, signed.                                          C = correct sign of (D - S).        Z = (D == S).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "21",
    "mnemonic": "CMPSX   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare D to (S + C), signed and extended.                       C = correct sign of (D - (S + C)).  Z = Z AND (D == S + C).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "22",
    "mnemonic": "CMPR    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare S to D (reverse).                                        C = borrow of (S - D).              Z = (D == S).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "23",
    "mnemonic": "CMPM    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare D to S, get MSB of difference into C.                    C = MSB of (D - S).                 Z = (D == S).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "24",
    "mnemonic": "SUBR    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Subtract D from S (reverse).                   D = S - D.        C = borrow of (S - D).              *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "25",
    "mnemonic": "CMPSUB  D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0010111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Compare and subtract S from D if D >= S. If D => S then D = D - S and C = 1, else D same and C = 0.  *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "26",
    "mnemonic": "FGE     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Force D >= S. If D < S then D = S and C = 1, else D same and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "27",
    "mnemonic": "FLE     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Force D <= S. If D > S then D = S and C = 1, else D same and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "28",
    "mnemonic": "FGES    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Force D >= S, signed. If D < S then D = S and C = 1, else D same and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "29",
    "mnemonic": "FLES    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Force D <= S, signed. If D > S then D = S and C = 1, else D same and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "30",
    "mnemonic": "SUMC    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Sum +/-S into D by  C. If C = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "31",
    "mnemonic": "SUMNC   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Sum +/-S into D by !C. If C = 0 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "32",
    "mnemonic": "SUMZ    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Sum +/-S into D by  Z. If Z = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "33",
    "mnemonic": "SUMNZ   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0011111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Sum +/-S into D by !Z. If Z = 0 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "34",
    "mnemonic": "TESTB   D,{#}S         WC/WZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of  D, write to C/Z. C/Z =          D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "35",
    "mnemonic": "TESTBN  D,{#}S         WC/WZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of !D, write to C/Z. C/Z =         !D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "36",
    "mnemonic": "TESTB   D,{#}S     ANDC/ANDZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of  D, AND into C/Z. C/Z = C/Z AND  D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "37",
    "mnemonic": "TESTBN  D,{#}S     ANDC/ANDZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of !D, AND into C/Z. C/Z = C/Z AND !D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "38",
    "mnemonic": "TESTB   D,{#}S       ORC/ORZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of  D, OR  into C/Z. C/Z = C/Z OR   D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "39",
    "mnemonic": "TESTBN  D,{#}S       ORC/ORZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of !D, OR  into C/Z. C/Z = C/Z OR  !D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "40",
    "mnemonic": "TESTB   D,{#}S     XORC/XORZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of  D, XOR into C/Z. C/Z = C/Z XOR  D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "41",
    "mnemonic": "TESTBN  D,{#}S     XORC/XORZ",
    "group": "Math and Logic",
    "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test bit S[4:0] of !D, XOR into C/Z. C/Z = C/Z XOR !D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "42",
    "mnemonic": "BITL    D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = 0.    Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "43",
    "mnemonic": "BITH    D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = 1.    Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "44",
    "mnemonic": "BITC    D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = C.    Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "45",
    "mnemonic": "BITNC   D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = !C.   Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "46",
    "mnemonic": "BITZ    D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = Z.    Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "47",
    "mnemonic": "BITNZ   D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = !Z.   Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "48",
    "mnemonic": "BITRND  D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Bits D[S[9:5]+S[4:0]:S[4:0]] = RNDs. Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "49",
    "mnemonic": "BITNOT  D,{#}S         {WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Toggle bits D[S[9:5]+S[4:0]:S[4:0]]. Other bits unaffected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "50",
    "mnemonic": "AND     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "AND S into D.    D = D & S.    C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "51",
    "mnemonic": "ANDN    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "AND !S into D.   D = D & !S.   C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "52",
    "mnemonic": "OR      D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "OR S into D.     D = D | S.    C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "53",
    "mnemonic": "XOR     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "XOR S into D.    D = D ^ S.    C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "54",
    "mnemonic": "MUXC    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Mux  C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ C}}). C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "55",
    "mnemonic": "MUXNC   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Mux !C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{!C}}). C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "56",
    "mnemonic": "MUXZ    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Mux  Z into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ Z}}). C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "57",
    "mnemonic": "MUXNZ   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0101111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Mux !Z into each D bit that is '1' in S. D = (!S & D ) | (S & {32{!Z}}). C = parity of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "58",
    "mnemonic": "MOV     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Move S into D. D = S. C = S[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "59",
    "mnemonic": "NOT     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get !S into D. D = !S. C = !S[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "60",
    "mnemonic": "NOT     D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110001 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Get !D into D. D = !D. C = !D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "61",
    "mnemonic": "ABS     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get absolute value of S into D. D = ABS(S). C = S[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "62",
    "mnemonic": "ABS     D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110010 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Get absolute value of D into D. D = ABS(D). C = D[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "63",
    "mnemonic": "NEG     D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Negate S into D. D = -S. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "64",
    "mnemonic": "NEG     D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110011 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Negate D.        D = -D. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "65",
    "mnemonic": "NEGC    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Negate S by  C into D. If C = 1 then D = -S, else D = S. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "66",
    "mnemonic": "NEGC    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110100 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Negate D by  C.        If C = 1 then D = -D, else D = D. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "67",
    "mnemonic": "NEGNC   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Negate S by !C into D. If C = 0 then D = -S, else D = S. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "68",
    "mnemonic": "NEGNC   D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110101 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Negate D by !C.        If C = 0 then D = -D, else D = D. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "69",
    "mnemonic": "NEGZ    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Negate S by  Z into D. If Z = 1 then D = -S, else D = S. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "70",
    "mnemonic": "NEGZ    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110110 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Negate D by  Z.        If Z = 1 then D = -D, else D = D. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "71",
    "mnemonic": "NEGNZ   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Negate S by !Z into D. If Z = 0 then D = -S, else D = S. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "72",
    "mnemonic": "NEGNZ   D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0110111 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Negate D by !Z.        If Z = 0 then D = -D, else D = D. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "73",
    "mnemonic": "INCMOD  D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Increment with modulus. If D = S then D = 0 and C = 1, else D = D + 1 and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "74",
    "mnemonic": "DECMOD  D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decrement with modulus. If D = 0 then D = S and C = 1, else D = D - 1 and C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "75",
    "mnemonic": "ZEROX   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111010 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Zero-extend D above bit S[4:0]. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "76",
    "mnemonic": "SIGNX   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111011 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Sign-extend D from bit S[4:0]. C = MSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "77",
    "mnemonic": "ENCOD   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111100 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get bit position of top-most '1' in S into D. D = position of top '1' in S (0..31). C = (S != 0). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "78",
    "mnemonic": "ENCOD   D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111100 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Get bit position of top-most '1' in D into D. D = position of top '1' in S (0..31). C = (S != 0). *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "79",
    "mnemonic": "ONES    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get number of '1's in S into D. D = number of '1's in S (0..32). C = LSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "80",
    "mnemonic": "ONES    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111101 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Get number of '1's in D into D. D = number of '1's in S (0..32). C = LSB of result. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "81",
    "mnemonic": "TEST    D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D with S. C = parity of (D & S). Z = ((D & S) == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "82",
    "mnemonic": "TEST    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111110 CZ0 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Test D. C = parity of D. Z = (D == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "83",
    "mnemonic": "TESTN   D,{#}S   {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 0111111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D with !S. C = parity of (D & !S). Z = ((D & !S) == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "84",
    "mnemonic": "SETNIB  D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 100000N NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set S[3:0] into nibble N in D, keeping rest of D same.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "85",
    "mnemonic": "SETNIB  {#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1000000 00I 000000000 SSSSSSSSS",
    "alias": "alias",
    "description": "Set S[3:0] into nibble established by prior ALTSN instruction.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "86",
    "mnemonic": "GETNIB  D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 100001N NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get nibble N of S into D. D = {28'b0, S.NIBBLE[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "87",
    "mnemonic": "GETNIB  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1000010 000 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Get nibble established by prior ALTGN instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "88",
    "mnemonic": "ROLNIB  D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 100010N NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate-left nibble N of S into D. D = {D[27:0], S.NIBBLE[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "89",
    "mnemonic": "ROLNIB  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1000100 000 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Rotate-left nibble established by prior ALTGN instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "90",
    "mnemonic": "SETBYTE D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1000110 NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set S[7:0] into byte N in D, keeping rest of D same.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "91",
    "mnemonic": "SETBYTE {#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1000110 00I 000000000 SSSSSSSSS",
    "alias": "alias",
    "description": "Set S[7:0] into byte established by prior ALTSB instruction.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "92",
    "mnemonic": "GETBYTE D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1000111 NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get byte N of S into D. D = {24'b0, S.BYTE[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "93",
    "mnemonic": "GETBYTE D",
    "group": "Math and Logic",
    "encoding": "EEEE 1000111 000 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Get byte established by prior ALTGB instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "94",
    "mnemonic": "ROLBYTE D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1001000 NNI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate-left byte N of S into D. D = {D[23:0], S.BYTE[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "95",
    "mnemonic": "ROLBYTE D",
    "group": "Math and Logic",
    "encoding": "EEEE 1001000 000 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Rotate-left byte established by prior ALTGB instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "96",
    "mnemonic": "SETWORD D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1001001 0NI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set S[15:0] into word N in D, keeping rest of D same.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "97",
    "mnemonic": "SETWORD {#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001001 00I 000000000 SSSSSSSSS",
    "alias": "alias",
    "description": "Set S[15:0] into word established by prior ALTSW instruction.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "98",
    "mnemonic": "GETWORD D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1001001 1NI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get word N of S into D. D = {16'b0, S.WORD[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "99",
    "mnemonic": "GETWORD D",
    "group": "Math and Logic",
    "encoding": "EEEE 1001001 100 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Get word established by prior ALTGW instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "100",
    "mnemonic": "ROLWORD D,{#}S,#N",
    "group": "Math and Logic",
    "encoding": "EEEE 1001010 0NI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Rotate-left word N of S into D. D = {D[15:0], S.WORD[N]).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "101",
    "mnemonic": "ROLWORD D",
    "group": "Math and Logic",
    "encoding": "EEEE 1001010 000 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Rotate-left word established by prior ALTGW instruction into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "102",
    "mnemonic": "ALTSN   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001010 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent SETNIB instruction. Next D field = (D[11:3] + S) & $1FF, N field = D[2:0].          D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "103",
    "mnemonic": "ALTSN   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001010 101 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent SETNIB instruction. Next D field = D[11:3], N field = D[2:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "104",
    "mnemonic": "ALTGN   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001010 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent GETNIB/ROLNIB instruction. Next S field = (D[11:3] + S) & $1FF, N field = D[2:0].   D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "105",
    "mnemonic": "ALTGN   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001010 111 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent GETNIB/ROLNIB instruction. Next S field = D[11:3], N field = D[2:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "106",
    "mnemonic": "ALTSB   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent SETBYTE instruction. Next D field = (D[10:2] + S) & $1FF, N field = D[1:0].         D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "107",
    "mnemonic": "ALTSB   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 001 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent SETBYTE instruction. Next D field = D[10:2], N field = D[1:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "108",
    "mnemonic": "ALTGB   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent GETBYTE/ROLBYTE instruction. Next S field = (D[10:2] + S) & $1FF, N field = D[1:0]. D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "109",
    "mnemonic": "ALTGB   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 011 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent GETBYTE/ROLBYTE instruction. Next S field = D[10:2], N field = D[1:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "110",
    "mnemonic": "ALTSW   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent SETWORD instruction. Next D field = (D[9:1] + S) & $1FF, N field = D[0].            D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "111",
    "mnemonic": "ALTSW   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 101 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent SETWORD instruction. Next D field = D[9:1], N field = D[0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "112",
    "mnemonic": "ALTGW   D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter subsequent GETWORD/ROLWORD instruction. Next S field = ((D[9:1] + S) & $1FF), N field = D[0].  D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "113",
    "mnemonic": "ALTGW   D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001011 111 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter subsequent GETWORD/ROLWORD instruction. Next S field = D[9:1], N field = D[0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "114",
    "mnemonic": "ALTR    D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter result register address (normally D field) of next instruction to (D + S) & $1FF.              D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "115",
    "mnemonic": "ALTR    D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 001 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter result register address (normally D field) of next instruction to D[8:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "116",
    "mnemonic": "ALTD    D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter D field of next instruction to (D + S) & $1FF.                                                 D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "117",
    "mnemonic": "ALTD    D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 011 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter D field of next instruction to D[8:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "118",
    "mnemonic": "ALTS    D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter S field of next instruction to (D + S) & $1FF.                                                 D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "119",
    "mnemonic": "ALTS    D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 101 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter S field of next instruction to D[8:0].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "120",
    "mnemonic": "ALTB    D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alter D field of next instruction to (D[13:5] + S) & $1FF.                                           D += sign-extended S[17:9].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "121",
    "mnemonic": "ALTB    D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001100 111 DDDDDDDDD 000000000",
    "alias": "alias",
    "description": "Alter D field of next instruction to D[13:5].",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "122",
    "mnemonic": "ALTI    D,{#}S",
    "group": "Register Indirection",
    "encoding": "EEEE 1001101 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Substitute next instruction's I/R/D/S fields with fields from D, per S. Modify D per S.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "123",
    "mnemonic": "ALTI    D",
    "group": "Register Indirection",
    "encoding": "EEEE 1001101 001 DDDDDDDDD 101100100",
    "alias": "alias",
    "description": "Execute D in place of next instruction. D stays same.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "124",
    "mnemonic": "SETR    D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001101 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set R field of D to S[8:0]. D = {D[31:28], S[8:0], D[18:0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "125",
    "mnemonic": "SETD    D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001101 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set D field of D to S[8:0]. D = {D[31:18], S[8:0], D[8:0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "126",
    "mnemonic": "SETS    D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001101 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set S field of D to S[8:0]. D = {D[31:9], S[8:0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "127",
    "mnemonic": "DECOD   D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decode S[4:0] into D. D = 1 << S[4:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "128",
    "mnemonic": "DECOD   D",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 000 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Decode D[4:0] into D. D = 1 << D[4:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "129",
    "mnemonic": "BMASK   D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Get LSB-justified bit mask of size (S[4:0] + 1) into D. D = ($0000_0002 << S[4:0]) - 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "130",
    "mnemonic": "BMASK   D",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 010 DDDDDDDDD DDDDDDDDD",
    "alias": "alias",
    "description": "Get LSB-justified bit mask of size (D[4:0] + 1) into D. D = ($0000_0002 << D[4:0]) - 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "131",
    "mnemonic": "CRCBIT  D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Iterate CRC value in D using C and polynomial in S. If (C XOR D[0]) then D = (D >> 1) XOR S, else D = (D >> 1).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "132",
    "mnemonic": "CRCNIB  D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001110 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Iterate CRC value in D using Q[31:28] and polynomial in S. Like CRCBIT x 4. Q = Q << 4. Use 'REP #n,#1'+SETQ+CRCNIB+CRCNIB+CRCNIB...",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "133",
    "mnemonic": "MUXNITS D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001111 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "For each non-zero bit pair in S, copy that bit pair into the corresponding D bits, else leave that D bit pair the same.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "134",
    "mnemonic": "MUXNIBS D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001111 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "For each non-zero nibble in S, copy that nibble into the corresponding D nibble, else leave that D nibble the same.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "135",
    "mnemonic": "MUXQ    D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001111 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Used after SETQ. For each '1' bit in Q, copy the corresponding bit in S into D. D = (D & !Q) | (S & Q).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "136",
    "mnemonic": "MOVBYTS D,{#}S",
    "group": "Math and Logic",
    "encoding": "EEEE 1001111 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Move bytes within D, per S. D = {D.BYTE[S[7:6]], D.BYTE[S[5:4]], D.BYTE[S[3:2]], D.BYTE[S[1:0]]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "137",
    "mnemonic": "MUL     D,{#}S          {WZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1010000 0ZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "D = unsigned (D[15:0] * S[15:0]). Z = (S == 0) | (D == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "138",
    "mnemonic": "MULS    D,{#}S          {WZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1010000 1ZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "D = signed (D[15:0] * S[15:0]).   Z = (S == 0) | (D == 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "139",
    "mnemonic": "SCA     D,{#}S          {WZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1010001 0ZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Next instruction's S value = unsigned (D[15:0] * S[15:0]) >> 16. *",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "140",
    "mnemonic": "SCAS    D,{#}S          {WZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1010001 1ZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Next instruction's S value = signed (D[15:0] * S[15:0]) >> 14. In this scheme, $4000 = 1.0 and $C000 = -1.0. *",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "141",
    "mnemonic": "ADDPIX  D,{#}S",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1010010 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Add bytes of S into bytes of D, with $FF saturation.",
    "interrupt_shield": "",
    "cog_lut_timing": "7",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "142",
    "mnemonic": "MULPIX  D,{#}S",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1010010 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Multiply bytes of S into bytes of D, where $FF = 1.0 and $00 = 0.0.",
    "interrupt_shield": "",
    "cog_lut_timing": "7",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "143",
    "mnemonic": "BLNPIX  D,{#}S",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1010010 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Alpha-blend bytes of S into bytes of D, using SETPIV value.",
    "interrupt_shield": "",
    "cog_lut_timing": "7",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "144",
    "mnemonic": "MIXPIX  D,{#}S",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1010010 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Mix bytes of S into bytes of D, using SETPIX and SETPIV values.",
    "interrupt_shield": "",
    "cog_lut_timing": "7",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "145",
    "mnemonic": "ADDCT1  D,{#}S",
    "group": "Events - Configuration",
    "encoding": "EEEE 1010011 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set CT1 event to trigger on CT = D + S. Adds S into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "146",
    "mnemonic": "ADDCT2  D,{#}S",
    "group": "Events - Configuration",
    "encoding": "EEEE 1010011 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set CT2 event to trigger on CT = D + S. Adds S into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "147",
    "mnemonic": "ADDCT3  D,{#}S",
    "group": "Events - Configuration",
    "encoding": "EEEE 1010011 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set CT3 event to trigger on CT = D + S. Adds S into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "148",
    "mnemonic": "WMLONG  D,{#}S/P",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1010011 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Write only non-$00 bytes in D[31:0] to hub address {#}S/PTRx.     Prior SETQ/SETQ2 invokes cog/LUT block transfer.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10 *",
    "hub_timing": "3...20 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "149",
    "mnemonic": "RQPIN   D,{#}S          {WC}",
    "group": "Smart Pins",
    "encoding": "EEEE 1010100 C0I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read smart pin S[5:0] result \"Z\" into D, don't acknowledge smart pin (\"Q\" in RQPIN means \"quiet\"). C = modal result.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "150",
    "mnemonic": "RDPIN   D,{#}S          {WC}",
    "group": "Smart Pins",
    "encoding": "EEEE 1010100 C1I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read smart pin S[5:0] result \"Z\" into D, acknowledge smart pin. C = modal result.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "151",
    "mnemonic": "RDLUT   D,{#}S/P {WC/WZ/WCZ}",
    "group": "Lookup Table",
    "encoding": "EEEE 1010101 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read data from LUT address {#}S/PTRx into D. C = MSB of data. *",
    "interrupt_shield": "",
    "cog_lut_timing": "3",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "152",
    "mnemonic": "RDBYTE  D,{#}S/P {WC/WZ/WCZ}",
    "group": "Hub RAM - Read",
    "encoding": "EEEE 1010110 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read zero-extended byte from hub address {#}S/PTRx into D. C = MSB of byte. *",
    "interrupt_shield": "",
    "cog_lut_timing": "9...16",
    "hub_timing": "9...26",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "153",
    "mnemonic": "RDWORD  D,{#}S/P {WC/WZ/WCZ}",
    "group": "Hub RAM - Read",
    "encoding": "EEEE 1010111 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read zero-extended word from hub address {#}S/PTRx into D. C = MSB of word. *",
    "interrupt_shield": "",
    "cog_lut_timing": "9...16 *",
    "hub_timing": "9...26 *",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "154",
    "mnemonic": "RDLONG  D,{#}S/P {WC/WZ/WCZ}",
    "group": "Hub RAM - Read",
    "encoding": "EEEE 1011000 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Read long from hub address {#}S/PTRx into D. C = MSB of long. *   Prior SETQ/SETQ2 invokes cog/LUT block transfer.",
    "interrupt_shield": "",
    "cog_lut_timing": "9...16 *",
    "hub_timing": "9...26 *",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "155",
    "mnemonic": "POPA    D        {WC/WZ/WCZ}",
    "group": "Hub RAM - Read",
    "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 101011111",
    "alias": "alias",
    "description": "Read long from hub address --PTRA into D. C = MSB of long. *",
    "interrupt_shield": "",
    "cog_lut_timing": "9...16 *",
    "hub_timing": "9...26 *",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "156",
    "mnemonic": "POPB    D        {WC/WZ/WCZ}",
    "group": "Hub RAM - Read",
    "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 111011111",
    "alias": "alias",
    "description": "Read long from hub address --PTRB into D. C = MSB of long. *",
    "interrupt_shield": "",
    "cog_lut_timing": "9...16 *",
    "hub_timing": "9...26 *",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "157",
    "mnemonic": "CALLD   D,{#}S   {WC/WZ/WCZ}",
    "group": "Branch S - Call",
    "encoding": "EEEE 1011001 CZI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Call to S** by writing {C, Z, 10'b0, PC[19:0]} to D.                    C = S[31], Z = S[30].",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "158",
    "mnemonic": "RESI3",
    "group": "Branch S - Resume",
    "encoding": "EEEE 1011001 110 111110000 111110001",
    "alias": "alias",
    "description": "Resume from INT3. (CALLD $1F0,$1F1 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "159",
    "mnemonic": "RESI2",
    "group": "Branch S - Resume",
    "encoding": "EEEE 1011001 110 111110010 111110011",
    "alias": "alias",
    "description": "Resume from INT2. (CALLD $1F2,$1F3 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "160",
    "mnemonic": "RESI1",
    "group": "Branch S - Resume",
    "encoding": "EEEE 1011001 110 111110100 111110101",
    "alias": "alias",
    "description": "Resume from INT1. (CALLD $1F4,$1F5 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "161",
    "mnemonic": "RESI0",
    "group": "Branch S - Resume",
    "encoding": "EEEE 1011001 110 111111110 111111111",
    "alias": "alias",
    "description": "Resume from INT0. (CALLD $1FE,$1FF WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "162",
    "mnemonic": "RETI3",
    "group": "Branch S - Return",
    "encoding": "EEEE 1011001 110 111111111 111110001",
    "alias": "alias",
    "description": "Return from INT3. (CALLD $1FF,$1F1 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "163",
    "mnemonic": "RETI2",
    "group": "Branch S - Return",
    "encoding": "EEEE 1011001 110 111111111 111110011",
    "alias": "alias",
    "description": "Return from INT2. (CALLD $1FF,$1F3 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "164",
    "mnemonic": "RETI1",
    "group": "Branch S - Return",
    "encoding": "EEEE 1011001 110 111111111 111110101",
    "alias": "alias",
    "description": "Return from INT1. (CALLD $1FF,$1F5 WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "165",
    "mnemonic": "RETI0",
    "group": "Branch S - Return",
    "encoding": "EEEE 1011001 110 111111111 111111111",
    "alias": "alias",
    "description": "Return from INT0. (CALLD $1FF,$1FF WCZ)",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "166",
    "mnemonic": "CALLPA  {#}D,{#}S",
    "group": "Branch S - Call",
    "encoding": "EEEE 1011010 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Call to S** by pushing {C, Z, 10'b0, PC[19:0]} onto stack, copy D to PA.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "PA",
    "hub_rw": "",
    "stack_rw": "Push"
  },
  {
    "order": "167",
    "mnemonic": "CALLPB  {#}D,{#}S",
    "group": "Branch S - Call",
    "encoding": "EEEE 1011010 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Call to S** by pushing {C, Z, 10'b0, PC[19:0]} onto stack, copy D to PB.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "PB",
    "hub_rw": "",
    "stack_rw": "Push"
  },
  {
    "order": "168",
    "mnemonic": "DJZ     D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011011 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decrement D and jump to S** if result is zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "169",
    "mnemonic": "DJNZ    D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011011 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decrement D and jump to S** if result is not zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "170",
    "mnemonic": "DJF     D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011011 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decrement D and jump to S** if result is $FFFF_FFFF.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "171",
    "mnemonic": "DJNF    D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011011 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Decrement D and jump to S** if result is not $FFFF_FFFF.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "172",
    "mnemonic": "IJZ     D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011100 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Increment D and jump to S** if result is zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "173",
    "mnemonic": "IJNZ    D,{#}S",
    "group": "Branch S - Mod & Test",
    "encoding": "EEEE 1011100 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Increment D and jump to S** if result is not zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "174",
    "mnemonic": "TJZ     D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011100 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "175",
    "mnemonic": "TJNZ    D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011100 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is not zero.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "176",
    "mnemonic": "TJF     D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011101 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is full (D = $FFFF_FFFF).",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "177",
    "mnemonic": "TJNF    D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011101 01I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is not full (D != $FFFF_FFFF).",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "178",
    "mnemonic": "TJS     D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011101 10I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is signed (D[31] = 1).",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "179",
    "mnemonic": "TJNS    D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011101 11I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D is not signed (D[31] = 0).",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "180",
    "mnemonic": "TJV     D,{#}S",
    "group": "Branch S - Test",
    "encoding": "EEEE 1011110 00I DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Test D and jump to S** if D overflowed (D[31] != C, C = 'correct sign' from last addition/subtraction).",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "181",
    "mnemonic": "JINT    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000000 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if INT event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "182",
    "mnemonic": "JCT1    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000001 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT1 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "183",
    "mnemonic": "JCT2    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000010 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT2 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "184",
    "mnemonic": "JCT3    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000011 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT3 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "185",
    "mnemonic": "JSE1    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000100 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE1 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "186",
    "mnemonic": "JSE2    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000101 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE2 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "187",
    "mnemonic": "JSE3    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000110 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE3 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "188",
    "mnemonic": "JSE4    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000000111 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE4 event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "189",
    "mnemonic": "JPAT    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001000 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if PAT event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "190",
    "mnemonic": "JFBW    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001001 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if FBW event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "191",
    "mnemonic": "JXMT    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001010 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XMT event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "192",
    "mnemonic": "JXFI    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001011 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XFI event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "193",
    "mnemonic": "JXRO    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001100 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XRO event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "194",
    "mnemonic": "JXRL    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001101 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XRL event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "195",
    "mnemonic": "JATN    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001110 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if ATN event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "196",
    "mnemonic": "JQMT    {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000001111 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if QMT event flag is set.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "197",
    "mnemonic": "JNINT   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010000 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if INT event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "198",
    "mnemonic": "JNCT1   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010001 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT1 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "199",
    "mnemonic": "JNCT2   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010010 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT2 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "200",
    "mnemonic": "JNCT3   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010011 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if CT3 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "201",
    "mnemonic": "JNSE1   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010100 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE1 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "202",
    "mnemonic": "JNSE2   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010101 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE2 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "203",
    "mnemonic": "JNSE3   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010110 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE3 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "204",
    "mnemonic": "JNSE4   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000010111 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if SE4 event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "205",
    "mnemonic": "JNPAT   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011000 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if PAT event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "206",
    "mnemonic": "JNFBW   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011001 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if FBW event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "207",
    "mnemonic": "JNXMT   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011010 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XMT event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "208",
    "mnemonic": "JNXFI   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011011 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XFI event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "209",
    "mnemonic": "JNXRO   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011100 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XRO event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "210",
    "mnemonic": "JNXRL   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011101 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if XRL event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "211",
    "mnemonic": "JNATN   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011110 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if ATN event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "212",
    "mnemonic": "JNQMT   {#}S",
    "group": "Events - Branch",
    "encoding": "EEEE 1011110 01I 000011111 SSSSSSSSS",
    "alias": ".",
    "description": "Jump to S** if QMT event flag is clear.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or 4",
    "hub_timing": "2 or 13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "213",
    "mnemonic": "<empty> {#}D,{#}S",
    "group": "Miscellaneous",
    "encoding": "EEEE 1011110 1LI DDDDDDDDD SSSSSSSSS",
    "alias": "",
    "description": "<empty>",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "214",
    "mnemonic": "<empty> {#}D,{#}S",
    "group": "Miscellaneous",
    "encoding": "EEEE 1011111 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "<empty>",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "215",
    "mnemonic": "SETPAT  {#}D,{#}S",
    "group": "Events - Configuration",
    "encoding": "EEEE 1011111 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set pin pattern for PAT event. C selects INA/INB, Z selects =/!=, D provides mask value, S provides match value.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "216",
    "mnemonic": "AKPIN   {#}S",
    "group": "Smart Pins",
    "encoding": "EEEE 1100000 01I 000000001 SSSSSSSSS",
    "alias": "alias",
    "description": "Acknowledge smart pins S[10:6]+S[5:0]..S[5:0].                              Wraps within A/B pins. Prior SETQ overrides S[10:6].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "217",
    "mnemonic": "WRPIN   {#}D,{#}S",
    "group": "Smart Pins",
    "encoding": "EEEE 1100000 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set mode of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ overrides S[10:6].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "218",
    "mnemonic": "WXPIN   {#}D,{#}S",
    "group": "Smart Pins",
    "encoding": "EEEE 1100000 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set \"X\"  of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ overrides S[10:6].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "219",
    "mnemonic": "WYPIN   {#}D,{#}S",
    "group": "Smart Pins",
    "encoding": "EEEE 1100001 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set \"Y\"  of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ overrides S[10:6].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "220",
    "mnemonic": "WRLUT   {#}D,{#}S/P",
    "group": "Lookup Table",
    "encoding": "EEEE 1100001 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Write D to LUT address {#}S/PTRx.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "221",
    "mnemonic": "WRBYTE  {#}D,{#}S/P",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1100010 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Write byte in D[7:0] to hub address {#}S/PTRx.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10",
    "hub_timing": "3...20",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "222",
    "mnemonic": "WRWORD  {#}D,{#}S/P",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1100010 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Write word in D[15:0] to hub address {#}S/PTRx.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10*",
    "hub_timing": "3...20 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "223",
    "mnemonic": "WRLONG  {#}D,{#}S/P",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1100011 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Write long in D[31:0] to hub address {#}S/PTRx.                   Prior SETQ/SETQ2 invokes cog/LUT block transfer.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10*",
    "hub_timing": "3...20 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "224",
    "mnemonic": "PUSHA   {#}D",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1100011 0L1 DDDDDDDDD 101100001",
    "alias": "alias",
    "description": "Write long in D[31:0] to hub address PTRA++.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10*",
    "hub_timing": "3...20 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "225",
    "mnemonic": "PUSHB   {#}D",
    "group": "Hub RAM - Write",
    "encoding": "EEEE 1100011 0L1 DDDDDDDDD 111100001",
    "alias": "alias",
    "description": "Write long in D[31:0] to hub address PTRB++.",
    "interrupt_shield": "",
    "cog_lut_timing": "3...10*",
    "hub_timing": "3...20 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "226",
    "mnemonic": "RDFAST  {#}D,{#}S",
    "group": "Hub FIFO - New Read",
    "encoding": "EEEE 1100011 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin new fast hub read via FIFO.  D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or WRFAST finish + 10...17",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "227",
    "mnemonic": "WRFAST  {#}D,{#}S",
    "group": "Hub FIFO - New Write",
    "encoding": "EEEE 1100100 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin new fast hub write via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 or WRFAST finish + 3",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "228",
    "mnemonic": "FBLOCK  {#}D,{#}S",
    "group": "Hub FIFO - New Block",
    "encoding": "EEEE 1100100 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Set next block for when block wraps. D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "229",
    "mnemonic": "XINIT   {#}D,{#}S",
    "group": "Streamer",
    "encoding": "EEEE 1100101 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Issue streamer command immediately, zeroing phase.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "230",
    "mnemonic": "XSTOP",
    "group": "Streamer",
    "encoding": "EEEE 1100101 011 000000000 000000000",
    "alias": "alias",
    "description": "Stop streamer immediately.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "231",
    "mnemonic": "XZERO   {#}D,{#}S",
    "group": "Streamer",
    "encoding": "EEEE 1100101 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Buffer new streamer command to be issued on final NCO rollover of current command, zeroing phase.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "232",
    "mnemonic": "XCONT   {#}D,{#}S",
    "group": "Streamer",
    "encoding": "EEEE 1100110 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Buffer new streamer command to be issued on final NCO rollover of current command, continuing phase.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "233",
    "mnemonic": "REP     {#}D,{#}S",
    "group": "Branch Repeat",
    "encoding": "EEEE 1100110 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Execute\u00a0next D[8:0] instructions S times. If S = 0, repeat instructions infinitely. If D[8:0] = 0, nothing repeats.",
    "interrupt_shield": "\u2714+code",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "234",
    "mnemonic": "COGINIT {#}D,{#}S       {WC}",
    "group": "Hub Control - Cogs",
    "encoding": "EEEE 1100111 CLI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Start cog selected by D. S[19:0] sets hub startup address and PTRB of cog. Prior SETQ sets PTRA of cog.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9, +2 if result",
    "hub_timing": "same",
    "register_write": "D if reg and WC",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "235",
    "mnemonic": "QMUL    {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101000 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC unsigned multiplication of D * S. GETQX/GETQY retrieves lower/upper product.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "236",
    "mnemonic": "QDIV    {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101000 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC unsigned division of {SETQ value or 32'b0, D} / S. GETQX/GETQY retrieves quotient/remainder.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "237",
    "mnemonic": "QFRAC   {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101001 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC unsigned division of {D, SETQ value or 32'b0} / S. GETQX/GETQY retrieves quotient/remainder.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "238",
    "mnemonic": "QSQRT   {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101001 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC square root of {S, D}. GETQX retrieves root.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "239",
    "mnemonic": "QROTATE {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101010 0LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC rotation of point (D, SETQ value or 32'b0) by angle S. GETQX/GETQY retrieves X/Y.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "240",
    "mnemonic": "QVECTOR {#}D,{#}S",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101010 1LI DDDDDDDDD SSSSSSSSS",
    "alias": ".",
    "description": "Begin CORDIC vectoring of point (D, S). GETQX/GETQY retrieves length/angle.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "241",
    "mnemonic": "HUBSET  {#}D",
    "group": "Hub Control - Multi",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000000000",
    "alias": ".",
    "description": "Set hub configuration to D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "242",
    "mnemonic": "COGID   {#}D            {WC}",
    "group": "Hub Control - Cogs",
    "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000001",
    "alias": ".",
    "description": "If D is register and no WC, get cog ID (0 to 15) into D. If WC, check status of cog D[3:0], C = 1 if on.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9, +2 if result",
    "hub_timing": "same",
    "register_write": "D if reg and !WC",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "243",
    "mnemonic": "COGSTOP {#}D",
    "group": "Hub Control - Cogs",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000000011",
    "alias": ".",
    "description": "Stop cog D[3:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "244",
    "mnemonic": "LOCKNEW D               {WC}",
    "group": "Hub Control - Locks",
    "encoding": "EEEE 1101011 C00 DDDDDDDDD 000000100",
    "alias": ".",
    "description": "Request a LOCK. D will be written with the LOCK number (0 to 15). C = 1 if no LOCK available.",
    "interrupt_shield": "",
    "cog_lut_timing": "4...11",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "245",
    "mnemonic": "LOCKRET {#}D",
    "group": "Hub Control - Locks",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000000101",
    "alias": ".",
    "description": "Return LOCK D[3:0] for reallocation.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "246",
    "mnemonic": "LOCKTRY {#}D            {WC}",
    "group": "Hub Control - Locks",
    "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000110",
    "alias": ".",
    "description": "Try to get LOCK D[3:0]. C = 1 if got LOCK. LOCKREL releases LOCK. LOCK is also released if owner cog stops or restarts. ",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9, +2 if result",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "247",
    "mnemonic": "LOCKREL {#}D            {WC}",
    "group": "Hub Control - Locks",
    "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000111",
    "alias": ".",
    "description": "Release LOCK D[3:0]. If D is a register and WC, get current/last cog id of LOCK owner into D and LOCK status into C.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9, +2 if result",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "248",
    "mnemonic": "QLOG    {#}D",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000001110",
    "alias": ".",
    "description": "Begin CORDIC number-to-logarithm conversion of D. GETQX retrieves log {5'whole_exponent, 27'fractional_exponent}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "249",
    "mnemonic": "QEXP    {#}D",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000001111",
    "alias": ".",
    "description": "Begin CORDIC logarithm-to-number conversion of D. GETQX retrieves number.",
    "interrupt_shield": "",
    "cog_lut_timing": "2...9",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "250",
    "mnemonic": "RFBYTE  D        {WC/WZ/WCZ}",
    "group": "Hub FIFO - Read",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010000",
    "alias": ".",
    "description": "Used after RDFAST. Read zero-extended byte from FIFO into D. C = MSB of byte. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "251",
    "mnemonic": "RFWORD  D        {WC/WZ/WCZ}",
    "group": "Hub FIFO - Read",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010001",
    "alias": ".",
    "description": "Used after RDFAST. Read zero-extended word from FIFO into D. C = MSB of word. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "252",
    "mnemonic": "RFLONG  D        {WC/WZ/WCZ}",
    "group": "Hub FIFO - Read",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010010",
    "alias": ".",
    "description": "Used after RDFAST. Read long from FIFO into D. C = MSB of long. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "253",
    "mnemonic": "RFVAR   D        {WC/WZ/WCZ}",
    "group": "Hub FIFO - Read",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010011",
    "alias": ".",
    "description": "Used after RDFAST. Read zero-extended 1..4-byte value from FIFO into D. C = 0. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "254",
    "mnemonic": "RFVARS  D        {WC/WZ/WCZ}",
    "group": "Hub FIFO - Read",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010100",
    "alias": ".",
    "description": "Used after RDFAST. Read sign-extended 1..4-byte value from FIFO into D. C = MSB of value. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "255",
    "mnemonic": "WFBYTE  {#}D",
    "group": "Hub FIFO - Write",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000010101",
    "alias": ".",
    "description": "Used after WRFAST. Write byte in D[7:0] into FIFO.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "256",
    "mnemonic": "WFWORD  {#}D",
    "group": "Hub FIFO - Write",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000010110",
    "alias": ".",
    "description": "Used after WRFAST. Write word in D[15:0] into FIFO.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "257",
    "mnemonic": "WFLONG  {#}D",
    "group": "Hub FIFO - Write",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000010111",
    "alias": ".",
    "description": "Used after WRFAST. Write long in D[31:0] into FIFO.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "258",
    "mnemonic": "GETQX   D        {WC/WZ/WCZ}",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011000",
    "alias": ".",
    "description": "Retrieve CORDIC result X into D. Waits, in case result not ready. C = X[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2...58",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "259",
    "mnemonic": "GETQY   D        {WC/WZ/WCZ}",
    "group": "CORDIC Solver",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011001",
    "alias": ".",
    "description": "Retrieve CORDIC result Y into D. Waits, in case result not ready. C = Y[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2...58",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "260",
    "mnemonic": "GETCT   D               {WC}",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 C00 DDDDDDDDD 000011010",
    "alias": ".",
    "description": "Get CT[31:0] or CT[63:32] if WC into D. GETCT WC + GETCT gets full CT. CT=0 on reset, CT++ on every clock. C = same.",
    "interrupt_shield": "\u2714 if WC",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "261",
    "mnemonic": "GETRND\u00a0 D\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 {WC/WZ/WCZ}",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011011",
    "alias": ".",
    "description": "Get RND into D/C/Z. RND is the PRNG that updates on every clock. D = RND[31:0], C = RND[31], Z = RND[30], unique per cog.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "262",
    "mnemonic": "GETRND\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  WC/WZ/WCZ",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 CZ1 000000000 000011011",
    "alias": "alias",
    "description": "Get RND\u00a0into C/Z.\u00a0C = RND[31], Z = RND[30], unique per cog.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "263",
    "mnemonic": "SETDACS {#}D",
    "group": "Smart Pins",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000011100",
    "alias": ".",
    "description": "DAC3 = D[31:24], DAC2 = D[23:16], DAC1 = D[15:8], DAC0 = D[7:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "264",
    "mnemonic": "SETXFRQ {#}D",
    "group": "Streamer",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000011101",
    "alias": ".",
    "description": "Set streamer NCO frequency to D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "265",
    "mnemonic": "GETXACC D",
    "group": "Streamer",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 000011110",
    "alias": ".",
    "description": "Get the streamer's Goertzel X accumulator into D and the Y accumulator into the next instruction's S, clear accumulators.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "266",
    "mnemonic": "WAITX   {#}D     {WC/WZ/WCZ}",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 000011111",
    "alias": ".",
    "description": "Wait 2 + D clocks if no WC/WZ/WCZ. If WC/WZ/WCZ, wait 2 + (D & RND) clocks. C/Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "2 + D",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "267",
    "mnemonic": "SETSE1  {#}D",
    "group": "Events - Configuration",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100000",
    "alias": ".",
    "description": "Set SE1 event configuration to D[8:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "268",
    "mnemonic": "SETSE2  {#}D",
    "group": "Events - Configuration",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100001",
    "alias": ".",
    "description": "Set SE2 event configuration to D[8:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "269",
    "mnemonic": "SETSE3  {#}D",
    "group": "Events - Configuration",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100010",
    "alias": ".",
    "description": "Set SE3 event configuration to D[8:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "270",
    "mnemonic": "SETSE4  {#}D",
    "group": "Events - Configuration",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100011",
    "alias": ".",
    "description": "Set SE4 event configuration to D[8:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "271",
    "mnemonic": "POLLINT          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000000 000100100",
    "alias": ".",
    "description": "Get INT event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "272",
    "mnemonic": "POLLCT1          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000001 000100100",
    "alias": ".",
    "description": "Get CT1 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "273",
    "mnemonic": "POLLCT2          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000010 000100100",
    "alias": ".",
    "description": "Get CT2 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "274",
    "mnemonic": "POLLCT3          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000011 000100100",
    "alias": ".",
    "description": "Get CT3 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "275",
    "mnemonic": "POLLSE1          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000100 000100100",
    "alias": ".",
    "description": "Get SE1 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "276",
    "mnemonic": "POLLSE2          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000101 000100100",
    "alias": ".",
    "description": "Get SE2 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "277",
    "mnemonic": "POLLSE3          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000110 000100100",
    "alias": ".",
    "description": "Get SE3 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "278",
    "mnemonic": "POLLSE4          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000000111 000100100",
    "alias": ".",
    "description": "Get SE4 event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "279",
    "mnemonic": "POLLPAT          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001000 000100100",
    "alias": ".",
    "description": "Get PAT event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "280",
    "mnemonic": "POLLFBW          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001001 000100100",
    "alias": ".",
    "description": "Get FBW event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "281",
    "mnemonic": "POLLXMT          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001010 000100100",
    "alias": ".",
    "description": "Get XMT event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "282",
    "mnemonic": "POLLXFI          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001011 000100100",
    "alias": ".",
    "description": "Get XFI event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "283",
    "mnemonic": "POLLXRO          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001100 000100100",
    "alias": ".",
    "description": "Get XRO event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "284",
    "mnemonic": "POLLXRL          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001101 000100100",
    "alias": ".",
    "description": "Get XRL event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "285",
    "mnemonic": "POLLATN          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001110 000100100",
    "alias": ".",
    "description": "Get ATN event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "286",
    "mnemonic": "POLLQMT          {WC/WZ/WCZ}",
    "group": "Events - Poll",
    "encoding": "EEEE 1101011 CZ0 000001111 000100100",
    "alias": ".",
    "description": "Get QMT event flag into C/Z, then clear it.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "287",
    "mnemonic": "WAITINT          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010000 000100100",
    "alias": ".",
    "description": "Wait for INT event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "288",
    "mnemonic": "WAITCT1          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010001 000100100",
    "alias": ".",
    "description": "Wait for CT1 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "289",
    "mnemonic": "WAITCT2          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010010 000100100",
    "alias": ".",
    "description": "Wait for CT2 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "290",
    "mnemonic": "WAITCT3          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010011 000100100",
    "alias": ".",
    "description": "Wait for CT3 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "291",
    "mnemonic": "WAITSE1          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010100 000100100",
    "alias": ".",
    "description": "Wait for SE1 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "292",
    "mnemonic": "WAITSE2          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010101 000100100",
    "alias": ".",
    "description": "Wait for SE2 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "293",
    "mnemonic": "WAITSE3          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010110 000100100",
    "alias": ".",
    "description": "Wait for SE3 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "294",
    "mnemonic": "WAITSE4          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000010111 000100100",
    "alias": ".",
    "description": "Wait for SE4 event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "295",
    "mnemonic": "WAITPAT          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011000 000100100",
    "alias": ".",
    "description": "Wait for PAT event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "296",
    "mnemonic": "WAITFBW          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011001 000100100",
    "alias": ".",
    "description": "Wait for FBW event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "297",
    "mnemonic": "WAITXMT          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011010 000100100",
    "alias": ".",
    "description": "Wait for XMT event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "298",
    "mnemonic": "WAITXFI          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011011 000100100",
    "alias": ".",
    "description": "Wait for XFI event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "299",
    "mnemonic": "WAITXRO          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011100 000100100",
    "alias": ".",
    "description": "Wait for XRO event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "300",
    "mnemonic": "WAITXRL          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011101 000100100",
    "alias": ".",
    "description": "Wait for XRL event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "301",
    "mnemonic": "WAITATN          {WC/WZ/WCZ}",
    "group": "Events - Wait",
    "encoding": "EEEE 1101011 CZ0 000011110 000100100",
    "alias": ".",
    "description": "Wait for ATN event flag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.",
    "interrupt_shield": "",
    "cog_lut_timing": "2+",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "302",
    "mnemonic": "ALLOWI",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100000 000100100",
    "alias": ".",
    "description": "Allow interrupts (default).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "303",
    "mnemonic": "STALLI",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100001 000100100",
    "alias": ".",
    "description": "Stall Interrupts.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "304",
    "mnemonic": "TRGINT1",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100010 000100100",
    "alias": ".",
    "description": "Trigger INT1, regardless of STALLI mode.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "305",
    "mnemonic": "TRGINT2",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100011 000100100",
    "alias": ".",
    "description": "Trigger INT2, regardless of STALLI mode.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "306",
    "mnemonic": "TRGINT3",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100100 000100100",
    "alias": ".",
    "description": "Trigger INT3, regardless of STALLI mode.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "307",
    "mnemonic": "NIXINT1",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100101 000100100",
    "alias": ".",
    "description": "Cancel INT1.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "308",
    "mnemonic": "NIXINT2",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100110 000100100",
    "alias": ".",
    "description": "Cancel INT2.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "309",
    "mnemonic": "NIXINT3",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 000 000100111 000100100",
    "alias": ".",
    "description": "Cancel INT3.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "310",
    "mnemonic": "SETINT1 {#}D",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100101",
    "alias": ".",
    "description": "Set INT1 source to D[3:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "311",
    "mnemonic": "SETINT2 {#}D",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100110",
    "alias": ".",
    "description": "Set INT2 source to D[3:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "312",
    "mnemonic": "SETINT3 {#}D",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000100111",
    "alias": ".",
    "description": "Set INT3 source to D[3:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "313",
    "mnemonic": "SETQ    {#}D",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000101000",
    "alias": ".",
    "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set block transfer. Also used before MUXQ/COGINIT/QDIV/QFRAC/QROTATE/WAITxxx.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "314",
    "mnemonic": "SETQ2   {#}D",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000101001",
    "alias": ".",
    "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set LUT block transfer.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "315",
    "mnemonic": "PUSH    {#}D",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000101010",
    "alias": ".",
    "description": "Push D onto stack.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": "Push"
  },
  {
    "order": "316",
    "mnemonic": "POP     D        {WC/WZ/WCZ}",
    "group": "Miscellaneous",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101011",
    "alias": ".",
    "description": "Pop stack (K). D = K. C = K[31]. *",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": "Pop"
  },
  {
    "order": "317",
    "mnemonic": "JMP     D        {WC/WZ/WCZ}",
    "group": "Branch D - Jump",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101100",
    "alias": ".",
    "description": "Jump to D.                                                              C = D[31], Z = D[30], PC = D[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "318",
    "mnemonic": "CALL    D        {WC/WZ/WCZ}",
    "group": "Branch D - Call",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101101",
    "alias": ".",
    "description": "Call to D by pushing {C, Z, 10'b0, PC[19:0]} onto stack.                C = D[31], Z = D[30], PC = D[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": "Push"
  },
  {
    "order": "319",
    "mnemonic": "RET              {WC/WZ/WCZ}",
    "group": "Branch Return",
    "encoding": "EEEE 1101011 CZ1 000000000 000101101",
    "alias": ".",
    "description": "Return by popping stack (K).                                            C = K[31], Z = K[30], PC = K[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": "Pop"
  },
  {
    "order": "320",
    "mnemonic": "CALLA   D        {WC/WZ/WCZ}",
    "group": "Branch D - Call",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101110",
    "alias": ".",
    "description": "Call to D by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRA++.     C = D[31], Z = D[30], PC = D[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "5...12 *",
    "hub_timing": "14...32 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "321",
    "mnemonic": "RETA             {WC/WZ/WCZ}",
    "group": "Branch Return",
    "encoding": "EEEE 1101011 CZ1 000000000 000101110",
    "alias": ".",
    "description": "Return by reading hub long (L) at --PTRA.                               C = L[31], Z = L[30], PC = L[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "11...18 *",
    "hub_timing": "20...40 *",
    "register_write": "",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "322",
    "mnemonic": "CALLB   D        {WC/WZ/WCZ}",
    "group": "Branch D - Call",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101111",
    "alias": ".",
    "description": "Call to D by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRB++.     C = D[31], Z = D[30], PC = D[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "5...12 *",
    "hub_timing": "14...32 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "323",
    "mnemonic": "RETB             {WC/WZ/WCZ}",
    "group": "Branch Return",
    "encoding": "EEEE 1101011 CZ1 000000000 000101111",
    "alias": ".",
    "description": "Return by reading hub long (L) at --PTRB.                               C = L[31], Z = L[30], PC = L[19:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "11...18 *",
    "hub_timing": "20...40 *",
    "register_write": "",
    "hub_rw": "Read",
    "stack_rw": ""
  },
  {
    "order": "324",
    "mnemonic": "JMPREL  {#}D",
    "group": "Branch D - Jump",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110000",
    "alias": ".",
    "description": "Jump ahead/back by D instructions. For cogex, PC += D[19:0]. For hubex, PC += D[17:0] << 2.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "325",
    "mnemonic": "SKIP \u00a0\u00a0 {#}D",
    "group": "Branch D - Skip",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110001",
    "alias": ".",
    "description": "Skip instructions per D. Subsequent instructions\u00a00..31 get cancelled\u00a0for each '1' bit in D[0]..D[31].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "326",
    "mnemonic": "SKIPF\u00a0\u00a0 {#}D",
    "group": "Branch D - Jump+Skip",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110010",
    "alias": ".",
    "description": "Skip cog/LUT instructions fast per D. Like SKIP, but instead of cancelling instructions, the PC leaps over them.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "ILLEGAL",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "327",
    "mnemonic": "EXECF\u00a0\u00a0 {#}D",
    "group": "Branch D - Call+Skip",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110011",
    "alias": ".",
    "description": "Jump to D[9:0] in cog/LUT and set SKIPF pattern to\u00a0D[31:10]. PC = {10'b0, D[9:0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "328",
    "mnemonic": "GETPTR  D",
    "group": "Hub FIFO",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 000110100",
    "alias": ".",
    "description": "Get current FIFO hub pointer into D.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "FIFO IN USE",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "329",
    "mnemonic": "GETBRK  D          WC/WZ/WCZ",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000110101",
    "alias": ".",
    "description": "Get breakpoint/cog status into D according to WC/WZ/WCZ. See documentation for details.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "330",
    "mnemonic": "COGBRK  {#}D",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110101",
    "alias": ".",
    "description": "If in debug ISR, trigger asynchronous breakpoint in cog D[3:0]. Cog D[3:0] must have asynchronous breakpoint enabled.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "331",
    "mnemonic": "BRK     {#}D",
    "group": "Interrupts",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110110",
    "alias": ".",
    "description": "If in debug ISR, set next break condition to D. Else, set BRK code to D[7:0] and unconditionally trigger BRK interrupt, if enabled.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "332",
    "mnemonic": "SETLUTS {#}D",
    "group": "Lookup Table",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000110111",
    "alias": ".",
    "description": "If D[0] = 1 then enable LUT sharing, where LUT writes within the adjacent odd/even companion cog\u00a0are copied to\u00a0this\u00a0cog's LUT.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "333",
    "mnemonic": "SETCY   {#}D",
    "group": "Color Space Converter",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111000",
    "alias": ".",
    "description": "Set the colorspace converter \"CY\" parameter to D[31:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "334",
    "mnemonic": "SETCI   {#}D",
    "group": "Color Space Converter",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111001",
    "alias": ".",
    "description": "Set the colorspace converter \"CI\" parameter to D[31:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "335",
    "mnemonic": "SETCQ   {#}D",
    "group": "Color Space Converter",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111010",
    "alias": ".",
    "description": "Set the colorspace converter \"CQ\" parameter to D[31:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "336",
    "mnemonic": "SETCFRQ {#}D",
    "group": "Color Space Converter",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111011",
    "alias": ".",
    "description": "Set the colorspace converter \"CFRQ\" parameter to D[31:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "337",
    "mnemonic": "SETCMOD {#}D",
    "group": "Color Space Converter",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111100",
    "alias": ".",
    "description": "Set the colorspace converter \"CMOD\" parameter to D[8:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "338",
    "mnemonic": "SETPIV  {#}D",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111101",
    "alias": ".",
    "description": "Set BLNPIX/MIXPIX blend factor to D[7:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "339",
    "mnemonic": "SETPIX  {#}D",
    "group": "Pixel Mixer",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111110",
    "alias": ".",
    "description": "Set MIXPIX mode to D[5:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "340",
    "mnemonic": "COGATN  {#}D",
    "group": "Events - Attention",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 000111111",
    "alias": ".",
    "description": "Strobe \"attention\" of all cogs whose corresponging bits are high in D[15:0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "341",
    "mnemonic": "TESTP   {#}D           WC/WZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000000",
    "alias": ".",
    "description": "Test  IN bit of pin D[5:0], write to C/Z. C/Z =          IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "342",
    "mnemonic": "TESTPN  {#}D           WC/WZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000001",
    "alias": ".",
    "description": "Test !IN bit of pin D[5:0], write to C/Z. C/Z =         !IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "343",
    "mnemonic": "TESTP   {#}D       ANDC/ANDZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000010",
    "alias": ".",
    "description": "Test  IN bit of pin D[5:0], AND into C/Z. C/Z = C/Z AND  IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "344",
    "mnemonic": "TESTPN  {#}D       ANDC/ANDZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000011",
    "alias": ".",
    "description": "Test !IN bit of pin D[5:0], AND into C/Z. C/Z = C/Z AND !IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "345",
    "mnemonic": "TESTP   {#}D         ORC/ORZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000100",
    "alias": ".",
    "description": "Test  IN bit of pin D[5:0], OR  into C/Z. C/Z = C/Z OR   IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "346",
    "mnemonic": "TESTPN  {#}D         ORC/ORZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000101",
    "alias": ".",
    "description": "Test !IN bit of pin D[5:0], OR  into C/Z. C/Z = C/Z OR  !IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "347",
    "mnemonic": "TESTP   {#}D       XORC/XORZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000110",
    "alias": ".",
    "description": "Test  IN bit of pin D[5:0], XOR into C/Z. C/Z = C/Z XOR  IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "348",
    "mnemonic": "TESTPN  {#}D       XORC/XORZ",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111",
    "alias": ".",
    "description": "Test !IN bit of pin D[5:0], XOR into C/Z. C/Z = C/Z XOR !IN[D[5:0]].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "349",
    "mnemonic": "DIRL    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000000",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = 0.                  Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "350",
    "mnemonic": "DIRH    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000001",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = 1.                  Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "351",
    "mnemonic": "DIRC    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000010",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = C.                  Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "352",
    "mnemonic": "DIRNC   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000011",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = !C.                 Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "353",
    "mnemonic": "DIRZ    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000100",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = Z.                  Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "354",
    "mnemonic": "DIRNZ   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000101",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = !Z.                 Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "355",
    "mnemonic": "DIRRND  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000110",
    "alias": ".",
    "description": "DIR bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs.               Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "356",
    "mnemonic": "DIRNOT  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111",
    "alias": ".",
    "description": "Toggle DIR bits of pins D[10:6]+D[5:0]..D[5:0].               Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "357",
    "mnemonic": "OUTL    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001000",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0.                  Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "358",
    "mnemonic": "OUTH    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001001",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1.                  Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "359",
    "mnemonic": "OUTC    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001010",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = C.                  Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "360",
    "mnemonic": "OUTNC   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001011",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C.                 Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "361",
    "mnemonic": "OUTZ    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001100",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z.                  Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "362",
    "mnemonic": "OUTNZ   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001101",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z.                 Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "363",
    "mnemonic": "OUTRND  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001110",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs.               Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "364",
    "mnemonic": "OUTNOT  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001111",
    "alias": ".",
    "description": "Toggle OUT bits of pins D[10:6]+D[5:0]..D[5:0].               Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "365",
    "mnemonic": "FLTL    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010000",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0.    DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "366",
    "mnemonic": "FLTH    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010001",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1.    DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "367",
    "mnemonic": "FLTC    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010010",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = C.    DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "368",
    "mnemonic": "FLTNC   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010011",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C.   DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "369",
    "mnemonic": "FLTZ    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010100",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z.    DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "370",
    "mnemonic": "FLTNZ   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010101",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z.   DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "371",
    "mnemonic": "FLTRND  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010110",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "372",
    "mnemonic": "FLTNOT  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010111",
    "alias": ".",
    "description": "Toggle OUT bits of pins D[10:6]+D[5:0]..D[5:0]. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "373",
    "mnemonic": "DRVL    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011000",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0.    DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "374",
    "mnemonic": "DRVH    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011001",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1.    DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "375",
    "mnemonic": "DRVC    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011010",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = C.    DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "376",
    "mnemonic": "DRVNC   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011011",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C.   DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "377",
    "mnemonic": "DRVZ    {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011100",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z.    DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "378",
    "mnemonic": "DRVNZ   {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011101",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z.   DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "379",
    "mnemonic": "DRVRND  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011110",
    "alias": ".",
    "description": "OUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "380",
    "mnemonic": "DRVNOT  {#}D           {WCZ}",
    "group": "Pins",
    "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011111",
    "alias": ".",
    "description": "Toggle OUT bits of pins D[10:6]+D[5:0]..D[5:0]. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT bit.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "DIRx* + OUTx",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "381",
    "mnemonic": "SPLITB  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100000",
    "alias": ".",
    "description": "Split every 4th bit of D into bytes. D = {D[31], D[27], D[23], D[19], ...D[12], D[8], D[4], D[0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "382",
    "mnemonic": "MERGEB  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100001",
    "alias": ".",
    "description": "Merge bits of bytes in D. D = {D[31], D[23], D[15], D[7], ...D[24], D[16], D[8], D[0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "383",
    "mnemonic": "SPLITW  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100010",
    "alias": ".",
    "description": "Split odd/even bits of D into words. D = {D[31], D[29], D[27], D[25], ...D[6], D[4], D[2], D[0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "384",
    "mnemonic": "MERGEW  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100011",
    "alias": ".",
    "description": "Merge bits of words in D. D = {D[31], D[15], D[30], D[14], ...D[17], D[1], D[16], D[0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "385",
    "mnemonic": "SEUSSF  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100100",
    "alias": ".",
    "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Forward pattern.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "386",
    "mnemonic": "SEUSSR  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100101",
    "alias": ".",
    "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Reverse pattern.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "387",
    "mnemonic": "RGBSQZ  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100110",
    "alias": ".",
    "description": "Squeeze 8:8:8 RGB value in D[31:8] into 5:6:5 value in D[15:0]. D = {15'b0, D[31:27], D[23:18], D[15:11]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "388",
    "mnemonic": "RGBEXP  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001100111",
    "alias": ".",
    "description": "Expand 5:6:5 RGB value in D[15:0] into 8:8:8 value in D[31:8]. D = {D[15:11,15:13], D[10:5,10:9], D[4:0,4:2], 8'b0}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "389",
    "mnemonic": "XORO32  D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101000",
    "alias": ".",
    "description": "Iterate D with xoroshiro32+ PRNG algorithm and put PRNG result into next instruction's S.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "390",
    "mnemonic": "REV     D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101001",
    "alias": ".",
    "description": "Reverse D bits. D = D[0:31].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "391",
    "mnemonic": "RCZR    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101010",
    "alias": ".",
    "description": "Rotate C,Z right through D. D = {C, Z, D[31:2]}. C = D[1],  Z = D[0].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "392",
    "mnemonic": "RCZL    D        {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101011",
    "alias": ".",
    "description": "Rotate C,Z left through D.  D = {D[29:0], C, Z}. C = D[31], Z = D[30].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "393",
    "mnemonic": "WRC     D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101100",
    "alias": ".",
    "description": "Write 0 or 1 to D, according to  C. D = {31'b0,  C).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "394",
    "mnemonic": "WRNC    D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101101",
    "alias": ".",
    "description": "Write 0 or 1 to D, according to !C. D = {31'b0, !C).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "395",
    "mnemonic": "WRZ     D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101110",
    "alias": ".",
    "description": "Write 0 or 1 to D, according to  Z. D = {31'b0,  Z).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "396",
    "mnemonic": "WRNZ    D",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001101111",
    "alias": ".",
    "description": "Write 0 or 1 to D, according to !Z. D = {31'b0, !Z).",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "D",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "397",
    "mnemonic": "MODCZ   c,z      {WC/WZ/WCZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 CZ1 0cccczzzz 001101111",
    "alias": ".",
    "description": "Modify C and Z according to cccc and zzzz. C = cccc[{C,Z}], Z = zzzz[{C,Z}].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "398",
    "mnemonic": "MODC    c               {WC}",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 C01 0cccc0000 001101111",
    "alias": "alias",
    "description": "Modify C according to cccc. C = cccc[{C,Z}].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "399",
    "mnemonic": "MODZ    z               {WZ}",
    "group": "Math and Logic",
    "encoding": "EEEE 1101011 0Z1 00000zzzz 001101111",
    "alias": "alias",
    "description": "Modify Z according to zzzz. Z = zzzz[{C,Z}].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "400",
    "mnemonic": "SETSCP  {#}D",
    "group": "Smart Pins",
    "encoding": "EEEE 1101011 00L DDDDDDDDD 001110000",
    "alias": ".",
    "description": "Set four-channel oscilloscope enable to D[6] and set input pin base to D[5:2].",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "401",
    "mnemonic": "GETSCP  D",
    "group": "Smart Pins",
    "encoding": "EEEE 1101011 000 DDDDDDDDD 001110001",
    "alias": ".",
    "description": "Get four-channel oscilloscope samples into D. D = {ch3[7:0],ch2[7:0],ch1[7:0],ch0[7:0]}.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "402",
    "mnemonic": "JMP     #{\\}A",
    "group": "Branch A - Jump",
    "encoding": "EEEE 1101100 RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Jump to A.                                                                  If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "403",
    "mnemonic": "CALL    #{\\}A",
    "group": "Branch A - Call",
    "encoding": "EEEE 1101101 RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Call to A by pushing {C, Z, 10'b0, PC[19:0]} onto stack.                    If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": "Push"
  },
  {
    "order": "404",
    "mnemonic": "CALLA   #{\\}A",
    "group": "Branch A - Call",
    "encoding": "EEEE 1101110 RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Call to A by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRA++.         If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "5...12 *",
    "hub_timing": "14...32 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "405",
    "mnemonic": "CALLB   #{\\}A",
    "group": "Branch A - Call",
    "encoding": "EEEE 1101111 RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Call to A by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRB++.         If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "5...12 *",
    "hub_timing": "14...32 *",
    "register_write": "",
    "hub_rw": "Write",
    "stack_rw": ""
  },
  {
    "order": "406",
    "mnemonic": "CALLD   PA/PB/PTRA/PTRB,#{\\}A",
    "group": "Branch A - Call",
    "encoding": "EEEE 11100WW RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Call to A by writing {C, Z, 10'b0, PC[19:0]} to PA/PB/PTRA/PTRB (per W).    If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "4",
    "hub_timing": "13...20",
    "register_write": "Per W",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "407",
    "mnemonic": "LOC     PA/PB/PTRA/PTRB,#{\\}A",
    "group": "Math and Logic",
    "encoding": "EEEE 11101WW RAA AAAAAAAAA AAAAAAAAA",
    "alias": ".",
    "description": "Get {12'b0, address[19:0]} into PA/PB/PTRA/PTRB (per W).          If R = 1, address = PC + A, else address = A. \"\\\" forces R = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "Per W",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "408",
    "mnemonic": "AUGS    #n",
    "group": "Miscellaneous",
    "encoding": "EEEE 11110nn nnn nnnnnnnnn nnnnnnnnn",
    "alias": ".",
    "description": "Queue #n to be used as upper 23 bits for next #S occurrence, so that the next 9-bit #S will be augmented to 32 bits.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "409",
    "mnemonic": "AUGD    #n",
    "group": "Miscellaneous",
    "encoding": "EEEE 11111nn nnn nnnnnnnnn nnnnnnnnn",
    "alias": ".",
    "description": "Queue #n to be used as upper 23 bits for next #D occurrence, so that the\u00a0next 9-bit #D will be augmented to 32 bits.",
    "interrupt_shield": "\u2714",
    "cog_lut_timing": "2",
    "hub_timing": "same",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "410",
    "mnemonic": "_RET_\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0000 ------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> always and return if no branch. If\u00a0<inst> is not\u00a0branching then return\u00a0by popping stack[19:0] into PC.",
    "interrupt_shield": "",
    "cog_lut_timing": "+2",
    "hub_timing": "+11...18",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": "Pop"
  },
  {
    "order": "411",
    "mnemonic": "IF_NC_AND_NZ\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0001 ------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 0 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "412",
    "mnemonic": "IF_NZ_AND_NC\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0001 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "413",
    "mnemonic": "IF_GT \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0001 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 0, or if 'greater than' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "414",
    "mnemonic": "IF_A\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0001 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 0, or if 'above' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "415",
    "mnemonic": "IF_00         <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0001 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "416",
    "mnemonic": "IF_NC_AND_Z \u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0010 ------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 0 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "417",
    "mnemonic": "IF_Z_AND_NC \u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0010\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "418",
    "mnemonic": "IF_01\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0010 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "419",
    "mnemonic": "IF_NC\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0011\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "420",
    "mnemonic": "IF_GE\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0011\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0, or if 'greater than or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "421",
    "mnemonic": "IF_AE\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0011\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0, or if 'above or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "422",
    "mnemonic": "IF_0X\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0011 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "423",
    "mnemonic": "IF_C_AND_NZ\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0100\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C =\u00a01 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "424",
    "mnemonic": "IF_NZ_AND_C\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0100\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C =\u00a01 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "425",
    "mnemonic": "IF_10\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0100 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 and Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "426",
    "mnemonic": "IF_NZ\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0101\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if\u00a0Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "427",
    "mnemonic": "IF_NE\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0101\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if\u00a0Z = 0, or if 'not equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "428",
    "mnemonic": "IF_X0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0101 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "429",
    "mnemonic": "IF_C_NE_Z\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0110\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if\u00a0C != Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "430",
    "mnemonic": "IF_Z_NE_C\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0110\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C != Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "431",
    "mnemonic": "IF_DIFF\u00a0\u00a0 \u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0110 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C != Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "432",
    "mnemonic": "IF_NC_OR_NZ\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0111\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C =\u00a00\u00a0or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "433",
    "mnemonic": "IF_NZ_OR_NC\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "0111\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C =\u00a00\u00a0or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "434",
    "mnemonic": "IF_NOT_11\u00a0 \u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "0111 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "435",
    "mnemonic": "IF_C_AND_Z\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1000\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 1 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "436",
    "mnemonic": "IF_Z_AND_C\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1000\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "437",
    "mnemonic": "IF_11\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1000 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 and Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "438",
    "mnemonic": "IF_C_EQ_Z\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1001\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "439",
    "mnemonic": "IF_Z_EQ_C \u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1001\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "440",
    "mnemonic": "IF_SAME\u00a0 \u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1001 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = Z.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "441",
    "mnemonic": "IF_Z \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1010\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "442",
    "mnemonic": "IF_E \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1010\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if Z = 1, or if 'equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "443",
    "mnemonic": "IF_X1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1010 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "444",
    "mnemonic": "IF_NC_OR_Z\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1011\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 0 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "445",
    "mnemonic": "IF_Z_OR_NC\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1011\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "446",
    "mnemonic": "IF_NOT_10 \u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1011 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 0 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "447",
    "mnemonic": "IF_C\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1100\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if\u00a0C = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "448",
    "mnemonic": "IF_LT \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1100\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if\u00a0C = 1, or if 'less than' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "449",
    "mnemonic": "IF_B \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1100\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if\u00a0C = 1, or if 'below' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "450",
    "mnemonic": "IF_1X\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1100 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "451",
    "mnemonic": "IF_C_OR_NZ\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1101\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C =\u00a01 or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "452",
    "mnemonic": "IF_NZ_OR_C\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1101\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "453",
    "mnemonic": "IF_NOT_01 \u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1101 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 0.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "454",
    "mnemonic": "IF_C_OR_Z\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1110\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> if C = 1 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "455",
    "mnemonic": "IF_Z_OR_C\u00a0 \u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1110\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "456",
    "mnemonic": "IF_LE\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1110\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 1, or if 'less than or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "457",
    "mnemonic": "IF_BE\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1110\u00a0------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 1, or if 'below or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "458",
    "mnemonic": "IF_NOT_00\u00a0\u00a0\u00a0\u00a0 <inst>  <ops>",
    "group": "Instruction Prefix",
    "encoding": "1110 ------- --- --------- ---------",
    "alias": "alias",
    "description": "Execute <inst> if C = 1 or Z = 1.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "459",
    "mnemonic": "\u00a0\u00a0\u00a0\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <inst>\u00a0 <ops>",
    "group": "Instruction Prefix",
    "encoding": "1111\u00a0------- --- --------- ---------",
    "alias": ".",
    "description": "Execute <inst> always. This is the default when no instruction prefix is expressed.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "460",
    "mnemonic": "_CLR",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0000",
    "alias": ".",
    "description": "C/Z = 0",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "461",
    "mnemonic": "_NC_AND_NZ",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0001",
    "alias": ".",
    "description": "C/Z = !C AND !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "462",
    "mnemonic": "_NZ_AND_NC",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0001",
    "alias": "alias",
    "description": "C/Z = !C AND !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "463",
    "mnemonic": "_GT",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0001",
    "alias": "alias",
    "description": "C/Z = !C AND !Z, or 'greater than' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "464",
    "mnemonic": "_NC_AND_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0010",
    "alias": ".",
    "description": "C/Z = !C AND Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "465",
    "mnemonic": "_Z_AND_NC",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0010",
    "alias": "alias",
    "description": "C/Z = !C AND Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "466",
    "mnemonic": "_NC",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0011",
    "alias": ".",
    "description": "C/Z = !C",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "467",
    "mnemonic": "_GE",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0011",
    "alias": "alias",
    "description": "C/Z = !C, or 'greater than or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "468",
    "mnemonic": "_C_AND_NZ",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0100",
    "alias": ".",
    "description": "C/Z = C AND !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "469",
    "mnemonic": "_NZ_AND_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0100",
    "alias": "alias",
    "description": "C/Z = C AND !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "470",
    "mnemonic": "_NZ",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0101",
    "alias": ".",
    "description": "C/Z = !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "471",
    "mnemonic": "_NE",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0101",
    "alias": "alias",
    "description": "C/Z = !Z, or 'not equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "472",
    "mnemonic": "_C_NE_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0110",
    "alias": ".",
    "description": "C/Z = C NOT_EQUAL_TO Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "473",
    "mnemonic": "_Z_NE_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0110",
    "alias": "alias",
    "description": "C/Z = C NOT_EQUAL_TO Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "474",
    "mnemonic": "_NC_OR_NZ",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0111",
    "alias": ".",
    "description": "C/Z = !C OR !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "475",
    "mnemonic": "_NZ_OR_NC",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 0111",
    "alias": "alias",
    "description": "C/Z = !C OR !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "476",
    "mnemonic": "_C_AND_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1000",
    "alias": ".",
    "description": "C/Z = C AND Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "477",
    "mnemonic": "_Z_AND_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1000",
    "alias": "alias",
    "description": "C/Z = C AND Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "478",
    "mnemonic": "_C_EQ_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1001",
    "alias": ".",
    "description": "C/Z = C EQUAL_TO Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "479",
    "mnemonic": "_Z_EQ_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1001",
    "alias": "alias",
    "description": "C/Z = C EQUAL_TO Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "480",
    "mnemonic": "_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1010",
    "alias": ".",
    "description": "C/Z = Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "481",
    "mnemonic": "_E",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1010",
    "alias": "alias",
    "description": "C/Z = Z, or 'equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "482",
    "mnemonic": "_NC_OR_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1011",
    "alias": ".",
    "description": "C/Z = !C OR Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "483",
    "mnemonic": "_Z_OR_NC",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1011",
    "alias": "alias",
    "description": "C/Z = !C OR Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "484",
    "mnemonic": "_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1100",
    "alias": ".",
    "description": "C/Z = C",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "485",
    "mnemonic": "_LT",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1100",
    "alias": "alias",
    "description": "C/Z = C, or 'less than' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "486",
    "mnemonic": "_C_OR_NZ",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1101",
    "alias": ".",
    "description": "C/Z = C OR !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "487",
    "mnemonic": "_NZ_OR_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1101",
    "alias": "alias",
    "description": "C/Z = C OR !Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "488",
    "mnemonic": "_C_OR_Z",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1110",
    "alias": ".",
    "description": "C/Z = C OR Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "489",
    "mnemonic": "_Z_OR_C",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1110",
    "alias": "alias",
    "description": "C/Z = C OR Z",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "490",
    "mnemonic": "_LE",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1110",
    "alias": "alias",
    "description": "C/Z = C OR Z, or 'less than or equal' after a comparison/subtraction.",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  },
  {
    "order": "491",
    "mnemonic": "_SET",
    "group": "MODCZ Operand",
    "encoding": "cccc or zzzz = 1111",
    "alias": ".",
    "description": "C/Z = 1",
    "interrupt_shield": "",
    "cog_lut_timing": "",
    "hub_timing": "",
    "register_write": "",
    "hub_rw": "",
    "stack_rw": ""
  }
]