When your ISR is done, it can do a RETIx instruction to return to the interrupted code. The RETIx instructions are actually
CALLD instructions:

         RETI1                   =     CALLD INB,IRET1         WCZ
         RETI2                   =     CALLD INB,IRET2         WCZ
         RETI3                   =     CALLD INB,IRET3         WCZ



The CALLD with D = <any register>, S = IRETx, and WCZ, signals the cog that the interrupt is complete. This causes the cog
to clear its internal interrupt-busy flag for that interrupt, so that another interrupt can occur. INB (read-only) is used as D for
RETIx instructions to effectively make the CALLD into a JMP back to the interrupted code.

Instead of using RETIx, though, you could use RESIx to have your ISR resume at the next instruction when the next interrupt
occurs:

         RESI1                    =     CALLD IJMP1,IRET1         WCZ
         RESI2                    =     CALLD IJMP2,IRET2         WCZ
         RESI3                    =     CALLD IJMP3,IRET3         WCZ



Once you've got the IJMPx register configured to point to your ISR, you can enable the interrupt. This is done using the
SETINTx instruction:

         SETINT1 D/#        Set INT1 event to 0..15 (see table above)
         SETINT2 D/#        Set INT2 event to 0..15 (see table above)
         SETINT3 D/#        Set INT3 event to 0..15 (see table above)



Interrupts may be forced in software by the TRGINTx instructions:

         TRGINT1            Trigger INT1
         TRGINT2            Trigger INT2
         TRGINT3            Trigger INT3



Interrupts that have been triggered and are waiting to branch may be nixed in software by the NIXINTx instructions. These
instructions are only useful in main code after STALLI executes or in an ISR which needs to stop a lower-level interrupt from
executing after the current ISR exits:

         NIXINT1            Nix INT1
         NIXINT2            Nix INT2
         NIXINT3            Nix INT3



Interrupts can be stalled or allowed using the following instructions:

         ALLOWI             Allow any stalled and future interrupt branches to occur indefinitely (default mode on cog start)
         STALLI             Stall interrupt branches indefinitely until ALLOWI executes



When an interrupt event occurs, certain conditions must be met during execution before the interrupt branch can happen:



                                                                                                                                  50
      ●    ALTxx / CRCNIB / SCA / SCAS / GETCT+WC / GETXACC / SETQ / SETQ2 / XORO32 / XBYTE must not be
           executing
      ●    AUGS must not be executing or waiting for a S/# instruction
      ●    AUGD must not be executing or waiting for a D/# instruction
      ●    REP must not be executing or active
      ●    STALLI must not be executing or active
      ●    The cog must not be stalled in any WAITx instruction



Once these conditions are all met, any pending interrupt is allowed to branch, with priority given to INT1, then INT2, and then
INT3.

Interrupt branches are realized, internally, by inserting a 'CALLD IRETx,IJMPx WCZ' into the instruction pipeline while holding
the program counter at its current value, so that the interrupt later returns to the address saved in IRETx.

Interrupts loop through these three states:

      1)   Waiting for interrupt event
      2)   Waiting for interrupt branch
      3)   Executing interrupt service routine

During states 2 and 3, any intervening interrupt events at the same priority level are ignored. When state 1 is returned to, a
new interrupt event will be waited for.



Example:            Using INT1 as a CT1 interrupt

            org

start       mov        ijmp1,#isr1               'set int1 vector

            setint1 #1                           'set int1 for ct-passed-ct1 event

            getct      ct1                       'set initial ct1 target
            addct1     ct1,#50

                                                 'main program, gets interrupted
loop        drvnot     #0                        'toggle p0
            jmp        #loop                     'loop

                                                 'int1 isr, runs once every 50 clocks
isr1        drvnot     #1                        'toggle p1
            addct1     ct1,#50                   'update ct1 target
            reti1                                'return to main program

ct1         res                                  'reserve long for ct1




DEBUG INTERRUPT

In addition to the three visible interrupts, there is a fourth "hidden" interrupt that has priority over all the others. It is the debug
interrupt, and it is inaccessible to normal cog programs.

                                                                                                                                       51
Debug interrupts are enabled on a per-cog basis via HUBSET. Each debug-enabled cog will generate a debug interrupt on
(re)start from each COGINIT exercised upon it. Within that initial debug ISR and within each subsequent debug ISR, multiple
trigger conditions may be set for the next debug interrupt. If no trigger conditions are set before the debug ISR ends, no more
debug interrupts will occur until the cog is restarted from another COGINIT.

The last 16KB of hub RAM, which is also mapped to $FC000..$FFFFF, gets partially used as a buffer area for saving and
restoring cog registers during debug ISR's. The initial debug ISR routines are also stored in this upper RAM. Once initialized
with debug ISR code, this upper hub RAM can be write-protected, in which case it is mapped only to $FC000..$FFFFF and it is
only writable from within debug ISR's.

Each cog has an execute-only ROM in cog registers $1F8..$1FF which contains special debug-ISR-entry and -exit routines.
These tiny routines perform seamless register-load and register-restore operations for your debugger program, which must be
realized entirely within debug ISR's.



                 Execute-only ROM in cog registers $1F8..$1FF
                           (%cccc = !CogNumber)

 Debug ISR Entry - IJMP0 is initialized to $1F8 on COGINIT

 $1F8   -   SETQ       #$0F       'save registers $000..$00F
 $1F9   -   WRLONG     0,*        '* = %1111_1111_1ccc_c000_0000
 $1FA   -   SETQ       #$0F       'load program into $000..$00F
 $1FB   -   RDLONG     0,*        '* = %1111_1111_1ccc_c100_0000
 $1FC   -   JMP        #0         'jump to loaded program

 Debug ISR Exit - Jump here to exit your debug ISR

 $1FD -     SETQ       #$0F       'restore registers $000..$00F
 $1FE -     RDLONG     0,*        '* = %1111_1111_1ccc_c000_0000
 $1FF -     RETI0                 'CALLD IRET0,IRET0 WCZ



During a debug ISR, INA and INB, normally read-only input-pin registers, become readable/writable RAM registers named
IJMP0 and IRET0, and are used by the debug interrupt as jump and return addresses. On COGINIT, IJMP0 is initialized to
$1F8 which is the debug-ISR-entry routine's address.

When a debug interrupt occurs with IJMP0 pointing to $1F8, the following sequence happens:

             -     Cog registers $000 to $00F are saved to hub RAM starting at ($FF800 + !CogNumber << 7), or
                   %1111_1111_1ccc_c000_0000, where %cccc = !CogNumber.

             -     Cog registers $000 to $00F are loaded from hub RAM starting at ($FF840 + !CogNumber << 7), or
                   %1111_1111_1ccc_c100_0000, where %cccc = !CogNumber.

             -     A "JMP #$000" executes to run the 16-instruction debugger program that was just loaded into registers $000
                   to $00F.

Your 16-instruction debugger program will likely want to determine if this debug interrupt was due to a COGINIT, in which case
the debugger will probably want to note that a new program is now running in this cog. Depending on what the debugger must
do next, it is likely that it will need to save more registers to the upper hub RAM and then load in more code from the upper
hub RAM to facilitate more complex operations than the initial 16-instruction ISR can achieve. The ISR may then need to
perform some communication between itself and a host system which may be serving as the debugger's user interface. It may
be necessary to employ a LOCK to time-share P2-to-host communication channels among cogs, likely on P63 (serial Rx) and

                                                                                                                              52
P62 (serial Tx). This scenario is somewhat hypothetical, but illustrates the design intent behind the debug interrupt
mechanism.

When your debug ISR is complete, you can do a 'JMP #$1FD' to execute the debug-ISR-exit routine which does the following:

             -    Original cog registers $000 to $00F are restored from hub RAM starting at ($FF800 + !CogNumber << 7), or
                  %1111_1111_1ccc_c000_0000, where %cccc = !CogNumber.

             -    A "RETI0" executes to return to the interrupted cog program.



Here is a table of the hub RAM locations used by each cog for register save/restore and ISR images during the debug interrupt
when the register ROM routines are used for ISR entry and exit:



   Cog           Save/Restore in Hub RAM               ISR image in Hub RAM
                  for Registers $000..$00F            for Registers $000..$00F

     7               $FFC00..$FFC3F                       $FFC40..$FFC7F

     6               $FFC80..$FFCBF                       $FFCC0..$FFCFF

     5               $FFD00..$FFD3F                       $FFD40..$FFD7F

     4               $FFD80..$FFDBF                       $FFDC0..$FFDFF

     3               $FFE00..$FFE3F                       $FFE40..$FFE7F

     2               $FFE80..$FFEBF                       $FFEC0..$FFEFF

     1               $FFF00..$FFF3F                       $FFF40..$FFF7F

     0               $FFF80..$FFFBF                       $FFFC0..$FFFFF



Though the first debug interrupt upon cog (re)start will always use the debug-ISR-entry routine at $1F8, you may redirect
IJMP0 during any debug ISR to point elsewhere for use by subsequent debug interrupts. This would mean that you would lose
the initial register-saving function provided by the small ROM starting at $1F8, so you would have to use some cog registers
for debugger-state storage that don't interfere with the cog program that is being debugged. If no register saving/restoring or
host communications are required, your debug ISR may execute very quickly.

What terminates a debug interrupt is not only RETI0 (CALLD INB,INB WCZ), but any D-register variant (CALLD anyreg,INB
WCZ). For example RESI0 (CALLD INA,INB WCZ) may be used to resume next time from where this debug ISR left off, but
this would imply that you are not using the debug-ISR-entry and -exit routines in the cog-register ROM and have, instead,
permanently located debugger code into some cog registers, so that your debugger program is already present at the start of
the debug interrupt.

This debug interrupt scheme was designed to operate stealthily, without any cooperation from the cog program being
debugged. All control has been placed within the debug ISR. This isolation from normal programming is intended to prevent, or
at least discourage, programmers from making any aspect of the debug interrupt system part of their application, thereby
rendering the debug interrupt compromised as a standard debugging mechanism. Also, by executing the ISR strictly in cog
register space, this scheme does not interfere with the hub FIFO state, which would be impossible to reconstruct if disturbed
by hub execution within the debug ISR.

Below are the instructions which are used in the debugging mechanism:

                                                                                                                             53
BRK D/#

During normal program execution, the BRK instruction is used to generate a debug interrupt with an 8-bit code which can be
read within the debug ISR. The BRK instruction interrupt must be enabled from within a prior debug ISR for this to work.
Regardless of the execution condition, the BRK instruction will trigger a debug interrupt, if enabled. The execution condition
only gates the writing of the 8-bit code:

  D/# = %BBBBBBBB: 8-bit BRK code



During a debug ISR, the BRK instruction operates differently and is used to establish the next debug interrupt condition(s). It is
also used to select INA/INB, instead of the IJMP0/IRET0 registers exposed during the ISR, so that the pins' inputs states may
be read:

  D/# = %aaaaaaaaaaaaaaaaeeee_LKJIHGFEDCBA

     %aaaaaaaaaaaaaaaaeeee: 20-bit breakpoint address or 4-bit event code (%eeee)
     %L: 1 = map INA/INB normally, 0 = map IJMP0/IRET0 at INA/INB (default during ISR) *
     %K: 1 = enable interrupt on breakpoint address match
     %J: 1 = enable interrupt on event %eeee
     %I: 1 = enable interrupt on asynchronous breakpoint (via COGBRK on another cog)
     %H: 1 = enable interrupt on INT3 ISR entry
     %G: 1 = enable interrupt on INT2 ISR entry
     %F: 1 = enable interrupt on INT1 ISR entry
     %E: 1 = enable interrupt on BRK instruction
     %D: 1 = enable interrupt on INT3 ISR code (single step)
     %C: 1 = enable interrupt on INT2 ISR code (single step)
     %B: 1 = enable interrupt on INT1 ISR code (single step)
     %A: 1 = enable interrupt on non-ISR code (single step)

     * If set to 1 by the debug ISR, %L must be reset to 0 before exiting the debug ISR, so
       that the RETI0 instruction is able to see IJMP0 and IRET0.

On debug ISR entry, bits L to A are cleared to '0'. If a subsequent debug interrupt is desired, a BRK instruction must be
executed before exiting the debug ISR, in order to establish the next breakpoint condition(s).



COGBRK D/#

The COGBRK instruction can trigger an asynchronous breakpoint in another cog. For this to work, the cog executing the
COGBRK instruction must be in its own debug ISR and the other cog must have its asynchronous breakpoint interrupt
enabled:

  D/# = %CCCC: the cog in which to trigger an asynchronous breakpoint



GETBRK D WCZ

During normal program execution, GETBRK with WCZ returns various data about the cog's internal status:

  C = 1 if STALLI mode or 0 if ALLOWI mode (established by STALLI/ALLOWI)

                                                                                                                                 54
  Z = 1 if cog started in hubexec or 0 if cog started in cogexec

  D[31:23] = 0
  D[22] = 1 if colorspace converter is active
  D[21] = 1 if streamer is active
  D[20] = 1 if WRFAST mode or 0 if RDFAST mode
  D[19:16] = INT3 selector, established by SETINT3
  D[15:12] = INT2 selector, established by SETINT2
  D[11:08] = INT1 selector, established by SETINT1
  D[07:06] = INT3 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
  D[05:04] = INT2 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
  D[03:02] = INT1 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
  D[01] = 1 if STALLI mode or 0 if ALLOWI mode (established by STALLI/ALLOWI)
  D[00] = 1 if cog started in hubexec or 0 if cog started in cogexec



During a debug ISR, GETBRK with WCZ returns additional data that is useful to a debugger:

  C = 1 if debug interrupt was from a COGINIT, indicating that the cog was (re)started

  D[31:24] = 8-bit break code from the last 'BRK #/D' during normal execution
  D[23] = 1 if debug interrupt was from a COGINIT, indicating that the cog was (re)started




GETBRK D WC

GETBRK with WC always returns the following:

  C = LSB of SKIP/SKIPF/EXECF/XBYTE pattern

  D[31:28] = 4-bit CALL depth since SKIP/SKIPF/EXECF/XBYTE (skipping suspended if not %0000)
  D[27] = 1 if SKIP mode or 0 if SKIPF/EXECF/XBYTE mode
  D[26] = 1 if LUT sharing enabled (established by SETLUTS)
  D[25] = 1 if top of stack = $001FF, indicating XBYTE will execute on next _RET_/RET
  D[24:16] = 9-bit XBYTE mode, established by '_RET_ SETQ/SETQ2' when top of stack = $001FF
  D[15:00] = 16 event-trap flags
     D[15] = GETQX/GETQY executed without prior CORDIC command
     D[14] = attention requested by cog(s)
     D[13] = streamer read location $1FF of lookup RAM
     D[12] = streamer NCO rolled over
     D[11] = streamer finished, now idle
     D[10] = streamer ready to accept new command
     D[09] = hub RAM FIFO interface loaded block count and start address
     D[08] = pin pattern match occurred
     D[07] = SE4 event occurred
     D[06] = SE3 event occurred
     D[05] = SE2 event occurred
     D[04] = SE1 event occurred
     D[03] = CT-passed-CT1
     D[02] = CT-passed-CT2
     D[01] = CT-passed-CT3
     D[00] = INT1, INT2, or INT3 occurred

                                                                                             55
