●
●

Set whenever GETQX/GETQY executes without any CORDIC results available or in progress.
Also cleared on POLLQMT/WAITQMT/JQMT/JNQMT.

Example:

ADDCT1/WAITCT1

'ADDCT1 D,S/#' must be used to establish a CT target. This is done by first using 'GETCT D' to get the current CT
value into a register, and then using ADDCT1 to add into that register, thereby making a future CT target, which,
when passed, will trigger the CT-passed-CT1 event and set the related event flag.
GETCT
ADDCT1
.loop

x
x,#500

WAITCT1
ADDCT1 x,#500
DRVNOT #0
JMP
#.loop

'get initial CT
'make initial CT1 target
'wait for CT to pass CT1 target
'update CT1 target
'toggle P0
'loop to the WAITCT1

It doesn't matter what register is used to keep track of the CT1 target. Whenever ADDCT1 executes, S/# is added
into D, and the result gets copied into a dedicated CT1 target register that is compared to CT on every clock. When
CT passes the CT1 target, the event flag is set. ADDCT1 clears the CT-passed-CT1 event flag to help with
initialization and cycling.

Selectable Events
Each cog can track up to four selectable pin, LUT, or hub lock events. This is accomplished by using the SETSEn instruction,
where "n" is 1, 2, 3, or 4. In order for user code to detect the occurrence of the selected event, the following options are
available:
●
●
●
●

The matched WAITSEn instruction will block until the event occurs
The matched POLLSEn instruction will check for the event without blocking
The matches JSEn and JNSEn branch instructions will branch according to the polled event state
As an interrupt (see INTERRUPTS)

Each selected event is set or cleared according to the following rules:
●
●
●

SEn is set whenever the configured event occurs.
SEn is cleared on matched POLLSEn / WAITSEn / JSEn / JNSEn.
SEn is cleared when matched 'SETSEn D/#' is called.

SETSEn D/# accepts the following configuration values:
%000_00_00AA = this cog reads LUT address %1111111AA
%000_00_01AA = this cog writes LUT address %1111111AA
%000_00_10AA = odd/even companion cog reads LUT address %1111111AA
%000_00_11AA = odd/even companion cog writes LUT address %1111111AA
%000_01_LLLL = hub lock %LLLL rises
%000_10_LLLL = hub lock %LLLL falls
%000_11_LLLL = hub lock %LLLL changes

48

%001_PPPPPP = INA/INB bit of pin %PPPPPP rises
%010_PPPPPP = INA/INB bit of pin %PPPPPP falls
%011_PPPPPP = INA/INB bit of pin %PPPPPP changes
%10x_PPPPPP = INA/INB bit of pin %PPPPPP is low
%11x_PPPPPP = INA/INB bit of pin %PPPPPP is high

INTERRUPTS
Each cog has three interrupts: INT1, INT2, and INT3.
INT1 has the highest priority and can interrupt INT2 and INT3.
INT2 has the middle priority and can interrupt INT3.
INT3 has the lowest priority and can only interrupt non-interrupt code.
The STALLI instruction can be used to hold off INT1, INT2 and INT3 interrupt branches indefinitely, while the ALLOWI
instruction allows those interrupt branches to occur. Critical blocks of code can, therefore, be protected from interruption by
beginning with STALLI and ending with ALLOWI.
There are 16 interrupt event sources, selected by a 4-bit pattern:
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

<off>, default on cog start for INT1/INT2/INT3 event sources
CT-passed-CT1, established by ADDCT1
CT-passed-CT2, established by ADDCT2
CT-passed-CT3, established by ADDCT3
SE1 event occurred, established by SETSE1
SE2 event occurred, established by SETSE2
SE3 event occurred, established by SETSE3
SE4 event occurred, established by SETSE4
Pin pattern match or mismatch occurred, established by SETPAT
Hub RAM FIFO interface wrapped and reloaded, established by RDFAST/WRFAST/FBLOCK
Streamer is ready for another command, established by XINIT/XZERO/ZCONT
Streamer ran out of commands, established by XINIT/XZERO/ZCONT
Streamer NCO rolled over, established by XINIT/XZERO/XCONT
Streamer read location $1FF of lookup RAM
Attention requested by other cog(s)
GETQX/GETQY executed without any CORDIC results available or in progress

To set up an interrupt, you need to first point its IJMP register to your interrupt service routine (ISR). When the interrupt occurs,
it will jump to where the IJMP register points and simultaneously store the C/Z flags and return address into the adjacent IRET
register:
$1F0
$1F1
$1F2
$1F3
$1F4
$1F5

RAM
RAM
RAM
RAM
RAM
RAM

/
/
/
/
/
/

IJMP3
IRET3
IJMP2
IRET2
IJMP1
IRET1

interrupt
interrupt
interrupt
interrupt
interrupt
interrupt

call
return
call
return
call
return

address
address
address
address
address
address

for
for
for
for
for
for

INT3
INT3
INT2
INT2
INT1
INT1

49

When your ISR is done, it can do a RETIx instruction to return to the interrupted code. The RETIx instructions are actually
CALLD instructions:
RETI1
RETI2
RETI3

=
=
=

CALLD INB,IRET1
CALLD INB,IRET2
CALLD INB,IRET3

WCZ
WCZ
WCZ

The CALLD with D = <any register>, S = IRETx, and WCZ, signals the cog that the interrupt is complete. This causes the cog
to clear its internal interrupt-busy flag for that interrupt, so that another interrupt can occur. INB (read-only) is used as D for
RETIx instructions to effectively make the CALLD into a JMP back to the interrupted code.
Instead of using RETIx, though, you could use RESIx to have your ISR resume at the next instruction when the next interrupt
occurs:
RESI1
RESI2
RESI3

=
=
=

CALLD IJMP1,IRET1
CALLD IJMP2,IRET2
CALLD IJMP3,IRET3

WCZ
WCZ
WCZ

Once you've got the IJMPx register configured to point to your ISR, you can enable the interrupt. This is done using the
SETINTx instruction:
SETINT1 D/#
SETINT2 D/#
SETINT3 D/#

Set INT1 event to 0..15 (see table above)
Set INT2 event to 0..15 (see table above)
Set INT3 event to 0..15 (see table above)

Interrupts may be forced in software by the TRGINTx instructions:
TRGINT1
TRGINT2
TRGINT3

Trigger INT1
Trigger INT2
Trigger INT3

Interrupts that have been triggered and are waiting to branch may be nixed in software by the NIXINTx instructions. These
instructions are only useful in main code after STALLI executes or in an ISR which needs to stop a lower-level interrupt from
executing after the current ISR exits:
NIXINT1
NIXINT2
NIXINT3

Nix INT1
Nix INT2
Nix INT3

Interrupts can be stalled or allowed using the following instructions:
ALLOWI
STALLI

Allow any stalled and future interrupt branches to occur indefinitely (default mode on cog start)
Stall interrupt branches indefinitely until ALLOWI executes

When an interrupt event occurs, certain conditions must be met during execution before the interrupt branch can happen:

50

●
●
●
●
●
●

ALTxx / CRCNIB / SCA / SCAS / GETCT+WC / GETXACC / SETQ / SETQ2 / XORO32 / XBYTE must not be
executing
AUGS must not be executing or waiting for a S/# instruction
AUGD must not be executing or waiting for a D/# instruction
REP must not be executing or active
STALLI must not be executing or active
The cog must not be stalled in any WAITx instruction

Once these conditions are all met, any pending interrupt is allowed to branch, with priority given to INT1, then INT2, and then
INT3.
Interrupt branches are realized, internally, by inserting a 'CALLD IRETx,IJMPx WCZ' into the instruction pipeline while holding
the program counter at its current value, so that the interrupt later returns to the address saved in IRETx.
Interrupts loop through these three states:
1)
2)
3)

Waiting for interrupt event
Waiting for interrupt branch
Executing interrupt service routine

During states 2 and 3, any intervening interrupt events at the same priority level are ignored. When state 1 is returned to, a
new interrupt event will be waited for.

Example:

Using INT1 as a CT1 interrupt
org

start

mov

ijmp1,#isr1

'set int1 vector

setint1 #1

'set int1 for ct-passed-ct1 event

getct
addct1

ct1
ct1,#50

'set initial ct1 target

loop

drvnot
jmp

#0
#loop

isr1

drvnot
addct1
reti1

#1
ct1,#50

ct1

res

'main program, gets interrupted
'toggle p0
'loop
'int1 isr, runs once every 50 clocks
'toggle p1
'update ct1 target
'return to main program
'reserve long for ct1

DEBUG INTERRUPT
In addition to the three visible interrupts, there is a fourth "hidden" interrupt that has priority over all the others. It is the debug
interrupt, and it is inaccessible to normal cog programs.
51

Debug interrupts are enabled on a per-cog basis via HUBSET. Each debug-enabled cog will generate a debug interrupt on
(re)start from each COGINIT exercised upon it. Within that initial debug ISR and within each subsequent debug ISR, multiple
trigger conditions may be set for the next debug interrupt. If no trigger conditions are set before the debug ISR ends, no more
debug interrupts will occur until the cog is restarted from another COGINIT.
The last 16KB of hub RAM, which is also mapped to $FC000..$FFFFF, gets partially used as a buffer area for saving and
restoring cog registers during debug ISR's. The initial debug ISR routines are also stored in this upper RAM. Once initialized
with debug ISR code, this upper hub RAM can be write-protected, in which case it is mapped only to $FC000..$FFFFF and it is
only writable from within debug ISR's.
Each cog has an execute-only ROM in cog registers $1F8..$1FF which contains special debug-ISR-entry and -exit routines.
These tiny routines perform seamless register-load and register-restore operations for your debugger program, which must be
realized entirely within debug ISR's.

Execute-only ROM in cog registers $1F8..$1FF
(%cccc = !CogNumber)
Debug ISR Entry - IJMP0 is initialized to $1F8 on COGINIT
$1F8
$1F9
$1FA
$1FB
$1FC

-

SETQ
WRLONG
SETQ
RDLONG
JMP

#$0F
0,*
#$0F
0,*
#0

'save registers $000..$00F
'* = %1111_1111_1ccc_c000_0000
'load program into $000..$00F
'* = %1111_1111_1ccc_c100_0000
'jump to loaded program

Debug ISR Exit - Jump here to exit your debug ISR
$1FD $1FE $1FF -

SETQ
RDLONG
RETI0

#$0F
0,*

'restore registers $000..$00F
'* = %1111_1111_1ccc_c000_0000
'CALLD IRET0,IRET0 WCZ

During a debug ISR, INA and INB, normally read-only input-pin registers, become readable/writable RAM registers named
IJMP0 and IRET0, and are used by the debug interrupt as jump and return addresses. On COGINIT, IJMP0 is initialized to
$1F8 which is the debug-ISR-entry routine's address.
When a debug interrupt occurs with IJMP0 pointing to $1F8, the following sequence happens:
-

Cog registers $000 to $00F are saved to hub RAM starting at ($FF800 + !CogNumber << 7), or
%1111_1111_1ccc_c000_0000, where %cccc = !CogNumber.

-

Cog registers $000 to $00F are loaded from hub RAM starting at ($FF840 + !CogNumber << 7), or
%1111_1111_1ccc_c100_0000, where %cccc = !CogNumber.

-

A "JMP #$000" executes to run the 16-instruction debugger program that was just loaded into registers $000
to $00F.

Your 16-instruction debugger program will likely want to determine if this debug interrupt was due to a COGINIT, in which case
the debugger will probably want to note that a new program is now running in this cog. Depending on what the debugger must
do next, it is likely that it will need to save more registers to the upper hub RAM and then load in more code from the upper
hub RAM to facilitate more complex operations than the initial 16-instruction ISR can achieve. The ISR may then need to
perform some communication between itself and a host system which may be serving as the debugger's user interface. It may
be necessary to employ a LOCK to time-share P2-to-host communication channels among cogs, likely on P63 (serial Rx) and
52

P62 (serial Tx). This scenario is somewhat hypothetical, but illustrates the design intent behind the debug interrupt
mechanism.
When your debug ISR is complete, you can do a 'JMP #$1FD' to execute the debug-ISR-exit routine which does the following:
-

Original cog registers $000 to $00F are restored from hub RAM starting at ($FF800 + !CogNumber << 7), or
%1111_1111_1ccc_c000_0000, where %cccc = !CogNumber.

-

A "RETI0" executes to return to the interrupted cog program.

Here is a table of the hub RAM locations used by each cog for register save/restore and ISR images during the debug interrupt
when the register ROM routines are used for ISR entry and exit:

Cog

Save/Restore in Hub RAM
for Registers $000..$00F

ISR image in Hub RAM
for Registers $000..$00F

7

$FFC00..$FFC3F

$FFC40..$FFC7F

6

$FFC80..$FFCBF

$FFCC0..$FFCFF

5

$FFD00..$FFD3F

$FFD40..$FFD7F

4

$FFD80..$FFDBF

$FFDC0..$FFDFF

3

$FFE00..$FFE3F

$FFE40..$FFE7F

2

$FFE80..$FFEBF

$FFEC0..$FFEFF

1

$FFF00..$FFF3F

$FFF40..$FFF7F

0

$FFF80..$FFFBF

$FFFC0..$FFFFF

Though the first debug interrupt upon cog (re)start will always use the debug-ISR-entry routine at $1F8, you may redirect
IJMP0 during any debug ISR to point elsewhere for use by subsequent debug interrupts. This would mean that you would lose
the initial register-saving function provided by the small ROM starting at $1F8, so you would have to use some cog registers
for debugger-state storage that don't interfere with the cog program that is being debugged. If no register saving/restoring or
host communications are required, your debug ISR may execute very quickly.
What terminates a debug interrupt is not only RETI0 (CALLD INB,INB WCZ), but any D-register variant (CALLD anyreg,INB
WCZ). For example RESI0 (CALLD INA,INB WCZ) may be used to resume next time from where this debug ISR left off, but
this would imply that you are not using the debug-ISR-entry and -exit routines in the cog-register ROM and have, instead,
permanently located debugger code into some cog registers, so that your debugger program is already present at the start of
the debug interrupt.
This debug interrupt scheme was designed to operate stealthily, without any cooperation from the cog program being
debugged. All control has been placed within the debug ISR. This isolation from normal programming is intended to prevent, or
at least discourage, programmers from making any aspect of the debug interrupt system part of their application, thereby
rendering the debug interrupt compromised as a standard debugging mechanism. Also, by executing the ISR strictly in cog
register space, this scheme does not interfere with the hub FIFO state, which would be impossible to reconstruct if disturbed
by hub execution within the debug ISR.
Below are the instructions which are used in the debugging mechanism:
53

BRK D/#
During normal program execution, the BRK instruction is used to generate a debug interrupt with an 8-bit code which can be
read within the debug ISR. The BRK instruction interrupt must be enabled from within a prior debug ISR for this to work.
Regardless of the execution condition, the BRK instruction will trigger a debug interrupt, if enabled. The execution condition
only gates the writing of the 8-bit code:
D/# = %BBBBBBBB: 8-bit BRK code

During a debug ISR, the BRK instruction operates differently and is used to establish the next debug interrupt condition(s). It is
also used to select INA/INB, instead of the IJMP0/IRET0 registers exposed during the ISR, so that the pins' inputs states may
be read:
D/# = %aaaaaaaaaaaaaaaaeeee_LKJIHGFEDCBA
%aaaaaaaaaaaaaaaaeeee: 20-bit breakpoint address or 4-bit event code (%eeee)
%L: 1 = map INA/INB normally, 0 = map IJMP0/IRET0 at INA/INB (default during ISR) *
%K: 1 = enable interrupt on breakpoint address match
%J: 1 = enable interrupt on event %eeee
%I: 1 = enable interrupt on asynchronous breakpoint (via COGBRK on another cog)
%H: 1 = enable interrupt on INT3 ISR entry
%G: 1 = enable interrupt on INT2 ISR entry
%F: 1 = enable interrupt on INT1 ISR entry
%E: 1 = enable interrupt on BRK instruction
%D: 1 = enable interrupt on INT3 ISR code (single step)
%C: 1 = enable interrupt on INT2 ISR code (single step)
%B: 1 = enable interrupt on INT1 ISR code (single step)
%A: 1 = enable interrupt on non-ISR code (single step)
* If set to 1 by the debug ISR, %L must be reset to 0 before exiting the debug ISR, so
that the RETI0 instruction is able to see IJMP0 and IRET0.
On debug ISR entry, bits L to A are cleared to '0'. If a subsequent debug interrupt is desired, a BRK instruction must be
executed before exiting the debug ISR, in order to establish the next breakpoint condition(s).

COGBRK D/#
The COGBRK instruction can trigger an asynchronous breakpoint in another cog. For this to work, the cog executing the
COGBRK instruction must be in its own debug ISR and the other cog must have its asynchronous breakpoint interrupt
enabled:
D/# = %CCCC: the cog in which to trigger an asynchronous breakpoint

GETBRK D WCZ
During normal program execution, GETBRK with WCZ returns various data about the cog's internal status:
C = 1 if STALLI mode or 0 if ALLOWI mode (established by STALLI/ALLOWI)
54

Z = 1 if cog started in hubexec or 0 if cog started in cogexec
D[31:23] = 0
D[22] = 1 if colorspace converter is active
D[21] = 1 if streamer is active
D[20] = 1 if WRFAST mode or 0 if RDFAST mode
D[19:16] = INT3 selector, established by SETINT3
D[15:12] = INT2 selector, established by SETINT2
D[11:08] = INT1 selector, established by SETINT1
D[07:06] = INT3 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
D[05:04] = INT2 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
D[03:02] = INT1 state: %0x = idle, %10 = interrupt pending, %11 = ISR executing
D[01] = 1 if STALLI mode or 0 if ALLOWI mode (established by STALLI/ALLOWI)
D[00] = 1 if cog started in hubexec or 0 if cog started in cogexec

During a debug ISR, GETBRK with WCZ returns additional data that is useful to a debugger:
C = 1 if debug interrupt was from a COGINIT, indicating that the cog was (re)started
D[31:24] = 8-bit break code from the last 'BRK #/D' during normal execution
D[23] = 1 if debug interrupt was from a COGINIT, indicating that the cog was (re)started

GETBRK D WC
GETBRK with WC always returns the following:
C = LSB of SKIP/SKIPF/EXECF/XBYTE pattern
D[31:28] = 4-bit CALL depth since SKIP/SKIPF/EXECF/XBYTE (skipping suspended if not %0000)
D[27] = 1 if SKIP mode or 0 if SKIPF/EXECF/XBYTE mode
D[26] = 1 if LUT sharing enabled (established by SETLUTS)
D[25] = 1 if top of stack = $001FF, indicating XBYTE will execute on next _RET_/RET
D[24:16] = 9-bit XBYTE mode, established by '_RET_ SETQ/SETQ2' when top of stack = $001FF
D[15:00] = 16 event-trap flags
D[15] = GETQX/GETQY executed without prior CORDIC command
D[14] = attention requested by cog(s)
D[13] = streamer read location $1FF of lookup RAM
D[12] = streamer NCO rolled over
D[11] = streamer finished, now idle
D[10] = streamer ready to accept new command
D[09] = hub RAM FIFO interface loaded block count and start address
D[08] = pin pattern match occurred
D[07] = SE4 event occurred
D[06] = SE3 event occurred
D[05] = SE2 event occurred
D[04] = SE1 event occurred
D[03] = CT-passed-CT1
D[02] = CT-passed-CT2
D[01] = CT-passed-CT3
D[00] = INT1, INT2, or INT3 occurred
55

GETBRK D WZ
GETBRK with WZ always returns the following:
Z = 1 if no SKIP/SKIPF/EXECF/XBYTE pattern queued (D = 0) or 1 if pattern queued (D <> 0)
D = 32-bit SKIP/SKIPF/EXECF/XBYTE pattern, used LSB-first to skip instructions in main code

HUB
Configuration
The hub contains several global circuits which are configured using the HUBSET instruction. HUBSET uses a single D
operand to both select the circuit to be configured and to provide the configuration data:
HUBSET

{#}D

- Configure global circuit selected by MSBs

%0000_xxxE_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
%0001_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx
%0010_xxxx_xxxx_xxLW_DDDD_DDDD_DDDD_DDDD
%0100_xxxx_xxxx_xxxx_xxxx_xxxR_RLLT_TTTT
%1DDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD

Set clock generator mode
Hard reset, reboots chip
Set write-protect and debug enables
Set filter R to length L and tap T
Seed Xoroshiro128** PRNG with D

Configuring the Clock Generator
The Prop2 can generate its system clock in several different ways.
There are two separate internal RC clock oscillators that can be used, a 20MHz+ (RCFAST) and a ~20kHz (RCSLOW). The
20MHz+ oscillator is designed to always run at least 20MHz, worst-case, in order to accommodate 2M baud serial loading
during boot. The ~20kHz oscillator is intended for low-power operation.
The XI and XO pins can also be used for clocking, with XI being an input and XO being a crystal-feedback output for
10MHz-20MHz crystals. Internal loading caps can also be enabled on XI and XO for crystal impedance matching.
If the XI pin is used as a clock input or crystal oscillator input, its frequency can be modified through an internal phase-locked
loop (PLL). The PLL divides the XI pin frequency from 1 to 64, then multiplies the resulting frequency from 1 to 1024 in the
VCO. The VCO frequency can be used directly, or divided by 2, 4, 6, ...30, to get the final PLL clock frequency which can be
used as the system clock.
The clock configuration setting consists of 25 bits. The four LSBs are all that are needed to switch among clock sources and
select all but the PLL settings.
HUBSET

##%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS

'set clock mode
56

The tables below explain the various bit fields within the HUBSET operand:

PLL Setting

Value

Effect

Notes

%E

0/1

PLL off/on

XI input must be enabled by %CC. Allow 10ms for crystal+PLL to
stabilize before switching over to PLL clock source.

%DDDDDD

0..63

1..64 division of XI
pin frequency

This divided XI frequency feeds into the phase-frequency
comparator's 'reference' input.

%MMMMMMMMMM

0..1023

1..1024 division of
VCO frequency

This divided VCO frequency feeds into the phase-frequency
comparator's 'feedback' input. This frequency division has the
effect of multiplying the divided XI frequency (per %DDDDDD)
inside the VCO. The VCO frequency should be kept within 100
MHz to 200 Mhz.

%PPPP

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

VCO / 2
VCO / 4
VCO / 6
VCO / 8
VCO / 10
VCO / 12
VCO / 14
VCO / 16
VCO / 18
VCO / 20
VCO / 22
VCO / 24
VCO / 26
VCO / 28
VCO / 30
VCO / 1

This divided VCO frequency is selectable as the system clock
when SS = %11.
For fastest overclocking, the PLL can be pushed to 350 MHz using
the 'VCO / 1' mode (%PPPP = 15).

%CC

XI status

XO status

XI / XO
impedance

XI / XO
loading caps

%00

ignored

float

Hi-Z

OFF

%01

input

600-ohm drive

1M-ohm

OFF

%10

input

600-ohm drive

1M-ohm

15pF per pin

%11

input

600-ohm drive

1M-ohm

30pF per pin

%SS

Clock Source

%11

PLL

%10

XI

%01

RCSLOW

~20 kHz, can be switched to at any time, low-power

%00

RCFAST

20 MHz+, can be switched to at any time, used on boot-up.

Notes
CC != %00 and E=1, allow 10ms for crystal+PLL to stabilize before switching to PLL
CC != %00, allow 5ms for crystal to stabilize before switching to XI pin

57

WARNING: Incorrectly switching away from the PLL setting (%SS = %11 and %CC <> %00) with %PPPP = %1111 can cause
a clock glitch which will hang the P2 chip until a reset occurs. In order to safely switch away, always start by switching to an
internal RC oscillator (%SS = %00 or %01), while maintaining the %PPPP = %1111 and %CC settings.

PLL Example
The PLL's VCO is designed to run between 100 MHz and 200 MHz and should be kept within that range.
𝑉𝐶𝑂 =

𝐹𝑟𝑒𝑞(𝑋𝐼) × (%𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀𝑀 + 1)
(%𝐷𝐷𝐷𝐷𝐷𝐷 + 1)

𝑃𝐿𝐿 = 𝑖𝑓(%𝑃𝑃𝑃𝑃 = 15) ⇒ 𝑉𝐶𝑂
𝑃𝐿𝐿 = 𝑖𝑓(%𝑃𝑃𝑃𝑃 ≠ 15) ⇒

𝑉𝐶𝑂
(%𝑃𝑃𝑃𝑃 + 1) × 2

Let's say you have a 20 MHz crystal attached to XI and XO and you want to run the Prop2 at 148.5 MHz. You could divide the
crystal by 40 (%DDDDDD = 39) to get a 500 kHz reference, then multiply that by 297 (%MMMMMMMMMM = 296) in the VCO
to get 148.5 MHz. You would set %PPPP to %1111 to use the VCO output directly. The configuration value would be
%1_100111_0100101000_1111_10_11. The last two 2-bit fields select 15pf crystal mode and the PLL. In order to realize this
clock setting, though, it must be done over a few steps:
HUBSET

#$F0

'set 20 MHz+ (RCFAST) mode

HUBSET

##%1_100111_0100101000_1111_10_00

'enable crystal+PLL, stay in RCFAST mode

WAITX

##20_000_000/100

'wait ~10ms for crystal+PLL to stabilize

HUBSET

##%1_100111_0100101000_1111_10_11

'now switch to PLL running at 148.5 MHz

The clock selector controlled by the %SS bits has a deglitching circuit which waits for a positive edge on the old clock source
before disengaging, holding its output high, and then waiting for a positive edge on the new clock source before switching over
to it. It is necessary to select mode %00 or %01 while waiting for the crystal and/or PLL to settle into operation, before
switching over to either.

Write-Protecting the Last 16KB of Hub RAM and Enabling Debug Interrupts
HUBSET

{#}D

'set write-protect and enable debug interrupts

{#}D = %0010_xxxx_xxxx_xxLW_DDDD_DDDD_DDDD_DDDD
%L:

Lock W and D bit settings until next reset
0 = establish W and D bit settings and allow subsequent modification
1 = establish W and D bit settings and disallow subsequent modification

%W:

Write-protect last 16KB of hub RAM
0 = Last 16KB of hub RAM can be read and written at both its normal range
and at $FC000..$FFFFF (default)
1 = Last 16KB of hub RAM disappears from its normal range and is writeprotected at $FC000..$FFFFF, except from within debug ISR's

%D:

Debug interrupt enables for cogs 15..0, respectively
0 = Debug interrupt is disabled for cog n (default)
58

1 = Debug interrupt is enabled for cog n
Examples:
HUBSET

##$2000_0001

'enable debug interrupt for cog 0

HUBSET

##$2001_FFFF

'enable debug interrupts for cogs 15..0
'..and write-protect the last 16KB of hub RAM

HUBSET

##$2003_00FF

'enable debug interrupts for cogs 7..0
'..and write-protect the last 16KB of hub RAM
'..and disallow subsequent changes to this scheme

See the DEBUG INTERRUPT section to learn how debug interrupts work.

Configuring the Digital Filters for Smart Pins
There are four global digital filter settings which can be used by each smart pin to low-pass filter its incoming pin states.
Each filter setting includes a filter length and a timing tap. The filter length is 2, 3, 5, or 8 flipflops, selected by values 0..3. The
flipflops shift pin state data at the timing tap rate and must be unanimously high or low to change the filter output to high or low.
The timing tap is one of the lower 32 bits of CT (the free-running 64-bit global counter), selected by values 0..31. Each time the
selected tap transitions, the current pin state is shifted into the flipflops and if the flipflops are all in agreement, the filter output
goes to that state. The filter will be reflected in the INA/INB bits if no smart pin mode is selected, or the filter states will be used
by the smart pin mode as its inputs.
The D operand selects both the filter to configure and the data to configure it with:
HUBSET
HUBSET
HUBSET
HUBSET

##$4000_0000
##$4000_0080
##$4000_0100
##$4000_0180

+
+
+
+

Length<<5
Length<<5
Length<<5
Length<<5

+
+
+
+

Tap
Tap
Tap
Tap

'set
'set
'set
'set

filt0
filt1
filt2
filt3

"Length" is 0..3 for 2, 3, 5, or 8 flipflops.
"Tap" is 0..31 for every single clock, every 2nd clock, every 4th clock,... every 2,147,483,648th clock.
The filters are set to the following defaults on reset:

Filter

Length
(flipflops)

Tap
(clocks per sample)

Low-pass time
(at 6.25ns/clock)

filt0

0
(2 flipflops)

0
(1:1)

12.5ns
(6.25ns * 2 * 1)

filt1

1
(3 flipflops)

5
(32:1)

600ns
(6.25ns * 3 * 32)

59

filt2

2
(5 flipflops)

19
(512K:1)

16.4ms
(6.25ns * 5 * 512K)

filt3

3
(8 flipflops)

22
(4M:1)

210ms
(6.25ns * 8 * 4M)

Seeding the Xoroshiro128** PRNG
To seed 32 bits of state data into the 128-bit PRNG, use HUBSET with the MSB of D set. This will write {1'b1, D[30:0]} into 32
bits of the PRNG, affecting 1/4th of its total state. The 1'b1 bit ensures that the overall state will not go to zero. Because the
PRNG's 128 state bits rotate, shift, and XOR against each other, they are thoroughly spread around within a few clocks, so
seeding from a fixed set of 32 bits should not pose a limitation on seeding quality.
After reset, the boot ROM uses HUBSET to seed the Xoroshiro128** PRNG fifty times, each time with 31 bits of thermal noise
gleaned from pin 63 while in ADC calibration mode. This establishes a very random seed which the PRNG iterates from,
thereafter. There is no need to do this again, but here is how you would do it if 'x' contained a seed value:
SETB
HUBSET

x,#31
x

'set the MSB of x to make a PRNG seed command
'seed 32 bits of the Xoroshiro128** state

The Xoroshiro128** PRNG iterates on every clock, generating 64 fresh bits which get spread among all cogs and smart pins.
Each cog receives a unique set of 32 different bits, in a scrambled arrangement with some bits inverted, from the 64-bit pool.
Each smart pin receives a similarly-unique set of 8 different bits. Cogs can sample these bits using the GETRND instruction
and directly apply them using the BITRND and DRVRND instructions. Smart pins utilize their 8 bits as noise sources for DAC
dithering and noise output.

Rebooting the Chip
HUBSET can be used to reset and reboot the chip:
HUBSET

##$1000_0000

'generate an internal reset pulse to reboot

HUB RAM
The globally-accessible hub RAM can be read and written as bytes, words, and longs, in little-endian format. Hub addresses
are always byte-oriented. There are no special alignment rules for words and longs in hub RAM. Cogs can read and write
bytes, words, and longs at any hub address, as well as execute instruction longs from any hub address starting at $400 (see
COGS > INSTRUCTION MODES > HUB EXECUTION).
On hub RAM implementations of less than the full 1MB, the last 16KB of hub RAM is normally addressable at both its normal
address range, as well as at $FC000..$FFFFF. This provides a stable address space for the 16KB of internal ROM which gets
cached into the last 16KB of hub RAM on startup. This upper 16KB mapping is also used by the cog debugging scheme.
The last 16KB of RAM can be hidden from its normal address range and made read-only at $FC000..$FFFFF. This is useful
for making the last 16KB of RAM persistent, like ROM. It is also how debugging is realized, as the RAM mapped to
$FC000..$FFFFF can still be written to from within debug interrupt service routines, permitting the otherwise-protected RAM to
60

be used as debugger-application space and cog-register swap buffers for debug interrupts.
See the HUBSET instruction definition for setting up write-protection.
Here are the hub memory maps for the various FPGA boards currently being supported during development. The "W" column
represents write-protection status, set by HUBSET, for the last 16KB of hub RAM:

FPGA Board

Hub RAM

Cogs/
Slices

W

Lower RAM

Gap (reads $00)

Top 16KB RAM

DE0-Nano

32KB

1

0
1

$00000..$07FFF
$00000..$03FFF

$08000..$FBFFF
$04000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

BeMicro-A2

128KB

1

0
1

$00000..$1FFFF
$00000..$1BFFF

$20000..$FBFFF
$1C000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

DE2-115

256KB

4

0
1

$00000..$3FFFF
$00000..$3BFFF

$40000..$FBFFF
$3C000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

Prop123-A7

512KB

4

0
1

$00000..$7FFFF
$00000..$7BFFF

$80000..$FBFFF
$7C000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

Prop123-A9
BeMicro-A9

512KB

8

0
1

$00000..$7FFFF
$00000..$7BFFF

$80000..$FBFFF
$7C000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

Prop123-A9
BeMicro-A9

1024KB

16

0
1

$00000..$FFFFF

none, full map

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

P2X8C4M64PES
<silicon>

512KB

8

0
1

$00000..$7FFFF
$00000..$7BFFF

$80000..$FBFFF
$7C000..$FBFFF

$FC000..$FFFFF, R/W
$FC000..$FFFFF, Read

THE COG -to- HUB RAM INTERFACE
Hub RAM is comprised of 32-bit-wide single-port RAMs with byte-level write controls. For each cog, there is one of these
RAMs, but it is multiplexed among all cogs. Let's call these separate RAMs "slices". Each RAM slice holds every
single/2nd/4th/8th/16th (depending on number of cogs) set of 4 bytes in the composite hub RAM. At every clock, each cog can
access the "next" RAM slice, allowing for continuously-ascending bidirectional streaming of 32 bits per clock between the
composite hub RAM and each cog.

61

When a cog wants to read or write the hub RAM, it must wait up to #cogs-1 clocks to access the initial RAM slice of interest.
Once that occurs, subsequent slices can be accessed on every clock, thereafter, for continuous reading or writing of 32-bit
longs.
To smooth out data flow for less than 32-bits-per-clock between hub RAM and the cog, each cog has a hub FIFO interface
which can be set for hub-RAM-read or hub-RAM-write operation. This FIFO interface allows hub RAM to be either sequentially
read or sequentially written in any combination of bytes, words, or longs, at any rate, up to one long per clock. No matter the
transfer frequency or the word size, the FIFO will ensure that the cog's reads or writes are all properly conducted from or to the
composite hub RAM.
Cogs can access hub RAM either via the sequential FIFO interface, or by waiting for RAM slices of interest, while yielding to
the FIFO. If the FIFO is not busy, which is soon the case if data is not being read from or written to it, random accesses will
have full opportunity to access the composite hub RAM.
There are three ways the hub FIFO interface can be used, and it can only be used for one of these at a time:
62

-

Hub execution (when the PC is $00400..$FFFFF)
Streamer usage (background transfers from hub RAM → pins/DACs, or from pins/ADCs → hub RAM)
Software usage (fast sequential-reading or sequential-writing instructions)

For streamer or software usage, FIFO operation must be established by a RDFAST or WRFAST instruction executed from cog
RAM (register/lookup, $00000..$003FF). After that, and while remaining in cog RAM, the streamer can be enabled to begin
moving data in the background, or the two-clock RFxxxx/WFxxxx instructions can be used to manually read and write
sequential data.
The FIFO contains (cogs+11) stages. When in read mode, the FIFO loads continuously whenever less than (cogs+7) stages
are filled, after which point, up to 5 more longs may stream in, potentially filling all (cogs+11) stages. These metrics ensure that
the FIFO never underflows, under all potential reading scenarios.

FAST SEQUENTIAL FIFO INTERFACE
To configure the hub FIFO interface for streamer or software usage, use the RDFAST and WRFAST instructions. These
instructions establish read or write operation, the hub start address, and the block count. The block count determines how
many 64-byte blocks will be read or written before wrapping to the original start address and reloading the original block count.
If you intend to use wrapping, your hub start address must be long-aligned (address ends in %00), since there won't be an
extra cycle in which to read/write a portion of a long in an extra hub RAM slice. In cases where you don't want wrapping, just
use 0 for the block count, so that wrapping won't occur until the entire 1MB hub map is sequenced through.
The FBLOCK instruction provides a way to set a new start address and a new 64-byte block count for when the current blocks
are fully read or written and the FIFO interface would have otherwise wrapped back to the prior start address and reloaded the
prior block count. FBLOCK can be executed after RDFAST, WRFAST, or a FIFO block wrap event. Coordinating FBLOCK
instructions with streamer-FIFO activity enables dynamic and seamless streaming between hub RAM and pins/DACs.
Here are the RDFAST, WRFAST, and FBLOCK instructions:
EEEE 1100011 1LI DDDDDDDDD SSSSSSSSS
EEEE 1100100 0LI DDDDDDDDD SSSSSSSSS
EEEE 1100100 1LI DDDDDDDDD SSSSSSSSS

RDFAST
WRFAST
FBLOCK

D/#,S/#
D/#,S/#
D/#,S/#

For these instructions, the D/# operand provides the block count, while the S/# operand provides the hub RAM start address:
D/#

%xxxx_xxxx_xxxx_xxxx_xx00_0000_0000_0000 = block count for limited r/w
%xxxx_xxxx_xxxx_xxxx_xxBB_BBBB_BBBB_BBBB = block count for wrapping

S/#

%xxxx_xxxx_xxxx_AAAA_AAAA_AAAA_AAAA_AAAA = start address for limited r/w
%xxxx_xxxx_xxxx_AAAA_AAAA_AAAA_AAAA_AA00 = start address for wrapping (long-aligned)

RDFAST and WRFAST each have two modes of operation.
If D[31] = 0, RDFAST/WRFAST will wait for any previous WRFAST to finish and then reconfigure the hub FIFO
interface for reading or writing. In the case of RDFAST, it will additionally wait until the FIFO has begun receiving hub
data, so that it can start being used in the next instruction.
If D[31] = 1, RDFAST/WRFAST will not wait for FIFO reconfiguration, taking only two clocks. In this case, your code
must allow a sufficient number of clocks before any attempt is made to read or write FIFO data.
63

FBLOCK doesn't need to wait for anything, so it always takes two clocks.
Once RDFAST has been used to configure the hub FIFO interface for reading, you can enable the streamer for any
hub-reading modes or use the following instructions to manually read sequential data from the hub:
EEEE
EEEE
EEEE
EEEE
EEEE

1101011
1101011
1101011
1101011
1101011

CZ0
CZ0
CZ0
CZ0
CZ0

DDDDDDDDD
DDDDDDDDD
DDDDDDDDD
DDDDDDDDD
DDDDDDDDD

000010000
000010001
000010010
000010011
000010100

RFBYTE
RFWORD
RFLONG
RFVAR
RFVARS

D
D
D
D
D

{WC/WZ/WCZ}
{WC/WZ/WCZ}
{WC/WZ/WCZ}
{WC/WZ/WCZ}
{WC/WZ/WCZ}

These instructions all take 2 clocks and read bytes, words, longs, and variable-length data from the hub into D, via the hub
FIFO interface.
If WC is expressed, the MSB of the byte, word, long, or variable-length data will be written to C.
If WZ is expressed, Z will be set if the data read from the hub equaled zero, otherwise Z will be cleared.
RFVAR and RFVARS read 1..4 bytes of data, depending upon the MSB of the first byte, and then subsequent bytes, waiting in
the FIFO. While RFVAR returns zero-extended data, RFVARS returns sign-extended data. This mechanism is intended to
provide a fast and memory-efficient means for bytecode interpreters to read numerical constants and offset addresses that
were assembled at compile-time for efficient reading during run-time.
This table shows the relationship between upcoming bytes in the FIFO and what RFVAR and RFVARS will return:
FIFO
1st Byte

FIFO
2nd Byte

FIFO
3rd Byte

FIFO
4th Byte

RFVAR Returns
RFVARS Returns

%0SAAAAAA

-

-

-

%00000000_00000000_00000000_0SAAAAAA
%SSSSSSSS_SSSSSSSS_SSSSSSSS_SSAAAAAA

%1AAAAAAA

%0SBBBBBB

-

-

%00000000_00000000_00SBBBBB_BAAAAAAA
%SSSSSSSS_SSSSSSSS_SSSBBBBB_BAAAAAAA

%1AAAAAAA

%1BBBBBBB

%0SCCCCCC

-

%00000000_000SCCCC_CCBBBBBB_BAAAAAAA
%SSSSSSSS_SSSSCCCC_CCBBBBBB_BAAAAAAA

%1AAAAAAA

%1BBBBBBB

%1CCCCCCC

%SDDDDDDD

%000SDDDD_DDDCCCCC_CCBBBBBB_BAAAAAAA
%SSSSDDDD_DDDCCCCC_CCBBBBBB_BAAAAAAA

Once WRFAST has been used to configure the hub FIFO interface for writing, you can enable the streamer for any hub-writing
modes or use the following instructions to manually write sequential data:
EEEE 1101011 00L DDDDDDDDD 000010101
EEEE 1101011 00L DDDDDDDDD 000010110
EEEE 1101011 00L DDDDDDDDD 000010111

WFBYTE
WFWORD
WFLONG

D/#
D/#
D/#

These instructions all take 2 clocks and write byte, word, or long data in D into the hub via the hub FIFO interface.
If a cog has been writing to the hub via WRFAST, and it wants to immediately COGSTOP itself, a 'WAITX #20' should be
executed first, in order to allow time for any lingering FIFO data to be written to the hub.
64

RANDOM ACCESS INTERFACE
Here are the random-access hub RAM read instructions:
EEEE 1010110 CZI DDDDDDDDD SSSSSSSSS
EEEE 1010111 CZI DDDDDDDDD SSSSSSSSS
EEEE 1011000 CZI DDDDDDDDD SSSSSSSSS

RDBYTE
RDWORD
RDLONG

D,S/#/PTRx
D,S/#/PTRx
D,S/#/PTRx

{WC/WZ/WCZ}
{WC/WZ/WCZ}
{WC/WZ/WCZ}

For these instructions, the D operand is the register which will receive the data read from the hub.
The S/#/PTRx operand supplies the hub address to read from.
If WC is expressed, the MSB of the byte, word, or long read from the hub will be written to C.
If WZ is expressed, Z will be set if the data read from the hub equaled zero, otherwise Z will be cleared.

Here are the random-access hub RAM write instructions:
EEEE
EEEE
EEEE
EEEE

1100010
1100010
1100011
1010011

0LI
1LI
0LI
11I

DDDDDDDDD
DDDDDDDDD
DDDDDDDDD
DDDDDDDDD

SSSSSSSSS
SSSSSSSSS
SSSSSSSSS
SSSSSSSSS

WRBYTE
WRWORD
WRLONG
WMLONG

D/#,S/#/PTRx
D/#,S/#/PTRx
D/#,S/#/PTRx
D,S/#/PTRx

For these instructions, the D/# operand supplies the data to be written to the hub.
The S/#/PTRx operand supplies the hub address to write to.
WMLONG writes longs, like WRLONG; however, it does not write any D byte fields whose data are $00. This is intended for
things like sprite overlays, where $00 byte data represent transparent pixels.
In the case of the 'S/#/PTRx' operand used by RDBYTE, RDWORD, RDLONG, WRBYTE, WRWORD, WRLONG, and
WMLONG, there are five ways to express a hub address:
$000..$1FF
#$00..$FF
##$00000..$FFFFF
PTRx {[index5]}
PTRx {[##index20]}

- register whose 20 LSBs will be used as the hub address
- 8-bit immediate hub address
- 20-bit immediate hub address (invokes AUGS)
- PTR expression with a 5-bit scaled index
- PTR expression with a 20-bit unscaled index (invokes AUGS)

If AUGS is used to augment the #S value to 32 bits, the #S value will be interpreted differently:
#%0AAAAAAAA
#%1SUPNNNNN
##%000000000000AAAAAAAAAAA_AAAAAAAAA
##%000000001SUPNNNNNNNNNNN_NNNNNNNNN

- No AUGS, 8-bit immediate address
- No AUGS, PTR expression with a 5-bit scaled index
- AUGS, 20-bit immediate address
- AUGS, PTR expression with a 20-bit unscaled index

PTRx expressions without AUGS:

65

INDEX6 = -32..+31 for non-updating offsets
INDEX = 1..16 for ++'s and --'s
SCALE = 1 for RDBYTE/WRBYTE, 2 for RDWORD/WRWORD, 4 for RDLONG/WRLONG/WMLONG
S = 0 for PTRA, 1 for PTRB
U = 0 to keep PTRx same, 1 to update PTRx (PTRx += INDEX*SCALE)
P = 0 to use PTRx + INDEX*SCALE, 1 to use PTRx (post-modify)
IIIIII = INDEX6, uses %100000..%111111 for -32..-1 and %000000..%011111 for 0..31
NNNNN = INDEX, uses %00001..%01111 for 1..15 and %00000 for 16
nnnnn = -INDEX, uses %10000..%11111 for -16..-1
1SUPNNNNN
PTR expression
-----------------------------------------------------------------------------100000000
PTRA
'use PTRA
110000000
PTRB
'use PTRB
100IIIIII
PTRA[INDEX6]
'use PTRA + INDEX6*SCALE
110IIIIII
PTRB[INDEX6]
'use PTRB + INDEX6*SCALE
101100001
111100001
101111111
111111111
101000001
111000001
101011111
111011111

PTRA++
PTRB++
PTRA-PTRB-++PTRA
++PTRB
--PTRA
--PTRB

'use
'use
'use
'use
'use
'use
'use
'use

PTRA,
PTRB,
PTRA,
PTRB,
PTRA +
PTRB +
PTRA PTRB -

1011NNNNN
1111NNNNN
1011nnnnn
1111nnnnn
1010NNNNN
1110NNNNN
1010nnnnn
1110nnnnn

PTRA++[INDEX]
PTRB++[INDEX]
PTRA--[INDEX]
PTRB--[INDEX]
++PTRA[INDEX]
++PTRB[INDEX]
--PTRA[INDEX]
--PTRB[INDEX]

'use
'use
'use
'use
'use
'use
'use
'use

PTRA,
PTRB,
PTRA,
PTRB,
PTRA +
PTRB +
PTRA PTRB -

SCALE,
SCALE,
SCALE,
SCALE,

PTRA
PTRB
PTRA
PTRB
PTRA
PTRB
PTRA
PTRB

+=
+=
-=
-=
+=
+=
-=
-=

SCALE
SCALE
SCALE
SCALE
SCALE
SCALE
SCALE
SCALE

INDEX*SCALE,
INDEX*SCALE,
INDEX*SCALE,
INDEX*SCALE,

PTRA
PTRB
PTRA
PTRB
PTRA
PTRB
PTRA
PTRB

+=
+=
-=
-=
+=
+=
-=
-=

INDEX*SCALE
INDEX*SCALE
INDEX*SCALE
INDEX*SCALE
INDEX*SCALE
INDEX*SCALE
INDEX*SCALE
INDEX*SCALE

Examples:
Read byte at PTRA into D
1111 1010110 001 DDDDDDDDD 100000000

RDBYTE

D,PTRA

WRWORD

D,PTRB[-7]

WRLONG

#10,PTRB++

Write lower word in D to PTRB - 7*2
1111 1100010 101 DDDDDDDDD 110111001
Write long value 10 at PTRB, PTRB += 1*4
1111 1100011 011 000001010 111100001
Read word at PTRA into D, PTRA -= 1*2

66

1111 1010111 001 DDDDDDDDD 101111111

RDWORD

D,PTRA--

WRBYTE

D,--PTRA

RDLONG

D,++PTRB[10]

WRBYTE

D,PTRA++[15]

RDWORD

D,PTRB++[16]

Write lower byte in D at PTRA - 1*1, PTRA -= 1*1
1111 1100010 001 DDDDDDDDD 101011111
Read long at PTRB + 10*4 into D, PTRB += 10*4
1111 1011000 001 DDDDDDDDD 111001010
Write lower byte in D to PTRA, PTRA += 15*1
1111 1100010 001 DDDDDDDDD 101101111
Read word at PTRB into D, PTRB += 16*2
1111 1010111 001 DDDDDDDDD 111100000

PTRx expressions with AUGS:
If "##" is used before the index value in a PTRx expression, the assembler will automatically insert an AUGS instruction and
assemble the 20-bit index instruction pair:
RDBYTE

D,++PTRB[##$12345]

...becomes...
1111 1111000 000 000111000 010010001
1111 1010110 001 DDDDDDDDD 101000101

AUGS
RDBYTE

#$00E12345
D,#$00E12345 & $1FF

FAST BLOCK MOVES
By preceding RDLONG with either SETQ or SETQ2, multiple hub RAM longs can be read into either cog register RAM or cog
lookup RAM. This transfer happens at the rate of one long per clock, assuming the hub FIFO interface is not accessing the
same hub RAM slice as RDLONG, on the same cycle, in which case the FIFO gets priority access and the block move must
wait for the hub RAM slice to come around again. If WC/WZ/WCZ are used with RDLONG, the flags will be set according to
the last long read in the sequence.
Use SETQ+RDLONG to read multiple hub longs into cog register RAM:
SETQ
RDLONG

#x
first_reg,S/#/PTRx

'x = number of longs, minus 1, to read
'read x+1 longs starting at first_reg

Use SETQ2+RDLONG to read multiple hub longs into cog lookup RAM:
SETQ2
RDLONG

#x
first_lut,S/#/PTRx

'x = number of longs, minus 1, to read
'read x+1 longs starting at first_lut

Similarly, WRLONG and WMLONG can be preceded by either SETQ or SETQ2 to write either multiple register RAM longs or
lookup RAM longs into hub RAM. When WRLONG/WMLONG‘s D field is an immediate, it instead writes that immediate value
67

to RAM, functioning as a memory filler.
Use SETQ+WRLONG/WMLONG to write multiple register RAM longs into hub RAM:
SETQ
WRLONG

#x
first_reg,S/#/PTRx

'x = number of longs, minus 1, to write
'write x+1 longs starting at first_reg

Use SETQ2+WRLONG/WMLONG to write multiple lookup RAM longs into hub RAM:
SETQ2
WRLONG

#x
first_lut,S/#/PTRx

'x = number of longs, minus 1, to write
'write x+1 longs starting at first_lut

For fast block moves, PTRx expressions cannot have arbitrary index values, since the index will be overridden with the
number of longs, with bit 4 of the encoded index value serving as the ++/-- indicator. In plain PTRA/PTRB cases, the index will
be overridden with zero:
SETQ
RDLONG

#x
first_reg,PTRA

'x = number of longs, minus 1
'read x+1 longs from PTRA

SETQ
RDLONG

#x
first_reg,PTRA++

'x = number of longs, minus 1
'read x+1 longs from PTRA, PTRA += (x+1)*4

SETQ
RDLONG

#x
first_reg,PTRA--

'x = number of longs, minus 1
'read x+1 longs from PTRA, PTRA -= (x+1)*4

SETQ
RDLONG

#x
first_reg,++PTRA

'x = number of longs, minus 1
'read x+1 longs from PTRA+(x+1)*4, PTRA += (x+1)*4

SETQ
RDLONG

#x
first_reg,--PTRA

'x = number of longs, minus 1
'read x+1 longs from PTRA-(x+1)*4, PTRA -= (x+1)*4

Because these fast block moves yield to the hub FIFO interface, they can be used during hub execution.

CORDIC Solver
In the hub, there is a 54-stage pipelined CORDIC solver that can compute the following functions for all cogs:
●
●
●
●
●
●
●
●

32 x 32 unsigned multiply with 64-bit product
64 / 32 unsigned divide with 32-bit quotient and 32-bit remainder
Square root of 64-bit unsigned value with 32-bit result
32-bit signed (X,Y) rotation around (0,0) by a 32-bit angle with 32-bit signed (X,Y) results
32-bit signed (X,Y) to 32-bit (length,angle) - cartesian to polar
32-bit (length,angle) to 32-bit signed (X,Y) - polar to cartesian
32-bit unsigned integer to 5:27-bit logarithm
5:27-bit logarithm to 32-bit unsigned integer

When a cog issues a CORDIC instruction, it must wait for its hub slot, which is zero to (cogs-1) clocks away, in order to hand
off the command to the CORDIC solver. Fifty-five clocks later, results will be available via the GETQX and GETQY
instructions, which will wait for the results, in case they haven't arrived yet.
Because each cog's hub slot comes around every 1/2/4/8/16 clocks (8 clocks for the current P2X8C4M64P, since it has 8
cogs) and the pipeline is 54 clocks long, it is possible to overlap CORDIC commands, where several commands are initially
68

given to the CORDIC solver, and then results are read and another command is given, indefinitely, until, at the end, the trailing
results are read. You must not have interrupts enabled during such a juggle, or enough clocks could be stolen by the interrupt
service routine that one or more of your results could be overwritten before you can read them. If you ever attempt to read
results when none are available and none are in progress, GETQX/GETQY will only take two clock and the QMT (CORDIC
empty) event flag will be set.

MULTIPLY
To multiply two unsigned 32-bit numbers together, use the QMUL instruction (CORDIC instructions wait for the hub slot):
QMUL

D/#,S/#

- Multiply D by S

To get the results (these instructions wait for the CORDIC results):
GETQX
GETQY

lower_long
upper_long

DIVIDE
For convenience, two different divide instructions exist, each with an optional SETQ prefix instruction which establishes a
non-0 value for one 32-bit part of the 64-bit numerator:
QDIV

D/#,S,#

- Divide {$00000000:D} by S

SETQ
QDIV

Q/#
D/#,S,#

- Set top part of numerator
- Divide {Q:D} by S

QFRAC

D/#,S,#

- Divide {D:$00000000} by S

SETQ
QFRAC

Q/#
D/#,S,#

- Set bottom part of numerator
- Divide {D:Q} by S

...or...

...or...
...or...

To get the results:
GETQX
GETQY

quotient
remainder

SQUARE ROOT
To get the square root of a 64-bit integer:
QSQRT

D/#,S,#

- Compute square root of {S:D}

To get the result:
GETQX

root

69

(X,Y) ROTATION
The rotation function inputs three terms: 32-bit signed X and Y values, and an unsigned 32-bit angle, where
$00000000..$FFFFFFFF = 0..359.9999999 degrees. The Y term, if non-zero, is supplied via an optional SETQ prefix
instruction:
SETQ
Q/#
QROTATE D/#,S,#

- Set Y
- Rotate (D,Q) by S

QROTATE D/#,S,#

- Rotate (D,$00000000) by S

...or...

Notice that in the second example, a polar-to-cartesian conversion is taking place.
To get the results:
GETQX
GETQY

X
Y

(X,Y) VECTORING
The vectoring function converts (X,Y) cartesian coordinates into (length,angle) polar coordinates:
QVECTOR D/#,S,#

- (X=D,Y=S) cartesian into (length,angle) polar

To get the results:
GETQX
GETQY

length
angle

LOGARITHM
To convert an unsigned 32-bit integer into a 5:27-bit logarithm, where the top 5 bits hold the whole part of the power-of-2
exponent and the bottom 27 bits hold the fractional part:
QLOG

D/#

- Compute log base 2 of D

To get the result:
GETQX

logarithm

EXPONENT
To convert a 5:27-bit logarithm into a 32-bit unsigned integer:
QEXP

D/#

- Compute 2 to the power of D
70

To get the result:
GETQX

integer

LOCKS
The hub contains a pool of 16 semaphore bits, called locks. Locks can be used by cogs to coordinate exclusive access of a
shared resource. In order to use a lock, one cog must first allocate a lock with LOCKNEW. Once allocated, cooperative cogs
use LOCKTRY and LOCKREL to respectively take or release the allocated lock. When the lock is no longer needed, it may be
returned to the unallocated lock pool by executing LOCKRET.
The LOCK instructions are:
LOCKNEW

D {WC}

LOCKRET {#}D
LOCKTRY {#}D {WC}
LOCKREL {#}D {WC}
What a lock represents is completely up to the application using it. locks are just a means of allowing one cog at a time the
exclusive status of 'owner'. All participant cogs must agree on a lock's number and its purpose for a lock to be useful.

Allocating Locks
LOCKNEW is used to allocate a lock from the hub lock pool. If an unallocated lock is available, that lock's number will be
stored in the D register. If WC is set on the instruction, the C flag will indicate whether a lock was allocated. Zero (0) indicates
success, while one (1) indicates that all locks are already allocated. A cog may allocate more than one lock. Once a lock has
been allocated, the lock number may be shared with other cogs so that they can use LOCKTRY/LOCKREL.
LOCKRET is used to return an allocated lock to the lock pool. Any cog can return an allocated lock, even if it wasn't the cog
that allocated it with LOCKNEW.

Using Locks
A cog may attempt to take an allocated lock by executing LOCKTRY with the lock number. If WC is used with the instruction,
the C flag will indicate afterwards whether the lock was successfully taken. Zero (0) indicates that the lock was not taken
because either another cog is holding it or the lock is not allocated, while one (1) indicates that the lock was successfully taken
(or is now "held" by this cog). While the lock is held, no other cog can take the lock until the cog that's holding the lock either
executes LOCKREL with the lock number or it is stopped via COGSTOP or restarted via COGINIT.
Because lock arbitration is performed by the hub in a round-robin fashion, any cog waiting in a loop to capture a lock will get its
fair turn:
'Keep trying to capture lock until successful
.try

LOCKTRY write_lock WC
IF_NC

JMP #.try

When a cog is done with a held lock, it must execute LOCKREL to release it for other cogs to take. Only the cog that has
taken the lock can release it.
71

NOTE: A lock will also be implicitly released if the cog that's holding the lock is stopped (COGSTOP) or restarted
(COGINIT), or if LOCKRET is executed for that lock.
LOCKREL can also be used to query the current lock status. When LOCKREL is executed with WC, the C flag will indicate
whether the lock is currently taken. Additionally, if the D field references a register (not an immediate value), the register will
be written with the cog ID of the current owner (if held) or last owner (if released). If the cog executing LOCKREL is also the
cog that is holding the lock, the normal LOCKREL behavior will still be performed (i.e. the lock will be released).

SMART PINS
Each I/O pin has a 'smart pin' circuit which, when enabled, performs some autonomous function on the pin. Smart pins free the
cogs from needing to micro-manage many I/O operations by providing high-bandwidth concurrent hardware functions which
cogs could not perform as well on their own by manipulating I/O pins via instructions.
Normally, an I/O pin's output enable is controlled by its DIR bit and its output state is controlled by its OUT bit, while the IN bit
returns the pin's read state. In smart pin modes, the DIR bit is used as an active-low reset signal to the smart pin circuitry,
while the output enable state is controlled by a configuration bit. In some modes, the smart pin takes over driving the output
state, in which case the OUT bit gets ignored. The IN bit serves as a flag to indicate to the cog(s) that the smart pin has
completed some function or an event has occurred, and acknowledgment is perhaps needed.
Smart pins have four 32-bit registers inside of them:
mode

- smart pin mode, as well as low-level I/O pin mode (write-only)

X

- mode-specific parameter (write-only)

Y

- mode-specific parameter (write-only)

Z

- mode-specific result (read-only)

These four registers are written and read via the following 2-clock instructions, in which S/# is used to select the pin number
(0..63) and D/# is the 32-bit data conduit:
WRPIN

D/#,S/#

- Set smart pin S/# mode to D/#, ack pin

WXPIN

D/#,S/#

- Set smart pin S/# parameter X to D/#, ack pin

WYPIN

D/#,S/#

- Set smart pin S/# parameter Y to D/#, ack pin

RDPIN

D,S/# {WC}

- Get smart pin S/# result Z into D, flag into C, ack pin

RQPIN

D,S/# {WC}

- Get smart pin S/# result Z into D, flag into C, don't ack pin

AKPIN

S/#

- Acknowledge pin S/#

Each cog has a 34-bit bus to each smart pin for write data and acknowledgment signalling. Each smart pin OR's all incoming
34-bit buses from the cogs in the same way DIR and OUT bits are OR'd before going to the pins. Therefore, if you intend to
have multiple cogs execute WRPIN / WXPIN / WYPIN / RDPIN / AKPIN instructions on the same smart pin, you must be sure
that they do so at different times, in order to avoid clobbering each other's bus data. Any number of cogs can read a smart pin
simultaneously, without bus conflict, though, by using RQPIN ('read quiet'), since it does not utilize the 34-bit cog-to-smart-pin
bus for acknowledgement signalling, like RDPIN does.
72

