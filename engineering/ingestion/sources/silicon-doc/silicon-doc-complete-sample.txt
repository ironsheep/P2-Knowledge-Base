SILICON DOCUMENTATION V35 - COMPLETE EXTRACTION\n======================================================================\n\n\n### Header\nPara llax  Propeller 2\nDocumentation\n2021-05-18\nv35 ( Rev B/C silicon )\n\n### P2X8C4M64PES\nLPD1941 (Rev B) or LHU2019 (Rev C)\n\n### PHILIPPINES\n(not yet updated: Boot ROM)\nDesign Status\nDate\nProgress\n2018_04_25\nVerilog design files sent to On Semi for Rev A silicon\n(8 cogs, 512KB hub, 64 smart pins)\n2018_05_29\nFinal ROM data sent to On Semi\n2018_07_09\nFinal Sign-off with On Semi, reticles being made\n2018_09_11\nWafers done! Only took 9 weeks, instead of 14.\n2018_09_27\nReceived 10 glob-top prototype chips from On Semi.\nChips are functional, but sign-extension problems in Verilog source files caused the following problems:\nCogs' IQ modulators' outputs are nonsensical.\nSmart pin measurement modes which are supposed to count by +1/-1 are counting by +1/+3.\nALTx instructions aren't sign-extending S[17:09] before adding into D.\nThese sign-extension problems have already been fixed in the Verilog source files and tested on the FPGA.\nThere is also a low-glitch-on-high-to-float problem on some I/O pins due to a race condition between DIR and OUT signals. This will be fixed by timing constraints in the next silicon.\nA respin of the silicon is planned after more testing.\n2018_11_13\nReceived 135 Amkor-packaged prototype chips from On Semi. These chips will have better heat dissipation than the glob-top prototypes.\n2019_04_11\nRev B respin entered the fab and is due out July 15.\nTen glob-top prototypes should arrive on August 1, with 2,400 production chips to follow in a few weeks.\nThe following improvements were made to the chip:\nAll known prior bugs fixed.\nClock-gating implemented, reduces power by ~40%.\nPLL filter modified to reduce jitter and improve lock.\nSystem counter extended to 64 bits. GETCT WC retrieves upper 32-bits.\nStreamer has many new modes with SINC1/SINC2 ADC conversions for Goertzel mode.\nHDMI mode added to streamer with ascending and descending pinouts for easy PCB layout.\nSINC2/SINC3 filters added to smart pins for improving ENOB in ADC conversions.\nEach cog has four 8-bit sample-per-clock ADC channels that feed from new smart pin 'SCOPE' modes.\nBITL/BITH/BITC/BITNC/BITZ/BITNZ/BITRND/BITNOT can now work on a span of bits (+S[9:5] bits). Prior SETQ overrides S[9:5].\nDIRx/OUTx/FLTx/DRVx can now work on a span of pins (+D[10:6] pins). Prior SETQ overrides D[10:6].\nWRPIN / WXPIN /WYPIN/AKPIN can now work on a span of pins (+S[10:6] pins). Prior SETQ overrides S[10:6].\nBIT_DAC output now has two 4-bit settings for low and high states, instead of one 8-bit high-state setting.\nRDxxxx/WRxxxx+PTRx expressions now index -16..+16 with updating and -32..+31 without updating.\nSensible PTRx behavior implemented for 'SETQ(2) + RDLONG/WRLONG/WMLONG' operations.\nRDLUT/WRLUT can now handle PTRx expressions.\nCog LUT sharing is now glitch-free.\nPOP now returns Z=1 if result=0, used to return result[30].\nXORO32 improved.\nMain PRNG upgraded to "Xoroshiro128 ** ".\nThe core logic increased by a net 15%, even with significant logic reductions resulting from clock-gating. Fortunately, ON Semi was able to make it all fit within the original die area.\n2019_07_13\nWafers out of fab. Packaging underway.\n\n### KNOWN SILICON BUGS\nIntervening ALTx/AUGS/AUGD instructions between SETQ/SETQ2 and RDLONG/WRLONG/WMLONG-PTRx instructions will cancel the special-case block-size PTRx deltas. The  expected  number of longs will transfer, but PTRx will only be modified according to normal PTRx expression behavior:\nSETQ #16-1 'ready to load 16 longs\nALTD start_reg 'alter start register (ALTD cancels block-size PTRx deltas)\nRDLONG 0,ptra++ 'ptra will only be incremented by 4 (1 long), not 16*4 as anticipated!!!\nIntervening ALTx instructions with an immediate #S operand, between AUGS and the AUGS' intended target instruction (which would have an immediate #S operand), will use the AUGS value, but not cancel it. So, the intended AUGS target instruction will use and cancel the AUGS value, as expected, but the intervening ALTx instruction will also use the AUGS value (if it has an immediate #S operand). To avoid problems in these circumstances, use a register for the S operand of the ALTx instruction, and not an immediate #S operand.\nAUGS #$FFFFF123 'This AUGS is intended for the ADD instruction.\nALTD index,#base 'Look out! AUGS will affect #base, too. Use a register, instead.\nADD 0-0,#$123 '#$123 will be augmented by the AUGS and cancel the AUGS.\n\n### OVERVIEW\nThe Propeller 2 is a microcontroller architecture  consisting  of  1, 2, 4, 8, or 16 identical 32-bit processors (called cogs ),  each with their own RAM , which connect to a common hub. The hub provides up to 1 MB of shared RAM, a CORDIC math solver, and housekeeping facilities. The architecture supports up to 64 smart I/O pins, each capable of many autonomous analog and digital functions.\nThe P2X8C4M6 4P  silicon contains 8 cogs, 512 KB of hub RAM, and 64 smart I/O pins in a n exposed-pad TQFP-100 package.\nDesign  Status\n\n### INSTRUCTION SKIPPING\nSpecial SKIPF Branching Rules\n\n### PIXEL OPERATIONS\nDACs\n\n### STREAMER\nImmediate ⇢ LUT ⇢ Pins/DACs\nImmediate ⇢ Pins/DACs\nRDFAST ⇢ LUT ⇢ Pins/DACs\nRDFAST ⇢ Pins/DACs\nRDFAST ⇢ RGB ⇢ Pins/DACs\nPins ⇢ DACs/WRFAST\nADCs/Pins ⇢ DACs/WRFAST\nDDS/Goertzel\nDigital Video Output (DVI/HDMI)\n\n### EVENTS\nSelectable Events\n\n### DEBUG INTERRUPT\nHUB\nConfiguration\nConfiguring the Clock Generator\nPLL Example\nWrite-Protecting the Last 16KB of Hub RAM and Enabling Debug Interrupts\nConfiguring the Digital Filters for Smart Pins\nSeeding the Xoroshiro128** PRNG\nRebooting the Chip\n\n### FAST BLOCK MOVES\nCORDIC Solver\n\n### LOCKS\nAllocating Locks\nUsing Locks\n\n### SMART PIN MODES\n%00001..%00011 and not DAC_MODE = long repository\n%00001 and DAC_MODE = DAC noise\n%00010 and DAC_MODE = DAC 16-bit with pseudo-random dither\n%00011 and DAC_MODE = DAC 16-bit with PWM dither\n%00100 = pulse/cycle output\n%00101 = transition output\n%00110 = NCO frequency\n%00111 = NCO duty\n%01000 = PWM triangle\n%01001 = PWM sawtooth\n%01010 = PWM switch-mode power supply with voltage and current feedback\n%01011 = A/B-input quadrature encoder\n%01100 = Count A-input positive edges when B-input is high\n%01101 = Accumulate A-input positive edges with B-input supplying increment (B=1) or decrement (B=0)\n%01110 AND !Y[0] = Count A-input positive edges\n%01110 AND Y[0] = Increment on A-input positive edge and decrement on B-input positive edge\n%01111 AND !Y[0] = Count A-input highs\n%01111 AND Y[0] = Increment on A-input high and decrement on B-input high\n%10000 = Time A-input states\n%10001 = Time A-input high states\n%10010 AND !Y[2] = Time X A-input highs/rises/edges\n%10010 AND Y[2] = Timeout on X clocks of missing A-input high/rise/edge\n%10011 = For X periods, count time\n%10100 = For X periods, count states\n%10101 = For periods in X+ clock cycles, count time\n%10110 = For periods in X+ clock cycles, count states\n%10111 = For periods in X+ clock cycles, count periods\n%11000 = ADC sample/filter/capture, internally clocked\n%11001 = ADC sample/filter/capture, externally clocked\nAbout SINC2 and SINC3 filtering\nSINC2 Sampling Mode (%00)\nSINC3 Filtering Mode (%10)\nBitstream Capturing Mode (%11)\n%11010 = ADC Scope with Trigger\nSCOPE Data Pipe\n%11011 = USB host/device\n%11100 = synchronous serial transmit\n%11101 = synchronous serial receive\n%11110 = asynchronous serial transmit\n%11111 = asynchronous serial receive\nBOOT PROCESS (needs more editing)\n\n### SERIAL LOADING PROTOCOL\nProp_Chk\nProp_Clk\nPLL Example\nReset to Boot Clock Configuration\nProp_Hex\nProp_Txt\n\n### SUMMARY\nAssembly Language\nBoot ROM / Debug ROM\nPackaging\nP2X\n8C\n4M\n64P\nES\nPropeller 2\n8 cogs (processors)\n4 Mb hub RAM (512 KB)\n64 smart I/O pins\nEngineering Sample\nEach cog has:\nAccess to all I/O pins, plus four fast DAC output channels and four fast ADC input channels\n512 longs of dual-port register RAM for code and fast variables\n512 longs of dual-port lookup RAM for code, streamer lookup, and variables\nAbility to execute code directly from register RAM, lookup RAM, and hub RAM\n~350 unique instructions for math, logic, timing, and control operations\n2-clock execution for all math and logic instructions, including 16 x 16 multiply\n6-clock custom-bytecode executor for interpreted languages\nAbility to stream hub RAM and/or lookup RAM to DACs and pins or HDMI modulator\nAbility to stream pins and/or ADCs to hub RAM\nLive colorspace conversion using a 3 x 3 matrix with 8-bit signed/unsigned coefficients\nPixel blending instructions for 8:8:8:8 data\n16 unique event trackers that can be polled and waited upon\n3 prioritized interrupts that trigger on selectable events\nHidden debug interrupt for single-stepping, breakpoint, and polling\n8-level hardware stack for fastest subroutine calls/returns and push/pop operations\nCarry and Zero flag\nThe hub provides the cogs with:  \nUp to 1 MB of contiguous RAM in a 20-bit address space (P2X8C4M64P contains 512 KB)\n32-bits-per-clock sequential read/write for all cogs, simultaneously\nreadable and writable as bytes, words, or longs in little-endian format\nlast 16KB of RAM also appears at the end of the 1MB map and is write-protectable\n32-bit, pipelined CORDIC solver with scale-factor correction\n32-bit x 32-bit unsigned multiply with 64-bit result\n64-bit / 32-bit unsigned divide with 32-bit quotient and 32-bit remainder\n64-bit → 32-bit square root\nRotate (X32,Y32) by Theta32 → (X32,Y32)\n(Rho32,Theta32) → (X32,Y32) polar-to-cartesian\n(X32,Y32) → (Rho32,Theta32) cartesian-to-polar\n32 → 5.27 unsigned-to-logarithm\n5.27 → 32 logarithm-to-unsigned\nCogs can start CORDIC operations every 1/2/4/8/16 (#cogs) clocks and get results 55 clocks later\n16 semaphore bits with atomic read-modify-write operations\n64-bit free-running counter which increments every clock, cleared on reset\nHigh-quality pseudo-random number generator (Xoroshiro128**), true-random seeded at start-up, updates every clock, provides unique data to each cog and pin\nMechanisms for starting, polling, and stopping cogs\n16KB boot ROM\n\n### PIN DESCRIPTIONS\nPin Name\nDirection\nV(typ)\nDescription\n\n### TEST\nI\n0\nTied to ground\nVDD\n-\n1.8\nCore power\nVSS\n-\n0\nGround\nVIO_{x}_{y}\n-\n3.3\nPower for smart pins {x} through {y} \nGIO_{x}_{y}\n-\n0\nGround for smart pins {x} through {y} and other related circuits\n\n### P0-63\nI/O\n0 to 3.3\nSmart pins\n\n### P58-P63\nBoot source(s). See  BOOT PROCESS .\nXI\nI\n-\nCrystal Input. Can be connected to output of crystal/oscillator pack (with XO left disconnected), or to one leg of crystal (with XO connected to other leg of crystal or resonator) depending on CLK Register settings. No external resistors or capacitors are required.\nXO\nO\n-\nCrystal Output. Provides feedback for an external crystal, or may be left disconnected depending on CLK Register settings. No external resistors or capacitors are required.\nRESn\nI\n0\nReset (active low). When low, resets the Propeller chip: all cogs disabled and I/O pins floating. Propeller restarts 3 ms after RESn transitions from low to high.\n\n### MEMORIES\nThere are three memory regions: cog RAM, lookup RAM, and hub RAM.  Each cog has its own cog RAM and lookup RAM, while the hub RAM is shared by all cogs.\nMemory\nRegion\nMemory Width\nMemory Depth\nInstruction D/S Address Ranges\nProgram Counter Address Ranges\nCOG\n32 bits\n512\n\n### LOOKUP\n32 bits\n512\n\n### $00200..$003FF\nHUB\n8 bits\n1,048,576 (*)\n\n### $00400..$FFFFF\n(*) 1,048,576 bytes is the maximum size supported.  However, some variants may have less available.  See the Hub Memory section below for more details.\n\n### COGS\nThe Propeller contains multiple processors, called "cogs".  Each cog  has its own RAM and can start, stop, and execute instructions independently of one another.  All active cogs share the same system clock, Hub RAM, and I/O pins.\nCogs employ a five-stage pipelined execution architecture.  When the execution pipeline is full, each instruction effectively takes as little as two clock cycles to execute.  If an instruction stalls for additional clock cycles, all following instructions in the pipeline are also stalled. Any instruction that is conditionally canceled will still move through the pipeline without stalling or executing, but taking two clock cycles.  Branch instructions cause the pipeline to be flushed, so the first instruction following the branch will take at least  four  clock cycles.\nThe available instruction set can be found at  Parallax Propeller 2 Instruction Set .  When reading the "Encoding" column, the following table may help:\nKey\nDescription\n\n### EEEE\nConditional test (see "Instruction Prefix" list at bottom of the instruction set spreadsheet)\nC\n0: Do not update the "C" register\n1: Update the "C" register. In the instruction syntax, this is denoted by "WC" or "WCZ".\nZ\n0: Do not update the "Z" register\n1: Update the "Z" register. In the instruction syntax, this is denoted by "WZ" or "WCZ".\nI\n0: Source field is a register address\n1: Source field is a literal value. In the instruction syntax, this is denoted by the "#" character.\nL\n0: Destination field is a register address\n1: Destination field is a literal value.  In the instruction syntax, this is denoted by the "#" character.\nR\n0: 20-bit Address field is relative to current PC.\n1: 20-bit Address field is absolute.\nWW\nIndex of special register (PA, PB, PTRA, or  PTRB ) to write.\n\n### DDDDDDDDD\nDestination field\n\n### SSSSSSSSS\nSource field\n\n### AAAAAAA...\n20-bit Address field\nnnnnnn...\n23-bit augment number field\n\n### N,NN,NNN\nIndex number. This is only used for instructions with a third operand to specify word, byte, or nibble.\ncccc\nconditional test used to update C (%0000=clear, %1111=set, all others per EEEE)\nzzzz\nconditional test used to update Z (%0000=clear, %1111=set, all others per EEEE)\n\n### INSTRUCTION MODES\nCogs use 20-bit addresses for program counters (PC). This affords an execution space of up to 1MB.  Depending on the value of a cog's PC, an instruction will be fetched from either its register RAM, its lookup RAM, or the hub RAM.\nPC Address\nInstruction Source\nMemory Width\nPC Increment\n\n### $00000..$001FF\ncog register RAM\n32 bits\n1\n\n### $00200..$003FF\ncog lookup RAM\n32 bits\n1\n\n### $00400..$FFFFF\nhub RAM\n8 bits\n4\n\n### REGISTER EXECUTION\nWhen the PC is in the range of $00000 and $001FF, the cog is fetching instructions from cog register RAM.  This is commonly referred to as "cog execution mode."  There is no special consideration when taking branches to a cog register address.\n\n### LOOKUP EXECUTION\nWhen the PC is in the range of $00200 and $003FF, the cog is fetching instructions from cog lookup RAM.  This is commonly referred to as "LUT execution mode."  There is no special consideration when taking branches to a cog lookup address,\n\n### HUB EXECUTION\nWhen the PC is in the range of $00400 and $FFFFF, the cog is fetching instructions from hub RAM.  This is commonly referred to as "hub execution mode."  When executing from hub RAM, the cog employs the FIFO hardware to spool up instructions so that a stream of instructions will be available for continuous execution. \nElsewhere I read that the spin interpreter now fetches instructions one at a time. \nBranching to a hub address takes a  minimum of 13  clock cycles.  If the instruction being branched to is not long-aligned, one additional clock cycle is required. A branch must occur to get from cog to hub, since rolling from $3FF to $400 will not initiate hub execution.\nWhile in hub execution mode, the FIFO  cannot be used for anything else.  So, during hub execution these instructions cannot be used:\n\n### WFBYTE / WFWORD / WFLONG\nXINIT / XZERO / XCONT - when the streamer mode engages the FIFO\nIt is  usually  not possible to execute code from hub addresses $00000 through $003FF, as the cog will instead read instructions from the cog register or lookup RAM as indicated above.\n\n### STARTING AND STOPPING COGS\nAny cog can start or stop any other cog, or restart or stop itself. Each of the eight cogs has a unique three-bit ID which can be used to start or stop it. It's also possible to start free (stopped or never started) cogs, without needing to know their ID's. This way, entire applications can be written which simply start free cogs, as needed, and as those cogs retire by stopping themselves or getting stopped by others, they return to the pool of free cogs and become available, again, for restarting.\nThe COGINIT instruction is used to start cogs:\n\n### COGINIT D/#,S/# {WC}\nNot clear what the % sign means. Nor what all the xxx means. Now what {wc} means.  \nWhat you want to do is to give a high level view, then the detailed view.  Say that starting a cag takes 5 arguments.  The target cog id, the hub address to start from, the hub address to load commands from,  the mode of starting and ….\nThen describe each of the commands. Otherwise the user has to figure out all of that.  Most painful. Make it easy for me please. \nIn the process of explaining you will find it clears up your thinking also. \nD/# =  %0_x_xxxx The target cog loads its own registers $000..$1F7 from the hub,\nstarting at address S/#, then begins execution at register address $000.\n%1_x_xxxx The target cog begins execution at register/LUT/hub address S/#.\n%x_0_CCCC The target cog's ID is %CCCC.\n%x_1_xxx0 If a cog is free (stopped), then start it.\nTo know if this succeeded, D must be a register and WC must be\nused. If successful, C will be cleared and D will be over-\nwritten with the target cog's ID. Otherwise, C will be set and D will be overwritten with $F.\n%x_1_xxx1 If an even/odd cog pair is free (stopped), then start them.\nTo know if this succeeded, D must be a register and WC must be\nused. If successful, C will be cleared and D will be over-\nwritten with the even/lower target cog's ID. Otherwise, C will be set\nand D will be overwritten with $F.\nS/# = address This value is either the hub address from which the target cog will\nload from, or it is the cog/hub address from which the target cog\nwill begin executing at, depending on D[5]. This 32-bit value will be\nwritten into the target cog's  PTRB  register.\nA more general introduction to setq is needed. \nAnd ptrA.  Most readers will scan the list of registers, remind us what it does. \nIf COGINIT is preceded by SETQ, the SETQ value will be written into the target cog's PTRA register. This is intended as a convenient means of pointing the target cog's program to some runtime data structure or passing it a 32-bit parameter. If no SETQ is used, the target cog's PTRA register will be cleared to zero.\nCOGINIT #1,#$100 'load and start cog 1 from $100\nCOGINIT #%1_0_0101,PTRA 'start cog 5 at PTRA\nSETQ    ptra_val 'ptra_val will go into target cog's PTRA register\nCOGINIT #%0_1_0000,addr 'load and start a free cog at addr\nCOGINIT #%1_1_0001,addr 'start a pair of free cogs at addr (lookup RAM sharing)\nCOGINIT id,addr WC '(id=$30) start a free cog at addr, C=0 and id=cog if okay\nCOGID   myID 'reload and restart me at  PTRB\nCOGINIT myID, PTRB\nThe COGSTOP instruction is used to stop cogs. The 4 LSB's of the D/# operand supply the target cog ID.\nCOGSTOP #0 'stop cog 0\nCOGID   myID 'stop me\nCOGSTOP myID\nA cog can discover its own ID by doing a COGID instruction, which will return its ID into D[3:0], with upper bits cleared. This is useful, in case the cog wants to restart or stop itself, as shown above.\nIf COGID is used with WC, it will not overwrite D, but will return the status of cog D/# into C, where C=0 indicates the cog is free (stopped or never started) and C=1 indicates the cog is busy (started).\nCOGID   ThatCog  WC 'C=1 if ThatCog is busy\n\n### COG RAM\nEach cog has a primary 512 x 32-bit dual-port RAM, which can be used in multiple ways:\nDirect/Register access\nAs a source of program instructions (see  COGS > INSTRUCTION MODES > REGISTER EXECUTION )\n\n### GENERAL PURPOSE REGISTERS\nRAM registers $000 through $1EF are general-purpose registers for code and data usage.\n\n### DUAL-PURPOSE REGISTERS\nRAM  registers $1F0 through $1F7 may either be used as general-purpose registers, or may be used as special-purpose registers if their associated functions are enabled.\n$1F0 RAM / IJMP3 interrupt call   address for INT3\n$1F1 RAM / IRET3 interrupt return address for INT3\n$1F2 RAM / IJMP2 interrupt call   address for INT2\n$1F3 RAM / IRET2 interrupt return address for INT2\n$1F4 RAM / IJMP1 interrupt call   address for INT1\n$1F5 RAM / IRET1 interrupt return address for INT1\n$1F6 RAM / PA CALLD-imm return, CALLPA parameter, or LOC address\n$1F7 RAM / PB CALLD-imm return, CALLPB parameter, or LOC address\n\n### SPECIAL-PURPOSE REGISTERS\nEach cog contains 8 special-purpose registers that are mapped into the RAM register address space from $1F8 to $1FF.  In general, when specifying an address between $1F8 and $1FF, the instruction is accessing a special-purpose register,  not  just the underlying RAM.\n$1F8 PTRA pointer A to hub RAM\n$1F9 PTRB pointer B to hub RAM