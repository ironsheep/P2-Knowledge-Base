                   CON
                   
                   
                   ' Ray, Peter, this little 'Load new ROM' routine rewrites the built-in
                   ' ..16KB ROM with what is being assembled into $FC000..$FFFFF. After
                   ' ..running it, you'll have a new ROM. To update the ROM image again,
                   ' ..you'll need to power-cycle the FPGA board to get it to reload the
                   ' ..original image which permits loading the whole 1024KB again.
                   
                   
                   {{ *********************** CHANGELOG **************************
                   
                   '' RR20180512 v134a     Combine: ROM_Booter v33d, LSD_v133i, SD2_133jx, TAQOZ BOOTROM(7)
                   '' CG20180513     c     Update booter
                   '' RR20180513     c_001 Use booter's ao baud value for Monitor
                   ''                  002 Disable interrupts and smart pins on P0 & P1, but don't stop uart
                   ''            v134d
                   ''                ef    Cmd_G coginit if addr $FC000, clockmax=200MHz, add nops/waitx to sendrecv
                   '' may want to change the SD fail destination???
                   PJ20180514 V134e        Implement buffered serial interrupts
                                           ^D from TAQOZ switches to DEBUGGER
                                           Add LF to LMM DEBUGGER (CRLF is standard line ending)
                   '' RR20180515 v135b     Add LF in other places; SD cogstop on failure
                   ''                cd    Add load SD file "R"UN; SDinit to check for pullup
                   ''                e     use "." in R<filename> as 8.3; add hubset #1 before cogstop
                   ''                f     if Sd fails, jmp to shut_down in booter, now does cogid/cogstop
                   ''                      parse R<filename>
                   ''                g     add Chip's latest booter
                   ''                h     Chip's latest; rearrange; remove delay1ms in serialinit & taqoz
                   
                   PBJ180516 v136          Adding in high level SD support, not complete but has virtual SD memory layer.
                                           Can load in full version of Tachyon with SD support using Ray's SD loader
                                           TAQOZ will reboot if four ESCs are entered in sequence (usually I use break detect)
                   
                   BIG BUG NOTICE!!!       SD fail should not stop cog as application may be on Flash - Check Flash before SD
                   
                   '' RR20180516 v136c     fix <lf> in _HubRxString; push/pop around pa use in _SDcard_Init; reset at _start_sdcard ???
                   '' RR20180517 v136d     move and fname+2 ##$00FFFFFF from _Run_SDfile to search_dir
                   ''                      use _str_hdg in _HubList (and for TAQOZ)
                   ''                      remove reset_pins call in _Start_SDcard
                   ''                e     _str_hdg add _str_dash; delay before calling taqoz
                   ''                f     _HubList extra space ea 4 bytes
                   '' RR20180519 v136m     combine ROM_Booter_base_v32g; if SD fails boot,jmp #try_serial; Peter to add latest TAQOZ
                   ''                      _str_hdg has dump header
                   ''                +     tweek for P2ASM compiler; alignl long alignment after _str_hdg; _parsehex skip "_"
                   
                                   138PBJ  Combine 137PBJ
                                      a    remove delay1ms before monitor calls taqoz; jmp to _Enter_TAQOZ; remove _str_hdg
                   
                   Need to:        Cmd_G   use hubset ##$1000_0000 for FC000  +delay1ms           (done)
                                           Taqoz to monitor needs to shutdown cogs
                                           Monitor to taqoz calls entry_taqoz and no 1ms delay    (done)
                                           reset_booter ???                                        ????
                                           Command9 needs to respect lmm_bufad not ##_HUBBUF ???
                                           _HUBBUF use ROM (FC000 ???)                            (done)
                                   Cmd_X   hex mode monitor/list option                           (done) "X"
                                           remove heading                                         (done)
                                           SD add write sector ???                                        no space!
                                           monitor <cr> to repeat list                            (done)
                                           <esc> on its own???
                   '' RR20180520   138b    command8 reply1=05 missing wz
                   ''                      LL command replaces X                                  (done)
                   ''                 c    add write_sector, command24, writeblock                 not verified!!
                   ''                      overflowed ROM so use $FC000 for _HUBBUF
                   ''                 d    try <cr> to repeat list for next addr
                   ''                      make G a call instead of a jump
                   ''                 e    tweeks to SD
                   ''                      comment out write sd
                   ''                      cmd_r result "="/"!"for passed/failed
                   ''                 f    mod _start/load/run_SDcard
                   ''                      ##hubdata use _hubdata
                   '' RR20180524   139     include ROM_Booter_base_138f.spin2  & RR139a (X<fname>)
                   ''              139C    w Chip pasted code
                   ''-----------------------------------------------------------------------------
                   ''              140_a   List uses xxxxx: was xxxxx-
                   ''                      R<filename> & L<fileanem>, List L[L] --> M[L]
                   ''                 _e   List xxxxx- does not require L/M
                   ''                 _f   use decod for PTN_SECCLU (needs TAQOZ 140e !!!)
                   ''                 _g   add TAQOZ 140F
                   ''                 _gx  remove unused labels fail etc
                   ''                 _hx  reorg SD routines
                   '' RR20180526   140i    proposed final SD & Monitor
                   ''                 k    fix SD timeout for dead/missing SD card w pullup. CMD0=10ms@35MHz
                   '' RR20180527  v141     proposed final SD & Monitor
                   '' PBJ20180527          Added SD and FAT32 routines
                   **************************************************************** }}
                   '' RR20190215  v33_01a  ROM_Booter_v33_01a.spin - tweek SD Booter
                   '' RR20190216        b  force release of SD-DO pin (& tweek to make space)
                   '' RR20190217        f  combine _SDcard_Init & _readMBR --> Init/CSD/CID/MBR/VOL/FSI/FAT etc
                   '' PBJ
                   '' RR20190219        h  remove SD_CS pull-up check for Start_SDcard (ROM booter)
                   '                    i  fix timeout bug
                   '                    j  use "G" for Prop2 silicon v2 (for Prop_Chk response)
                   
                   '
                   '
                   ' Load new ROM and wait for next reset
                   '
00000 000          dat		org
                   
00000 000 fecfc000 		loc	ptra,#$FC000		'ready to enter new data into rom
                   
00004 001 fac41361 .lp		rdbyte	byte_data,ptra++	'get new rom byte
00008 002 f8d00e09 		setbyte	rom_write,byte_data,#2	'install into command
0000c 003 fd600e00 		hubset	rom_write		'do rom write command
00010 004 f1040e01 		add	rom_write,#1		'inc address in command
00014 005 fb6c11fb 		djnz	byte_count,#.lp		'loop until 16KB loaded into rom
                   
00018 006 fd9ffffc 		jmp	#$			'wait for reset
                   
0001c 007 30000000 rom_write	long	$30000000		'rom write command
00020 008 00004000 byte_count	long	$4000			'number of rom bytes
00024 009          byte_data	res	1			'byte buffer
                   
                   
                   '****************************************
                   '*					*
                   '*	Propeller 2 ROM Booter		*
                   '*					*
                   '*	5/28/2018 - v32i		*
                   '*					*
                   '****************************************
                   
                   CON
                   '	ver		=	"A"		'Prop123-A9 / BeMicro-A9, 8 cogs, 64 smart pins
                   '	ver		=	"B"		'DE2-115
                   '	ver		=	"C"		'DE0-Nano / DE0-Nano Bare
                   '	ver		=	"D"		'BeMicro-A2
                   '	ver		=	"E"		'Prop123-A7
                   '	ver		=	"F"		'Prop123-A9 / BeMicro-A9, 16 cogs, 12 smart pins
                   	ver		=	"G"		'Prop2 Silicon v2
                   
                   	rx_pin		=	63		'pin serial receiver
                   	tx_pin		=	62		'pin serial transmitter
                   	spi_cs		=	61		'pin SPI memory select		(also sd_ck)
                   	spi_ck		=	60		'pin SPI memory clock		(also sd_cs)
                   	spi_di		=	59		'pin SPI memory data in		(also sd_di)
                   	spi_do		=	58		'pin SPI memory data out	(also sd_do)
                   	rx_ths		=	1		'pin autobaud time high states
                   	rx_tne		=	0		'pin autobaud time negative edges
                   
                   	cog_spi		=	$000		'cog SPI program start
                   	cog_start	=	$100		'cog code start
                   	cog_base64	=	$180		'cog base64 start
                   
                   	lut_buff	=	$000		'lut serial receive buffer
                   	lut_btop	=	$00F		'lut serial receive buffer top
                   	lut_start	=	$010		'lut code start
                   
                   	spi_ok		=	0		'bit flags
                   	cmd_on		=	1
                   	ser_no		=	2
                   
                   	rc_max		=	30_000_000	'max frequency of RC oscillator
                   
                   DAT
                   '
                   '
                   '*******************************************
                   '*  Cog init - overwritten by SPI program  *
                   '*******************************************
                   '
fc000              		orgh	$FC000
fc000 000          		org
                   '
                   '
                   ' Seed xoroshiro 128** using delta-sigma ADC bits from calibration mode
                   '
fc000 000 ff800800 		wrpin	##$00100000,#rx_pin	'put rx pin in adc gio calibration mode
fc004 001 fc0c003f 
                   
fc008 002 f606c832 		mov	x,#50			'ready to seed 50 times with 31 bits
                   
fc00c 003 fcdc041f .seed		rep	#2,#31			'get 31 bits (31*4 clocks = 124/20 = ~6us)
fc010 004 fd747e40 		testp	#rx_pin		wc
fc014 005 f0a6ca01 		rcl	y,#1
                   
fc018 006 f426ca1f 		bith	y,#31			'seed via hubset
fc01c 007 fd62ca00 		hubset	y
                   
fc020 008 fb6ec9fa 		djnz	x,#.seed
                   
fc024 009 fc0c003f 		wrpin	#0,#rx_pin		'return rx pin to normal mode
                   '
                   '
                   ' Move code into position
                   '
fc028 00a fd64c428 		setq	#cog_end-cog_code-1	'move cog code into position
fc02c 00b ff0007e0 		rdlong	cog_start,##@cog_code
fc030 00c fb06012c 
                   
fc034 00d fd655229 		setq2	#lut_end-lut_code-1	'move lut code into position
fc038 00e ff0007e1 		rdlong	lut_start,##@lut_code
fc03c 00f fb0420b8 
                   '
                   '
                   ' Make 256-byte base64 lookup table
                   '
fc040 010 fd647e28 		setq	#$FF>>2			'reset table in hub
fc044 011 ffffffff 		wrlong	##$FFFFFFFF,#0
fc048 012 fc6ffe00 
                   
fc04c 013 fb4c8231 		callpa	#"A",#fill26		'"A".."Z" --> $00..$19
                   
fc050 014 fb4cc230 		callpa	#"a",#fill26		'"a".."z" --> $1A..$33
                   
fc054 015 f606c80a 		mov	x,#10			'"0".."9" --> $34..$3D
fc058 016 fb4c602f 		callpa	#"0",#fill
                   
fc05c 017 fc4c7c2b 		wrbyte	#$3E,#"+"		'"+" --> $3E
                   
fc060 018 fc4c7e2f 		wrbyte	#$3F,#"/"		'"/" --> $3F
                   
fc064 019 fd647e28 		setq	#$FF>>2			'load table into cog
fc068 01a fb070000 		rdlong	cog_base64,#0
                   '
                   '
                   ' If pull-up on spi_di then try serial
                   '
fc06c 01b fb4c76ed 		callpa	#spi_di,#check_pullup
fc070 01c cd9007cc 	if_c	jmp	#reset_serial
                   '
                   '
                   ' If pull-up on spi_cs then try to load from SPI memory
                   '
fc074 01d fb4c7aeb 		callpa	#spi_cs,#check_pullup
fc078 01e cd90000c 	if_c	jmp	#try_spi
                   '
                   '
                   ' If pull-up on spi_ck (also sd_cs) then try to load from SD card
                   '
fc07c 01f fb4c78e9 		callpa	#spi_ck,#check_pullup
fc080 020 cd8fc560 	if_c	jmp	#@_start_sdcard
                   '
                   '
                   ' If no pull-down on spi_di then try serial
                   '
fc084 021 fd900378 		jmp	#try_serial
                   '
                   '
                   ' Try to load from SPI memory
                   '
fc088 022 fd647a59 try_spi		drvh	#spi_cs			'drive spi_cs high
fc08c 023 fd647858 		drvl	#spi_ck			'drive spi_ck low
                   
fc090 024 f667ee01 		neg	pb,#1			'set command bits to all 1's
fc094 025 fd647459 		drvh	#spi_do			'drive spi_do high in case quad/dual mode
fc098 026 fb4c04e8 		callpa	#2,#spi_cmd		'send exit-quad command
fc09c 027 fb4c10e7 		callpa	#8,#spi_cmd		'send exit-quad command
fc0a0 028 fb4c20e6 		callpa	#16,#spi_cmd		'send exit-dual command
fc0a4 029 fd647450 		fltl	#spi_do			'float spi_do
                   
fc0a8 02a fb5ccce3 		callpb	#$66,#spi_cmd8		'send reset-enable command
fc0ac 02b fb5d32e2 		callpb	#$99,#spi_cmd8		'send reset command
fc0b0 02c ff800002 		waitx	##rc_max/20_000		'wait 50us
fc0b4 02d fd67b81f 
                   
fc0b8 02e fb5c08df 		callpb	#$04,#spi_cmd8		'send write-disable command to clear WEL
                   
fc0bc 02f fb5c0ade .wait		callpb	#$05,#spi_cmd8		'send read-status command
fc0c0 030 fdb00398 		call	#spi_in			'get status
fc0c4 031 f42ec801 		testbn	x,#1		wz	'if WEL high, no SPI memory (z=0)
fc0c8 032 5d90003c 	if_nz	jmp	#.fail
fc0cc 033 f42ec800 		testbn	x,#0		wz	'if BUSY high, wait for erase/write to finish
fc0d0 034 5d9fffe8 	if_nz	jmp	#.wait
                   
fc0d4 035 f607ec20 		mov	pa,#32			'send read-from-start command
fc0d8 036 fb5c06d8 		callpb	#$03,#spi_cmd
                   
fc0dc 037 f9c6ca0a 		decod	y,#10			'ready to input $400 bytes from SPI
fc0e0 038 fc8c0000 		wrfast	#0,#0			'ready to write bytes to hub
fc0e4 039 fdb00374 .data		call	#spi_in			'get byte
fc0e8 03a fd62c815 		wfbyte	x			'store byte into hub
fc0ec 03b fb6ecbfd 		djnz	y,#.data		'loop for next byte (y=0 after)
                   
fc0f0 03c fc7c0000 		rdfast	#0,#0			'ready to read longs from hub
fc0f4 03d fcdc0500 		rep	@.sum,#$100		'ready to read and sum $100 longs
fc0f8 03e fd62cc12 		rflong	z			'read long
fc0fc 03f f102cb66 		add	y,z			'sum long
fc100 040          .sum
fc100 040 f20acb52 		cmp	y,csum		wz	'verify checksum, z=1 if okay
fc104 041 f4868e00 		bitz	flags,#spi_ok		'if program verified, set spi_ok flag
fc108 042          .fail
                   '
                   '
                   ' If SPI failed, check for pull-up on spi_ck (also sd_cs)
                   '
fc108 042 5b4c78c6   if_nz		callpa	#spi_ck,#check_pullup	'if no SPI program, check for pull-up on spi_ck (also sd_cs)
fc10c 043 4d8fc560   if_nz_and_c	jmp	#@_start_sdcard		'if no SPI program and pull-up on spi_ck, try to load from SD card
                   
fc110 044 fd9002ec 		jmp	#try_serial		'try serial
                   '
                   '
                   ' Fill table
                   '
fc114 045 f606c81a fill26		mov	x,#26			'ready to fill "A".."Z"/"a".."z" entries
                   
fc118 046 fc8801f6 fill		wrfast	#0,pa			'set table pointer
                   
fc11c 047 fcd80564 		rep	@.v,x			'fill entries with ascending values
fc120 048 fd609415 		wfbyte	.v
fc124 049 f1049401 		add	.v,#1
                   
fc128 04a 02040000 .v	_ret_	cmp	0,#0			'bottom byte used as a counter
                   
                   
fc12c 04b          		fit	cog_start		'make sure below cog code
                   '
                   '
                   '**************
                   '*  Cog code  *
                   '**************
                   '
fc12c 100          		org	cog_start
fc12c 100          cog_code
                   '
                   '
                   ' Try serial if no pull-down on spi_di
                   ' else, run SPI program if valid or float SPI pins and shut down
                   '
fc12c 100 f40e8e00 try_serial	testb	flags,#spi_ok	wz	'SPI program?
                   
fc130 101 5d647a50 	if_nz	fltl	#spi_cs			'if no SPI program, float SPI pins
fc134 102 5d647850 	if_nz	fltl	#spi_ck
                   
fc138 103 ad65fe28 	if_z	setq	#$FF			'if SPI program, move it into cog $000..$0FF
fc13c 104 ab040000 	if_z	rdlong	0,#0
                   
fc140 105 fd647659 		drvh	#spi_di			'check pull-down on spi_di, leave floating
fc144 106 fb4c7603 		callpa	#spi_di,#check_pulldn	'c=0 if pull-down
                   
fc148 107 3d900664 	if_nc	jmp	#serial_done		'if pull-down on spi_di, boot if SPI okay (z=1) or shut down
                   
fc14c 108 fd90041c 		jmp	#reset_serial		'else try serial
                   '
                   '
                   ' Check pin pull-up
                   '
fc150 109 fd63ec58 check_pullup	drvl	pa			'drive pin low
fc154 10a fd643c1f check_pulldn	waitx	#30*1			'wait >1us
fc158 10b fd63ec50 		fltl	pa			'float pin
fc15c 10c fd652c1f 		waitx	#30*5			'wait >5us
fc160 10d 0d73ec40 	_ret_	testp	pa		wc	'sample pin
                   '
                   '
                   ' SPI long/byte out
                   '
fc164 10e f607ec08 spi_cmd8	mov	pa,#8			'ready to send 8 bits
                   
fc168 10f fd647a59 spi_cmd		drvh	#spi_cs			'cs pin high
fc16c 110 f027ee18 		rol	pb,#24			'msb-justify byte
fc170 111 fd647a58 		drvl	#spi_cs			'cs pin low
                   
fc174 112 f037ee01 .out		rol	pb,#1		wc	'get bit to send
fc178 113 fd64765a 		drvc	#spi_di			'drive data-in pin to bit
fc17c 114 fd647859 		drvh	#spi_ck			'drive clock pin high
fc180 115 fd647858 		drvl	#spi_ck			'drive clock pin low
fc184 116 0b6fedfb 	_ret_	djnz	pa,#.out		'loop to output bits, return when done
                   '
                   '
                   ' SPI byte in
                   '
fc188 117 fcdc0808 spi_in		rep	@.in,#8			'ready to input a byte
fc18c 118 fd647859 		drvh	#spi_ck			'drive clock pin high
fc190 119 fd647858 		drvl	#spi_ck			'drive clock pin low
fc194 11a fd747440 		testp	#spi_do		wc	'sample data-out pin ('testp' is from before 'drvh')
fc198 11b f0a6c801 		rcl	x,#1			'save data bit
fc19c 11c          .in
fc19c 11c fd64002d 		ret
                   '
                   '
                   ' Autobaud ISR - detects initial "> "
                   '
                   '	      falls |--7---|
                   '	 $3E --> ..10011111001..10000001001..
                   '	        highs |-5--|
                   '
fc1a0 11d fa8ed200 autobaud_isr	rdpin	a0,#rx_tne		'2	get fall-to-fall time	(7x if $3E)
fc1a4 11e fa8ed401 		rdpin	a1,#rx_ths		'2	get high time		(5x if $3E)
                   
fc1a8 11f f292d33d 		cmpr	a0,limit	wc	'2	make sure both measurements are within limit
fc1ac 120 3292d53d 	if_nc	cmpr	a1,limit	wc	'2
                   
fc1b0 121 fa32d33e 		scas	a0,norm0		'2	if they are within 1/35th of each other, $3E
fc1b4 122 3292d400 	if_nc	cmpr	a1,0		wc	'2
fc1b8 123 fa32d53f 		scas	a1,norm1		'2
fc1bc 124 3292d200 	if_nc	cmpr	a0,0		wc	'2
fc1c0 125 cb3bfff5 	if_c	reti1				'2/4	if not $3E, exit
                   
fc1c4 126 fb3be9f5 		resi1				'4	got $3E, resume on next interrupt
                   
fc1c8 127 fc0c0200 		akpin	#rx_tne			'2	acknowledge pin
fc1cc 128 fa02d340 		mul	a0,baud0		'2	compute baud rate
fc1d0 129 f8c6d207 		setbyte	a0,#7,#0		'2	set word size to 8 bits
fc1d4 12a fc16d23f 		wxpin	a0,#rx_pin		'2	set receiver baud rate and word size
fc1d8 12b fc16d23e 		wxpin	a0,#tx_pin		'2	set transmitter baud rate and word size
fc1dc 12c fb3be9f5 		resi1				'4	resume on next interrupt
                   
fc1e0 12d fd647e41 		dirh	#rx_pin			'2	enable receiver before next start bit
fc1e4 12e fc068c00 		wrpin	mtpe,#rx_tne		'2	change rx_tne to measure positive edges
fc1e8 12f fd677e20 		setse1	#%110<<6+rx_pin		'2	set se1 to trigger on rx_pin high
fc1ec 130 fb3be9f5 		resi1				'4	resume on next interrupt
                   '
                   '
                   ' Receiver ISR - detects maintenance ">" chrs
                   '
                   '	        rises |--7---|
                   '	 $3E --> ..10011111001..
                   '
fc1f0 131 fa8ed400 		rdpin	a1,#rx_tne		'2	get rise-to-rise time	(7x if $3E)
                   
fc1f4 132 fa9ed63f 		rdpin	a2,#rx_pin	wc	'2	get received chr
fc1f8 133 f046d618 		shr	a2,#32-8		'2	shift to lsb justify
fc1fc 134 f20ed63e 		cmp	a2,#">"		wz	'2	autobaud chr?
fc200 135 5c32d76c 	if_nz	wrlut	a2,head			'2	if not, write byte to circular buffer in lut
fc204 136 5706d80f 	if_nz	incmod	head,#lut_btop		'2	..increment buffer head
fc208 137 5b3bfff5 	if_nz	reti1				'2/4	..exit
                   
fc20c 138 fa02d540 		mul	a1,baud0		'2	autobaud chr, compute baud rate
fc210 139 f8c6d407 		setbyte	a1,#7,#0		'2	set word size to 8 bits
fc214 13a fc16d43f 		wxpin	a1,#rx_pin		'2	set receiver baud rate and word size
fc218 13b fc16d43e 		wxpin	a1,#tx_pin		'2	set transmitter baud rate and word size
fc21c 13c fb3bfff5 		reti1				'4	exit
                   
                   
fc220 13d 000058e4 limit		long	$58E4				'count limit ($58E4 = 1.3889, keeps SCAS within $7FFF w/norm1)
fc224 13e 00002f05 norm0		long	$41D4*5/7			'fall-to-fall normalization factor
fc228 13f 00005c28 norm1		long	$41D4*7/5			'high-time normalization factor ($41D4 = 1.0 + 1/(7*5))
fc22c 140 00002492 baud0		long	$1_0000/7			'7x baud computation factor
                   '
                   '
                   ' Constants / initialized variables
                   '
fc230 141 002dc6c0 timeout_per	long	rc_max/10			'100ms timeout for serial receive
fc234 142 00000258 timeout_cnt	long	600				'60s timeout for serial completion
                   
fc238 143 0000387c mtxf		long		%111<<11+%01_11110_0	'asynchronous serial transmit, float on high
fc23c 144 60000022 mths		long	%0_110_0_000<<24+%00_10001_0	'time high states on pin[-2] (pin 63 in case of pin 1)
fc240 145 ff000026 mtne		long	%1_111_1_111<<24+%00_10011_0	'time neg edges   on pin[-1] (pin 63 in case of pin 0)
fc244 146 77000026 mtpe		long	%0_111_0_111<<24+%00_10011_0	'time pos edges   on pin[-1] (pin 63 in case of pin 0)
fc248 147 00000000 flags		long	0				'bit flags
                   
fc24c 148 50726f70 text_prop	byte	"porP"				'text
fc250 149 5f43686b text_chk	byte	"khC_"
fc254 14a 5f436c6b text_clk	byte	"klC_"
fc258 14b 5f486578 text_hex	byte	"xeH_"
fc25c 14c 5f547874 text_txt	byte	"txT_"
fc260 14d 72500a0d text_ver	byte	13,10,"Prop_Ver ",ver,13,10,0,0
fc270 151 0000002e text_sta	byte	".",0,0,0
                   
fc274 152 706f7250 csum		byte	"Prop"				'checksum
                   
fc278 153 00000000 hexchrs		long	%00000000_00000000_00000000_00000000
fc27c 154 03ff0000 		long	%00000011_11111111_00000000_00000000		'"0".."9"
fc280 155 0000007e 		long	%00000000_00000000_00000000_01111110		'"A".."F"
fc284 156 0000007e 		long	%00000000_00000000_00000000_01111110		'"a".."f"
fc288 157 00000000 		long	%00000000_00000000_00000000_00000000
fc28c 158 00000000 		long	%00000000_00000000_00000000_00000000
fc290 159 00000000 		long	%00000000_00000000_00000000_00000000
fc294 15a 00000000 		long	%00000000_00000000_00000000_00000000
                   
fc298 15b 00002600 whitechrs	long	%00000000_00000000_00100110_00000000		'cr, lf, tab
fc29c 15c 20000001 		long	%00100000_00000000_00000000_00000001		'"=", space
fc2a0 15d 00000000 		long	%00000000_00000000_00000000_00000000
fc2a4 15e 00000000 		long	%00000000_00000000_00000000_00000000
fc2a8 15f 00000000 		long	%00000000_00000000_00000000_00000000
fc2ac 160 00000000 		long	%00000000_00000000_00000000_00000000
fc2b0 161 00000000 		long	%00000000_00000000_00000000_00000000
fc2b4 162 00000000 		long	%00000000_00000000_00000000_00000000
                   
fc2b8 163          cog_end
                   '
                   '
                   ' Uninitialized variables
                   '
fc2b8 163          i		res	1		'universal
fc2b8 164          x		res	1
fc2b8 165          y		res	1
fc2b8 166          z		res	1
                   
fc2b8 167          checksum	res	1		'checksum
fc2b8 168          bytemask	res	1
                   
fc2b8 169          a0		res	1		'serial autobaud/receiver ISR
fc2b8 16a          a1		res	1
fc2b8 16b          a2		res	1
                   
fc2b8 16c          head		res	1		'serial receiver buffer
fc2b8 16d          tail		res	1
                   
fc2b8 16e          		fit	cog_base64	'make sure below cog_base64
                   '
                   '
                   '**************
                   '*  Lut code  *
                   '**************
                   '
fc2b8 210          		org	$200 + lut_start
fc2b8 210          lut_code
                   '
                   '
                   ' Reset serial autobaud/receiver interrupt
                   '
fc2b8 210 f527f403 reset_serial	andn	dira,#%11		'disable timing measurements for autobaud
                   
fc2bc 211 fd640025 		setint1	#0			'disable int1
                   
fc2c0 212 f606d800 		mov	head,#0			'reset serial buffer pointers
fc2c4 213 f606da00 		mov	tail,#0
                   
fc2c8 214 fd647e40 		dirl	#rx_pin			'disable receiver
fc2cc 215 fc0c7c3f 		wrpin	#%00_11111_0,#rx_pin	'configure rx_pin for asynchronous receive, always input
                   
fc2d0 216 fc0cf83e 		wrpin	#%01_11110_0,#tx_pin	'configure tx_pin for asynchronous transmit, always output
fc2d4 217 fd647c41 		dirh	#tx_pin			'enable transmitter
                   
fc2d8 218 fc068801 		wrpin	mths,#rx_ths		'configure rx_ths for timing high states
                   
fc2dc 219 fc068a00 		wrpin	mtne,#rx_tne		'configure rx_tne for timing negative edges
fc2e0 21a fc1c0200 		wxpin	#1,#rx_tne		'report each cycle
fc2e4 21b fc2c0000 		wypin	#0,#rx_tne		'measure fall to fall
                   
fc2e8 21c fd670020 		setse1	#%110<<6+rx_tne		'set se1 to trigger on rx_tne high
                   
fc2ec 21d f607e91d 		mov	ijmp1,#autobaud_isr	'set int1 jump vector to autobaud ISR
                   
fc2f0 21e fd640825 		setint1	#4			'set int1 to trigger on se1 (rx_tne high)
                   
fc2f4 21f f547f403 		or	dira,#%11		'enable timing measurements for autobaud
                   '
                   '
                   ' Attempt to get serial command
                   '
fc2f8 220 fd62c81a get_command	getct	x			'reset serial timeout in case SPI program ready
fc2fc 221 fa62c941 		addct1	x,timeout_per
                   
fc300 222 f606cc00 		mov	z,#0			'reset string buffer
                   
fc304 223 fdb001d4 .byte		call	#get_rx			'get byte
                   
fc308 224 f20ec81b 		cmp	x,#$1B		wz	'esc?
fc30c 225 ad8fd028 	if_z	jmp	#@_start_taqoz
                   
fc310 226 f20ec804 		cmp	x,#$04		wz	'ctrl-d?
fc314 227 ad8fca88 	if_z	jmp	#@_start_monitor
                   
fc318 228 f91acb66 		rolbyte	y,z,#3			'scroll byte into 2-long/8-byte string buffer
fc31c 229 f902cd64 		rolbyte	z,x,#0
                   
fc320 22a f20acb48 		cmp	y,text_prop	wz	'"Prop"?
fc324 22b 5d9fffdc 	if_nz	jmp	#.byte
                   
fc328 22c f20acd4c 		cmp	z,text_txt	wz	'"_Txt"?
fc32c 22d ad90005c 	if_z	jmp	#command_txt
                   
fc330 22e f20acd4b 		cmp	z,text_hex	wz	'"_Hex"?
fc334 22f ad9000b0 	if_z	jmp	#command_hex
                   
fc338 230 f20acd4a 		cmp	z,text_clk	wz	'"_Clk"?
fc33c 231 ad900018 	if_z	jmp	#command_clk
                   
fc340 232 f20acd49 		cmp	z,text_chk	wz	'"_Chk"?
fc344 233 5d9fffbc 	if_nz	jmp	#.byte
                   '
                   '
                   ' Command - check device
                   '
fc348 234 fdb000ec command_chk	call	#match_device		'receive and check INA/INB filter values
                   
fc34c 235 f606c74d 		mov	i,#text_ver		'transmit version string
fc350 236 fdb001c0 		call	#transmit
                   
fc354 237 fd9fffa0 		jmp	#get_command		'get next command
                   '
                   '
                   ' Command - clock setup
                   '
fc358 238 fdb000dc command_clk	call	#match_device		'receive and check INA/INB filter values
                   
fc35c 239 fdb0011c 		call	#get_hex		'get clock setting
fc360 23a 3d9fff94 	if_nc	jmp	#get_command		'if not hex, error, wait for another command
                   
fc364 23b f606a22e 		mov	text_sta,#"."		'transmit acknowledgement character
fc368 23c fdb001a4 		call	#transmit_sta
                   
fc36c 23d f746c818 		zerox	x,#24			'clear non-clock bits
                   
fc370 23e f602cb64 		mov	y,x			'switch to partial setting, but in RC fast mode
fc374 23f f526ca03 		andn	y,#%11
fc378 240 fd62ca00 		hubset	y
                   
fc37c 241 ff800124 		waitx	##rc_max/200		'wait 5ms
fc380 242 fd67e01f 
                   
fc384 243 fd62c800 		hubset	x			'switch to full setting
                   
fc388 244 fd9fff2c 		jmp	#reset_serial		'restart serial at new setting, get next command
                   '
                   '
                   ' Command - text load
                   '
fc38c 245 fdb000a8 command_txt	call	#match_device		'receive and check INA/INB filter values
                   
fc390 246 f606c600 		mov	i,#0			'reset bit counter
                   
fc394 247 fdb00144 .chr		call	#get_rx			'get byte
                   
fc398 248 f99ec95b 		altb	x,#whitechrs		'whitespace?
fc39c 249 f4280164 		testbn	0,x		wz
fc3a0 24a 5d9ffff0 	if_nz	jmp	#.chr			'if whitespace, get another byte
                   
fc3a4 24b f96ec980 		altgb	x,#cog_base64		'lookup base64 value in table
fc3a8 24c f8e2ca00 		getbyte	y
                   
fc3ac 24d f42eca07 		testbn	y,#7		wz	'if msb set, not base64 chr
                   
fc3b0 24e a066cc06 if_z		shl	z,#6			'if base64 chr, shift data buffer up 6 bits
fc3b4 24f a542cd65 if_z		or	z,y			'..or in new value
fc3b8 250 a106c606 if_z		add	i,#6			'..add 6 into bit counter
fc3bc 251 a2f6c608 if_z		cmpsub	i,#8		wc	'..if bit counter >= 8, subtract 8, byte ready
fc3c0 252 8602c966 if_z_and_c	mov	x,z			'....get data buffer value
fc3c4 253 8042c963 if_z_and_c	shr	x,i			'....shift down to justify byte
fc3c8 254 8d62c815 if_z_and_c	wfbyte	x			'....write byte to hub
fc3cc 255 89fec800 if_z_and_c	movbyts	x,#%%0000		'....replicate byte within long
fc3d0 256 8502c968 if_z_and_c	and	x,bytemask		'....mask current byte position
fc3d4 257 8102cf64 if_z_and_c	add	checksum,x		'....add into checksum
fc3d8 258 8026d008 if_z_and_c	rol	bytemask,#8		'....update byte position mask
fc3dc 259 ad9fffb4 if_z		jmp	#.chr			'..loop for next chr
                   
fc3e0 25a f726da0f 		decmod	tail,#lut_btop		'not base64 chr, repoint to prior chr
fc3e4 25b fd900020 		jmp	#end_of_data		'done
                   '
                   '
                   ' Command - hex load
                   '
fc3e8 25c fdb0004c command_hex	call	#match_device		'receive and check INA/INB filter values
                   
fc3ec 25d fdb0008c .byte		call	#get_hex		'get hex byte
fc3f0 25e cd62c815 	if_c	wfbyte	x			'if hex, write byte to hub
fc3f4 25f c9fec800 	if_c	movbyts	x,#%%0000		'..replicate byte within long
fc3f8 260 c502c968 	if_c	and	x,bytemask		'..mask current byte position
fc3fc 261 c102cf64 	if_c	add	checksum,x		'..add into checksum
fc400 262 c026d008 	if_c	rol	bytemask,#8		'..update byte position mask
fc404 263 cd9fffe4 	if_c	jmp	#.byte			'..loop for next byte (followed by end_of_data)
                   '
                   '
                   ' End of data for text/hex load - get "~" and launch code
                   '
fc408 264 fdb000b4 end_of_data	call	#get_chr		'end of data, check terminus chr
                   
fc40c 265 f20ec87e 		cmp	x,#"~"		wz	'if "~", run program
fc410 266 ad90001c 	if_z	jmp	#.run
                   
fc414 267 f20ec83f 		cmp	x,#"?"		wz	'if not "?", error, wait for another command
fc418 268 5d9ffedc 	if_nz	jmp	#get_command
                   
fc41c 269 f56acf52 		xor	checksum,csum	wz	'test checksum
                   
fc420 26a a606a22e 	if_z	mov	text_sta,#"."		'(okay)
fc424 26b 5606a221 	if_nz	mov	text_sta,#"!"		'(error)
fc428 26c fdb000e4 		call	#transmit_sta		'transmit status character
                   
fc42c 26d fb9ecfb2 		tjnz	checksum,#get_command	'if error, wait for another command
                   
fc430 26e fdb00110 .run		call	#reset_pins		'reset smart pins
                   
fc434 26f fcec0000 		coginit	#0,#$00000		'relaunch cog from $00000
                   '
                   '
                   ' Get and check INA/INB mask and data values
                   '
fc438 270 f4268e01 match_device	bith	flags,#cmd_on		'command on, enable serial timeout for SPI program
                   
fc43c 271 f606c7fe 		mov	i,#ina			'check INA first
                   
fc440 272 fdb00038 .pair		call	#get_hex		'get hex mask
fc444 273 3d9ffeb0 	if_nc	jmp	#get_command		'if not hex, error, wait for another command
fc448 274 f60acd64 		mov	z,x		wz	'got mask
fc44c 275 5c06863e 	if_nz	wrpin	mtxf,#tx_pin		'if mask non-0, make tx_pin float on high
fc450 276 f996c600 		alts	i			'point to INA/INB
fc454 277 f502cdfe 		and	z,ina			'mask INA/INB
fc458 278 fdb00020 		call	#get_hex		'get hex data
fc45c 279 3d9ffe98 	if_nc	jmp	#get_command		'if not hex, wait for another command
fc460 27a f20acd64 		cmp	z,x		wz	'test for match
fc464 27b 5d9ffe90 	if_nz	jmp	#get_command		'if mismatch, wait for another command
                   
fc468 27c f4fec600 		bitnot	i,#0		wcz	'toggle INA/INB pointer
fc46c 27d 3d9fffd0 	if_nc	jmp	#.pair			'if INA checked, loop to check INB
                   
fc470 27e f606ce00 		mov	checksum,#0		'reset checksum
fc474 27f f606d0ff 		mov	bytemask,#$FF		'reset bytemask
                   
fc478 280 0c8c0000 	_ret_	wrfast	#0,#0			'ready to load data bytes into hub
                   '
                   '
                   ' Get hex value, c=1 if hex
                   '
fc47c 281 fdb00040 get_hex		call	#get_chr		'get chr
                   
fc480 282 fdb00024 		call	#.check			'check for hex
fc484 283 3d900018 	if_nc	jmp	#.prior			'if not hex, repoint to chr, c=0
                   
fc488 284 f602cb64 		mov	y,x			'got first hex digit
                   
fc48c 285 fdb00014 .digit		call	#.get			'get any additional hex digits
fc490 286 c882cb64 	if_c	rolnib	y,x,#0
fc494 287 cd9ffff4 	if_c	jmp	#.digit
                   
fc498 288 f602c965 		mov	x,y			'done, set result
fc49c 289 fd75e06f 		modcz	_set,0		wc	'c=1 for hex
fc4a0 28a 0726da0f .prior	_ret_	decmod	tail,#lut_btop		'repoint to chr, exit
                   
                   
fc4a4 28b fdb00034 .get		call	#get_rx			'get byte
fc4a8 28c f99ec953 .check		altb	x,#hexchrs		'check for hex
fc4ac 28d f4100164 		testb	0,x		wc
fc4b0 28e 3d64002d 	if_nc	ret				'if not hex, c=0
                   
fc4b4 28f f42ec806 		testbn	x,#6		wz	'hex, "0".."9"?
fc4b8 290 5106c809 	if_nz	add	x,#9			'if not, make $A..$F
fc4bc 291 0506c80f 	_ret_	and	x,#$F			'isolate nibble, c=1
                   '
                   '
                   ' Get chr after any whitespace
                   '
fc4c0 292 fdb00018 get_chr		call	#get_rx			'get byte
                   
fc4c4 293 f99ec95b 		altb	x,#whitechrs		'whitespace?
fc4c8 294 f4280164 		testbn	0,x		wz
                   
fc4cc 295 5d9ffff0 	if_nz	jmp	#get_chr		'if whitespace, get another byte
                   
fc4d0 296 fd64002d 		ret
                   '
                   '
                   ' Get serial byte
                   '
fc4d4 297 fd62c81a get_rx_res	getct	x			'reset timer
fc4d8 298 fa62c941 		addct1	x,timeout_per
                   
                   
fc4dc 299 fbcc0204 get_rx		jct1	#.timeout		'timeout?
fc4e0 29a f20ad96d 		cmp	head,tail	wz	'byte received?
fc4e4 29b ad9ffff4 	if_z	jmp	#get_rx			'loop until timeout or byte received
                   
fc4e8 29c faa2c96d 		rdlut	x,tail			'get byte from circular buffer in lut
fc4ec 29d 0706da0f 	_ret_	incmod	tail,#lut_btop		'increment buffer tail
                   
                   
fc4f0 29e f40e8e00 .timeout	testb	flags,#spi_ok	wz	'timeout, SPI program?
fc4f4 29f f4168e01 		testb	flags,#cmd_on	wc	'command on?
fc4f8 2a0 db6e85f6 if_nz_or_c	djnz	timeout_cnt,#get_rx_res	'if no SPI program or command on, try until 60s (serial_done follows)
                   '
                   '
                   ' Serial done
                   ' on entry, z=1 if SPI program
                   '
fc4fc 2a1 fdb00044 serial_done	call	#reset_pins		'reset pins
                   
fc500 2a2 ad9ff574 	if_z	jmp	#0			'if SPI program, run it, else shut down
                   
fc504 2a3 fd62c801 shut_down	cogid	x			'get cogid (in case jumped to from outside)
fc508 2a4 fd640200 		hubset	#1			'set 20KHz oscillator
fc50c 2a5 fd62c803 		cogstop	x			'shut down cog (floats pins)
                   '
                   '
                   ' Transmit message
                   '
fc510 2a6 f606c751 transmit_sta	mov	i,#text_sta		'point to status character
                   
fc514 2a7 f9b6c601 transmit	setd	i,#1			'set auto-increment for altgb
                   
fc518 2a8 f602cb69 		mov	y,a0			'wait 16 bit periods to allow host turn-around time
fc51c 2a9 f046ca0e 		shr	y,#16-4+2		'shr 16 gets clocks/bit, -4 gets 16 bits, +2 gets 4 clocks/djnz
fc520 2aa fb6ecbff 		djnz	y,#$			'y=0 after (djnz allows interrupts, unlike waitx)
                   
fc524 2ab f96acb63 .byte		altgb	y,i			'get next byte of string, increment y
fc528 2ac f8e2cc00 		getbyte	z
                   
fc52c 2ad 0b9ecc00 	_ret_	tjnz	z,#.send		'if zero, done
                   
fc530 2ae fc26cc3e .send		wypin	z,#tx_pin		'send byte
                   
fc534 2af fd64021f 		waitx	#1			'accommodate wypin -> rdpin latency
                   
fc538 2b0 fa9ecc3e .wait		rdpin	z,#tx_pin	wc	'wait for transmit done
fc53c 2b1 cd9ffff8 	if_c	jmp	#.wait
                   
fc540 2b2 fd9fffe0 		jmp	#.byte			'loop for more bytes
                   '
                   '
                   ' Reset smart pins
                   '
fc544 2b3 fd640025 reset_pins	setint1	#0			'disable int1
                   
fc548 2b4 f527f403 		andn	dira,#%11		'reset smart pins (avoids output on mode clears)
fc54c 2b5 f747f61d 		zerox	dirb,#29		'..but leave spi pins in current state
                   
fc550 2b6 fc0c0001 		wrpin	#0,#rx_ths		'clear rx_ths mode
fc554 2b7 fc0c0000 		wrpin	#0,#rx_tne		'clear rx_tne mode
fc558 2b8 fc0c003f 		wrpin	#0,#rx_pin		'clear rx_pin mode
fc55c 2b9 0c0c003e 	_ret_	wrpin	#0,#tx_pin		'clear tx_pin mode
                   
fc560 2ba          lut_end
                   
                   
                   CON
                   '------------------------------------------------------------------------------------------------
                   ''  _clockmax     = 200_000_000                ' max clock freq
                   ''  _clockfreq    = 80_000_000
                   ''  _clockfpga    = 20_000_000
                     _cpufreq      = rc_max
                     _1us          = _cpufreq / 1_000_000       ' 1us
                   
                     delay1s       = _cpufreq                   ' 1s  (xtal * pll)
                     delay10ms     = _cpufreq / 100             ' 10ms
                     delay1ms      = _cpufreq / 1_000           ' 1ms
                     delay5us      = (20_000_000 / 100_000 / 2) - 2        ' 5us @20MHz 100KHz (20MHz/100KHz/2-2=98)       ] {{ tweek }}
                   
                     _baud         = 115_200
                     _bitper       = (_cpufreq / _baud) << 16 + 7            ' 115200 baud, 8 bits
                     _txmode       = %0000_0000_000_0000000000000_01_11110_0 'async tx mode, output enabled for smart output
                     _rxmode       = %0000_0000_000_0000000000000_00_11111_0 'async rx mode, input  enabled for smart input
                   '------------------------------------------------------------------------------------------------
                           sd_ck           =       spi_cs          'pin SD Card clock
                           sd_cs           =       spi_ck          'pin SD Card select
                           sd_di           =       spi_di          'pin SD Card MOSI
                           sd_do           =       spi_do          'pin SD Card MISO
                   
                   '------------------------------------------------------------------------------------------------
                   '    ASCII equates
                   '------------------------------------------------------------------------------------------------
                   _CLS_     =       $0C     '$00    ' clear screen
                   _BS_      =       $08
                   _LF_      =       $0A
                   _CR_      =       $0D
                   _TAQOZ_   =       $1B             ' <esc>   goto TAQOZ
                   '------------------------------------------------------------------------------------------------
                   
                   '------------------------------------------------------------------------------------------------
                   '               HUB ADDRESSES
                   '------------------------------------------------------------------------------------------------
                     _HUBROM       = $FC000                        ' ROM $FC000
                     _HUBBUF       = $FC000                        ' overwrite Booter
                     _HUBBUFSIZE   = 80                            ' RxString default size for _HUBBUF
                   '------------------------------------------------------------------------------------------------
                   
                   DAT
                   ''============[ COG VARIABLES - SD BOOT]========================================
fc560 1c0                          org     $1C0              ' place the variables in cog $1C0-$1DF
                   
fc560 1c0          cmdout          res     1                       ' The 8b CMDxx | $40
fc560 1c1          cmdpar          res     1                       ' The 32b parameters
fc560 1c2          cmdcrc          res     1                       ' The 8b CRC (must be valid for CMD0 & CMD8)
fc560 1c3          cmdpar2         res     1                       ' SDV1=$0, SDV2=$40000000
fc560 1c4          cmdtype         res     1                       ' reply is R1=1, R3=3, R7=7, else 0
fc560 1c5          reply           res     1                       ' R1 reply (moved to replyR1 when R3/R7 32b reply here)
fc560 1c6          replyR1         res     1                       ' R1 reply (8b saved when R3/R7 32b reply follows)
fc560 1c7          dataout         res     1                       ' 8/32 bit data being shifted out
fc560 1c8          bytescnt        res     1                       ' #bytes to send/recv
fc560 1c9          bitscnt         res     1                       ' #bits to be shifted in/out
fc560 1ca          ctr1            res     1
fc560 1cb          timeout         res     1                       ' = starttime + delay
fc560 1cc          _AA55           res     1                       ' used to store $AA55 to validate MBR/VOL/FSI
fc560 1cd          skiprun         res     1                       ' 1= skip load/run mbr/vol & load/no-run fname
                                                                   '\ 1=SDV1, 2=SDV2(byte address), 3=SDHC/SDV2(block address)
fc560 1ce          blocksh         res     1                       '/ block shift 0/9 bits
fc560 1cf          clustersh       res     1                       ' sectors/cluster SHL 'n' bits
                   
fc560 1d0          vol_begin       res     1 '$0000_2000           ' Ptn0: first sector of PTN
fc560 1d1          fsi_begin       res     1 '$0000_2001           ' Ptn0:       sector of file system info
fc560 1d2          fat_begin       res     1 '$0000_3122           ' Ptn0: first sector of FAT table
fc560 1d3          dir_begin       res     1' $0000_4000           ' Ptn0: first sector of DATA is DIR table
fc560 1d4          dat_begin       res     1 '$0000_4580 $0000_54C0' Ptn0: first sector of file's DATA
fc560 1d5          ptn_size        res     1 '$0008_0000           '       file-size 32KB = 64<<9 sectors
                   
fc560 1d6          _bufad          res     1
fc560 1d7          _blocknr        res     1
fc560 1d8          _sectors        res     1
fc560 1d9          _entries        res     1
fc560 1da          bufad           res     1                       ' ptr sector buffer
fc560 1db          blocknr         res     1                       ' sector#
fc560 1dc          fname           res     3                       ' 8+3+1
fc560 1df          _hubdata        res     1
fc560 1e0                          fit     $1E0
                   
                   ''============[ COG VARIABLES - MONITOR]========================================
fc560 1e0                          org     $1E0              ' place the variables in cog $1E0-$1EF
                   ''-------[ LMM parameters, etc ]------------------------------------------------
fc560 1e0          lmm_x           res     1       ' parameter passed to/from LMM routine (typically a value)
fc560 1e1          lmm_f           res     1       ' parameter passed to      LMM routine (function options; returns unchanged)
fc560 1e2          lmm_p           res     1       ' parameter passed to/from LMM routine (typically a hub/cog ptr/addr)
fc560 1e3          lmm_p2          res     1       ' parameter passed to/from LMM routine (typically a 2nd hub/cog address)
fc560 1e4          lmm_c           res     1       ' parameter passed to/from LMM routine (typically a count)
                   ''-------[ LMM additional workareas ]-------------------------------------------
fc560 1e5          lmm_w           res     1       ' workarea (never saved - short term use between calls, except _HubTx)
fc560 1e6          lmm_tx          res     1       ' _HubTx
fc560 1e7          lmm_hx          res     1       ' _HubHex/_HubString
fc560 1e8          lmm_hx2         res     1       ' _HubHex
fc560 1e9          lmm_hc          res     1       '   "
fc560 1ea          lmm_lx          res     1       ' _HubList
fc560 1eb          lmm_lf          res     1       '   "
fc560 1ec          lmm_lp          res     1       '   "
fc560 1ed          lmm_lp2         res     1       '   "
fc560 1ee          lmm_lc          res     1       '   "
fc560 1ef          lmm_bufad       res     1       ' _HubRxString
fc560 1f0                          fit     $1F0
                   ''=======[ ^^^^^ End of COG Variables ^^^^^ ]===================================
                   
                   
                   '' +--------------------------------------------------------------------------+
                   '' | Cluso's Minimal SD Boot Test for P2  (c)2012-2018 "Cluso99" (Ray Rodrick)|
                   '' +--------------------------------------------------------------------------+
                   '' RR20180505 v128a    add into ROM_v131b
                   
                   ''============================[ CON ]============================================================
                   CON
                   
                     _csum    = ("P" + "r"<<8 + "o"<<16 + "p"<<24)  ' "Prop" checksum (reversed)
                     _csum2   = ("P" + "r"<<8 + "o"<<16 + "P"<<24)  ' "ProP" checksum (reversed)
                   
                     _fname1a = ("_" + "B"<<8 + "O"<<16 + "O"<<24)  '\\ filename...
                     _fname1b = ("T" + "_"<<8 + "P"<<16 + "2"<<24)  '||   8.3 +$00
                     _fname1c = ("B" + "I"<<8 + "X"<<16 + $00<<24)  '//
                     _fname2c = ("B" + "I"<<8 + "Y"<<16 + $00<<24)  '//
                   
                     mbr_begin  = 0                 ' first sector of disk $0000_0000
                   
                   '------------------------------------------------------------------------------------------------
                   '       COG & LUT & HUB ADDRESSES
                   '------------------------------------------------------------------------------------------------
                     hubdata       = $0_0000        ' expands up   (512byte sectors)
                     max_size      = (512-16)*1024  ' max file_size(bytes) that can be loaded
                   
                     cog_start0    = $000           ' cog code start
                     cog_len       = 512-16         ' cog code length
                     cog_len80     = 512/4          ' 512 bytes (sector)
                   
                   '------------------------------------------------------------------------------------------------
                   ' SD Commands & Responses...
                   '------------------------------------------------------------------------------------------------
                   ' Command              Argument        Response/Data    Description
                     CMD0   = 0  +$40   ' 0               R1       -       GO_IDLE_STATE            *Reqs valid CRC
                   '  CMD1   = 1  +$40   ' 0               R1       -       SEND_OP_COND
                     ACMD41 = 41 +$40   ' $4000_0000      R1       -       APP_SEND_OP_COND         *Reqs CMD55 first
                     CMD8   = 8  +$40   ' 0               R1+R7    -       SEND_IF_COND             *Reqs valid CRC
                     CMD9   = 9  +$40   ' 0               R1       Y       SEND_CSD
                     CMD10  = 10 +$40   ' 0               R1       Y       SEND_CID
                   '  CMD12  = 12 +$40   ' 0               R2       -       STOP_TRANSMISSION
                     CMD16  = 16 +$40   ' BlkLen[31:0]    R1       -       SET_BLOCKLEN
                     CMD17  = 17 +$40   ' Addr[31:0]      R1       Y       READ_SINGLE_BLOCK
                   '  CMD18  = 18 +$40   ' Addr[31:0]      R1       Y       READ_MULTIPLE_BLOCK
                   '  CMD23  = 23 +$40   ' NoBlks[15:0]    R1       -       SET_BLOCK_COUNT
                   '  ACMD23 = 23 +$40   ' NoBlks[22:0]    R1       -       SET_WR_BLOCK_ERASE_COUNT *Reqs CMD55 first
                   '  CMD24  = 24 +$40   ' Addr[31:0]      R1       Y*      WRITE_BLOCK
                   '  CMD25  = 25 +$40   ' Addr[31:0]      R1       Y*      WRITE_MULTIPLE_BLOCK
                     CMD55  = 55 +$40   ' 0               R1       -       APP_CMD                  *Prefix for ACMD41/ACMD23
                     CMD58  = 58 +$40   ' 0               R1+R3    -       READ_OCR
                   
                   
                   ' R1 response:  $FF = busy/wait (0-8 bytes?)
                   '               b7: 0 (msb first)
                   '               b6: Parameter Error
                   '               b5: Address Error
                   '               b4: Erase Sequence Error
                   '               b3: Command CRC Error
                   '               b2: Illegal Command
                   '               b1: Erase Reset
                   '               b0: In Idle State
                   ' R1b response: ???
                   ' R3 response:  R1 + OCR(32b)
                   ' R7 response:  R1($01) + 32b(b11..b0 = $1AA = SDC V2 2V7-3V6, else reject)
                   '
                   ' DataPacket:   DataToken(1byte) + DataBlock(1-2048bytes) + CRC(2bytes)
                   '   DataToken:  $FE = CMD17/18/24 (read'1'block/read'n'blocks/write'1'block)
                   '               $FC = CMD25 (write'n'blocks)
                   '               $FD = CMD25 StopToken  (Single byte packet without data or CRC)
                   ' ErrorToken:   Single Byte Reply
                   '               b7-b5: 000
                   '               b4: Card Locked
                   '               b3: Out of Range
                   '               b2: Card ECC failed
                   '               b1: CC Error
                   '               b0: Error
                   ' DataResponse:
                   '               b7-b4: xxx0
                   '               $x5: Data Accepted
                   '               $xB: Data Rejected - CRC Error
                   '               $xD: Data Rejected - Write Error
                   
                   
                   DAT
                   ''################################################################################################
                   ''##    SD Card - HUBEXEC code...                                                               ##
                   ''################################################################################################
fc560                              orgh
                   
                   '+-------[ SD: Initialise/Locate/Load/Run a file from SD ]---------------------+ <--- SD: init/locate/load/run a file --->
                   '+ On Entry:                                                                   +
                   '+      fname[3]:       filename[11] 8+3 without "."  (will be $0 terminated)  +
                   '+ Call Format:                                                                +
                   '+              CALL    #@_Run_SDfile                   '                      + < call: init/locate/load/run a file >
                   '+ On Return:                                                                  +
                   '+      "NZ" if error, else does not return                                    +
                   '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
fc560     f6079a00 _Start_SDcard   mov     skiprun,          #0            ' load/run MBR/VOL code                         \ --tweek2--
fc564     fdb00050                 call    #@_SDcard_Init0                 ' Init/CSD/CID/MBR/VOL/FSI/FAT (skiprun=0)      | --tweek2--
fc568     adb00290         if_e    call    #@_readDIR                      ' read directory for filenames
                   ''              mov     skiprun,          #0            ' load/run <file>              (already 0)
fc56c     adb00378         if_e    call    #@_readFILE                     ' read/load/run the file
fc570     fdb004ec                 call    #@_releaseDO                    ' /CS=1, send CLKs, tristate CS/CK/DI/DO        | --tweek2--
fc574     fd800100                 JMP     #try_serial                     ' failed: so go back and try serial
                   '+-----------------------------------------------------------------------------+
fc578     fdb00020 _Run_SDfile     call    #@_SDcard_Init1                 ' Init/CSD/CID/MBR/VOL/FSI/FAT (skiprun=1)      | --tweek2--
fc57c     adb002ac         if_e    call    #@_searchDIR                    ' search dir for <fname>
fc580     f6079a00                 mov     skiprun,          #0            ' load/run <file>              (skiprun=0)
fc584              _Loadit                                                 '                                               \ {{ tweek }}
fc584     adb00360         if_e    call    #@_readFILE                     ' read/load/[run] the file                      / {{ tweek }}
fc588     fdb004d4                 call    #@_releaseDO                    ' /CS=1, send CLKs, tristate CS/CK/DI/DO        | --tweek2--
fc58c     fd64002d                 RET                                     ' return "NZ" = failed, "Z" if loaded ok
                   '+-----------------------------------------------------------------------------+
fc590     fdb00008 _Load_SDfile    call    #@_SDcard_Init1                 ' Init/CSD/CID/MBR/VOL/FSI/FAT (skiprun=1)      | --tweek2--
fc594     adb00294         if_e    call    #@_searchDIR                    ' search dir for <fname>
                   ''              mov     skiprun,          #1            ' load, do not run <file>      (already 1)
fc598     fd9fffe8                 jmp     #@_Loadit                       ' if Z go read/load file                        ] {{ tweek }}
                   '+-----------------------------------------------------------------------------+
                   
                   
                   '+-------[ SD Card Initialisation ]--------------------------------------------+ <--- SD initialisation --->
                   '+ On Entry:                                                                   +
                   '+ Call Format:                                                                +
                   '+              CALL    #@_SDcard_Init                  '                      + < call: sd initialise >
                   '+ On Return:                                                                  +
                   '+      hub $0   = CSD[16] + CID[16]                    ' csd/cid data         +
                   '+      Returns  "Z" if ok, "NZ" if error                                      +
                   '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SD/SDHC/sdxc SPI Initialisation                                        +
                   '+-----------------------------------------------------------------------------+
                   '+      Send >74 clocks with /CS=1 & DI=1 starting & ending with CLK=0         +
                   '+-----------------------------------------------------------------------------+
fc59c     f6079a01 _SDcard_Init1   mov     skiprun,          #1            ' do not load/run MBR/VOL code                  ] --tweek2--
fc5a0     fd647858                 drvl    #sd_cs                          '\ ensure we have an SD card                    \ {{ tweek }}
fc5a4     fd643c1f                 waitx   #30*1                           '| wait >1us                                    |
fc5a8     fd647850                 fltl    #sd_cs                          '| /CS=tristate                                 |
fc5ac     fd652c1f                 waitx   #30*5                           '| wait >5us                                    |
fc5b0     fd747840                 testp   #sd_cs                      wc  '| /CS=1? pullup?                               /
fc5b4     3d900240         if_nc   jmp     #@_fail_pullup                  '/
                   
fc5b8     f607be00 _SDcard_Init0   mov     _hubdata,         #hubdata      ' init hub data ptr=$0                          ] --tweek-h--
fc5bc     fd647859                 drvh    #sd_cs                          ' cs=1 & output
fc5c0     fd647a58                 drvl    #sd_ck                          ' ck=0 & output
fc5c4     fd647659                 drvh    #sd_di                          ' di=1 & output
                   
fc5c8     fcdc02c0                 rep     @.rep,#(96*2)                   '                                               \ {{ tweek }}
fc5cc     fd64c41f                 waitx   #delay5us                       '\ 5us @20MHz 100KHz (20MHz/100KHz/2-2=98)      |
fc5d0     fd647a4f                 outnot  #sd_ck                          '/ CLK=0-->1-->0                                |
fc5d4              .rep                                                    '                                               |
fc5d4     fd64c41f                 waitx   #delay5us                       '  CLK=0 (idle) & /CS=1                         /
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Software Reset:                                                             +
                   '+      CMD0,  PAR=$0,        CRC=$95, REPLY=R1($01)                           +
                   '+-----------------------------------------------------------------------------+
fc5d8     fd63961a .Command0       getct   timeout                         '\ set timeout up to CMD9
fc5dc     ff000249                 add     timeout,          ##delay10ms   '/
fc5e0     f10797e0 
fc5e4     f607940a                 mov     ctr1,             #10           ' try a few times
fc5e8     f6078040 .again0         mov     cmdout,           #CMD0
fc5ec     f6078200                 mov     cmdpar,           #0
fc5f0     f6078495                 mov     cmdcrc,           #$95
                   '+-----------------------------------------------------------------------------+
fc5f4     fdb003b8                 call    #@_cmdR1          ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
fc5f8     3f00e4e1   if_nc         add     timeout,          ##delay1s     ' increase timeout to 1s
fc5fc     31079780 
                                                                           '\ $01(idle): SD/MMC, not fully validated
fc600     3d90000c   if_nc         jmp     #.Command8                      '/ $00(good): (dane card response)
                   '+-----------------------------------------------------------------------------+
fc604     fd64c41f                 waitx   #delay5us                       ' delay 5us @20MHz                              ] {{ tweek }}
fc608     fb6f95f7                 djnz    ctr1,             #.again0      ' n: try again?
fc60c     fd9001e8                 jmp     #@_fail00                       '
                   '+=============================================================================+
                   
                   ' we know we now have an SD/MMC card but its not fully validated yet...
                   '+-----------------------------------------------------------------------------+
                   '+ Check Voltage:                                                              +
                   '+      CMD8,  PAR=$1AA,      CRC=$87, REPLY=R1($01)+R7($xx1AA) ($05=try SDV1) +
                   '+-----------------------------------------------------------------------------+
fc610     f6078048 .Command8       mov     cmdout,           #CMD8
fc614     f60783aa                 mov     cmdpar,           #$1AA
fc618     f6078487                 mov     cmdcrc,           #$87
                   '+-----------------------------------------------------------------------------+
fc61c     fdb00390                 call    #@_cmdR1R7        ' /CS=0, send cmd, recv R1+R7, /CS=1
                   '+-----------------------------------------------------------------------------+
fc620     ed90001c   if_c_or_z     jmp     #.illegal                       ' j if <> $01 (not idle)
fc624     ff000007 .idle           and     reply,            ##$FFF        '\
fc628     f5078bff 
fc62c     f20f8baa                 cmp     reply,            #$1AA     wz  '/ R7[11:0]=$1AA ?
fc630     ff200000                 mov     cmdpar2,          ##$40000000   ' preset for SDV2
fc634     f6078600 
fc638     5d9001bc   if_ne         jmp     #@_fail98                       ' n: unknown R7
fc63c     fd90000c                 jmp     #.Command55                     ' y: CMD55+ACMD41($4000_0000)
                   
fc640     f20f8c05 .illegal        cmp     replyR1,          #$05      wz  ' $05(illegal cmd) ?
fc644     5d9001b0   if_ne         jmp     #@_fail08                       ' <>$01/$05 (not idle/illegal)
fc648     f6078600                 mov     cmdpar2,          #0            ' try SDV1
                                                                           ' CMD55+ACMD41($0) fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Prefix to ACMD41 & ACMD23:                                                  +
                   '+      CMD55, PAR=$0,        CRC=$xx, REPLY=R1($01)                           +
                   '+-----------------------------------------------------------------------------+
fc64c     f6078077 .Command55      mov     cmdout,           #CMD55        '
fc650     f6078200                 mov     cmdpar,           #0            '
                   '+-----------------------------------------------------------------------------+
fc654     fdb00350                 call    #@_cmdRZA41       ' /CS=0, send cmd, recv R1, /CS=0(ena)
                   '+-----------------------------------------------------------------------------+
fc658     ed90019c   if_c_or_z     jmp     #@_fail55                       ' <>$01 (not idle)
                                                                           '              fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Check SDV1/SDV2:  (follows CMD55)                                           +
                   '+     ACMD41, PAR=$0,        CRC=$xx, REPLY=R1($00) SD-V1                     +
                   '+     ACMD41, PAR=$40000000, CRC=$xx, REPLY=R1($00) SD-V2                     +
                   '+-----------------------------------------------------------------------------+
fc65c     f6078069 .CommandA41     mov     cmdout,           #ACMD41       '
fc660     f60383c3                 mov     cmdpar,           cmdpar2       ' SDV1=0 / SDV2=$40000000
                   '+-----------------------------------------------------------------------------+
fc664     fdb00348                 call    #@_cmdR1          ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
fc668     1d9fffe0   if_nc_and_nz  jmp     #.Command55                     '  =$01(busy): CMD55+CMD41 again
fc66c     cd900188   if_c          jmp     #@_fail41                       ' <>$00/$01: error
                   
fc670     f20f8600                 cmp     cmdpar2,          #0        wz  ' SDV1 ?
fc674     a6079c09         if_z    mov     blocksh,          #9            ' y: #1 SDV1(byte address)
fc678     ad90001c         if_z    jmp     #.Command16                     ' y: SDV1 does not use CMD58
                                                                           ' SDV2         fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Check OCR CCS bit:                                                          +
                   '+      CMD58, PAR=$0,        CRC=$xx, REPLY=R1($00)+R3(b30=1)                 +
                   '+-----------------------------------------------------------------------------+
fc67c     f607807a .Command58      mov     cmdout,           #CMD58        ' SDHC ?
fc680     f6078200                 mov     cmdpar,           #0            '
                   '+-----------------------------------------------------------------------------+
fc684     fdb00328                 call    #@_cmdR1R3        ' /CS=0, send cmd, recv R1+R3, /CS=1
                   '+-----------------------------------------------------------------------------+
fc688     dd90016c   if_c_or_nz    jmp     #@_fail58                       ' <>$00(good): error
fc68c     f42f8a1e                 testbn  reply,            #30       wz  ' bit30=CCS=1? $40000000?
fc690     a6079c09         if_z    mov     blocksh,          #9            ' n: #2 SDV2(byte address)
fc694     56079c00         if_nz   mov     blocksh,          #0            ' y: #3 SDHC/SDV2(block address)
                   ''      if_nz   jmp     #.Command9x                     ' y: does not req cmd16?                        ?????????
                                                                           ' SDV2(byte)   fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Force block size to 512 bytes:                                              +
                   '+      CMD16, PAR=$200,      CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc698     f6078050 .Command16      mov     cmdout,           #CMD16        ' force blocksize=512bytes
fc69c     ff000001                 mov     cmdpar,           ##512         ' 512 bytes
fc6a0     f6078200 
                   '+-----------------------------------------------------------------------------+
fc6a4     fdb00308                 call    #@_cmdR1          ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
fc6a8     1d9fffec   if_nc_and_nz  jmp     #.Command16                     '  =$01(idle): again
fc6ac     dd900148   if_c_or_nz    jmp     #@_fail16                       ' <>$00(good): error
                   '+-----------------------------------------------------------------------------+
fc6b0     f603addf .Command9x      mov     _bufad,           _hubdata      ' where to store data
fc6b4     f603b5d6                 mov     bufad,            _bufad        ' where to store CSD/CID
                   '+-----------------------------------------------------------------------------+
                   '+ Read CSD register (16 bytes):                                               +
                   '+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc6b8     f6078049 .Command9       mov     cmdout,           #CMD9         ' read CSD register
fc6bc     fdb002a0                 call    #@_readREG                      '
fc6c0     5d900134         if_nz   jmp     #@_fail09                       ' "NZ" = failed                                 ] --tweek2--
                   '+-----------------------------------------------------------------------------+
                   '+ Read CID register (16 bytes):                                               +
                   '+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc6c4     f607804a .Command10      mov     cmdout,           #CMD10        ' read CID register
fc6c8     fdb00294                 call    #@_readREG                      '
fc6cc     5d900128         if_nz   jmp     #@_fail10                       ' "NZ" = failed                                 ] --tweek2--
                   '+-----------------------------------------------------------------------------+
                                                                           '              fall thru
                   
                   '+-------[ SD: Read MBR/VOL/FSI/FAT ]------------------------------------------+ <--- SD: read mbr/vol/fsi/fat --->
                   '+ On Entry:                                                                   +
                   '+      skiprun:        #0 = load/run boot code if found on MBR/VOL            +
                   '+                      #1 = do not load/run boot code on MBR/VOL              +
                   '+ Call Format:                                                                +
                   '+              CALL    #@_readMBR                      '                      + < call: read mbr/vol/fsi/fat >
                   '+ On Return:                                                                  +
                   '+      DOES NOT RETURN if skiprun = #0 and code found on MBR/VOL              +
                   '+      Returns: "Z" if ok, "NZ" if error                                      +
                   '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read MBR/VBR (Sector 0):                                                    +
                   '+-----------------------------------------------------------------------------+
fc6d0     f607ae00 ._readMBR       mov     _blocknr,         #mbr_begin    ' VBR/MBR = SECTOR 0
fc6d4     fdb00264                 call    #@_readSECTOR                   ' read sector
fc6d8     fd639a31                 skip    skiprun                         ' skips next instr if #1
fc6dc     fdb001d8                 call    #@_validateCSUM                 ' valid -> load & run
                     '+-----------------------------------------------------------------------------+
                     '+ Validate MBR (PTN0 table & signature)                                       +
                     '+              +$1BE[16]   =         = Ptn0 Table...                          +
                     '+      verify  +$1BE+$0[1] = $00/$80 = Ptn0 State                             +
                     '+      verify  +$1BE+$4[1] = $0B/$0C = Ptn0 Type                              +
                     '+      calc    +$1BE+$8[4] =         = Ptn0 StartSector#    --> vol_begin     +
                     '+      calc    +$1BE+$C[4] =         = Ptn0 SectorSize      --> ptn_size      +
                     '+      verify  +$1FE[2]    = $55AA   = signature                              +
                     '+-----------------------------------------------------------------------------+
fc6e0     f603b5d6 ._validateMBR     mov     bufad,            _bufad        ' MBR hub addr
fc6e4     f107b5be                   add     bufad,            #$1BE         ' offset to PTN0 table
fc6e8     fac38bda                   rdbyte  reply,            bufad         ' ptn_state
fc6ec     f50f8a7f                   and     reply,            #$7F      wz  ' $00/80? inactive/active                     ] {{ tweek }}
fc6f0     5d900104           if_ne   jmp     #@_fail_mbr                     '
fc6f4     f107b404                   add     bufad,            #$4           ' offset to ptn_type
fc6f8     fac38bda                   rdbyte  reply,            bufad         ' ptn_type
fc6fc     f20f8a0c                   cmp     reply,            #$0C      wz  ' $0C=FAT32(LBA)
fc700     520f8a0b           if_ne   cmp     reply,            #$0B      wz  ' $0B=FAT32(CHS)
                     ''''    if_ne   cmp     reply,            #$07      wz  ' $07=exFAT/NTFS        Do not allow!!!
fc704     5d9000f0           if_ne   jmp     #@_fail_mbr                     '
fc708     f107b43c                   add     bufad,         #($1FE-$1BE-$4)  ' offset to $55AA signature
fc70c     fae38bda                   rdword  reply,            bufad         ' read
fc710     ff000055                   mov     _AA55,            ##$AA_55      ' initialise (reversed)                       \ {{ tweek }}
fc714     f6079855 
fc718     f20b8bcc                   cmp     reply,            _AA55     wz  ' we read it reversed!                        / {{ tweek }}
fc71c     5d9000d8           if_ne   jmp     #@_fail_mbr                     '
                   
fc720     f603b5d6                   mov     bufad,            _bufad        ' MBR hub addr
fc724     f107b5be                   add     bufad,            #$1BE         ' offset to PTN0 table
                     '+-----------------------------------------------------------------------------+
                     '+ Calculate the raw sector address (LBA) for the VOL sector (vol_begin)...    +
                     '+     vol_begin = LBA begin  ptn0 $1BE+$08[4] (reversed & not long aligned!!!)+
                     '+-----------------------------------------------------------------------------+
fc728     f107b408                   add     bufad,            #$08          ' offset to start sector LBA
fc72c     fb03a1da                   rdlong  vol_begin,        bufad         ' read
                     '+-----------------------------------------------------------------------------+
                     '+ Calculate the partition size in sectors                                     +
                     '+     ptn_size = #sectors in ptn0 $1BE+$0C[4] (reversed & not long aligned!!!)+
                     '+-----------------------------------------------------------------------------+
fc730     f107b404                   add     bufad,            #($0C-$08)    ' offset to PTN0 size
fc734     fb03abda                   rdlong  ptn_size,         bufad         ' read
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read VOL (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc738     f603afd0 ._readVOL       mov     _blocknr,         vol_begin     ' VOL SECTOR#
fc73c     fdb001fc                 call    #@_readSECTOR                   ' read sector
fc740     fd639a31                 skip    skiprun                         ' skips next instr if #1
fc744     fdb00170                 call    #@_validateCSUM                 ' valid -> load & run
                     '+-----------------------------------------------------------------------------+
                     ' Validate VOL...                                                              +
                     '       verify  +$00B[2] = 512   = #Bytes/Sector                               +
                     '       calc    +$00D[1] =       = #Sectors/Cluster 64?    --> clustersh       +
                     '       calc    +$00E[2]         = #ResvSectors            --> PTN0RESV        +
                     '       verify  +$010[1] = 2     = #NoOfFATs                   PTN0NFATS       +
                     '       ???     +$020[4]         = #Sectors/PTN            --> =ptn_size?      +
                     '       calc    +$024[4]         = #Sectors/FAT            --> PTN0SECFAT      +
                     '       calc    +$030[2]         = #FileSystemInfo         --> fsi_begin       +
                     '       verify  +$1FE[2] = $55AA = signature                                   +
                     '                                                                              +
                     '       calc    fat_begin = vol_begin + PTN0RESV                               +
                     '       calc    dir_begin = fat_begin + (PTN0SECFAT * 2)                       +
                     '+-----------------------------------------------------------------------------+
fc748     f603b5d6 ._validateVOL     mov     bufad,            _bufad        ' VOL hub locn
                   
fc74c     f107b40b                   add     bufad,            #$0B          '\ offset to bytes/sector
fc750     fae38bda                   rdword  reply,            bufad         '| read
fc754     ff000001                   cmp     reply,            ##512     wz  '|
fc758     f20f8a00 
fc75c     5d900098           if_ne   jmp     #@_fail_vol                     '/
                   
fc760     f107b402                   add     bufad,            #($0D-$0B)    ' offset to #Sectors/Cluster
fc764     fac39fda                   rdbyte  clustersh,        bufad         '\ calc as shift left 'n'
fc768     f7839fcf                   encod   clustersh                       '/
                   
fc76c     f107b401                   add     bufad,            #($0E-$0D)    ' offset to #ResvSectors
fc770     fae3a5da                   rdword  fat_begin,        bufad         '\ start of FAT table
fc774     f103a5d0                   add     fat_begin,        vol_begin     '/
                   
fc778     f107b402                   add     bufad,            #($10-$0E)    '\ offset to #nooffats
fc77c     fac38bda                   rdbyte  reply,            bufad         '| read
fc780     f20f8a02                   cmp     reply,            #2        wz  '| $02   PTN0NFATS
fc784     5d900070           if_ne   jmp     #@_fail_vol                     '/
                   
fc788     f107b414                   add     bufad,            #($24-$10)    ' offset to #Sectors/FAT
fc78c     fb03a7da                   rdlong  dir_begin,        bufad         '\ start of DATA (DIR table)
fc790     f067a601                   shl     dir_begin,        #1            '| *2
fc794     f103a7d2                   add     dir_begin,        fat_begin     '/ +base
                   
fc798     f107b40c                   add     bufad,            #($30-$24)    ' offset to #FileSystemSector
fc79c     fae3a3da                   rdword  fsi_begin,        bufad         ' read
fc7a0     f103a3d0                   add     fsi_begin,        vol_begin     ' add vol_begin
                   
fc7a4     f107b5ce                   add     bufad,            #($1FE-$30)   ' offset to $55AA signature
fc7a8     fae38bda                   rdword  reply,            bufad         ' read
fc7ac     f20b8bcc                   cmp     reply,            _AA55     wz  ' we read it reversed!                        ] {{ tweek }}
fc7b0     5d900044           if_ne   jmp     #@_fail_vol                     '
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read FSI (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc7b4     f603afd1 ._readFSI       mov     _blocknr,         fsi_begin     ' FSI SECTOR#
fc7b8     fdb00180                 call    #@_readSECTOR                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     '+ Validate FSI...                                                             +
                     '+      verify  +$000[4] = "RRaA" = signature                                  +
                     '+      verify  +$1E4[4] = "rrAa" = signature                                  +
                     '+      verify  +$1FE[2] = $55AA  = signature                                  +
                     '+-----------------------------------------------------------------------------+
fc7bc     f603b5d6 ._validateFSI     mov     bufad,            _bufad        ' FSI hub locn
fc7c0     fb038bda                   rdlong  reply,             bufad        ' read
fc7c4     ff20b0a9                   cmp     reply,          ##$41615252 wz  ' "RRaA" signature (reversed)
fc7c8     f20f8a52 
fc7cc     f107b5e4                   add     bufad,            #$1E4         ' offset to signature
fc7d0     fb038bda                   rdlong  reply,            bufad         ' read
fc7d4     af30a0b9           if_e    cmp     reply,          ##$61417272 wz  ' "rrAa" signature (reversed)
fc7d8     a20f8a72 
fc7dc     f107b41a                   add     bufad,            #($1FE-$1E4)  ' offset to signature
fc7e0     fae38bda                   rdword  reply,            bufad         ' read
fc7e4     a20b8bcc           if_e    cmp     reply,            _AA55     wz  ' we read it reversed!                        ] {{ tweek }}
fc7e8     5d90000c           if_ne   jmp     #@_fail_fsi                     '
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read FAT (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc7ec     f603afd2 ._readFAT       mov     _blocknr,         fat_begin     ' FAT SECTOR#
fc7f0     fdb00148                 call    #@_readSECTOR                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     '+ Validate FAT...                                                             +
                     '+       nothing to validate                                                   +
                     '+-----------------------------------------------------------------------------+
fc7f4     0d6c1e6f         _RET_   MODZ    _set                      wz    ' "Z" = success
                   '+=============================================================================+
fc7f8              _fail_pullup
fc7f8              _fail00
fc7f8              _fail98
fc7f8              _fail08
fc7f8              _fail55
fc7f8              _fail41
fc7f8              _fail58
fc7f8              _fail16
fc7f8              _fail09
fc7f8              _fail10
fc7f8              _fail_mbr
fc7f8              _fail_vol
fc7f8              _fail_fsi
fc7f8     0d7de06f         _RET_   MODCZ   _set,_clr                   wcz ' C & NZ = failed                               ] --tweek2--
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read DIR (n Sectors):  Search for "<_fname/_fname2>"                        +
                   '+-----------------------------------------------------------------------------+
fc7fc     ff27a7a1 _readDIR        mov     fname,            ##_fname1a    ' copy _fname1 -> fname
fc800     f607b85f 
fc804     ff19282f                 mov     fname+1,          ##_fname1b    '
fc808     f607bb54 
fc80c     ff002c24                 mov     fname+2,          ##_fname1c    '
fc810     f607bd42 
fc814     fdb00014                 call    #@_searchDIR                    ' search dir for <fname>
fc818     ad64002d         if_e    RET                                     ' return "Z" = found
                   
fc81c     ff002ca4                 mov     fname+2,          ##_fname2c    ' new fname ext
fc820     f607bd42 
fc824     fdb00004                 call    #@_searchDIR                    ' search dir for <fname2>
fc828     fd64002d                 RET                                     ' return "Z" = found, else "NZ"
                   '+=============================================================================+
                   
                    '+-------[ SD: Search Root Directory for <_fname> entry ]----------------------+ <--- SD: search root directory --->
                   '+ On Entry:                                                                   +
                   '+      fname[3]:       filename[11] 8+3 without "."                           +
                   '+ Call Format:                                                                +
                   '+              CALL    #@_searchDIR                    '                      + < call: search root directory >
                   '+ On Return:                                                                  +
                   '+              "Z"  if <file> found, and sets                                 +
                   '+                     dat_begin = first native sector of file's data          +
                   '+                     _sectors  = file size in bytes                          +
                   '+             "NZ"  if <file> not found / error                               +
                   '+-----------------------------------------------------------------------------+
fc82c     ff007fff _searchDIR      and     fname+2,          ##$00FFFFFF   ' 12th char must be $00
fc830     f507bdff 
fc834     f603afd3                 mov     _blocknr,         dir_begin     ' DIR SECTOR#
fc838     f9c3b1cf                 decod   _sectors,         clustersh     ' max sectors to scan (1 cluster)
fc83c     fdb000fc .search_next    call    #@_readSECTOR                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     '+ Walk Directory: (read DIR sectors)                                          +
                     '+ 16 x 32byte DIR(fname) entries per DIR sector                               +
                     '+              +$00[1] = $00 = empty                                          +
                     '+                     => $80 = deleted file                                   +
                     '+      search  +$00[11] = 8.3 filename                                        +
                     '+      verify  +$0B[1]  = FileAttrib                 AND $D8,check $00        +
                     '+         $01=read,02=hidden,04=system,08=volume,0F=longfile,10=dir,20=archive+
                     '+      calc    +$14[2]  = FAT32: 1st cluster# HI     -\-> cluster             +
                     '+      calc    +$1A[2]  = FAT32: 1st cluster# LO     -/                       +
                     '+      calc    +$1C[4]  = FAT32: FileSize in bytes   --> file_size            +
                     '+      calc    dat_begin = dir_begin + ((cluster-2)<<6)                       +
                     '+-----------------------------------------------------------------------------+
                     ' scan dir sector for files...
fc840     f607b210 .walk_dir         mov     _entries,         #16           ' 16*32byte file entries
fc844     f603b5d6                   mov     bufad,            _bufad        ' dir hub locn
                     ' scan this sector for filename entry...
fc848     fb0b8bda .scan             rdlong  reply,            bufad     wz  '\ check this entry, $0=empty                 ] {{ tweek }}
fc84c     5d900004           if_ne   jmp     #.check                         '|  n:
fc850     0d6c006f         _RET_   MODZ      _clr                        wz  '/ return "NZ" = not found
                   
fc854     f20b8bdc .check            cmp     reply,            fname     wz  '| check fname...
fc858     f107b404                   add     bufad,            #4            '|
fc85c     fb038bda                   rdlong  reply,            bufad         '|
fc860     a20b8bdd           if_e    cmp     reply,            fname+1   wz  '|
fc864     f107b404                   add     bufad,            #4            '|
fc868     fb038bda                   rdlong  reply,            bufad         '|
fc86c     ff6c7fff                   and     reply,            ##$D8FFFFFF   '|  check atts b7+6+4+3
fc870     f5078bff 
fc874     a20b8bde           if_e    cmp     reply,            fname+2   wz  '|
fc878     ad900010           if_e    jmp     #.found                         '/  found!
fc87c     f107b418                   add     bufad,            #(32-8)       ' next entry
fc880     fb6fb3f1                   djnz    _entries,         #.scan        ' "NZ" not found this sector
                     '+-----------------------------------------------------------------------------+
fc884     f107ae01                 add     _blocknr,         #1            ' next sector#
fc888     0b6fb1ec         _RET_   djnz    _sectors,         #.search_next ' return "NZ" = not found
                   
                     '+-----------------------------------------------------------------------------+
                     '+ set:         cluster  = +$14[2] +$1A[2]                                     +
                     '+              filesize = +$1C[4]                                             +
                     '+              sector   = ((cluster-2)<<clustersh)+base                       +
                     '+                       where clustersh=encod(sectors/cluster), base=dir_begin+
                     '+-----------------------------------------------------------------------------+
fc88c     f107b40c .found            add     bufad,            #($14-8)      ' ptr to 1st cluster hi
fc890     fae3a9da                   rdword  dat_begin,        bufad         ' read
fc894     f067a810                   shl     dat_begin,        #16           ' bytes 3&2
fc898     f107b406                   add     bufad,            #($1A-$14)    ' ptr to 1st cluster lo
fc89c     fae38bda                   rdword  reply,            bufad         ' read
fc8a0     f543a9c5                   or      dat_begin,        reply         ' bytes 3-0
                     ' convert to sector#
fc8a4     f187a802                   sub     dat_begin,        #2            '\ correct cluster addr(-2)
fc8a8     f063a9cf                   shl     dat_begin,        clustersh     '| convert to sector <<6?
fc8ac     f103a9d3                   add     dat_begin,        dir_begin     '/ +base
                     ' read filesize(bytes)
fc8b0     f107b402                   add     bufad,            #($1C-$1A)    '\ _sectors <-- filesize
fc8b4     0b03b1da           _RET_   rdlong  _sectors,         bufad         '/ return "Z" = found
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Validate MBR/VOL CSUM $080-$17F="Prop". If valid, copy to Cog & Run         +
                   '+-----------------------------------------------------------------------------+
fc8b8     f607b57c _validateCSUM   mov     bufad,            #$17C         ' check long at $17C
fc8bc     fb038bda                 rdlong  reply,            bufad         '
fc8c0     ff3837b9                 cmp     reply,            ##_csum   wz  ' ="Prop"?
fc8c4     f20f8a50 
fc8c8     ad900048         if_e    jmp     #@_success80                    ' y: go load it
fc8cc     ff2837b9                 cmp     reply,            ##_csum2  wz  ' ="ProP"? sector/size?
fc8d0     f20f8a50 
fc8d4     5d64002d         if_ne   RET                                     ' return "NZ" = not found
                   '               ----------------------------------------
fc8d8     f607b574                 mov     bufad,            #$174         ' get sector start
fc8dc     fb03a9da                 rdlong  dat_begin,        bufad         '
fc8e0     f607b578                 mov     bufad,            #$178         ' get length(bytes)
fc8e4     fb03b1da                 rdlong  _sectors,         bufad         ' simulate file found
                   '                                                       ' fall thru to _readFILE
                   
                   '+-------[ SD: Read File ]-----------------------------------------------------+ <--- SD: load/run file --->
                   '+ On Entry:                                                                   +
                   '+      dat_begin = first native sector of file's data                         +
                   '+      _sectors  = file size in bytes                                         +
                   '+ Call Format:                                                                +
                   '+              CALL    #@_readFILE                     '                      + < call: load/run file >
                   '+ On Return:                                                                  +
                   '+      "NZ" if error, else does not return                                    +
                   '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read FILE (n Sectors):  File "<_fname/_fname2>"                             +
                   '+-----------------------------------------------------------------------------+
fc8e8     f603afd4 _readFILE       mov     _blocknr,         dat_begin     ' DAT SECTOR#
                   ' convert _sectors = file_size (bytes) into sectors to read
fc8ec     ff0003e0                 fle     _sectors,         ##max_size    ' limit max size to load
fc8f0     f327b000 
fc8f4     f107b1ff                 add     _sectors,         #511          ' +sector if extra bytes
fc8f8     f047b009                 shr     _sectors,         #9            ' sectors=file_size/512
                   ' load file's data - multiple sector(s)
fc8fc     fdb0003c                 call    #@_readSECTOR                   ' read sector
fc900     fb67b002                 djz     _sectors,         #.done
fc904     fdb00028 .nextsector     call    #@_readnxtSECTOR                ' read sector(s)
fc908     fb6fb1fe                 djnz    _sectors,         #.nextsector
fc90c     f20f9a01 .done           cmp     skiprun,          #1        wz  ' skip running?
fc910     ad64002d         if_e    RET                                     ' return "Z" = successful load
                                                                           ' else fall thru & run
                   '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                           ' <-- NZ: load Cog 496 longs & jmp #$000        \ {{ tweek }}
fc914              _success80                                              ' <-- Z:  load cog 128 longs & jmp #$020        |
fc914     fdb00148                 call    #@_releaseDO                    ' /CS=1, send CLKs, tristate CS/CK/DI/DO        |
fc918     56078bef         if_ne   mov     reply,            #cog_len-1    ' set to copy whole cog (496 longs)             |
fc91c     a6078a7f         if_e    mov     reply,            #cog_len80-1  ' set to copy 512 bytes (128 longs)             |
fc920     fd638a28                 setq    reply                           ' length -1                                     |
fc924     fb0001df                 rdlong  cog_start0,       _hubdata      ' copy loaded code into cog                     |
fc928     5d800000         if_ne   jmp     #$0                             ' NZ: execute loaded cog code                   |
fc92c     fd800020                 jmp     #$020                           ' Z:  execute loaded cog code from $080+        /
                   '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                   
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read Sector:                                                                +
                   '+-----------------------------------------------------------------------------+
fc930     f107ae01 _readnxtSECTOR  add     _blocknr,         #1            ' next sector#
fc934     ff000001 _readnxtSLOT    add     _bufad,           ##512         ' next data slot
fc938     f107ac00 
                   
fc93c     f603b7d7 _readSECTOR     mov     blocknr,          _blocknr      ' sector#
fc940     f603b5d6                 mov     bufad,            _bufad        ' where to store data
                   '+-----------------------------------------------------------------------------+
                   '+ Read Block/Sector:  (512 bytes)                                             +
                   '+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
                   '+-----------------------------------------------------------------------------+
fc944     ff000001 .Command17      mov     bytescnt,         ##512         ' read block (no. bytes)
fc948     f6079000 
fc94c     f6078051                 mov     cmdout,           #CMD17        '
fc950     f60383db                 mov     cmdpar,           blocknr       '
fc954     f06383ce                 shl     cmdpar,           blocksh       ' <<0 or <<9
                   '+-----------------------------------------------------------------------------+
fc958     fdb0000c                 call    #@_readBLOCK                    ' read 512 bytes
                   '+-----------------------------------------------------------------------------+
fc95c     fd64002d                 RET                                     ' "Z"=success, "NZ"=failed
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read Block/Sector:  (512 bytes)                                             +
                   '+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
                   '+-----------------------------------------------------------------------------+
fc960     f6079010 _readREG        mov     bytescnt,         #16           ' CMD9,10: CSD,CID register
fc964     f6078200                 mov     cmdpar,           #0            '        PAR=$0,      16 bytes
fc968              _readBLOCK                                              ' CMD17: PAR=sector, 512 bytes
fc968     fd63961a                 getct   timeout                         '\ set timeout for cmd9,10,17
fc96c     ff00e4e1                 add     timeout,          ##delay1s     '/
fc970     f1079780 
                   '+-----------------------------------------------------------------------------+
fc974     fdb00030                 call    #@_cmdRZtoken     ' /CS=0, send cmd, recv R1, /CS=0(ena)
fc978     5d64002d         if_nz   RET                                     '<>$00=error="NZ"=failed                        ] --tweek2--
                   '+-----------------------------------------------------------------------------+
fc97c     fdb00064                 call    #@_getreply                     ' n*$FF+$FE
fc980     f20f8afe                 cmp     reply,            #$FE      wz  ' $FE=valid Data Token
fc984     5d64002d         if_nz   RET                                     '<>$FE=error="NZ"=failed                        ] --tweek2--
                   '+-----------------------------------------------------------------------------+
fc988     fdb0009c .readbyte       call    #@_recvbyte                     ' read data byte
fc98c     fc438bda                 wrbyte  reply,            bufad         ' save byte
fc990     f107b401                 add     bufad,            #1            ' bufad++
fc994     fb6f91fc                 djnz    bytescnt,         #.readbyte    ' byte--
fc998     fdb0008c                 call    #@_recvbyte                     ' read CRC16 1/2
fc99c     fdb00088                 call    #@_recvbyte                     ' read CRC16 2/2
                   ' NOTE: CRC16 not checked - do we want to do this?                                         ??????????
                   ''              outl    #sd_ck                          ' CLK=0 (idle)          already=0
fc9a0     fd647849                 outh    #sd_cs                          ' /CS=1 (disable)
fc9a4     0d6c1e6f         _RET_   MODZ    _set                        wz  ' "Z" = success
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SEND: CMDx, PARx, CRCx, GET REPLY                                      +
                   '+-----------------------------------------------------------------------------+
fc9a8              _cmdRZA41                                               ' CMD55:       R1 response
fc9a8              _cmdRZtoken                                             ' CMD9,10,17,24: R1+$FE response
fc9a8     f6078801                 mov     cmdtype,          #1            ' returns w /CS=0(ena)
fc9ac     fd900004                 jmp     #@_cmdxx                        '
fc9b0              _cmdR1R3                                                ' CMD58:    R1+R3 response
fc9b0              _cmdR1R7                                                ' CMD8:     R1+R7 response
fc9b0              _cmdR1                                                  ' CMD0,A41,16: R1 response
fc9b0     f6078800                 mov     cmdtype,          #0            ' returns w /CS=1(disabled)
fc9b4              _cmdxx                                                  '
                   '+-----------------------------------------------------------------------------+
fc9b4     fd647848                 outl    #sd_cs                          ' /CS=0 (enable)
                   '+-----------------------------------------------------------------------------+
fc9b8     fdb0006c                 call    #@_sendFF                       ' send $FF byte first
fc9bc     f6038fc0                 mov     dataout,          cmdout        ' CMD
fc9c0     fdb00068                 call    #@_sendbyte                     ' send cmd byte
fc9c4     f6038fc1                 mov     dataout,          cmdpar        ' Parameter
fc9c8     fdb00054                 call    #@_sendlong                     ' send 4 bytes (MSB first)
fc9cc     f6038fc2                 mov     dataout,          cmdcrc        ' CRC
fc9d0     fdb00058                 call    #@_sendbyte                     ' send crc byte
                   '+-----------------------------------------------------------------------------+
fc9d4     fdb0000c                 call    #@_getreply                     ' recv R1/R1+R3/R1+R7/RZ..+Token
                   '+-----------------------------------------------------------------------------+
                   ''              outl    #sd_ck                          ' CLK=0 (idle)           already=0
                   
fc9d8     fd638831                 skip    cmdtype                         '\ skips next instr if #1
fc9dc     fd647849                 outh    #sd_cs                          '| /CS=1(disable) if reqd
fc9e0     fd64002d               RET                                       '/ else /CS=0 cmdRZA41/cmdRZtoken
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      READ REPLY: R1/R1+R3/R1+R7/R1+token                                    +
                   '+-----------------------------------------------------------------------------+
fc9e4     fdb00040 _getreply       call    #@_recvbyte                     ' recv R1 byte
fc9e8     f20f8aff                 cmp     reply,            #$FF      wz  ' reply=$FF=busy ?
fc9ec     5d900010         if_nz   jmp     #.doneR1                        ' n:
                   
                   ' timeout set in CMD0(for CMD0,8,55,A41,58,16) and CMD9,10,17(readblock)
fc9f0     fd638c1a                 getct   replyR1                         '\ timeout ?
fc9f4     f2b397c6                 cmpm    timeout,          replyR1   wc  '| c if timeout < replyR1                       \ --tweek4--
fc9f8     3d9fffe8         if_nc   jmp     #@_getreply                     '| n: try again                                 /
fc9fc     0d7de06f         _RET_   MODCZ   _set,_clr                   wcz '/ timeout C & NZ = fail                        ] --tweek2--
                   '+=============================================================================+
fca00     f6038dc5 .doneR1         mov     replyR1,          reply         ' save R1/Token reply
                   '+-----------------------------------------------------------------------------+
fca04     f20f8048                 cmp     cmdout,           #CMD8     wz
fca08     520f807a         if_nz   cmp     cmdout,           #CMD58    wz
fca0c     5d900004         if_nz   jmp     #.end                           ' ret if not CMD8/CMD58
                   '+-----------------------------------------------------------------------------+
fca10     fdb00008                 call    #@_recvlong                     ' R7=CMD8=volts/R3=CMD58=OCR
                   '+-----------------------------------------------------------------------------+
fca14              .end                                                    '\ returns with...
                                                                           '| nc+z  replyR1=$00(success)
fca14     f7cf8c01                 test    replyR1,          #1        wz  '| nc+nz replyR1=$01(idle)
fca18     02978c01         _RET_   cmpr    replyR1,          #$01      wc  '/  c    replyR1>$01(error)
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SD SPI Send/Recv Routines... (write/read byte/long simultaneously)     +
                   '+              /CS=0 & CLK=0 on both entry and exit                           +
                   '+-----------------------------------------------------------------------------+
fca1c     f6678e01 _recvlong       neg     dataout,          #1            ' call here to Recv a Long (+send 1's)
fca20     f6079220 _sendlong       mov     bitscnt,          #32           ' call here to Send a Long (long=32bits)
fca24     fd90000c                 jmp     #@_sendrecv                     '
fca28              _sendFF                                                 ' call here to Send $FF Byte
fca28     f6678e01 _recvbyte       neg     dataout,          #1            ' call here to Recv a Byte (+send 1's)
fca2c     f0278e18 _sendbyte       rol     dataout,          #24           ' call here to Send a Byte (msbit first)
fca30     f6079208                 mov     bitscnt,          #8            '                          (byte=8bits)
fca34     f6078a00 _sendrecv       mov     reply,            #0            ' clear reply
                   ' 8+15 low/high clk cycles (8.7MHz@200MHz, 1.3MHz@30MHz)
fca38     f0378e01 .nextbit        rol     dataout,          #1        wc  ' \ prepare output bit (DI=0/1)..
fca3c     fd647a48                 outl    #sd_ck                          ' | CLK=0  (already 0 first time)
fca40     fd64764a                 outc    #sd_di                          ' / write output bit: output on CLK falling edge
fca44     fd64041f                 waitx   #2                              ' |   setup time to be safe
fca48     fd647a49                 outh    #sd_ck                          ' \ CLK=1
fca4c     fd64061f                 waitx   #3                              ' |   setup time to be safe
fca50     fd747440                 testp   #sd_do                      wc  ' | read input bit:   sample on CLK rising edge
fca54     f0a78a01                 rcl     reply,            #1            ' / accum DO input bits
fca58     fb6f93f7                 djnz    bitscnt,          #.nextbit     '   8/32 bits?
fca5c     0d647a48         _RET_   outl    #sd_ck                          ' CLK=0 on exit
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+                        \ {{ tweek }}
                   '+      /CS=1, Release SD Card DO pin, tristate SD CS/CK/DI/DO                 +                        |
                   '+-----------------------------------------------------------------------------+                        |
fca60     fd647849 _releaseDO      outh    #sd_cs                          ' /CS=1                                         |
fca64     fdbfffc0                 call    #@_sendFF                       ' 8 CLKs                                        |
fca68     ff1e0000                 andn    dirb,             ##($F<<26)    ' tristate CS/CK/DI/DO                          |
fca6c     f527f600 
fca70     fd7c002d                 ret                                 wcz ' restore flags                                 |
                   '+=============================================================================+                        /
fca74     00000000 spare           long    0                               ' keep here to make monitor/debugger compile to same location as P2-ES
                   
                   
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   
                   '' +--------------------------------------------------------------------------+
                   '' | Cluso's LMM_SerialDebugger for P2    (c)2013-2018 "Cluso99" (Ray Rodrick)|
                   '' +--------------------------------------------------------------------------+
                   '' RR20180512  v133i    LSD_v131i
                   
                   ''============================[ CON ]============================================================
                   CON
                   ''-----------------------------------------------------------------------------------------------
                   ''              LMM DEBUGGER - SUPPORTED COMMANDS
                   ''-----------------------------------------------------------------------------------------------
                   ''  xxxxxx : xx xx xx xx ... <cr>  DOWNLOAD:  to cog/lut/hub {addr1} following {byte(s)}
                   ''  xxxxxx - [xxxxxx] [L] <cr>     LIST:      from cog/lut/hub {addr1} to < {addr2}, L=longs
                   ''  xxxxxx G <cr>                  GOTO:      to cog/lut/hub {addr1}
                   ''  Q <cr>                         QUIT:      Quit Rom Monitor and return to the User Program
                   ''  Rffffffffxxx<cr>               RUN:       Run file from SD (case sensitive)
                   ''  <esc><cr>                      TAQOZ:     goto TAQOZ
                   ''-----------------------------------------------------------------------------------------------
                   ''              LMM DEBUGGER - CALL Modes...(not all modes supported)
                   ''-----------------------------------------------------------------------------------------------
                     _MODE         = $F << 5                       ' mode bits defining the call b8..b5 (b4..b0 are modifier options)
                     _SHIFT        = 5                             ' shr # to extract mode bits
                     _HEX_         = 2 << 5                        ' hex...
                       _REV_               = 1 << 4                '   - reverse byte order
                       _SP                 = 1 << 3                '   - space between hex output pairs
                      '_DIGITS             = 7..0 where 8->0       '   - no. of digits to display
                     _LIST         = 3 << 5                        ' LIST memory line (1/4 longs) from cog/hub
                       _ADDR2              = 1 << 4                ' 1= use lmm_p2 as to-address
                       _LONG_              = 1 << 1                ' 1=display longs xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
                     _TXSTRING     = 4 << 5                        ' tx string (nul terminated) from hub
                     _RXSTRING     = 5 << 5                        ' rx string
                       _ECHO_              = 1 << 4                '    - echo char
                       _PROMPT             = 1 << 3                '    - prompt (lmm_x)
                       _ADDR               = 1 << 2                '    - addr of string buffer supplied
                       _NOLF               = 1 << 1                '    - strip <lf>
                     _MONITOR      = 7 << 5                        ' goto rom monitor
                   '------------------------------------------------------------------------------------------------
                   
                   
                   DAT
                   ''################################################################################################
                   ''##    LMM Monitor - HUBEXEC code...                                                           ##
                   ''################################################################################################
fca78                              orgh
                   
                   ''-----------------------------------------------------------------------------------------------
                   ''      RESET BOOTER SERIAL INTERRUPTS & AUTOBAUD - KEEP SMART UART RUNNING
                   ''-----------------------------------------------------------------------------------------------
fca78     fd640025 _reset_booter   setint1 #0                              ' disable int1
fca7c     f527f403                 andn    dira,#3                         ' reset smart pins on P0 & P1
fca80     fc0c0001                 wrpin   #0,#rx_ths                      ' clear P1 rx_ths mode
fca84     0c0c0000         _RET_   wrpin   #0,#rx_tne                      ' clear P0 rx_tne mode
                   ''===============================================================================================
                   
                   
                   ''-------[ Start Monitor ]----------------------------------------------------- <--- start monitor --->
fca88     fdbfffec _Start_Monitor  call    #@_reset_booter                 ' reset the booters interrupts and autobaud
                   
fca8c     ff0007e0 _Enter_Monitor  mov       lmm_bufad,      ##_HUBBUF     ' addr of hub buffer (_HubRxString)
fca90     f607de00 
                   
fca94     f607c00d                 mov     lmm_x,            #_CR_         ' we have to prime send buffer empty flag,
fca98     fc27c03e                 wypin   lmm_x,            #tx_pin       ' ... so send <cr> to tx pin
                   ''---------------------------------------------------------------------------------------------------
                   ' this code displays a version string (it's not required)
fca9c     fdb000fc _Redo_Monitor   call      #@_HubTxStrVer                 ' send version string
                   ''---------------------------------------------------------------------------------------------------
                   ' call the Monitor (because we need a return address set)
fcaa0     fdb002d4 .monitor      call      #@_HubMonitor                   ' to the monitor/debugger
fcaa4     fd9ffff8               jmp       #.monitor                       ' loop back in case of "Q<cr>"
                   ''===============================================================================================
                   
                   
                   ''-------[ Serial Routines (uses SmartPins) ]---------------------------------- <--- serial initialise --->
                   ''_SerialInit
                   '' On Entry:
                   ''      lmm_x     = _bitper                             ' tx & rx bit period + #(bits-1)
                   ''      lmm_bufad = 'bufad'                             ' hubbuf addr for use by _HubRxString
                   '' Call Format:
                   ''            CALL      #@_SerialAddr                   ' use default _HUBBUF   < call: serial initilise>
                   ''            CALL      #@_SerialBaud                   ' use default _bitper   < call: serial initilise>
                   ''            CALL      #@_SerialInit                   ' provide addr & baud   < call: serial initilise>
                   '' On Return:
                   ''      lmm_x = #CR                                     ' (changed)
                   ''--------------------------------------------------------------------------------------------------
fcaa8     ff0007e0 _SerialAddr     mov     lmm_bufad,        ##_HUBBUF     ' addr of hub buffer (_HubRxString)
fcaac     f607de00 
fcab0     ff008200 _SerialBaud     mov     lmm_x,            ##_bitper     ' 115200 baud, 8 bits
fcab4     f607c007 
fcab8     ff800000 _SerialInit     wrpin   ##_txmode,        #tx_pin       ' set asynchronous tx mode in smart pin tx
fcabc     fc0cf83e 
fcac0     fc17c03e                 wxpin   lmm_x,            #tx_pin       ' set tx bit period + #(bits-1)
fcac4     fd647c41                 dirh    #tx_pin                         ' enable smart pin tx
                   
fcac8     ff800000                 wrpin   ##_rxmode,        #rx_pin       ' set asynchronous rx mode in smart pin rx
fcacc     fc0c7c3f 
fcad0     fc17c03f                 wxpin   lmm_x,            #rx_pin       ' set rx bit period + #(bits-1)
fcad4     fd647e41                 dirh    #rx_pin                         ' enable smart pin rx
                   
fcad8     f607c00d                 mov     lmm_x,            #_CR_         ' we have to prime send buffer empty flag,
fcadc     fc27c03e                 wypin   lmm_x,            #tx_pin       ' ... so send <cr> to tx pin
fcae0     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Display Char(s) ]--------------------------------------------------- <--- display char(s) --->
                   ''_HubTx                                                '
                   '' On Entry:
                   ''      lmm_x = char(s)                                 ' char(s): up to 4 chars; B0 first; <nul> terminates
                   ''                                                      '            if =$0, tx one <nul>
                   '' Call Format:
                   ''            CALL      #@_HubTxCR                      ' preloads cr+lf        < call: display char(s)>
                   ''            CALL      #@_HubTxRev                     ' reverses lmm_x        < call: display char(s)>
                   ''            CALL      #@_HubTx                        '                       < call: display char(s)>
                   '' On Return:
                   ''      lmm_x = -same-                                  ' char(s):  (unchanged)
                   ''--------------------------------------------------------------------------------------------------
fcae4     ff068500 _HubTxCR        mov     lmm_x, ##(_CR_<<24+_LF_<<16)    ' <cr><lf> (gets reversed)
fcae8     f607c000 
fcaec     f9ffc01b _HubTxRev       movbyts lmm_x, #%%0123                  ' reversed
fcaf0     f603cbe0 _HubTx         MOV       lmm_w, lmm_x                   '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fcaf4     fd747c40 .send           testp   #tx_pin                 wc      ' wait for buffer empty on tx pin
fcaf8     3d9ffff8         if_nc   jmp     #.send                          '
fcafc     fc27c03e                 wypin   lmm_x, #tx_pin                  ' send byte (bits7:0) to tx pin
                   
fcb00     f04fc008                 shr     lmm_x, #8               wz      ' any more chars to send?
fcb04     5d9fffec         if_nz   jmp     #.send                          '> br back:  (nz = another char in lmm_x)
                   '               ----------------------------------------
fcb08     f603c1e5               MOV       lmm_x, lmm_w                    '                       < pop:  'x'    #0 >
fcb0c     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Rx: Receive a char ]------------------------------------------------ <--- receive char --->
                   ''_HubRx
                   '' On Entry:
                   ''      lmm_x = -anything-                              ' value:
                   '' Call Format:
                   ''             CALL     #@_HubRx                        '                       < call: receive char>
                   '' On Return:
                   ''      lmm_x = char                                    ' char:   input char
                   ''--------------------------------------------------------------------------------------------------
fcb10              _HubRx                                                  '                       <--- receive char --->
fcb10     fd747e40 .recv           testp   #rx_pin                 wc      ' char ready?
fcb14     3d9ffff8         if_nc   jmp     #.recv                          '
fcb18     fa8fc03f                 rdpin   lmm_x,            #rx_pin       ' recv byte (bits31:24) from rx pin
fcb1c     f047c018                 shr     lmm_x,            #24           ' shift rx bits
fcb20     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Display Hex ]------------------------------------------------------- <--- display hex --->
                   ''_HubHex                                               '
                   '' On Entry:
                   ''      lmm_f = _HEX_ [+options]                        ' mode:  #_HEX_[+_REV_][+_SP][+_ndigits]
                   ''                                                      '        'n' digits = 7..0 where 0 = 8 digits
                   ''      lmm_x = char(s)                                 ' char(s):
                   '' Call Format:
                   ''            CALL      #@_HubHexRev                    ' reverse lmm_x         < call: display hex >
                   ''            CALL      #@_HubHex8                      ' hex 8 digits          < call: display hex >
                   ''            CALL      #@_HubHex                       '                       < call: display hex >
                   '' On Return:
                   ''      lmm_f = -same-                                  ' mode:     (unchanged)
                   ''--------------------------------------------------------------------------------------------------
fcb24     f9ffc01b _HubHexRev      movbyts lmm_x, #%%0123                  ' reversed
fcb28     f607c240 _HubHex8        mov     lmm_f, #_HEX_+0                 ' 8 digits
fcb2c     f603cfe0 _HubHex       MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
fcb30     f603d3e4               MOV       lmm_hc, lmm_c                   '                       < push: 'c'    #1 >
                   '               ----------------------------------------
fcb34     f7cfc210                 test    lmm_f, #_REV_           wz      '  reverse mode?
fcb38     59ffc01b         if_nz   movbyts lmm_x, #%%0123                  '  y: reverse bytes
fcb3c     f603c9e1                 mov     lmm_c, lmm_f                    '\ CTR = ...
fcb40     f50fc807                 and     lmm_c, #7               wz      '|   ... 'n' digits ...
fcb44     a607c808         if_z    mov     lmm_c, #8                       '/   ... if 0, then 8
fcb48     f607ca08                 mov     lmm_w, #8                       '\ nibbles to...
fcb4c     f18bcbe4                 sub     lmm_w, lmm_c            wz      '|   ...     ...
fcb50     5067ca02         if_nz   shl     lmm_w, #2                       '|   ... *4  ...
fcb54     5023c1e5         if_nz   rol     lmm_x, lmm_w                    '/   ... discard
                   '               ----------------------------------------
fcb58     f027c004 .next           rol     lmm_x, #4                       '\  next nibble  ...
fcb5c     f603d1e0               MOV       lmm_hx2, lmm_x                  '|   ... save    ...    < push: 'x'    #2 >
fcb60     f507c00f                 and     lmm_x, #$0F                     '|   ... extract ...
fcb64     f547c030                 or      lmm_x, #"0"                     '|   ... convert ...
fcb68     f217c03a                 cmp     lmm_x, #":"             wc      '|   ...         ...
fcb6c     3107c007         if_nc   add     lmm_x, #("A"-"9"-1)             '/   ... now 0-9,A-F
fcb70     fdbfff7c               CALL      #@_HubTx                        '                       < call: display char(s)>
                   '               ----------------------------------------
fcb74     f7cfc208                 test    lmm_f, #_SP             wz      ' hex space mode?
fcb78     f7d7c801                 test    lmm_c, #1               wc      ' c if odd count
fcb7c     bd900008    if_z_or_nc   jmp     #.nospace                       '> br: (no space reqd)
fcb80     f607c020                 mov     lmm_x, #" "                     ' " "
fcb84     fdbfff68               CALL      #@_HubTx                        '                       < call: transmit char(s)>
                   '               ----------------------------------------
fcb88              .nospace
fcb88     f603c1e8               MOV       lmm_x, lmm_hx2                  '    ... restore ...    < pop:  'x'    #2 >
fcb8c     fb6fc9f2                 djnz    lmm_c, #.next                   '> CTR--
                   '               ----------------------------------------
fcb90     f603c9e9               MOV       lmm_c, lmm_hc                   '                       < pop:  'c'    #1 >
fcb94     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcb98     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Display String, <nul> terminated ]---------------------------------- <--- display string --->
                   ''_HubTxString                                          '
                   '' On Entry:
                   ''      lmm_p = 'addr'                                  ' addr:   string (hub ptr)
                   '' Call Format:
                   ''            CALL      #@_HubTxStrVer                  ' display version       < call: display string>
                   ''            CALL      #@_HubTxString                  '                       < call: display string>
                   '' On Return:
                   ''      lmm_p = 'addr' (next string)                    ' addr:   (hub ptr to next string)
                   ''--------------------------------------------------------------------------------------------------
fcb9c     ff0007e8 _HubTxStrVer  mov       lmm_p,  ##_str_vers             ' send version string, $00 terminated
fcba0     f607c414 
fcba4     f603cfe0 _HubTxString  MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fcba8     facbc1e2 .loop           rdbyte  lmm_x, lmm_p            wz      ' get char from string: nul?
fcbac     f107c401                 add     lmm_p, #1                       ' PTR++
fcbb0     ad900008         if_z    jmp     #.return                        '> br fwd:              (returns to calling program)
fcbb4     fdbfff38               CALL      #@_HubTx                        '                       < call: transmit char(s)>
fcbb8     fd9fffec                 jmp     #.loop                          '  br back
                   '               ----------------------------------------
fcbbc              .return
fcbbc     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcbc0     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ LIST a line(s) ]---------------------------------------------------- <--- LIST a line(s) --->
                   ''_HubList
                   '' On Entry:
                   ''      lmm_f   = #_LIST [+options]                     ' mode:         _LIST[+_ADDR2][+_LONG_]
                   ''      lmm_p   = 'addr'        (from)                  ' addr:    from cog addr / hub ptr
                   ''      lmm_p2  = 'addr2'       (to)    (optional)      ' addr2:   to   cog addr / hub ptr (if _ADDR2 specified)
                   '' Call Format:
                   ''             CALL     #@_HubListA2                    ' _LIST+_ADDR2          < call: LIST a line >
                   ''             CALL     #@_HubList                      '                       < call: LIST a line >
                   '' On Return:
                   ''      lmm_f   = same except _HDG off                  ' mode:    same except _HDG will be off
                   ''      lmm_p   = addr++        (from)                  ' addr:    next from cog addr / hub ptr
                   ''      lmm_p2  = addr2++/same  (to)                    ' addr2:   next to addr -OR- unchanged
                   ''---------------------------------------------------------------------------------------------------
fcbc4     f607c270 _HubListA2H     mov     lmm_f,  #_LIST+_ADDR2           ' list addr2
fcbc8     f603d5e0 _HubList      MOV       lmm_lx, lmm_x                   '\ save params
fcbcc     f603d7e1               MOV       lmm_lf, lmm_f                   '|
fcbd0     f603d9e2               MOV       lmm_lp, lmm_p                   '|
fcbd4     f603dbe2               MOV       lmm_lp2,lmm_p                   '|   orig {addr}
fcbd8     f603dde4               MOV       lmm_lc, lmm_c                   '/
fcbdc     f7cfc210                 test    lmm_f, #_ADDR2          wz      ' nz if {addr2} mode
fcbe0     a603c7e2         if_z    mov     lmm_p2, lmm_p                   ' n: replace {addr2} <-- {addr}
                   '               ----------------------------------------
                   ' ===LOOPS HERE FOR MULTIPLE LINES===
fcbe4              _HubListLoop
                   '               ----------------------------------------
                   ' ===DISPLAY LINE: ADDR===
fcbe4     f603c5ec               MOV       lmm_p, lmm_lp                   ' restore 'addr'
fcbe8     ff000001                 cmp     lmm_p, ##$3FF           wcz     ' z|c if =<$3FF = cog/lut mode?
fcbec     f21fc5ff 
                   ' hub:
fcbf0     1607c245         if_a    mov     lmm_f, #_HEX_+5                 ' set hex mode with 5 digits
                   ' cog:
fcbf4     e607c243         if_be   mov     lmm_f, #_HEX_+3                 ' set hex mode with 3 digits
fcbf8     ef000010         if_be   mov     lmm_x, ##(" "+" "<<8)           ' "  "
fcbfc     e607c020 
fcc00     edbffeec         if_be CALL      #@_HubTx                        '                       < call: transmit char(s) >
                   ' display address
fcc04     f603c1e2                 mov     lmm_x, lmm_p                    ' set cog/lut/hub address (for displaying)
fcc08     fdbfff20               CALL      #@_HubHex                       '                       < call: display hex >
fcc0c     ff000010                 mov     lmm_x, ##(":"+" "<<8)           ' ": "
fcc10     f607c03a 
fcc14     fdbffed8               CALL      #@_HubTx                        '                       < call: transmit char(s) >
                   '               ----------------------------------------
                   ' ===DISPLAY 4x HEX LONGS===
                   ' lmm_p = ptr to 1st long
fcc18     f7cfd602                 test    lmm_lf, #_LONG_         wz      ' long or byte mode
fcc1c     5607c240         if_nz   mov     lmm_f, #_HEX_+0                 ' set hex with 8(=0) digits
fcc20     a607c258         if_z    mov     lmm_f, #_HEX_+_REV_+_SP+0       ' set hex reversed space mode with 8(=0) digits
fcc24     f607c804                 mov     lmm_c, #4                       ' set 4 longs
                   ' read a long from cog/lut/hub into lmm_x pointed to by lmm_p and inc lmm_p
fcc28     fdb00308 .long4        CALL      #_RdLongCogHub                  '                       < call: read cog/hub long >
fcc2c     fdbffefc               CALL      #@_HubHex                       '                       < call: display hex>
fcc30     f607c020                 mov     lmm_x, #" "                     ' extra space
fcc34     fdbffeb8               CALL      #@_HubTx                        '                       < call: transmit char(s) >
fcc38     fb6fc9fb                 djnz    lmm_c, #.long4                  ' (4 longs)--
                   '               ----------------------------------------
                   ' ===DISPLAY ASCII===
fcc3c     f607c804                 mov     lmm_c, #4                       ' set 4 longs
fcc40     f603c5ec               MOV       lmm_p, lmm_lp                   ' restore {addr}
fcc44     ff000013                 mov     lmm_x, ##(" "+"'"<<8)           ' " '"
fcc48     f607c120 
fcc4c     fdbffea0               CALL      #@_HubTx                        '                       < call: transmit char(s) >
                   '               ------------------------
                   ' read a long from cog/lut/hub into lmm_x pointed to by lmm_p and inc lmm_p
fcc50     fdb002e0 .asciiloop    CALL      #_RdLongCogHub                  '                       < call: read cog/hub long >
fcc54     f7cfd602                 test    lmm_lf, #_LONG_         wz      ' long mode?
fcc58     59ffc01b         if_nz   movbyts lmm_x,  #%%0123                 ' y: reverse bytes
                   ' convert 4 bytes to visible
fcc5c     f607c204                 mov     lmm_f, #4                       ' (lmm_f as temp byte counter)
fcc60     f603cbe0 .convert        mov     lmm_w, lmm_x                    ' duplicate
fcc64     f527c0ff                 andn    lmm_x, #$FF                     ' clear   lower byte
fcc68     f507caff                 and     lmm_w, #$FF                     ' extract lower byte
fcc6c     f217ca20                 cmp     lmm_w, #" "             wc      ' c if <$20: invisible?
fcc70     c607ca2e         if_c    mov     lmm_w, #"."                     ' y: replace
fcc74     f217ca7f                 cmp     lmm_w, #$7F             wc      ' c if <$7F: visible?
fcc78     3607ca2e         if_nc   mov     lmm_w, #"."                     ' n: replace
fcc7c     f543c1e5                 or      lmm_x, lmm_w                    ' replace lower byte
fcc80     f007c008                 ror     lmm_x, #8                       ' next byte
fcc84     fb6fc3f6                 djnz    lmm_f, #.convert                ' (lmm_f as temp byte counter)
fcc88     fdbffe64               CALL      #@_HubTx                        ' 4 ascii bytes         < call: transmit char(s)>
fcc8c     fb6fc9f0                 djnz    lmm_c, #.asciiloop              ' (longs count)--
                   
fcc90     ff000506                 mov     lmm_x, ##("'"+_CR_<<8+_LF_<<16) ' "'"<cr><lf>
fcc94     f607c127 
fcc98     fdbffe54               CALL      #@_HubTx                        '                       < call: transmit char(s)>
fcc9c     f603d9e2               MOV       lmm_lp, lmm_p                   ' save new {addr}
                   '               ----------------------------------------
                   ' ===MULTIPLE LINES ?===
fcca0     f213c5e3                 cmp     lmm_p, lmm_p2           wc      ' c if addr < addr2
fcca4     cd9fff3c         if_b    jmp     #_HubListLoop                   ' n: another line
                   '               ----------------------------------------
                   ' calculate how far 'addr' advanced and advance 'addr2' by the same amount
fcca8     f183c7ed                 sub     lmm_p2,lmm_lp2                  ' {addr2} - orig  {addr}
fccac     f103c7e2                 add     lmm_p2,lmm_p                    '         + final {addr}
fccb0     f603dbe3                 mov     lmm_lp2, lmm_p2                 ' save new {addr2}
                   '               ----------------------------------------
fccb4     f603c1ea               MOV       lmm_x, lmm_lx                   '\ restore params
fccb8     f603c3eb               MOV       lmm_f, lmm_lf                   '|
                   ''            MOV       lmm_p, lmm_lp                   '| \(already done)
                   ''            MOV       lmm_p2,lmm_lp2                  '| /
fccbc     f603c9ee               MOV       lmm_c, lmm_lc                   '/
                   '               ----------------------------------------
fccc0     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Receive String ]---------------------------------------------------- <--- receive string --->
                   ''_HubRxString
                   '' On Entry:
                   ''      lmm_f = #_RXSTRING [+options]                   ' mode:   #_RXSTRING[+_ECHO_][+_PROMPT][+_ADDR][+_NOLF]
                   ''      lmm_x = char(s)                 (optional)      ' prompt: char(s)
                   ''      lmm_p = 'bufad'                 (optional)      ' addr:   input string (hub ptr)
                   ''      lmm_bufad = 'bufad'             (default)       ' addr:   input string (hub ptr)
                   '' Call Format:
                   ''            CALL      #@_HubRxStrMon                  ' presets lmm_x & lmm_f < call: receive string >
                   ''            CALL      #@_HubRxString                  '                       < call: receive string >
                   '' On Return:
                   ''      lmm_f = -same-                                  ' mode:   (unchanged)
                   ''      lmm_x = -same-                                  '
                   ''      lmm_p = 'addr'                                  ' addr:   input string (hub ptr)
                   ''      lmm_c = 'count'                                 ' count:  char(s) entered (incl <cr>, excl <nul>)
                   ''--------------------------------------------------------------------------------------------------
fccc4     f607c02a _HubRxStrMon    mov     lmm_x, #"*"                           ' prompt
fccc8     f607c2b8                 mov     lmm_f, #_RXSTRING+_ECHO_+_PROMPT      ' params
fcccc     f603cfe0 _HubRxString  MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fccd0     f7cfc208                 test    lmm_f, #_PROMPT         wz      ' prompt ?
fccd4     ad900004         if_z    jmp     #.noprompt                      ' n:
                   ' Display prompt char(s) in lmm_x
fccd8     fdbffe14               CALL      #@_HubTx                        '                       < call: transmit char(s) >
                   ' setup the hub string address ptr
fccdc     f7cfc204 .noprompt       test    lmm_f, #_ADDR           wz      ' {addr} supplied option ?
fcce0     a603c5ef         if_z    mov     lmm_p, lmm_bufad                ' n: use default hub buffer
                   ' receive char(s) terminated in <cr>
fcce4     f607c800                 mov     lmm_c, #0                       ' set char count=0
                   
fcce8     fdbffe24 .loop         CALL      #@_HubRx                        '                       < call: receive char >
fccec     f20fc00a                 cmp     lmm_x, #_LF_            wz      ' <lf> ?
fccf0     5d900008         if_nz   jmp     #.notlf                         ' n:
fccf4     f7cfc202                 test    lmm_f, #_NOLF           wz      ' strip <lf> ?
fccf8     5d9fffec         if_nz   jmp     #.loop                          ' y:
fccfc     f20fc008 .notlf          cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd00     a20fc800         if_z    cmp     lmm_c, #0               wz      ' start of input ?
fcd04     ad9fffe0         if_z    jmp     #.loop                          ' y: skip
fcd08     f217c84e                 cmp     lmm_c, #_HUBBUFSIZE-2   wc      ' c if < end-of-buf ?
fcd0c     320fc008         if_nc   cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd10     120fc00d    if_nc_and_nz cmp     lmm_x, #_CR_            wz      ' <cr> ?
fcd14     1d9fffd0    if_nc_and_nz jmp     #.loop                          ' j if buf full + not <bs> not <cr> (ignore)
fcd18     fc43c1e2                 wrbyte  lmm_x, lmm_p                    ' push input char to buf (don't inc ptr yet)
fcd1c     f7cfc210                 test    lmm_f, #_ECHO_          wz      ' echo?
fcd20     ad900020         if_z    jmp     #.noecho                        ' n:
fcd24     f20fc008                 cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd28     af000410         if_z    mov     lmm_x, ##(_BS_+" "<<8+_BS_<<16) ' y: echo <bs>" "<bs>
fcd2c     a607c008 
fcd30     fdbffdbc               CALL      #@_HubTx                '       < call: transmit char(s) >
fcd34     f20fc00d                 cmp     lmm_x, #_CR_            wz      ' <cr> ?
fcd38     a607c00a         if_z    mov     lmm_x, #_LF_                    ' y: follow <cr> with <lf>
fcd3c     adbffdb0         if_z  CALL      #@_HubTx                '
fcd40     fac3c1e2                 rdbyte  lmm_x, lmm_p                    ' restore input char
fcd44     f20fc008 .noecho         cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd48     a187c401         if_z    sub     lmm_p, #1                       ' y: PTR--
fcd4c     a187c801         if_z    sub     lmm_c, #1                       ' y: CTR--
fcd50     ad9fff94         if_z    jmp     #.loop                          ' y:
fcd54     f107c401 .notbs          add     lmm_p, #1                       ' PTR++
fcd58     f107c801                 add     lmm_c, #1                       ' CTR++
fcd5c     f20fc00d                 cmp     lmm_x, #_CR_            wz      ' <cr> ?
fcd60     5d9fff84         if_nz   jmp     #.loop                          ' n:
                   ' have a buffer with <cr> followed by <nul> terminated
fcd64     f607c000                 mov     lmm_x, #0                       '\ load $0 (nul)
fcd68     fc43c1e2                 wrbyte  lmm_x, lmm_p                    '/ push to buf
fcd6c     f183c5e4                 sub     lmm_p, lmm_c                    ' reset PTR to start of string
                   '               ----------------------------------------
fcd70     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcd74     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   
                   ''-------[ Monitor: DebugMonitor]---------------------------------------------- <--- monitor/debug --->
                   ''_HubMonitor
                   ''      lmm_bufad = 'bufad'                             ' hubbuf addr for use by _HubRxString
                   '' Call Format:                                         '
                   ''            CALL      #@_HubMonitor                   '                       < call: monitor/debug>
                   ''--------------------------------------------------------------------------------------------------
fcd78     fdbfff48 _HubMonitor   CALL      #@_HubRxStrMon                  '                       < call: recv string >
                   
                   ' get optionl 1st param: [xxxxxx]  hex/addr {addr} followed by 'cmd'
fcd7c     fdb001e8 .parse        CALL      #@_ParseHex                      '                      < call: parse hex >
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
                   ' check commands w/o {addr} first
fcd80     f20fca0d                 cmp     lmm_w, #_CR_            wz      ' <cr>?    repeat LIST
fcd84     ad900044         if_e    jmp     #@_Cmd_CR                       '
fcd88     f20fca1b                 cmp     lmm_w, #_TAQOZ_         wz      ' <esc>?   TAQOZ
fcd8c     ad90029c         if_e    jmp     #@_Enter_TAQOZ                  '
fcd90     f20fca4c                 cmp     lmm_w, #"L"             wz      ' "L" ?    Load a file, don't run
fcd94     520fca52         if_ne   cmp     lmm_w, #"R"             wz      ' "R" ?    Run  a file (Load & Run)
fcd98     ad9000b8         if_e    jmp     #@_Cmd_Run                      '
fcd9c     f20fca51                 cmp     lmm_w, #"Q"             wz      ' "Q" ?    QUIT
fcda0     ad7c002d         if_e    RET                             wcz     ' y: return to caller   <--- return to calling routine --->
                                   '---------------------------------------
                   ' check commands w optional {addr} before cmd char
fcda4     f20fca2d                 cmp     lmm_w, #"-"             wz      ' "-" ?    LIST
fcda8     ad900044         if_e    jmp     #@_Cmd_List                     '
fcdac     f20fca3a                 cmp     lmm_w, #":"             wz      ' ":" ?    Download
fcdb0     ad9000f0         if_e    jmp     #@_Download                     '
fcdb4     f20fca47                 cmp     lmm_w, #"G"             wz      ' "G" ?    GOSUB
fcdb8     ad900074         if_e    jmp     #@_Cmd_G                        '
                   '-------------------------------------------------------
fcdbc     ff000506 _Cmd_What       mov     lmm_x, ##("?"+_CR_<<8+_LF_<<16) ' unknown
fcdc0     f607c13f 
fcdc4     fdbffd28               CALL      #@_HubTx                        '
fcdc8     fd9fffac                 jmp     #@_HubMonitor                   '
                   '-------------------------------------------------------
fcdcc              _Cmd_CR       ' repeat previous LIST command
fcdcc     f603cbeb                 mov     lmm_w, lmm_lf                   ' check valid list saved
fcdd0     f507cbe0                 and     lmm_w, #_MODE                   '
fcdd4     f20fca60                 cmp     lmm_w, #_LIST           wz      '
fcdd8     5d9fffe0         if_ne   jmp     #@_Cmd_What                     ' invalid
fcddc     f603c3eb                 mov     lmm_f, lmm_lf                   '\ restore last saved list params
fcde0     f603c5ec                 mov     lmm_p, lmm_lp                   '|
fcde4     f603c7ed                 mov     lmm_p2, lmm_lp2                 '/
fcde8     fdbffddc               CALL      #@_HubList                      '
fcdec     fd9fff88                 jmp     #@_HubMonitor                   '
                   '-------------------------------------------------------
                   ' LIST: get optional 2nd param: [yyyyyy]  {addr2} optionally followed by "L" (L=long)
fcdf0              _Cmd_List
fcdf0     f603d9e0                 mov     lmm_lp, lmm_x                   ' save {addr}
fcdf4     f607da00                 mov     lmm_lp2, #0                     ' set  {addr2} =0
fcdf8     f217c804                 cmp     lmm_c, #4               wc      ' c if digitcount <4 ?
fcdfc     3427d814         if_nc   bith    lmm_lp,  #20                    ' $1_xxxxx trick forces hub :)
fce00     3427da14         if_nc   bith    lmm_lp2, #20                    ' $1_xxxxx trick forces hub :)
                                   '---------------------------------------
fce04     fdb00160               CALL      #@_ParseHex                     '                       < call: parse hex >
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
fce08     f20fc800                 cmp     lmm_c, #0               wz      ' {addr2} ?
fce0c     ad900004         if_z    jmp     #.list                          '
fce10     f543dbe0                 or      lmm_lp2, lmm_x                  ' save {addr2} keep b20
                                   '-------------------------------------------------------
                   '               lmm_lp='addr', lmm_lp2='addr2', lmm_lc='digitcount of param1
                                   '-------------------------------------------------------
fce14     f603c5ec .list           mov     lmm_p,  lmm_lp                  ' {addr}
fce18     f603c7ed                 mov     lmm_p2, lmm_lp2                 ' {addr2}
                                   '---------------------------------------
fce1c     f20fca4c                 cmp     lmm_w, #"L"             wz      ' "L" ?    LIST longs
fce20     a607c272         if_e    mov     lmm_f,  #_LIST+_ADDR2+_LONG_    ' list addr2 in longs
fce24     5607c270         if_ne   mov     lmm_f,  #_LIST+_ADDR2           ' list addr2 in bytes
fce28     fdbffd9c               CALL      #@_HubList                      '
fce2c     fd9fff48                 jmp     #@_HubMonitor                   '
                   '-------------------------------------------------------
fce30              _Cmd_G        ' xxxxxxG<cr>    GOSUB cog/lut/hub address
fce30     fd63ca2b               POP       lmm_w                           ' pop stack
fce34     ff0007e0                 cmp     lmm_x, ##$FC000         wz      ' is it a ROM reboot?
fce38     f20fc000 
fce3c     af80003a         if_z    waitx   ##delay1ms                      ' allow char to get out
fce40     ad66601f 
fce44     af880000         if_z    hubset  ##$1000_0000                    ' y: reboot h/w
fce48     ad640000 
fce4c     fd63c02d                 CALL    lmm_x                           ' call cog/lut/hub addr in lmm_x (not #lmm_x)
fce50     fd9fff24                 jmp     #@_HubMonitor                   '
                   '-------------------------------------------------------
fce54              _Cmd_Run      ' R<filename.xtn><cr>                     ' Run  filename "ffffffff.xxx" from SD
                   '             ' L<filename.xtn><cr>                     ' Load filename "ffffffff.xxx" from SD
                   
fce54     f603c3e5                 mov     lmm_f,  lmm_w                   ' save optional "L"
fce58     fdb0018c                 call    #@_ParseFname                   ' get filename..
fce5c     f603b9e0                 mov     fname,  lmm_x                   '
fce60     fdb00184                 call    #@_ParseFname                   '
fce64     f603bbe0                 mov     fname+1,lmm_x                   '
fce68     f20fca2e                 cmp     lmm_w,  #"."            wz      ' skipover "." ?
fce6c     a107c401         if_z    add     lmm_p,  #1                      '
fce70     fdb00174                 call    #@_ParseFname                   '
fce74     f603bde0                 mov     fname+2,lmm_x                   '
                   
fce78     f20fc252                 cmp     lmm_f, #"R"             wz      ' run?
fce7c     5d900008         if_ne   jmp     #.load                          '
fce80     fdbff6f4 .run            CALL    #@_Run_SDfile                   ' run  <filename> from SD
fce84     fd900004                 jmp     #.done                          '
fce88     fdbff704 .load           CALL    #@_LOAD_SDfile                  ' load <filename> from SD
                   
fce8c     af000506 .done   if_e    mov     lmm_x, ##("="+_CR_<<8+_LF_<<16) ' passed run
fce90     a607c13d 
fce94     5f000506         if_ne   mov     lmm_x, ##("!"+_CR_<<8+_LF_<<16) ' failed run!
fce98     5607c121 
fce9c     fdbffc50               CALL      #@_HubTx                        '
fcea0     fd9ffed4                 jmp     #@_HubMonitor
                   ''===============================================================================================
                   
                   
                   ''-------[ Download Command ]-------------------------------------------------- <--- download command --->
                   '' On Entry:
                   ''      '---------------------------------------------------------------
                   ''      ' lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                   ''      '---------------------------------------------------------------
                   ''      lmm_x   = 'addr(hex)'                           ' addr(hex):  download addr in cog/hub
                   ''      lmm_c   = 'count'                               ' count:  count of chars in 'addr' for cog/hub
                   ''      lmm_p   = 'addr'                                ' addr:   ptr to string (hub)
                   ''      lmm_p2  = ????                                  ' addr2:
                   '' Call Format:
                   ''             CALL     #@_Download                     '                       < call: download command >
                   '' On Return:
                   ''      ????
                   ''--------------------------------------------------------------------------------------------------
                   ''      [xx]xxx : xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx ['xxxxxxxxxxxxxxxx'] <cr>
                   ''--------------------------------------------------------------------------------------------------
fcea4     f603c7e0 _Download       mov     lmm_p2,           lmm_x         ' save download addr(hex)
fcea8     f217c804                 cmp     lmm_c,            #4        wc  ' c if <4 digits (cog/lut?)
fceac     3427c61f         if_nc   bith    lmm_p2,           #31           ' n: set 'hub'
fceb0     fdb000b4 .loop         CALL      #@_ParseHex                     ' get next hex value
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=value(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
fceb4     f20fc800                 cmp     lmm_c, #0                   wz  ' any input?
fceb8     ad9ffebc         if_z    jmp     #@_HubMonitor                   ' n: done so back to monitor
fcebc     f417c61f                 testb   lmm_p2,           #31       wc  ' hub?
fcec0     cd900044         if_c    jmp     #.hub                           ' y:
                   ' cog/lut
                   ' get a long or 4 bytes for cog/lut
fcec4     f217c808                 cmp     lmm_c,            #8        wc  ' c if <8 chars?
fcec8     3d900018         if_nc   jmp     #.gotlong                       ' n:
fcecc     fdb000a0 .getmore      CALL      #@_ParseHex2                    ' get another hex byte
fced0     f217c808                 cmp     lmm_c,            #8        wc  ' c if <8 chars?
fced4     3d900008         if_nc   jmp     #.got4bytes                     ' n:
fced8     f20fca0d                 cmp     lmm_w,            #_CR_     wz  ' <cr>?
fcedc     5d9fffec         if_ne   jmp     #.getmore                       ' n:
fcee0     f9ffc01b .got4bytes      movbyts lmm_x,            #%%0123       ' reverse bytes
fcee4     f21fc7ff .gotlong        cmp     lmm_p2,           #$1FF     wcz ' c|z if <$200 (cog?)
fcee8     ed90000c      if_c_or_z  jmp     #.cog                           ' y:
                   
fceec     fc33c1e3 .lut            wrlut   lmm_x,            lmm_p2        ' write a long to lut
fcef0     f107c601                 add     lmm_p2,           #1            ' PTR++
fcef4     fd9fffb8                 jmp     #.loop
                   
                   ' write 'long' from lmm_x into cog 'addr' in lmm_p2..   don't forget we are in hubexec!
fcef8     f98fc600 .cog            altd    lmm_p2                          '\ set PTR
fcefc     f60001e0                 mov     0-0,              lmm_x         '/ write a long to cog
fcf00     f107c601                 add     lmm_p2,           #1            ' PTR++
fcf04     fd9fffa8                 jmp     #.loop
                   
fcf08     f217c803 .hub            cmp     lmm_c,            #3        wc  ' c if <3 chars (byte)
fcf0c     cc43c1e3         if_c    wrbyte  lmm_x,            lmm_p2        ' write a byte to hub
fcf10     c107c601         if_c    add     lmm_p2,         #1            ' PTR++ (+1)
fcf14     cd9fff98         if_c    jmp     #.loop
fcf18     f217c805                 cmp     lmm_c,            #5        wc  ' c if <5 chars (word)
fcf1c     cc53c1e3         if_c    wrword  lmm_x,            lmm_p2        ' write a word to hub
fcf20     c107c602         if_c    add     lmm_p2,         #2            ' PTR++ (+2)
fcf24     cd9fff88         if_c    jmp     #.loop
fcf28     fc63c1e3                 wrlong  lmm_x,          lmm_p2        ' write a long to hub
fcf2c     f107c604                 add     lmm_p2,         #4            ' PTR++ (+4)
fcf30     fd9fff7c                 jmp     #.loop
                   ''===============================================================================================
                   
                   
                   ''-------[ Read Cog/Lut/Hub Long ]--------------------------------------------- <--- read: cog/lut/hub long --->
                   ''_RdLongCogHub
                   '' On Entry:
                   ''      lmm_x   = -anything-                            ' 'long':
                   ''      lmm_p   = 'addr'                                ' 'addr':  cog/lut addr / hub ptr
                   '' Call Format:
                   ''              CALL    #@_RdLongCogHub                 '                       < call: read cog/lut/hub long >
                   '' On Return:
                   ''      lmm_x   = 'long'                                ' 'long':  read from cog/hub
                   ''      lmm_p   = 'addr++'                              ' 'addr++' cog/lut addr++ / hub ptr++
                   '---------------------------------------------------------------------------------------------------
fcf34              _RdLongCogHub                                           '                       <--- read: cog/lut/hub long --->
fcf34     ff000001                 cmp     lmm_p, ##$3FF           wcz     ' z|c if =<$3FF = cog/lut mode?
fcf38     f21fc5ff 
                   ' read the 'long' into lmm_x from hub 'addr' in lmm_p
fcf3c     1b03c1e2         if_a    rdlong  lmm_x, lmm_p                    '\ read a long (hub)
fcf40     1107c404         if_a    add     lmm_p, #4                       '| PTR++
fcf44     1d7c002d         if_a    RET                             WCZ     '/
                   
fcf48     f21fc5ff                 cmp     lmm_p, #$1FF            wcz     ' z|c if =<$3FF = cog mode?
                   ' read the 'long' into lmm_x from lut 'addr' in lmm_p
fcf4c     1aa3c1e2         if_a    rdlut   lmm_x, lmm_p                    '\ read a long (lut)
fcf50     1107c401         if_a    add     lmm_p, #1                       '| PTR++
fcf54     1d7c002d         if_a    RET                             WCZ     '/
                   
                   ' read the 'long' into lmm_x from cog 'addr' in lmm_p..
                   '   don't forget we are executing from hub (hubexec)
fcf58     e997c400         if_be   alts    lmm_p                           '\ set PTR
fcf5c     e603c000         if_be   mov     lmm_x, 0-0                      '| read a long (cog)
fcf60     e107c401         if_be   add     lmm_p, #1                       '| PTR++
fcf64     fd7c002d                 RET                             WCZ     '/
                   ''===============================================================================================
                   
                   
                   ''-------[ Parse hex input ]--------------------------------------------------- <--- parse hex input --->
                   ''_ParseHex
                   '' On Entry:
                   ''      lmm_x   = -anything-/'hex'                      ' 'hex':   ---/prev hex value
                   ''      lmm_c   = -anything-/'count'                    ' 'count': ---/prev count
                   ''      lmm_p   = 'addr'                                ' 'addr':  ptr to string (hub)
                   ''      lmm_w   = -anything-                            '
                   '' Call Format:
                   ''             CALL     #@_ParseHex                     '                       < call: parse hex >
                   '' On Return:
                   ''      lmm_x   = 'hex'                                 ' 'hex':   hex value
                   ''      lmm_c   = 'count'                               ' 'count': of hex digits
                   ''      lmm_p   = 'addr++'                              ' 'addr':  ptr past next non-hex char
                   ''      lmm_w   = 'ucase'                               ' 'ucase': next non-hex char in ucase
                   ''--------------------------------------------------------------------------------------------------
fcf68              _ParseHex                                               '                       <--- parse hex input --->
fcf68     f607c000                 mov     lmm_x, #0                       ' preset hex=0
fcf6c     f607c800                 mov     lmm_c, #0                       ' preset count=0
                   
fcf70     fac3cbe2 _ParseHex2      rdbyte  lmm_w, lmm_p                    '\ read a char from string
fcf74     f20fca20                 cmp     lmm_w, #" "             wz      '| " " ?
fcf78     a107c401         if_e    add     lmm_p, #1                       '| y: PTR++
fcf7c     ad9ffff0         if_e    jmp     #@_ParseHex2                     '/    skip <spaces>
                   
fcf80     fac3cbe2 .loop           rdbyte  lmm_w, lmm_p                    ' read a char from string
fcf84     f20fca5f                 cmp     lmm_w, #"_"             wz      ' "_" ?
fcf88     a107c401         if_e    add     lmm_p, #1                       ' y: PTR++
fcf8c     ad9ffff0         if_e    jmp     #.loop                          ' y: skip "_"
fcf90     f217ca30                 cmp     lmm_w, #"0"             wc      ' c if <"0"
fcf94     cd900044         if_b    jmp     #.done                          ' j if not hex
fcf98     f217ca3a                 cmp     lmm_w, #"9"+1           wc      ' c if "0"-"9"
fcf9c     cd900018         if_b    jmp     #.num                           ' y: 0-9
fcfa0     f547ca20                 or      lmm_w, #$20                     ' force lower case a-z
fcfa4     f217ca61                 cmp     lmm_w, #"a"             wc      ' c if <"a"
fcfa8     cd900024         if_b    jmp     #.nothex                        ' j if not hex
fcfac     f217ca67                 cmp     lmm_w, #"f"+1           wc      ' c if <"g"
fcfb0     3d90001c         if_nc   jmp     #.nothex                        ' j if not hex
fcfb4     f187ca07                 sub     lmm_w, #("A"-"9"-1)             ' convert from A-F/a-f
fcfb8     f507ca0f .num            and     lmm_w, #$0F                     ' extract valid nibble
fcfbc     f067c004                 shl     lmm_x, #4                       ' shift nibbles
fcfc0     f543c1e5                 or      lmm_x, lmm_w                    '   and add nibble
fcfc4     f107c401                 add     lmm_p, #1                       ' PTR++
fcfc8     f107c801                 add     lmm_c, #1                       ' CTR++
fcfcc     fd9fffb0                 jmp     #.loop                          '
                   '               ----------------------------------------
fcfd0     fac3cbe2 .nothex         rdbyte  lmm_w, lmm_p                    ' re-read the non-hex char
fcfd4     f217ca60                 cmp     lmm_w, #$60             wc      ' c if < lower case columns
fcfd8     3527ca20         if_nc   andn    lmm_w, #$20                     ' converts to uppercase columns
fcfdc     f217c00d .done           cmp     lmm_x, #_CR_            wc      ' <cr>?    (don't skip over <cr>)
fcfe0     5107c401         if_ne   add     lmm_p, #1                       ' n: PTR++ (skip over non-hex char)
fcfe4     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''===============================================================================================
                   
                   ''-------[ Parse <filename> ]-------------------------------------------------- <--- parse filename --->
                   '' On Entry:
                   ''      lmm_x   = -anything-                            ' -anything-
                   ''      lmm_c   = -anything-                            ' -anything-
                   ''      lmm_p   = 'addr'                                ' 'addr':  ptr to string (hub)
                   ''      lmm_w   = -anything-                            '
                   '' Call Format:
                   ''             CALL     #@_ParseFname                   '                       < call: parse filename >
                   '' On Return:
                   ''      lmm_x   = 'fname'                               ' 'fname':   4 chars of filename
                   ''      lmm_c   = -undefined-                           '
                   ''      lmm_p   = 'addr++'                              ' 'addr':
                   ''      lmm_w   = _undefined-                           '
                   ''--------------------------------------------------------------------------------------------------
fcfe8     f607c804 _ParseFname     mov     lmm_c,  #4                      ' 4 chars per call
fcfec     f607c000                 mov     lmm_x,  #0
fcff0     fac3cbe2 .loop           rdbyte  lmm_w,  lmm_p                   ' get a char
fcff4     f20fca2e                 cmp     lmm_w,  #"."           wz
fcff8     520fca0d         if_ne   cmp     lmm_w,  #_CR_          wz
fcffc     5543c1e5         if_ne   or      lmm_x,  lmm_w                   ' insert char..
fd000     a547c020         if_e    or      lmm_x,  #" "                    ' .. or space..
fd004     f007c008                 ror     lmm_x,  #8                      ' .. & rotate byte
fd008     5107c401         if_ne   add     lmm_p,  #1                      ' PTR++
fd00c     5ac3cbe2         if_ne   rdbyte  lmm_w,  lmm_p                   ' get a char
fd010     0b6fc9f7         _RET_   djnz    lmm_c,  #.loop                  ' <4 chars
                   ''===============================================================================================
                   
fd014     4d2d3250 _str_vers       byte    "P2-MONITOR V1.3",$0D,$0A,0
                   ''===============================================================================================
fd026                              alignl
                   
                   '*******************************************************************************
                   '*                                                                             *
                   '*          TAQOZ - Tachyon Forth for the Parallax P2 CPU ROM                  *
                   '*                                                                             *
                   '*******************************************************************************
                   
                   
                   
                   CON
                           '''''''''''''' SERIAL BUFFERS ''''''''''
                           rxbuffers       = $180
                           rxrd            = $0C
                           rxwr            = $0E
                   ''	lastkey		= $10
                           rxsize          = $0E80
                   
                           codeorg         = $1000
                           ramdict         = $B400                 ' dictionary can be moved elsewhere at runtime'
                   
                   '        sys_clk         = 23_000_000		' RCFAST
                           sys_clk         = 20_000_000		' FPGA
                   '        nscnt           = 100000/(sys_clk/1000000)
                   
                           ''        baud_rate       = 115200
                           ''        baudval         = (sys_clk/baud_rate)<<16
                   
                   
                   
                   ' 180524 - implement 10-bit short literals and 9-bit task register addresses for compact fat32 variables'
                   
                           w               =       $F800           ' wordcode offset for 10-bit literals
                           _IF             =       $FC00           ' IF relative forward branch 0 to 127 words
                           _UNTIL          =       $FC80           ' UNTIL relative reverse branch 0 to 127 words
                           opunused        =       $FD00
                           rg              =       $FE00          ' task/cog register 8-bit offset
                           fat             =       $FF00
                           registers       =       rg                         'Variables used by kernel + general-purpose
                           tasks           =       rg+$D0          ' 2 longs/task * 8 cogs
                   
                           SKIPZ           =       _IF+01
                   
                           ex              =       1               ' EXITs (jump to hub wordcode instead of call)
                   
                           _FALSE          =       w+0
                           _0              =       w+0
                           _1              =       w+1
                           _2              =       w+2
                           _3              =       w+3
                           _4              =       w+4
                           _5              =       w+5
                           _6              =       w+6
                           _7              =       w+7
                           _8              =       w+8
                           _9              =       w+9
                           _13             =       w+13
                           _16             =       w+16
                           _32             =       w+32
                           _BL             =       w+32
                   
                   
                   CON
                   ' Offsets in LUT for stacks
                           datstk          = $000
                           brastk          = $020
                           lpstk           = $030
                           retstk          = $040
                   
                   ' The LUT is essentially free from $80 onwards
                   
                   
                   CON
                   
                   lastkey         = $00F0         ' written to directly from serialrx to hub ram ( reuse blank "R1" location )
                   
                   
                   numpadsz        = 26            ' We really only need a large buffer for when long binary numbers with separators are used
                                                   ' 26 digits for double number 18,446,744,073,709,551,615
                   wordsz          = 39            ' any word up to 37 characters (1 count, 1 terminator)
                   tasksz          = 8             ' 8 bytes/task RUN[2] FLAG[1]
                   
                   ' fflags
                   echo            = 1
                   'linenums       = 2             ' prepend line number to each new line
                   ipmode          = 4             ' interpret this number in IP format where a "." separates bytes
                   
                   
                   prset           = $10           ' private headers set as default
                   sign            = $20
                   comp            = $40           ' force compilation of the current word - resets each time
                   defining        = $80
                   
                   
                   CON
                   
                   flashpins       = spi_cs<<24+spi_do<<16+spi_di<<8+spi_ck
                   sdpins          = sd_cs<<24+sd_do<<16+sd_di<<8+sd_ck
                   
                   WW              = $FFFF
                   
                   cntm            = $1F           ' mask for nfa count byte to mask off atrs'
                   
                   ' Dictionary header attribute flags
                   pubatr  = 0
                   priatr  = 1
                   preatr  = 2
                   modatr  = 3
                   maxlen  = 15
                   
                   im      = preatr<<6           'lexicon immediate bit
                   pr      = priatr<<6           'private (can be removed from the dictionary)
                   
                   
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   
                   DAT
                   
fd028                              orgh
fd028                              alignw
                   
                   ''-------[ Start TAQOZ ]----------------------------------------------------- <--- start TAQOZr --->
fd028     fdbffa4c _Start_TAQOZ    call    #@_reset_booter                 ' reset the booters interrupts and autobaud
                   
fd02c              _Enter_TAQOZ
                   ''---------------------------------------------------------------------------------------------------
                   
                   
fd02c     fedfefd0                 loc     PTRA,#_hubrom           ' copy all of ROM to low 64K'
fd030     fef0efcc                 loc     PTRB,#$C000
fd034     ff000008                 rep     #2,##$1000
fd038     fcdc0400 
fd03c     fb041761                 rdlong  fx,PTRA++
fd040     fc6417e1                 wrlong  fx,PTRB++
                   
                   
                                   'mov    fx,##_ReEnter_TAQOZ & WW
                                   'wrlong fx,#4
fd044              _ReEnter_TAQOZ
                   {
                                   coginit #7,##@RESET
                                   coginit #6,##@RESET
                                   coginit #5,##@RESET
                                   coginit #4,##@RESET
                                   coginit #3,##@RESET
                                   coginit #2,##@RESET
                                   coginit #1,##@RESET
                   }
fd044     ff0007f6                 coginit #0,##@RESET
fd048     fcec0142 
                   
                   dat
fd04c                              orgh
                   
fd04c     0000000b taqoz_version           long    1_1
fd050     7161251c taqoz_time              long    190219_1900
fd054     68333376 taqoz_name              byte    "v33h"  ' use exactly 4 characters = 1 long'
                   
                   
fd058                              orgh
                   
                   { *** OUTPUT OPERATIONS *** }
                   
fd058     f820     SPACE   word    _BL
fd05a     00e0feae EMIT    word    rg+linenum,WFETCH
fd05e     0073fc06         word    _IF+06,DUP,w+$0A,_EQ,_IF+02,DROP,_13
fd06c     ec86fe10         word    rg+uemit,QJMP
fd070     0063017b         word    CONEMIT,EXIT
                   
fd074     f803     SPACES3 word    _3
fd076     007ef820 SPACES  word    _BL,SWAP
                   '
                   ' EMITS ( ch cnt -- )
fd07a     fc040072 EMITS   word    QDUP,_IF+04,FOR,DUP,EMIT,forNEXT,DROPEX+ex
                   
                   ' ?EMIT ,( ch --  ) suppress emitting the character if echo flag is off
fd088              QEMIT
fd088     d100f801         word    w+echo,CHKFLG,SKIPZ,EMIT+ex
fd090     00630069 DROPEX  word    DROP,EXIT
                   
                   ' mov   txpin,#tx_pin
fd094     ec66fe10 _CON    word    rg+uemit,CLRL,EXIT
                   ' direct output to a smartpin (after init)
fd09a     013feb06 _COM    word    _PIN,_WORD,WRACK
fd0a0     fe10     SETEMIT word    rg+uemit
fd0a2     006300e8 WSTOREX word    WSTORE,EXIT
fd0a6     d0a1f869 NONE    word    w+DROP,SETEMIT+ex
fd0aa     d0a3fe12 SETKEY  word    rg+ukey,WSTOREX+ex
                   
fd0ae     d05bf80c CLS     word    w+$0C,EMIT+ex
fd0b2     d05bf807 BELL    word    w+7,EMIT+ex
                   
fd0b6     00ddfeb2 SPINNER word    rg+spincnt,CFETCH,_3,_SHR,_3,_AND
fd0c2     d5a4             word    _STRING
fd0c4     5c2d2f7c         byte    "|/-\ ",0
fd0ca     00dd0086         word    PLUS,CFETCH
fd0ce     f808d05a         word    EMIT,_8,EMIT,rg+spincnt,CINC,_1,ms+ex
                   
                   ' ACCEPTED
fd0dc     d5ba     OK      word    PRTSTR
fd0de     006b6f20         byte    " ok",0
fd0e2     d0e8     CRLF    word    CR
fd0e4     d05bf80a LF      word    w+$0A,EMIT+ex
                   
fd0e8     d05bf80d CR      word    _13,EMIT+ex
                   
                   ' emit printable ASCII or a dot otherwise
fd0ec     00b7da0e AEMIT   word    QCHAR,_ZEQ
fd0f0     0069fc02         word    _IF+02,DROP
fd0f4     d05bf82e DOT     word    w+".",EMIT+ex
fd0f8     d05bf85f SCORE   word    w+"_",EMIT+ex
fd0fc     d05bf827 PRTTICK word    w+"'",EMIT+ex
                   
                   
fd100     ec52fe20 CHKFLG  word    rg+fflags,BITQ,EXIT
fd106     ec42fe20 CLRFLG  word    rg+fflags,CLR,EXIT
fd10c     ec32fe20 SETFLG  word    rg+fflags,SET,EXIT
                   
                   
                   ' U>    SWAP U< ;
fd112     eb52007e UGT     word    SWAP,_ULT,EXIT
                   ' <=    ( n1 n2 -- flg )
fd118     007e     LTEQ    word    SWAP
                   ' =>    ( n1 n2 -- flg  )       1- > ;
fd11a     eb420089 EQGT    word    DEC,GT,EXIT
                   
                   
fd120     00c10077 DIVIDE  word    OVER,_ABS,OVER,_ABS,UDIVIDE,ROT2,_XOR,MNEGATE,EXIT
                   
                   
                   ' */ ( u1 u2 div1 -- res )
                   ' CLKHZ 1.333333 1,000,000 LAP */ LAP .LAP  35.200us ok
fd132     00c70081 MULDIV  word    ROT2,UMMUL,ROT,UMDIVMOD64,DROP,NIP,EXIT
                   
                   
                   ' C--
fd140     d1470141 CDEC    word    MINUS1,CINC+2+ex
                   ' C++
fd144     007ef801 CINC    word    _1,SWAP,CPLUSST,EXIT
                   
                   ' W--
fd14c     d1530141 WDEC    word    MINUS1,WINC+2+ex
                   ' W++
fd150     007ef801 WINC    word    _1,SWAP,WPLUSST,EXIT
                   
                   ' --
fd158     d15f0141 LDEC    word    MINUS1,LINC+2+ex
                   ' ++
fd15c     007ef801 LINC    word    _1,SWAP,PLUSST,EXIT
                   
                   
                   'BOOTQ  word    rg+bootsig
fd164     006300e1 FETCHX  word    FETCH,EXIT
                   
                   ''''''''''''''''''' SMARTPIN MODES '''''''''''''''''
                   {
                   ( * OUT signal overridden )
                   
                   00 100*  = pulse/cycle output
                   00 101*  = transition output
                   00 110*  = NCO frequency
                   00 111*  = NCO duty
                   01 000*  = PWM triangle
                   01 001*  = PWM sawtooth
                   
                   
                   }
                   
fd168     00ae016c WRFNC	word	F,_SHL1,_WRPIN,L,EXIT
                   
fd172     f800016c MUTE    word	F,_0,_WRPIN,EXIT
                   
fd17a     00c5fbe8 MHZ     word    w+1000,MUL16
fd17e     00c5fbe8 KHZ     word    w+1000,MUL16
fd182     d192     HZ      word    NCOCNT
fd184     f826     NCO     word    w+%01_00110
                   ' ( Y X mode -- )       mode    prescaler  value
                   ' SMART ( n mode -- )
fd186     f801d168 SETNCO  word    WRFNC,_1,_WXPIN,_WYPINX+ex
                   
                   ' DUTY ( val -- ) $4E 100.1110
fd18e     d187f827 DUTY    word    w+%01_00111,SETNCO+ex
                   
                   ' -1/2 /CLKHZ/20000     == HZCON
                   ' NCOCNT ( freq -- ncocnt )     HZCON #10000 */ ;
                   ' pub NCOCNT ( hz -- cntval )	CLKHZ 4 << SWAP U/ $10.0000.0000. ROT UM// DROP NIP ;
                   
                   '                      |<------ fudged this from a 4
fd192     f804d232 NCOCNT	word	CLKHZ,_4,_SHL,SWAP,UDIVIDE,_0,w+$10,ROT
fd1a2     0069eb5e UMDIV	word	UMDIVMOD64,DROP,NIP,EXIT
                   
                   '' pub SETNCO ( val mode --)	WRFNC 1 WXPIN WYPIN ;
                   
                   ' BLINK ( pin -- )
fd1aa     f802eb06 BLINK   word    _PIN,_2,HZ+ex
                   
                   
                   '--- TRIANGLE PWM MODE
                   ' PWM ( duty frame div -- )     @PIN LOW $50 WRPIN SWAP 16 << + WXPIN WYPIN ;
fd1b0     f852     PWM     word    w+$52
fd1b2     0153016a PWM1    word    L,_WRPIN,SWAP,_SHL16,_OR,_WXPIN,_WYPINX+ex
fd1c0     d1b3f850 SAW     word    w+$50,PWM1+ex
                   ' SAW ( duty frame div -- )     @PIN LOW $50 WRPIN SWAP 16 << + WXPIN WYPIN ;
                   
                   
fd1c4     00c2fbe8 ns	word	w+1000,MULTIPLY,_LONG
fd1ca     d4a51000 	long	$D4A51000
fd1ce     d232f8e8 	word	w+$E8,CLKHZ,UMDIV,UDIVIDE,EXIT
                   
                   ' transistion mode
                   ' PW ( width -- )
fd1d8     f825016a PW      word    L,w+%01_00101,WRFNC
fd1de     00630155 _WXPINX	word	_WXPIN,EXIT
fd1e2     f801     PULSE   word    _1
fd1e4              _WYPINX
fd1e4     00630157 PULSES  word    _WYPIN,EXIT
                   ' HILO ( high low -- )
fd1e8     d168f824 HILO    word    w+%01_00100,WRFNC,SWAP,OVERPLUS,SWAP,_SHL16,_OR,_WXPINX+ex
                   
                   
                   
                   
                   
                   
                   
                   
                   ''''''''''''''' SERIAL MODES ''''''''''''''''''
                   
fd1f8     ebeaf819 DL      word    w+tepin,COGFETCH,EXIT
                   ' BIT ( n -- ) Set bit length of serial smartpin interface
fd1fe     f8190089 BIT     word    DEC,w+tepin,COGSTORE,EXIT
                   
fd206     f87c0169 TXD     word    H,w+$7C
                   ' BAUD ( baud mode -- )
fd20a     d2320153 BAUDST  word    _WRPIN,CLKHZ,SWAP,UDIVIDE,_SHL16,DL,_ZEQ,_IF+02,_8,BIT,DL,PLUS,_WXPIN,EXIT
fd226     d20bf83e RXD     word    w+$3E,BAUDST+ex
                   
                   { TRANSMITTING ASYNCH
                   TAQOZ# 34 PIN 8 BIT 115200 TXD  ok
                   TAQOZ# $55 WYPIN  ok
                   TAQOZ# $41 WYPIN  ok
                   TAQOZ# @NAMES 4 TXDAT  ok
                   }
                   '        1098 7654 321 0987654321098 76 54321 0
                   '           0 0001 000 0000000000000 01 11100 0
                   ' D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0
                   ' 11100*  = sync serial transmit         (A-data, B-clock)
                   ' SYNTX ( bits -- )             L $100.0078 WRPIN 1- $20 OR WXPIN ;
fd22a     f878     SYNTX   word    w+$78
                   
                   
                   {
                   pub TX          WYPIN ;
                   pub SERIAL ( pin -- )           PIN ' TX uemit W! ;
                   
                   }
                   
                   ''''''''''''''''''' CONSTANTS '''''''''''''''''''''
                   
fd22c              W1000000
fd22c     014d             word    CONL
fd22e     000f4240         long    1000000
                   'W1000   word    CONL
                   '        long    1000
                   
fd232     014d     CLKHZ   word    CONL
fd234     01312d00         long    sys_clk
fd238     014d     CLKKHZ  word    CONL
fd23a     00004e20         long    sys_clk/1000
fd23e     014d     CLKMHZ  word    CONL
fd240     00000014         long    sys_clk/1000000
                   
                   ' ADDRESS OF TAQOZ BACKUP/RESTORE IN FLASH'
fd244     014d     BRORG   word    CONL
fd246     000f0000         long    $F0000
                   
                   
fd24a     014d     BUFFERS word    CONL
fd24c     0000f000         long    $F000
fd250     014d     ROM     word    CONL
fd252     000fc000         long    $0F_C000
fd256     014d     IRQVEC  word    CONL
fd258     000fffe0         long    $0F_FFE0
                   
                   
                   {
                   %0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS     Set clock generator mode
                   %0001_0000_0000_0000_0000_0000_0000_0000     Hard reset, reboots chip
                   %001P_0000_0000_0000_0000_0000_0000_0000     Set write-protect of last 16KB RAM to P
                   %01RR_0000_0000_0000_0000_0000_0LLT_TTTT     Set filter R to length L and tap T
                   %1DDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD     Seed Xoroshiro128+ PRNG with D
                   }
                   
fd25c     d267f801 REBOOT  word    w+1,HUBSW+ex
fd260     d267f802 WE      word    w+2,HUBSW+ex
fd264     f803     WP      word    w+3
fd266     00a6f81c HUBSW   word    w+28,_SHL
fd26a     0063ecae HUBEX   word    _HUBSET,EXIT
                   
                   ' 1=80MZ 2=40MHZ 3=20MHZ 4=10MHZ 5=5MHZ
fd26e     00d8f801 CLKDIV  word    _1,_MAX,w+$1FF,SWAP,_SHR,HUBEX+ex
fd27a     d26bf801 RCSLOW  word    _1,HUBEX+ex
                   
                   {
                   pub 50MHZ       $9F HUBSET ;
                   pub 45.4MHZ     $8F HUBSET ;
                   pub 62.5MHZ     $C7 HUBSET ;
                   }
                   
                   
                   
                   
                   
                   { *** NUMBER BASE *** }
                   
                   
                   ' change the default number bases
                   
fd27e     f802     BIN     word    w+2
fd280     fe16     SETBASE word    rg+base
fd282     006300e4 CSTOREX word    CSTORE,EXIT
fd286     d281f80a DECIMAL word    w+10,SETBASE+ex
fd28a     d281f810 HEX     word    w+16,SETBASE+ex
fd28e     00ddfe16 GETBASE word    rg+BASE,CFETCH,EXIT
                   
                   
                   ' >UPPER  ( str1 --  ) Convert lower-case letters to upper-case
fd294     008c     TULP    word    INC
fd296     007200de TOUPPER word    DUPCFT,QDUP,_IF+08                      ' end of string?
fd29c     f87af861         word    w+"a",w+"z",WITHIN
fd2a2     fc88             word    _UNTIL+08
fd2a4     0077f8e0         word    w+$E0,OVER,CPLUSST,TULP+ex              ' convert case (subtract $20)
fd2ac     d091             word    DROPEX+ex
                   
                   { *** STRING TO NUMBER CONVERSION *** }
                   
fd2ae     f839f830 DECQ    word    w+"0",w+"9",WITHIN+ex
fd2b4     f846f841 HEXQ    word    w+"A",w+"F",WITHIN+ex
                   
                   ' functional test for now - optimize later
                   ' Convert ASCII value as a digit to a numeric value - only interested in bases up to 16 at present
                   '
fd2ba              TODIGIT ' ( char -- val true | false )
fd2ba     d2ae0073         word    DUP,DECQ,_IF+04 ',td8           ' only work with 0..9,A..F
fd2c0     0085f830         word    w+"0",MINUS
fd2c4     00630141 TRUEX   word    _TRUE,EXIT                      ' pass decimal digits
fd2c8     d2b40073 td8     word    DUP,HEXQ,_IF+03 ',td2
fd2ce     0085f837         word    w+$37,MINUS,TRUEX+ex            ' pass hex digits
fd2d4     0069     td2     word    DROP
fd2d6     0063f800 FALX    word    _FALSE,EXIT
                   
                   {  Try to convert a string to a number
                   Allow all kinds of symbols but these are the rules for it to be treated as a number.
                   1. Leading character must be either a recognized prefix or a decimal digit
                   2. If trailing character is a recognized suffix then the first character must be a decimal digit
                   Acceptable forms are:
                   $1000   hex number
                   1000h
                   #1000   decimal number
                   1000d
                   %1000   binary number
                   1000b
                   
                   Also as long as the first character and last character are valid (0..9,prefix,suffix) then any symbols me be mixed in the number i.e.
                   11:59  11.59  #5_000_000
                   }
                   
fd2da     00b50079 OVEQ    word    THIRD,_EQ,EXIT
                   
fd2e0              _NUMBER ' ( str -- value digits | false )
fd2e0     ec66fe04         word    rg+4,CLRL                                               ' REG0L = 0
fd2e4     d106f820         word    w+sign,CLRflg                                           ' clear sign
fd2e8              snlp
fd2e8     00560073         word    DUP,STRLEN,OVERPLUS,DEC,CFETCH,rg+suffix,CSTORE                        ' save suffix (assume string has count byte)
fd2f6     f82d00de         word    DUPCFT,w+"-",_EQ,_IF+03                                 ' save SIGN
fd2fe     d10cf820         word    w+sign,SETFLG,INC                               ' and use string without sign
                                                                                           ' prefix may come after the sign
fd304     007300de         word    DUPCFT,DUP,rg+prefix,CSTORE                             ' save prefix (it may or may not be)
                   
                           ' PREFIX HANDLER
                           '       ( str ch )
fd30c     f800             word    _FALSE                                                  ' preset prefix flag = false
                   '               $nnnn - set hex base - flag true
fd30e     d2daf824         word    w+"$",OVEQ,_IF+02,HEX,INC
fd318     d2daf823         word    w+"#",OVEQ,_IF+02,DECIMAL,INC                       ' as does # - also set decimal base
fd322     d2daf825         word    w+"%",OVEQ,_IF+02,BIN,INC                           ' as does % - also set binary base
fd32c     d2daf826         word    w+"&",OVEQ,_IF+05,DECIMAL,INC                       ' as does & - also set decimal base and IP notation
fd336     fe87f880         word    w+$80,rg+bnumber+3,CSTORE                               ' this forces "." symbols to work the same as ":"
                           '       ( str ch flg )
fd33c     fc030073         word    DUP,_IF+03,ROT,INC,ROT2                                 ' adjust string pointer to skip prefix
                           '       ( str ch flg )
fd346     d2ae007e         word    SWAP,DECQ,_OR                                           ' 0..9 forces processing as a number
                           ''      ( str flg ) flg is true if a prefix is found OR the first character is 0..9
fd34c     dda7eb36         word    SKIPNZ,DROPFEX+ex ' ( -- false )                                ' Give up now, it isn't a candiate
                           ''      ( str )                                                 ' so far, so good, now check suffix
                           ' SUFFIX HANDLER  - must end in 0..9 or A..F or valid suffix
fd350     00ddfe78         word    rg+suffix,CFETCH
fd354     d2ae0073         word    DUP,DECQ                                                ' 0..9
fd358     d2b40077         word    OVER,HEXQ,_OR                                           ' A..F ( str sfx flg ) true if still a digit
fd35e     d2daf868         word    w+"h",OVEQ,_IF+02,HEX,INC                           ' h = HEX
fd368     d2daf862         word    w+"b",OVEQ,_IF+02,BIN,INC                           ' b = BINARY
fd372     f864007e         word    SWAP,w+"d",_EQ,_IF+02,DECIMAL,INC                       ' d = DECIMAL
fd37e     dda7eb36         word    SKIPNZ,DROPFEX+ex                                               ' bad suffix, no good
                           ' so far the prefix and suffx have been checked prior to attempt a number conversion
                           ' From here on there must be at least one valid digit for a number to be accepted
                           ' DIGIT EXTRACTION & ACCUMULATION
fd382              nmlp
fd382     007300de         word    DUPCFT,DUP,_IF+(nmend-nm1)/2                    ' while there is another character
fd388     fc12d2ba nm1     word    TODIGIT,_IF+(nmsym-nm2)/2                               ' convert to a digit? or else check symbol
                           ' a digit has been found but is it valid for this base? ' ( str val )
fd38c     d28e0073 nm2     word    DUP,GETBASE,DEC,GT,_IF+02
fd396     d2d70068 FALX2   word    DROP2,FALX+ex                                           ' a digit but exceeded base
fd39a     00e1fe80 nmok    word    rg+anumber,FETCH,GETBASE,MULTIPLY                       ' shift anumber left one digit (base)
fd3a2     fe800086         word    PLUS,rg+anumber,STORE                                   ' and merge in new digit
fd3a8     d144fe88         word    rg+digits,CINC                                          ' update number of digits
fd3ac     d383008c nmnxt   word    INC,nmlp+ex                                             ' update str and loop
                   
                           ' character was not a digit - check for valid symbols (keep it simple for now)
                           ' SYMBOLS
fd3b0     f83a00de nmsym   word    DUPCFT,w+":",_EQ                                        ' : ENTER
fd3b6     00dd0077         word    OVER,CFETCH,w+".",_EQ                                   '  . dot
fd3be     fc040073         word    DUP,_IF+04,rg+digits,CFETCH,rg+dpl,CSTORE               ' remember last decimal place
fd3ca     00e1fe84 ns01    word    rg+bnumber,FETCH,_ZNE,_AND,_OR
fd3d4     fc0a             word    _IF+10                                                  ' Use : as special byte shift for IP notation etc
fd3d6     00e1fe84 nmsym1  word    rg+bnumber,FETCH
fd3da     00e1fe80         word    rg+anumber,FETCH,PLUS,_SHL8
fd3e2     00ecfe84         word    rg+bnumber,STORE,rg+anumber,CLRL                        ' accumulate & number in bnumber
fd3ea     d3ad     nmsym2  word    nmnxt+ex                                                ' just ignore other symbols for now
                           '
fd3ec              nmend   ' end of string - check
fd3ec     fe880068         word    DROP2,rg+digits,CFETCH,DUP,ZEXIT                        ' return with false if there are no digits
fd3f6     00e1fe80         word    rg+anumber,FETCH,rg+bnumber,FETCH,PLUS
fd400     d100f820         word    w+sign,CHKFLG,QNEGATE
fd406     0063007e         word    SWAP,EXIT                                               ' all good, return with number and true
                   
                   ' NUMBER processing -try to convert a string to a number
fd40a              NUMBER  ' ( str -- value digits | false )
                           ' process control prefix i.e. ^A
fd40a     00560073         word    DUP,STRLEN,_2,_EQ
fd412     00dd0077         word    OVER,CFETCH,w+"^",_EQ,_AND,_IF+06                       ' ^ch  Accept caret char as <control> char
fd41e     00dd008c         word    INC,CFETCH,w+$1F,_AND,_1,EXIT                           ' control character processed - single digit
                           ' process character literal i.e. "A"
fd42a     00560073 ch01    word    DUP,STRLEN,_3,_EQ
fd432     00dd0077         word    OVER,CFETCH,DUP,w+$22,_EQ,SWAP,w+$27,_EQ
fd442     00930097         word    _OR,_AND,_IF+04                                 ' "ch" or 'ch' Accept as an ASCII literal
fd448     00dd008c ascch   word    INC,CFETCH,_1,EXIT
                   
                                                                                           ' It wasn't an ASCII literal, process as a number
fd450     f80afe80 ch02    word    rg+anumber,w+10,ERASE                                   ' zero out assembled number (double), digits, dpl
fd456     fe17d28e         word    GETBASE,rg+base+1,CSTORE                                ' backup current base as it may be overridden
fd45c     d2e0             word    _NUMBER '( str -- digits num | false )
fd45e     00ddfe17 nmb1    word    rg+base+1,CFETCH,SETBASE+ex                             ' restore default base before returning
                   
                   
                   
                   ' QFNUM ( -- flg ) Test if word is a fast prefixed number
fd464              QFNUM   'word   _TRUE,rg+wordbuf,DUP,STRLEN,ADO,IX,CFETCH,DECQ,_AND,LOOP,QDUP,IFEXIT
fd464     00ddfe24         word    rg+wordbuf,CFETCH,w+"#",w+"%",WITHIN                    ' Numeric prefixes?
fd46e     00ddfe23         word    rg+wordbuf-1,CFETCH,_2,GT,_AND                          ' and more than 2 characters? (inc term)
fd478     00defe23         word    rg+wordbuf-1,DUPCFT,PLUS,CFETCH                 ' and last char is a digit or hex digit?
fd480     d2ae0073         word    DUP,DECQ                                                ' decimal digit?
fd484     d2b4007e         word    SWAP,HEXQ,_OR,_AND                                      ' hex digit?
fd48c     0063             word    EXIT
                   
                   
                   
                   { *** COMPILER EXTENSIONS *** }
                   
                   
                   
                   ' Most of these words are acted upon immediately rather than compiled as they are
                   ' part of the "compiler" in that they create the necessary structures
                   '
                   
                   ''' dumb compiler for literals - improve later - just needs to optimize the number of bytes needed
fd48e              LITCOMP ' ( n -- ) compile the literal according to size
fd48e     009d0073         word    DUP,_SHR16,_IF+07
                                   ' Compile long
fd494     d600f93d         word    w+_LONG,COMPW                               ' compile the _LONG instruction
fd498     009d0073         word    DUP,_SHR16,SWAP,COMPW,COMPW+ex                                  ' compile the long itself
                                   ' Compile 2 bytes - 16bits
fd4a2     f80a0073 .L1     word    DUP,W+10,_SHR,_IF+03                    ' 10 BIT LITERAL?'
fd4aa     d600f93f         word    w+_WORD,COMPW,COMPW+ex
fd4b0              .L2             ' Compile short literal directly
fd4b0     f800013f         word    _WORD,w,PLUS,COMPW+ex
                   
                   
                   ''''    BEGIN as in BEGIN...AGAIN or BEGIN...UNTIL  generate branch for BEGIN
fd4b8     f8bed692 _BEGIN_ word    ATCODES,w+$BE
                   '''
                   ''' MARK ( addr tag -- tag&addr ) Merge tag and addr by shifting tag into hi word
fd4bc     00a6f818 MARK    word    w+24,_SHL
fd4c0     00630097 ORX     word    _OR,EXIT
                   
                   ' UNMARK        ( tag&addr -- addr tag )
fd4c4     01410073 UNMARK  word    DUP,MINUS1,_SHR8,_AND,SWAP,w+24,_SHR,EXIT
                   
                   
                   
                   ''' REPEAT if mark is $1F preceded by $BE mark
fd4d4              _REPEAT_
fd4d4     d4da007e         word    SWAP,_AGAIN_,_THEN_+ex
                   
                   ''' AGAIN if mark is $BE
fd4da              _AGAIN_
fd4da     d4c4     __AGAIN word    UNMARK
fd4dc     00b5f8be         word    w+$BE,_EQ,_IF+(badthen-ag1)/2
                           ' ( addr bc -- ) compile the wordcode and calculate the branch back
fd4e2     d601008c ag1     word    INC,COMPW+ex
                   
                   ''' UNTIL ( flg -- )
fd4e6     d4c4     _UNTIL_ word    UNMARK
fd4e8     00b5f8be unt00   word    w+$BE,_EQ,_IF+(badthen-unt1)/2
fd4ee     007ed692 unt1    word    ATCODES,SWAP,MINUS,_SHR1,INC
fd4f8     fc80013f         word    _WORD,_UNTIL,_OR,COMPW+ex
                   
                   
                   
                   ''' IF as in IF...THEN or IF...ELSE...THEN
                   ''' WHILE
fd500              _IF_
fd500     f81fd692         word    ATCODES,w+$1F,MARK
fd506     fc00013f         word    _WORD,_IF,COMPW+ex                      ' compile an IF and a dummy branch (else/then will set)
                   
fd50c     f81ed692 GOTO    word    ATCODES,w+$1E,MARK
                           ''      compile a dummy NOP to be replacd later with a goto (addr+ex)
fd512     d601f871         word    w+_NOP,COMPW+ex
                   
                   ' ELSE
fd516              _ELSE_
fd516     d4c4             word    UNMARK ' ( addr tag )
                   ''              does this match an IF?
fd518     00b5f81f         word    w+$1F,_EQ,_IF+(badthen-.L0)/2
                   ''              mark the else to be processed on a THEN
fd51e     d50c     .L0     word    GOTO
                   '
                   ''              get the IF addr and proceed as if it were a THEN
fd520     f81f007e         word    SWAP,w+$1F,MARK
                   ' THEN
fd526     d4c4     _THEN_  word    UNMARK '( addr tag )
                           '
                           ' ( addr tag ) resolve structure branch
                           ''      ELSE THEN ?
fd528     f81e0073         word    DUP,w+$1E,_EQ,_IF+05
fd530     d6920069         word    DROP,ATCODES,INC,SWAP,WSTOREX+ex
                           ''      IF THEN ?
fd53a     00b5f81f         word    w+$1F,_EQ,_IF+8
                           ''      update IF's branch
fd540     0077d692         word    ATCODES,OVER,MINUS,_SHR1,DEC,SWAP,CSTOREX+ex
                           '
fd54e     d5ba     badthen word    PRTSTR
fd550     72745320         byte    " Structure mismatch! ",0
fd566     d091e016         word    ERROR,DROPEX+ex
                   
                   
                   
                   
                   ''''''''''''''''''''' STRINGS ''''''''''''''''''''''''''
                   
                   
                   
                   
                   ' NULL$
fd56a     00000150 NULLSTR word    VARB,0
                   
                   ' $! ( str1 str2 -- )
fd56e     00560077 STRST   word    OVER,STRLEN,INC,CMOVE,EXIT
                   
                   ' $= ( str1 str2 -- flg )
fd578     00560077 STREQ   word    OVER,STRLEN,OVER,STRLEN,_EQ
fd582     0073fc0e         word    _IF+14,DUP,STRLEN,ADO
fd58a     010300da         word    CFETCHINC,IX,CFETCH,_NEQ,_IF+03,DROP,_0,LEAVE,LOOP,_ZNE,EXIT
fd5a0     00010068         word    DROP2,FALSE+ex
                   
                   
                   ' STR ( -- n ) Leave address of inline string on stack and skip to next instruction
fd5a4     0073012d _STRING word    RPOP,DUP,STRLEN,OVERPLUS,INC,WALIGN,AJMP
                   
                   
                   ' " string"     Compile a literal string - no length restriction - any codes can be included except the delimiter "
fd5b2              _STRING_
                           ''      compile wordcodes for string
fd5b2     d5a4013f         word    _WORD,_STRING,COMPW,COMPSTR+ex
                   
                   
                   ' Print inline string
fd5ba     012d     PRTSTR  word    RPOP
fd5bc     007200da .lp     word    CFETCHINC,QDUP,_IF+02,EMIT,.lp+ex
fd5c6     012ad672         word    WALIGN,PUSHR,EXIT
                   
                   ' PRINT" HELLO WORLD"   Compile a literal print string - no length restriction - any codes can be included except the delimiter "
fd5cc     d5ba013f _PSTR_  word    _WORD,PRTSTR,COMPW
fd5d2     0073e114 COMPSTR word    WKEY,DUP,QEMIT          ' echo string
fd5d8     f8220073         word    DUP,w+$22,_NEQ,_IF+02,COMPC,COMPSTR+ex
                   ''              word align end of string with an extra null
fd5e4     f801d692         word    ATCODES,_1,_AND,_ZEQ,_IF+02,_0,COMPC
fd5f2     f8000069         word    DROP,_0
fd5f6     00e8d692 COMPC   word    ATCODES,WSTORE
                   ''              advance code write address by 1
fd5fa     d15cfea2         word    rg+codes,LINC,COMPX+ex
                   
                   
                   ' ( wordcode -- ) append this wordcode to next free code location + append EXIT (without counting)
fd600     d672d692 COMPW   word    ATCODES,WALIGN,WSTORE
fd606     fea2f802         word    _2,rg+codes,WPLUSST
                   ''      word    WALIGN
                   ''              advance code write address by 2
                   ''      word    rg+codes,STORE
                   ''              compile an EXIT after the latest codes
fd60c     d692f863 COMPX   word    w+EXIT,ATCODES,WSTOREX+ex
                   
                   ' C, or | ( n -- ) IMMEDIATE --- compile a byte into code and allocate
fd612     d5f6d63e CCOMP   word    GRAB,COMPC,rg+codes,WFETCH,_1,_AND,IFEXIT,ALLOCATED+ex
                   ' W, or || ( n -- )
fd622     d62fd63e WCOMP   word    GRAB,WCOMMA+ex
                   
                   ' , ( n -- ) Compile a long literal
fd626     d63e     LCOMP   word    GRAB
fd628     d6000073 COMPL   word    DUP,COMPW,_SHR16
fd62e     d639d600 WCOMMA  word    COMPW,ALLOCATED+ex
                   
                   
                   
                   ' ALLOT ( bytes -- )
fd632     00eafea2 ALLOT   word    rg+codes,PLUSST,ALLOCATED+ex
                   
                   ' lock in compiled code so far - do not release but set new "here" to the end of these codes
fd638              ALLOCATED
fd638     fe9ed692         word    ATCODES,rg+here,STOREX+ex
                   
                   ' GRAB ( -- ) \ IMMEDIATE --- executes preceding code to make it available for any immediate words following
fd63e     d600f863 GRAB    word    w+EXIT,COMPW                                        ' append an EXIT
fd642     0073d688         word    ATHERE,DUP,rg+codes,STORE,ACALL                         ' execute and release preceding code in text line
fd64c     0063             word    EXIT
                   
                   
                   
                   
                   ' NFA' ( <name> -- nfaptr )
                   ' COMPILE  ( not used in this version )
fd64e              NFATICK
fd64e     0089dd84         word    _GETWORD,DEC,SEARCH+ex
                   
fd654              _NFATICK
fd654     d48fd64e         word    NFATICK,LITCOMP+ex
                   
                   ' The CPA is the address of the word code stored in the header that points to the code to execute
                   
                   ' 03,D,U,P,CPAL,CPAH'
                   ' CPA ( nfa -- cpa )
fd658     f81f00da NFACPA  word    CFETCHINC,w+cntm,_AND,PLUS,EXIT
                   
                   
                   ' ' <name>  ( -- pfa ) Find the address of the following word - zero if not found or its CFA/PFA
fd662     d64e     TICK    word    NFATICK
                   ' CFA ( nfa -- cfa )'
fd664     00610073 NFACFA  word    DUP,ZEXIT,NFACPA,WFETCH,EXIT
                   
fd66e     d48fd662 ATICK   word    TICK,LITCOMP+ex
                   
                   
                   
                   
fd672     f801008c WALIGN   word   INC,_1,_ANDN,EXIT
                   
fd67a     f804     _ALIGNL word    _4
                   ' ALIGN ( address align -- val00  )                                     1- SWAP OVER + SWAP ANDN ;
fd67c     007e0089 _ALIGN  word    DEC,SWAP,OVERPLUS,SWAP,_ANDN,EXIT
                   
                   
                   {HELP _HERE ( -- addr ) Address of next compilation location }
fd688     00e0fe9e ATHERE  word    rg+here,WFETCH,EXIT
                   ' ( -- atradr ) --- point to the attribute byte in the header of the latest name
fd68e              ATATR
fd68e     d165fe96 ATNAMES word    rg+names,FETCHX+ex
fd692     00e0fea2 ATCODES word    rg+codes,WFETCH,EXIT
                   
                   
                   '  CREATEWORD - create a name in the dictionary using the next word encountered
                   ''               cnt,name,atr,cpa
fd698              CREATEWORD
fd698     dd84             word    _GETWORD                                ' ( str ) read the next word
                   ' CREATE$ ( str -- )
fd69a              CREATESTR
                           '       skip empty string '
fd69a     eb3600de         word    DUPCFT,SKIPNZ,DROPEX+ex
                   '       '       get attribute
                   '       word    rg+fflags,CFETCH,w+prset,_AND
                   '               setup CPA field right now '
fd6a0     d68ed692         word    ATCODES,ATNAMES,DEC2,WSTORE
                           '       build up a header in the word buffer then copy across
                           '       get string count ( str )
fd6a8     00730089         word    DEC,DUP,CFETCH,INC  ' ( c+str size )'
                           '       ( str size ) update names ptr by backwards count + cpa field
fd6b0     008b0073         word    DUP,INC2,NEGATE,rg+names,PLUSST
                           ''      copy it across
fd6ba     007ed68e         word    ATNAMES,SWAP,CMOVE
                           ''      check for dictionary full ( less than 64 bytes )
fd6c0     d688d68e         word    ATNAMES,ATHERE
fd6c4     0086f840         word    w+64,PLUS,LT,ZEXIT,PRTSTR
fd6ce     69442020         byte    "  Dictionary full! ",0
fd6e2     e017             word    ERROR+ex
                   
                   ' CREATE <name> - Create a name in the dictionary and also a VARIABLE code entry - or revectored through NOP
fd6e4     d6980071 CREATE  word    _NOP,CREATEWORD,w+VARB,COMPW,_0,ALLOT+ex
                   
                   ' Change the value of a constant
                   ' pub ==! ( val 'con -- )               2+ ! ;
fd6f0     da87008b CONST   word    INC2,STOREX+ex
                   
fd6f4     f800d6e4 _VAR    word    CREATE,_0,COMPL+ex
                   
                   ' :=
fd6fa     d698d63e _CON9   word    GRAB,CREATEWORD,BITS9,_WORD,w,PLUS,ATNAMES,NFACPA,WSTOREX+ex
                   
                   ' ==
fd70c     d698d63e _CONST  word    GRAB,CREATEWORD,w+CONL
fd712     d628d600 DCOMP   word    COMPW,COMPL,_0,ALLOT+ex
                   
                   ' Identical to a constant except the call address is slightly different so a FORGET can release the data area
fd71a     d698d63e _DATCON word    GRAB,CREATEWORD
fd71e     d713f94c         word    w+DATCON,DCOMP+ex
                   
                   
                   
                   ' GETATR ( -- code )
fd722     f806d68e GETATR  word  ATNAMES,_6,_SHR,EXIT
                   
                   ' Create a new entry in the dictionary but also prevent any execution of code
                   ' : <name>
                   
fd72a              PUBDEF
fd72a     d698     NEWDEF  word    CREATEWORD
fd72c     d10df880 REDEF   word    w+defining,SETFLG+ex                  ' flag that we have entered a definition
                   
                   'MODDEF  word    w+modatr,SDEF+ex
fd730     d737f802 PREDEF  word    w+preatr,SDEF+ex
fd734     f801     PRIDEF  word    w+priatr
fd736     d72a     SDEF    word    NEWDEF
                   ' SETATR ( code -- )
fd738     00a6f806 SETATR  word    _6,_SHL,ATNAMES,CFETCH,w+cntm,_AND,_OR,ATNAMES,CSTORE,EXIT
                   
                   ' Update "here" pointer to point to current free position which "codes" pointer is now at
                   ' Also unsmudge the headers tag
                   '
fd74c              ENDDEF
fd74c     d600f863         word    w+EXIT,COMPW                                        ' compile an EXIT
fd750     d106f880 UNDEF   word    w+defining,CLRFLG,ALLOCATED+ex              ' end definition and lock allocated bytes
                   
                   
                   ' [C] force compilation of the next word
fd756              COMPILES
fd756     d10df840         word    w+comp,SETFLG+ex
                   
                   
                   
                   ' ************** CASE STATEMENTS *********************8
                   
                   ' SWITCH ( val -- )
fd75a     da87fe1c _SWITCH word    rg+uswitch,STOREX+ex
                   
                   ' SWITCH@ ( -- val )
fd75e     d165fe1c SWFETCH word    rg+uswitch,FETCHX+ex
                   
                   ' SWITCH= ( val -- flg )
fd762              ISEQ
fd762     00b5d75e         word    SWFETCH,_EQ,EXIT
                   
                   ' CASE ( compare -- )
fd768     d762013f _CASE   word    _WORD,ISEQ,COMPW,_IF_+ex
                   
                   ' BREAK
fd770     d600f863 ISEND   word    w+EXIT,COMPW,_THEN_,ALLOCATED+ex
                   
                   
                   ' SWITCH>< ( from to -- flg )..
fd778              ISWITHIN
fd778     0081d75e         word    SWFETCH,ROT2,WITHIN+ex
                   
                   
                   {  Table vectoring -
                   index a table of vectors and jump to that vector
                   A table limit is supplied as well as a default vector
                   
                    Usage:
                           <limit> VECTORS <vector if over>
                           <vector0> <vector1> ...... <vectorx>)
                   Sample:
                           4 LOOKUP BELL                   \ an index of 4 or more will default to BELL
                           INDEX0 INDEX1 INDEX2 INDEX3     \ 0 to 3 will execute corresponding vectors
                   
                   }
                   {
                   ' LOOKUP
                   ' VECTORS ( index range -- )
                   VECTORS
                           word    OVER,GT,_ZEQ,_IF+02,DROP,MINUS1         ' limit index to range or -1 (.>0)
                   .L0     word    INC,_SHL1,RPOP,PLUS,WFETCH,ACALL,EXIT
                   
                   }
                   
                   
                   
                   ' ( n lo hi -- flg ) true if n is within range of low and high inclusive
fd77e     0077008c WITHIN  word    INC,OVER,MINUS,PUSHR
fd786     012d0085         word    MINUS,RPOP,_ULT
fd78c     006300b9 WT1     word    _ZNE,EXIT
                   
                   
                   
                   
                   { *** MOVES & FILLS *** }
                   ' <CMOVE ( src dst cnt -- ) byte move in reverse from the ends to the start
fd790     00750082 RCMOVE  word    ROT,OVERPLUS,DEC,ROT,THIRD,PLUS,DEC,ROT,pRCMOVE,EXIT
                   
                   
                   { *** TIMING *** }
                   
fd7a4     00c5fbe8 secs    word    w+1000,MUL16
                   ' ms ( n -- ) Wait for n milliseconds
fd7a8     00610072 ms      word    QDUP,ZEXIT,_LONG
fd7ae     00004e20         long    sys_clk/1000
fd7b2     eaee00c2         word    MULTIPLY,WAIT,EXIT
                   
fd7b8     00c5d23e us      word    CLKMHZ,MUL16,w+485,MINUS,WAIT,EXIT
                   
                   
                   
                   
                   
fd7c4     00c2d22c M       word    W1000000,MULTIPLY,EXIT
fd7ca     d7cc     MB      word    KB
fd7cc     00a6f80a KB      word    w+10,_SHL,EXIT
                   
                   
                   
                   
                   
                   
                   { debug print routines - also used by DUMP etc }
                   
                   {HELP  .HEX ( n -- ) print nibble n as a hex character }
fd7d2              PRTHEX  ' ( n -- ) print n (0..$0F) as a hex character
fd7d2     f83000b2         word    BITS4,w+"0",PLUS,DUP,w+$39,GT,_IF+02,_7,PLUS,EMIT+ex
                   
fd7e6     d05bf824 HEXSYM  word    w+"$",EMIT+ex
                   
fd7ea     d7e6     PRTB    word    HEXSYM
                   {HELP  .BYTE ( n -- ) print n as 2 hex characters }
fd7ec     f8040073 PRTBYTE word    DUP,_4,_SHR,PRTHEX,PRTHEX+ex
                   
fd7f6     d7e6     PRTW    word    HEXSYM
                   {HELP  .WORD ( n -- ) print n as 4 hex characters }
fd7f8     009f0073 PRTWORD word  DUP,_SHR8
fd7fc     d7edd7ec         word  PRTBYTE,PRTBYTE+ex
                   
                   
fd800     d7e6     PRTL    word    HEXSYM
                   {HELP .LONG ( n -- ) print n as 8 hex characters }
fd802     009d0073 PRTLONG word  DUP,_SHR16,PRTWORD
fd808     d7f9d0f8         word  SCORE,PRTWORD+ex
                   
                   
fd80c     00e0fe8a DCFETCH word    rg+dmm,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd818     006300dd .L0     word    CFETCH,EXIT
fd81c     00e0fe8c DWFETCH word    rg+dmm+2,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd828     006300e0 .L0     word    WFETCH,EXIT
fd82c     00e0fe8e DFETCH  word    rg+dmm+4,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd838     d165     .L0     word    FETCHX+ex
                   
fd83a     fe8a012d SETDMP  word  RPOP,rg+dmm,_6,CMOVE,EXIT
                   
                   
fd844     00e0fe90 DUMP    word    rg+dmp,WFETCH,rg+dmp,CLRW,QDUP,SKIPZ,AJMP,DUMPB+ex
                   
fd854     0103d8e2 DMPA    word    PRTADR,IX,_16,rg+dcnt,CLRC,EXIT
fd860     fe6ed058 DSPACE  word    SPACE,rg+dcnt,CINC,rg+dcnt,CFETCH,_3,_AND,IFEXIT,SPACE+ex
                   { QUICK DUMP }
fd872     f820     QD      word    w+$20
                   '' DUMP ( addr cnt -- ) Hex dump of hub RAM - }
fd874     010a     DUMPB   word    ADO
fd876     010ad854         word      DMPA,ADO,IX,DCFETCH,PRTBYTE,DSPACE,LOOP
fd884     d8fe     DMPLP   word      DUMPASC
fd886     0113f810         word    _16,PLOOP
fd88a     f808fe8a RAM     word    rg+dmm,_8,ERASE,EXIT
                   
                   ' QUICK WORD DUMP '
fd892     f820     QW      word    w+$20
                   { DUMP as WORDs }
fd894     010a     DUMPW   word    ADO
fd896     010ad854         word      DMPA,ADO,IX,DWFETCH,PRTWORD,DSPACE,_2,PLOOP
fd8a6     d885             word      DMPLP+ex
                   
                   { DUMP as LONGs }
fd8a8     010a     DUMPL   word    ADO
fd8aa     010ad854         word      DMPA,ADO,IX,DFETCH,PRTLONG,DSPACE,_4,PLOOP
fd8ba     d885             word      DMPLP+ex
                   
                   { DUMP as ASCII WIDE }
fd8bc     d8c3f880 DUMPAW  word    w+128,DUMPS+ex
                   { DUMP as ASCII }
fd8c0     f840     DUMPA   word    w+64
fd8c2     0081     DUMPS   word    ROT2
fd8c4     010a             word    ADO
fd8c6     d8e2             word      PRTADR
fd8c8     00770103         word      IX,OVER,ATYPE
fd8ce     01130073         word    DUP,PLOOP,DROP
fd8d4     d88b             word    RAM+ex
fd8d6     0103010a ATYPE   word    ADO,IX,DCFETCH,AEMIT,LOOP,EXIT
                   
fd8e2     0103d0e2 PRTADR  word    CRLF,IX,DUP,_SHR16,DUP,_IF+03,DROP,PRTLONG,PRTCOL+ex,PRTHEX,PRTWORD
fd8f8     d05af83a PRTCOL  word    w+":",EMIT,SPACE+ex
                   
fd8fe     d0fcd074 DUMPASC word      SPACES3,PRTTICK,IX,_16,ADO,IX,DCFETCH,AEMIT,LOOP,PRTTICK+ex
                   
                   
fd912     d919f8ee _LUT    word    w+LUTFETCH,COGSET+ex
fd916     e3ea     _COG    word    w+COGFETCH
fd918     d946013f COGSET  word    _WORD,COGLUT,WSTORE,_WORD,COGDUMP,rg+dmp,WSTOREX+ex
                   
fd926              COGDUMP
fd926     0103010a         word    ADO,IX,_7,_AND,_ZEQ,_IF+09,CRLF,SPACE,SPACE,IX,_SHR8,PRTHEX,IX,PRTBYTE,PRTCOL
                   ''        word    IX,_3,_AND,SKIPNZ,SPACE
fd944     0103             word    IX
fd946     d802ebea COGLUT  word    COGFETCH,PRTLONG,DSPACE,LOOP,EXIT
                   
                   
                   
                   ' Print the stack(s) and dump the registers - also called by hitting <ctrl>D during text input
fd950     e086     DEBUG   word    PRTSTKS
fd952     d5ba             word    PRTSTR
fd954     45520a0d         byte    $0D,$0A,"REGS ",0
fd95c     f900fe00         word    rg+temp,w+$100,DUMPW
fd962     d5ba             word    PRTSTR
fd964     4f430a0d         byte    $0D,$0A,"CODE ",0
fd96c     f820d688         word    ATHERE,_32,MINUS,w+64,DUMPW
fd976     d5ba             word    PRTSTR
fd978     4f570a0d         byte    $0D,$0A,"WORDS",0
fd980     f840d68e         word    ATNAMES,w+$40,DUMPB
fd986     d996d0e2         word    CRLF,lsio
fd98a     d0e3             word    CRLF+ex
                   
                   
fd98c     d5bad0e2 PRTP    word    CRLF,PRTSTR
fd990     003a500d         byte    $0D,"P:",0
fd994     0063             word    EXIT
fd996              lsio
                   
fd996     d98c             word    PRTP
fd998     f800f83e         word    w+62,_0,DO,IX,w+10,DIVIDE,PRINT,LOOP
fd9a8     d98c             word    PRTP
fd9aa     f800f83e         word    w+62,_0,DO,IX,w+10,UMOD,PRINT,LOOP
fd9ba     d5bad0e2         word    CRLF,PRTSTR
fd9be     003a3d0d         byte    $0D,"=:",0
fd9c2     f800f83e         word    w+62,_0,DO
fd9c8     01720103         word    IX,LOW,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_1,_AND,_SHL1
fd9e2     01700103         word    IX,HIGH,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_1,_AND,_OR
fd9fc     d5a4             word    _STRING
fd9fe     68637e64         byte    "d~ch ",0
fda04     00dd0086         word    PLUS,CFETCH,EMIT,LOOP
fda0c     0063             word    EXIT
                   
                   
                   
fda0e     f8200073 QCHAR   word    DUP,_BL,w+$7E,WITHIN+ex
fda16     00b7da0e TOCHAR  word    QCHAR,_ZEQ,_IF+02,DROP,w+$20,EXIT
                   
                   ' @PAD ( -- addr ) pointer to current position in number pad
fda22     00ddfe65 ATPAD   word    rg+padwr,CFETCH,rg+numpad,PLUS,EXIT
                   
                   ' >CHAR  ( val -- ch ) convert binary value to an ASCII character
fda2c     0093f83f BINASC  word    w+$3F,_AND,w+"0",PLUS,DUP,w+"9"                 ' convert to "0".."9"
fda38     f807eb42         word    GT,_7,_AND,PLUS                                         ' convert to "A"..
fda40     f85d0073         word    DUP,w+$5D,GT,ZEXIT,_3,PLUS,EXIT                 ' skip symbols to go to "a"..
                   
                   ' <#    ' resets number pad write index to end of pad
fda4e     fe65f81a LHASH   word    w+numpadsz,rg+padwr,CSTORE,_0
                   '''
                   ' HOLD ( char -- )
fda56     d140fe65 HOLD    word    rg+padwr,CDEC,ATPAD,CSTOREX+ex
                   
                   
                   ' # ( n1 -- n2 ) convert the next ls digit of a double to a char and prepend to number string
fda5e     00e1fe0c HASH    word    rg+double,FETCH,GETBASE,UMDIVMOD64,rg+double,STORE
fda6a     da2c007e         word    SWAP,BINASC,HOLD+ex
                           ' conversion digits exhausted, use zeros or spaces
                   
                   ' #S ( d1 -- 0 ) Convert all digits
fda70     0073da5e HASHS   word    HASH,DUP,_ZEQ,_UNTIL+04,EXIT
                   
                   ' #> ( n1 -- caddr )
fda7a     da220069 RHASH   word    DROP,ATPAD,rg+double,CLRL,EXIT
                   
                   ' <D> ( d1 -- n1 ) ' Store high long of double for formating
fda84     fe0c     DNUM    word    rg+double
fda86     006300ec STOREX  word    STORE,EXIT
                   
                   
                   ' . ( n -- ) Print the number off the stack
fda8a              PRINT
fda8a     00bf0073 PRT     word    DUP,_ZLT,_IF+03,w+"-",EMIT,NEGATE
                   '''
                   ' U. ( n -- ) Print an unsigned number
fda96     da70da4e UPRT    word    LHASH,HASHS,RHASH
                   '''
                   
                   ' PRINT$ ( adr -- ) Print the null or 8th bit terminated string - stops on any non-printable character
fda9c              PRINTSTR
fda9c     008c0073         word    DUP,INC,SWAP,DCFETCH,QDUP,_IF+02,EMIT,PRINTSTR+ex
fdaac     d88b0069 pstrxt  word    DROP,RAM+ex
                   
                   ' since printing a 32-bit binary number with formatting can be quite long, this one prints directly
fdab0     d05af825 PRTBIN  word    w+"%",EMIT,_BL,FOR,DUP,w+31,_SHR,w+"0",PLUS,EMIT,_SHL1,forNEXT,DROPEX+ex
                   
                   
                   
                   
                   
                   {
                           .AS" Format string spec:
                           #       Convert one digit (default is decimal)
                           ~       Toggle leading zero suppression
                           \       pad leading zeros with spaces
                           $|      Hexadecimal
                           *|      Convert all remaining digits
                           4|      Convert 4 digits
                   }
fdaca     00970076 DZEQ    word    DUP2,_OR,_ZEQ,EXIT
                   
fdad2     f802daca AHASH   word    DZEQ,_2,rg+pflg,BITQ,_AND,_IF+02,w+$20,HOLD+ex,rg+pbase,CFETCH,UMDIVMOD64,ROT,BINASC,HOLD+ex
                   
fdaee     f804d75a ASHASH  word    _SWITCH,_4,rg+pflg,BITQ,_NOT,_4,rg+pflg,CLR,_IF+(ASCMD-.L3)/2
fdb00     d762f87c .L3     word    w+"|",ISEQ,_IF+04,_4,rg+pflg,SET,EXIT
fdb0e     d762f87e         word    w+"~",ISEQ,_IF+03,rg+pflg,CINC,EXIT
fdb1a     d762f85c         word    w+"\",ISEQ,_IF+04,_2,rg+pflg,SET,EXIT
fdb28     f801daca         word    DZEQ,_1,rg+pflg,BITQ,_AND,IFEXIT
fdb34     d762f823         word    w+"#",ISEQ,_IF+(ASONE-.L0)/2
fdb3a     dad3     .L0     word    AHASH+ex
                           ''      $| command - hexadecimal
fdb3c     d762f824 ASCMD   word    w+"$",ISEQ,_IF+03,_16,rg+pbase,CSTOREX+ex
                           ''      n| multiple # command 3 TO 9
fdb48     f833d75e         word    SWFETCH,w+"3",w+"9",WITHIN,_IF+07,SWFETCH,w+"0",MINUS,FOR,AHASH,forNEXT,EXIT
                           ''      *| Convert remaining digits
fdb60     d762f82a .L2     word    w+"*",ISEQ,_IF+05,DUP2,_OR,ZEXIT,AHASH,.L2+ex
                           ''      [| send an escape
fdb70     d762f85b         word    w+"[",ISEQ,_IF+02,w+$1B,AHOLD+ex
                           ''      @| treat simply as ASCII
fdb7a     d762f840         word    w+"@",ISEQ,_IF+03,OVER,BITS8,AHOLD+ex
                           ''      literal character
fdb86     da57d75e ASONE   word    SWFETCH,HOLD+ex
                   
                   
fdb8a     da57da16 AHOLD   word    TOCHAR,HOLD+ex
                   
                   
fdb8e     0073012d PRTAST  word    RPOP,DUP,STRLEN,INC2,_1,_ANDN,OVERPLUS,PUSHR
fdb9e     ec7efe66 PRTAS   word    rg+pflg,CLRC,w+10,rg+pbase,CSTORE
fdba8     00e1fe0c         word    rg+double,FETCH,SWAP,LHASH,DUP,STRLEN
fdbb4     00750089         word    DEC,OVERPLUS,rg+pfmt,STORE,STRLEN
fdbbe     fe68010d         word    FOR,rg+pfmt,FETCH,CFETCH,ASHASH,rg+pfmt,LDEC,forNEXT
fdbce     da7a0069         word    DROP,RHASH,PRINTSTR+ex
fdbd4     db8e013f PRTASR  word    _WORD,PRTAST,COMPW,COMPSTR+ex
                   
fdbdc     db8e     PRTDECL word    PRTAST
fdbde     232c2323         byte    "##,###,###,##~#",0
fdbee     0063             word    EXIT
                   
fdbf0     db8e     PRTDEC4 word    PRTAST
fdbf2     5c232323         byte    "###\#",0
fdbf8     0063             word    EXIT
                   
fdbfa     db8e     PRTDEC2 word    PRTAST
fdbfc     0023232e         byte    ".##",0
fdc00     0063             word    EXIT
                   {
                   PRTDEC2D
                           word    PRTAST
                           byte    "##.",0
                           word    EXIT
                   }
                   ' Print decimal with at least a single digit
fdc02     db8e     PRTDEC  word    PRTAST
fdc04     00237c2a         byte    "*|#",0
fdc08     0063             word    EXIT
                   
                   
                   '---------------------------------------------------
                   
                   
                   
                   { *** CONSOLE INPUT HANDLERS *** }
                   
                   {
                   Replaced traditional parse function with realtime stream parsing
                   Each word is acted upon when a delimiter is encountered and this also allows for
                   interactive error checking and even autocompletion.
                   }
                   
                   ' SCRUB --- scrub out any temporary compiled code, restore the code pointers etc.
fdc0a     fea2d688 SCRUB   word    ATHERE,rg+codes,STORE
fdc10     ec7efe23         word    rg+wordcnt,CLRC,rg+wordbuf,CLRC
                   ''      restore end-of-line delimiter to a CR
fdc18     fe6df80d         word    _13,rg+delim+1,CSTORE
                   ''      print long line of dashes
fdc1e     f82dd0e8 PRTDASH word    CR,w+"-",w+79,EMITS+ex
                   
                   ' ( ch -- ) write a character into the next free position in the word buffer
fdc26     00dafe23 PUTCHAR word    rg+wordcnt,CFETCHINC,PLUS,CSTOREX+ex
                   
fdc2e              PUTCHARPL
fdc2e     fe23dc26         word    PUTCHAR,rg+wordcnt,DUPCFT,INC
fdc36     00cdf827         word    w+wordsz,UMOD,SWAP,CSTOREX+ex
                   
                   ' As characters are accepted from the input stream, checks need to be made for delimiters,
                   ' editing commands etc. 123us/CHAR, 184us/CTRL
fdc3e              doCHAR  ' ( char -- flg ) Process char into wordbuf and flag true if all done
                   '       ignore null
fdc3e     00610073         word    DUP,ZEXIT
                   '       delimiter is always last character
fdc42     fe6d0073         word    DUP,rg+delim+1,CSTORE
                   '       Replace DEL with BS
fdc48     0077f87f         word    w+$7F,OVER,_EQ,_IF+02,DROP,_8
                   '       only check for control characters
fdc54     f8200073 dch1    word    DUP,_BL,LT,_IF+(ischar-ctrls)/2
                   '
                   ' PROCESS CONTROL CHARACTERS
                   '
fdc5c              ctrls
                   ''              discard LF
fdc5c     0077f80a         word    w+$0A,OVER,_EQ,SKIPZ,DROPFEX+ex
                   ''              ^W WORDS
fdc66     0077f817         word    w+$17,OVER,_EQ,_IF+04,DROP,WORDS,CRLF,FALX+ex
                   ''              ^R FIXDICT
                   ''      word    w+$12,OVER,_EQ,_IF+03,DROP,FIXDICT,FALX+ex
                   
                   '               ^X reeXecute previous compiled line
fdc76     0077f818         word    w+$18,OVER,_EQ,_IF+02,DROP,TRUEX+ex
                   ''              ^C RESET
fdc82     0077f803         word    _3,OVER,_EQ,SKIPZ,RESET
                   '               ^R RESTORE
fdc8c     0077f812         word    w+$12,OVER,_EQ,_IF+03,DROP,RESTORE,TERMINAL
                   ''              ^V VERSION
fdc9a     0077f816         word    w+$16,OVER,_EQ,_IF+02,PRTVER,CONSOLE+ex
                   '               ^D DEBUGGER
fdca6     0077f804         word    _4,OVER,_EQ,_IF+03,DROP,DEBUGGER,FALX+ex
                   '               ^? DEBUG
fdcb4     0077f81f         word    w+$1F,OVER,_EQ,_IF+03,DROP,DEBUG,FALX+ex
                   
                   '               ^Q print top stack
fdcc2     0077f811         word    w+$11,OVER,_EQ,_IF+04,DROP,PRTSTK,CRLF,FALX+ex
                   '               ^S clear Stack
fdcd2     0077f813         word    w+$13,OVER,_EQ,_IF+03,DROP,INITSP,FALX+ex
                   '               ^B Block dump
fdce0     0077f802         word    _2,OVER,_EQ,_IF+06,DROP
fdcea     f900f800         word    _0,w+$100,_SHL8
fdcf0     d2d7d874         word    DUMPB,FALX+ex
                   '               ^K  --- ^Z^Z cold start
fdcf4     0077f80b         word    w+$0B,OVER,_EQ          '''rg,prevch+1,CFETCH,w+$1A,_EQ,_AND
fdcfa     0069fc03         word    _IF+03,DROP,COLDST,RESET        '''SCRUB,FALX+ex
fdd02              ignore2
fdd02     0077f81b         word    w+$1B,OVER,_EQ,_IF+03,DROP,SCRUB,TRUEX+ex                               ' ESC will cancel line
fdd10     0077f809 ig01    word    _9,OVER,_EQ,_IF+02,EMIT,_BL                                             ' TAB - substitute with a space
fdd1c     0077f81c ig02    word    w+$1C,OVER,_EQ,_IF+03,DROP,CRLF,_BL                                     ' ^| - multi-line interactive
fdd2a     0077f80d ig03    word    _13,OVER,_EQ,_IF+02,DROP,TRUEX+ex                                       ' CR - Return & indicate completion
fdd36              ig04    '
fdd36     0077f808         word    _8,OVER,_EQ,_IF+(ischar-bksp1)/2                                        ' BKSP - null out last char
fdd3e     00ddfe23 bksp1   word    rg+wordcnt,CFETCH,_IF+09                                                ' don't backspace on empty word
fdd44     d058d05a bksp2   word    EMIT,SPACE,_8,EMIT                                                      ' backspace and clear
fdd4c     d140fe23         word    rg+wordcnt,CDEC,_0,PUTCHAR                                              ' null previous char
fdd54     d2d7             word    FALX+ex
                           ''                      '
fdd56     d05af807 bksp3   word    _7,EMIT,DROPFEX+ex                                                      ' can't backspace anymore, bell
                           '
fdd5c     d100f801 ischar  word    w+echo,CHKFLG,_IF+02,DUP,EMIT                                           ' don't echo if we don't want it
fdd66     00ddfe6c .L0     word    rg+delim,CFETCH,OVER,_EQ                                                ' delimiter? (always accept a blank)
fdd6e     f8200077         word    OVER,_BL,_EQ,_OR,_IF+04,DROP,rg+wordcnt,CFETCH,EXIT                     ' true if trailing delimiter - all done (flg=cnt)
                           '
                           ' otherwise build text in wordbuf - null terminated with a preceding count .....
fdd80     d2d7dc2e .L1     word    PUTCHARPL,FALX+ex                                                       ' put a character into the word buffer
                   
                   ' Build a delimited word in wordbuf for wordcnt and return immediately upon a valid delimiter
fdd84              _GETWORD        ' ( -- str )
                   '       Erase the word buffer & preceding count
fdd84     f827fe23         word    rg+wordcnt,w+wordsz,ERASE
                           'word   w+6,PEN
                   '       get another character
fdd8a     dc3ee114         word    WKEY,doCHAR,_UNTIL+03
                           'word   PLAIN
fdd90     0063fe24         word    rg+wordbuf,EXIT
                   
                   
                   { ****************** DICTIONARY SEARCH ********************** }
                   
                   ' SEARCH ( cstr -- nfaptr )                                             ' cstr points to the count+strinw+null
fdd94              SEARCH
fdd94     ec86fe7e         word    rg+ufind,QJMP                                           ' use alternative method if enabled (hash search)
fdd98     d68e0073         word    DUP,ATNAMES,FINDSTR
fdd9e     fc020072         word    QDUP,_IF+02,NIP,EXIT                                    ' found it - return now with result
fdda6     d2d70069 DROPFEX word    DROP,FALX+ex                                            ' not found in dictionary
                   
                   
                   
                   
                   
                   ' Discard the current line
fddaa              DISCARD
fddaa     00b7e0c2 dslp    word    KEY,_ZEQ,_UNTIL+03                                              ' fast discard
fddb0     d7a8f814 ds01    word    w+20,ms,KEY,_ZEQ,_UNTIL+08,EXIT                                ' pause and check and repeat if necessarys
                   
fddbc     ebfe     ATID    word    _COGID
                   ' TASK ( cog -- addr ) Return with address of task control register in "tasks"
fddbe     00a6f803 TASK    word    _3,_SHL,_WORD,tasks,PLUS,EXIT
                   
                   { TASK RECORD
                   0       ENTRY CODE ADDRESS
                   4       flags
                   
                   }
                   
fddca     ea12     IDLE    word    INITSTKS
fddcc     f808ddbc         word    ATID,_8,ERASE					' clear this cog's task registers
fddd2     ddbcf801 idlp    word    _1,ATID,_3,PLUS,CPLUSST                         ' increment task+3 to indicate Tachyon running
                           'word    w+10,ms                                         ' do nothing for a bit - saves power (but not with P2)
fdddc     00e0ddbc         word    ATID,WFETCH                                     ' fetch cog's task variable
fdde0     fc890072         word    QDUP,_UNTIL+09                                  ' until it is non-zero
fdde4     002d             word    ACALL                                           ' Execute
fdde6     ec72ddbc         word    ATID,CLRW                                       ' clear run address only if it has returned back to idle
fddea     ddcb             word    IDLE+ex
                   
                   
fddec     fea6d662 AUTORUN word    TICK,rg+autovec,WSTOREX+ex
                   
fddf2     33253130 radix   byte    "01%34567o9#BCDEF$ "
                   
                           ''      List line number if enabled
fde04              PROMPT
                           ''      execute user prompt code
fde04     00e0fe70         word    rg+uprompt,WFETCH,QDUP,_IF+02,ACALL,trl1+ex
fde10     00e0feae         word    rg+linenum,WFETCH,_IF+08
                           ''      display line#
fde16     feaed0e8         word    CR,rg+linenum,WFETCH,PRTDEC4,SPACES3
                           ''      increment line#
fde20     d150feae         word    rg+linenum,WINC,EXIT
                           ''      Prompt with version and base
fde26     d5ba             word    PRTSTR
fde28     4f514154         byte    "TAQOZ",0
                           ''      prompt char = base %#$ etc
fde2e     013fd28e         word    GETBASE,_WORD,radix,PLUS,CFETCH,EMIT,SPACE+ex
                   
                   
                   
                   ' COLD  Force factory defaults
fde3c              COLDST
fde3c              FIXDICT         ' Copy dictionary from ROM to area just before copied ROM in bank 0'
fde3c     013d             word    _LONG
fde3e     000ff466         long    romdict
fde42     013d             word    _LONG
fde44     0000b400         long    ramdict
fde48     0b4a013f         word    _WORD,enddict-romdict,CMOVE
                   ''              initialize task registers
fde4e     f900fe00         word    rg+0,w+$100,ERASE
                   ''              free memory                   backup
fde54     1000013f         word    _WORD,codeorg
fde58     fe9e0073         word    DUP,rg+here,STORE,rg+here-4,STORE
fde62     ed42013f         word    _word,endcode,DATORG
fde68     013d             word    _LONG
fde6a     0000b400         long    ramdict
fde6e     00ecfe96         word    rg+names,STORE
                   ''        word    DUP,rg+names,STORE,rg+oldnames,STORE
                   '               reset cold start
fde72     d5bad094 XCOLD   word    _CON,PRTSTR
fde76     200a0d78         byte    "x",$0D,$0A,"  Cold start",0
fde86     a55a013f         word    _WORD,$A55A,rg+cold,WSTOREX+ex
                   
                   
                   { *** MAIN TERMINAL CONSOLE ***  }
fde8e              TERMINAL
fde8e     e9c6ea1e         word    InitRP,INITSP                                           ' Init the internal stack and setup external stack space
fde92     f832d264         word    WP,w+50,ms                                                      ' a little startup delay (also wait for serial cog)
fde98     f960f810         word    w+$10,w+$160,ERASE
                           ''      performing a check for a saved session
fde9e     00e0feaa         word    rg+cold,WFETCH,_WORD,$A55A,_NEQ,SKIPZ,COLDST
fdeac     d094             word    _CON
fdeae     ec72fe14         word    rg+keypoll,CLRW,rg+accept,CLRW
fdeb6     ec72feae         word    rg+linenum,CLRW
fdeba     fe20f801         word    _1,rg+fflags,WSTORE
                   
                           ''      Show VERSION with optional CLS (default CR)
fdec0     dc1ed0e2         word    CRLF,PRTDASH,CRLF,DECIMAL,PRTVER
                   ''      word    _GETRND,rg+bootsig,STORE
                   
                           ''      ^A abort autostart with ^A
fdeca     00ddf8f0         word    w+lastkey,CFETCH,_1,_NEQ,_IF+(CS1-.L0)/2
                           ''      check for an AUTORUN
fded4     00e0fea6         word    rg+autovec,WFETCH,QDUP,SKIPZ,ACALL
                           ''      Set the rx buffer size
fdede              .L0     ''      echo on
fdede     fe20f801         word    w+echo,rg+fflags,CSTORE
                           ''      default delimiter is a space character
fdee4     fe6cf820         word    _BL,rg+delim,CSTORE
                   
                           '
fdeea     dc0aea1e CONSOLE word    InitRP,SCRUB,CRLF
                           ''      Stop compilation
fdef0     d106f880 CS1     word    w+defining,CLRFLG
                           '
                           ' ***   Main console line loop - get a new line (word by word) ***
                           '
                   
                   
                   '-------------------------------------------------------------
                   
                   
fdef4     de04     LINELP  word    PROMPT
                           ''      reset temporary code compilation pointer
fdef6     fea2d688 trl1    word    ATHERE,rg+codes,STORE
                           '
                           ''      Main console loop - read a word and process
fdefc     dd84     WORDLP  word    _GETWORD
fdefe     fe21f804         word    _4,rg+fflags+1,CLR
                           ''      ignore empty string
fdf04     00b700dd         word    CFETCH,_ZEQ,_IF+(EVAL-.L0)/2
                           ''      ^X then repeat last line
fdf0a     00ddfe6d .L0     word    rg+delim+1,CFETCH,w+$18,_NEQ,_IF+(execinp-.L2)/2
                           ''      Otherwise process ENTER
fdf14     00ddfe6d .L2     word    rg+delim+1,CFETCH,_13,_NEQ,_IF+(chkeol-EVAL)/2
                           ''      good, try to process this as a number first (for speed)
fdf1e     00b7d464 EVAL    word    QFNUM,_ZEQ,_IF+(TRYNUM-trm4)/2
                           ''      otherwise search the dicitonary for a match (as a counted string)
fdf24     0089fe24 trm4    word    rg+wordbuf,DEC,SEARCH
                           ''      found it
fdf2a     fc3c0072         word    QDUP,_IF+(TRYNUM-foundword)/2
                           ''      found the word in the dictionary - compile or execute?
fdf2e              foundword
                   '               point to attribute word (CNT,<NAME>,ATR,CPA)
fdf2e     d6640073         word    DUP,NFACFA  ' ( cpa cfa )
                           ''      is the immediate bit set?
fdf32     00dd007e         word    SWAP,CFETCH,_6,_SHR,w+preatr,_EQ
                           ''      and comp flag off (not forced to compile with [COMPILE])
fdf3e     d100f840         word    w+comp,CHKFLG,_ZEQ,_AND
                           ''              Fetch and EXECUTE code immediately
fdf46     002dfc02         word    _IF+02,ACALL,chkeol+ex
                   
fdf4c              compword
                           ''      or else COMPILE the wordcode(s) for this word
fdf4c     d600             word    COMPW
                           ''      reset any forced compile mode via [COMPILE]
fdf4e     d106f840         word    w+comp,CLRFLG
                           ''      *** END OF LINE CHECK ***
fdf52     00ddfe6d chkeol  word    rg+delim+1,CFETCH,_13,_EQ
fdf5a     fc0a0073         word    DUP,_IF+(eol01-.L0)/2
                           ''      Yes, put a space between any user input and response
fdf5e     00e0fe72 .L0     word    rg+accept,WFETCH,QDUP,_IF+02,ACALL,eol01+ex
fdf6a     d5ba     	word	PRTSTR
fdf6c     2d2d2d20 	byte	" --- ",0
                           ''      and are we in a definition or interactive?
fdf72     f8800073 eol01   word    DUP,w+defining,CHKFLG,_AND
                           ''      If not interactive then CRLF (no other response)
fdf7a     d0e2fc01         word    SKIPZ,CRLF
                           ''      do not execute if still defining
fdf7e     d100f880 eol02   word    w+defining,CHKFLG,_ZEQ,_AND
                           ''      wait until CR to execute compiled codes
fdf86     fcc6             word    _UNTIL+(.L0-WORDLP)/2
fdf88              .L0
fdf88              execs   ''      EXECUTE CODE from user input (append an EXIT first)
fdf88     d600f863         word    w+EXIT,COMPW
                           ''      execute wordcodes from beginning
fdf8c     002dd688 execinp word    ATHERE,ACALL
                           ''      execute accept vector if 0<>
fdf90     00e0fe72         word    rg+accept,WFETCH,QDUP,_IF+02,ACALL,LINELP+ex
fdf9c     00e0feae         word    rg+linenum,WFETCH,SKIPNZ,OK,LINELP+ex
                   '-------------------------------------------------------------
                   
fdfa6              TRYNUM  ''      Attempt to process this word as a number but check for special literals first (^ ' etc)
fdfa6     d40afe24         word    rg+wordbuf,NUMBER,_IF+02
                           ''      is it a number? ( value digits )
fdfac     df53d48e compnum word    LITCOMP,chkeol+ex
                   
                           ''      Unknown word or number - try converting case first time
fdfb0     00ddfe21 UNKNOWN word    rg+fflags+1,CFETCH,_4,_AND,_ZEQ
fdfba     f804fc06         word    _IF+06,_4,rg+fflags+1,CPLUSST
fdfc2     d296fe24         word    rg+wordbuf,TOUPPER,trm4+ex
                           ''      UNKNOWN - try unum vector if set
fdfc8     00e0fe7c         word    rg+unum,WFETCH,QDUP,_IF+02,ACALL,chkeol+ex
                   '
                   ' Failed all searches and conversions!!!!
                   '
                           ''      interactive or in the middle of a definition?
fdfd4     fe20f880         word    w+defining,rg+fflags,CFETCH,_AND,_IF+(HUH-nfdef)/2
                           ''      Display position in line of error
fdfde     d5ba     nfdef   word    PRTSTR
fdfe0     20200909         byte    9,9,"  error in ",0
                   	''	display latest definition
fdfee     00dad68e         word    ATNAMES,CFETCHINC,w+$1F,_AND,CTYPE,PRTSTR
fdffa     74612020         byte    "  at ",0
                           ''      Spit out offending word
fe000     da9cfe24         word    rg+wordbuf,PRINTSTR,SPACE
                           ''      discard but echo remainder of line
fe006     0073e114 .L0     word    WKEY,DUP,_13,_NEQ,_IF+02,EMIT,.L0+ex,DROP
                   	'word	DEBUG
                   
                           ''      count errors and force a new line to display error
fe016     d150feac ERROR   word    rg+errors,WINC	'',CR,w+$10A,EMIT
fe01a     d5ba     ERRSTR  word    PRTSTR
fe01c     72652a20         byte    " *error* ",7,$0D,$0A,$0B,0
                           '
                           ''      force a new line to prevent overwrite then return to console
fe02a     d05af90a         word    w+$10A,EMIT,DISCARD,INITSP,_END,CONSOLE+ex
                   
                           ' as-you-go error prompt in interactive mode
fe036     d5ba     HUH     word    PRTSTR
fe038     3f3f3f20         byte    " ??? ",0
fe03e     defd             word    WORDLP+ex
                   
                   
fe040     d5bad0e2 PRTSTK  word    CRLF,PRTSTR
fe044     54414420         byte    " DATA STACK (",0
fe052     0073ed2e         word    _DEPTH,DUP,PRINT1
fe058     0061             word    ZEXIT
fe05a     0073ed2e         word    _DEPTH,DUP,_0
fe060     d0e2010b         word    DO,CRLF,IX,INC,PRINT,SPACES3,DEC,DUP,INC4,LUTFETCH,DUP,PRTL,SPACES3,PRINT,LOOP
fe07e     d091             word    DROPEX+ex
fe080     f829da8a PRINT1  word    PRINT,w+")",EMIT+ex
                   
fe086     e040     PRTSTKS word    PRTSTK
fe088     d5bad0e2 PRTRET  word    CRLF,PRTSTR
fe08c     54455220         byte    " RETURN (",0
fe096     f814f840         word    w+retstk,w+retptr
fe09a     0076ebea PRTSTKX word    COGFETCH,DUP2,SWAP,MINUS,PRINT1
fe0a4     007ed074 DMPSTK  word    SPACES3,SWAP
fe0a8     00bc0076 .L0     word    DUP2,_NEQ,_IF+06,DUP,LUTFETCH,SPACE,PRTL,INC,.L0+ex,DROP2,EXIT
                   
                   
                   ' KEY! ( ch -- ) Force a character as the next KEY read
fe0be              PUTKEY
fe0be     da87fe74         word    rg+keychar,STOREX+ex
                   
                   ' KEY ( -- ch ) if ch is zero then no key was read
fe0c2              KEY
fe0c2     00ddfe74         word    rg+keychar,CFETCH,QDUP,_IF+06                   ' read a "key" that was forced with KEY!
fe0ca     00e1fe74         word    rg+keychar,FETCH,_SHR8,rg+keychar,STORE,CHKKEY+ex
fe0d6     00e0fe12         word    rg+ukey,WFETCH,_IF+06,rg+ukey,WFETCH,ACALL
fe0e2     005e0073         word    DUP,IFEXIT,DOPOLL+ex
fe0e8     ea6e     CONKEY  word    READRX
fe0ea     fc070073 DOKEY   word    DUP,_IF+07
fe0ee     007300b3         word    BITS8,DUP,_ZEQ,ZEXIT                            ' return as if non-zero
fe0f6     0086f900         word    w+$0100,PLUS,EXIT                               ' otherwise add $100 to a null
                          '
fe0fc     ec86fe14 DOPOLL  word    rg+keypoll,QJMP                                 ' execute background polling while waiting for input
fe100     0063             word    EXIT
                   
                   ' keep a track of the position of the this key on the input line (useful for assembler etc)
fe102     d144fe22 CHKKEY  word    rg+keycol,CINC,DUP,_13,_EQ,ZEXIT,rg+keycol,CLRC,EXIT
                   
                                                           ' background polling while waiting for a key
                   
                   ' WKEY ( -- ch ) wait for a key and return with character
fe114     0072e0c2 WKEY    word    KEY,QDUP,_UNTIL+03,BITS8,EXIT
                   
                   
                   
                   { *** COMMENTING *** }
                   
                   ''      \       ( -- )
                   ''      Ignore following text till the end of line.
                   ''      IMMED
fe11e              COMMENT
fe11e     00ddfe6d         word    rg+delim+1,CFETCH,_13,_NEQ,ZEXIT                        ' ignore is this is an empty line
fe128     f80de0c2 .L0     word    KEY,_13,_EQ,_UNTIL+04                                   ' terminate comment on a CR
fe130     fe74f80d         word    _13,rg+keychar,STOREX+ex                                ' force a CR back into the key stream on exit
                   
fe136     0073e0c2 PAREN   word    KEY,DUP,QEMIT,w+")",_EQ,_UNTIL+06,EXIT
                   
fe144     00b7d64e IFDEF   word    NFATICK,_ZEQ,ZEXIT,BRACE+ex
                   
fe14c     0061d64e IFNDEF  word    NFATICK,ZEXIT
                           ''''
                   ' Block comments - allow nested  operation
                           ''''
fe150              BRACE
fe150     f801             word    _1                                              ' allow nesting by counting braces
fe152     e114     .LP     word    WKEY                                            ' keep reading each char until we have a matching closing brace
fe154     f87b0073         word    DUP,w+"{",_EQ,_IF+03,DROP,INC,.LP+ex    ' add up opening braces
fe162     00b5f87d         word    w+"}",_EQ,SKIPZ,DEC                             ' count down closing braces
fe16a     00b70073         word    DUP,_ZEQ,_UNTIL+15,DROPEX+ex
                   
                   
                   
                   ' 06,F,O,R,G,E,T,CODEL,CODEH
                   
fe172     d63ed64e FORGET  word    NFATICK,GRAB,QDUP,_IF+17
fe17a     00de0073         word    DUP,DUPCFT,PLUS,_3,PLUS,rg+names,STORE
fe188     008600de         word    DUPCFT,PLUS,INC,WFETCH,DUP,rg+here,STORE
fe196     007ef863         word    w+EXIT,SWAP,WSTOREX+ex
fe19c              NOTFOUND
fe19c     d5ba             word    PRTSTR
fe19e     746f6e20         byte    " not found ",0
fe1aa     0063             word    EXIT
                   
                   ' >W
fe1ac     0091f810 TOW     word    w+16,BITS,EXIT
                   ' L>W
fe1b2     e1ac0073 L2W     word    DUP,TOW,SWAP,_SHR16,EXIT
                   ' W>B ( word bytel byteh )
fe1bc     00b30073 W2B     word    DUP,BITS8,SWAP,_SHR8,BITS8,EXIT
                   
fe1c8     0136e1d2 B2L     word    B2W,PUSHL,B2W,LPOP
fe1d0     00ac     W2L     word    _SHL8
fe1d2     d4c100ac B2W     word    _SHL8,ORX+ex
                   
                   
                   ' CTYPE ( str cnt -- )
fe1d6     0103010a CTYPE   word    ADO,IX,CFETCH,TOCHAR,EMIT,LOOP,EXIT
                   
                   
                   
                   ' .VER
fe1e4              PRTVER
fe1e4     d5ba             word    PRTSTR
                                   '12345678901234567890123456789012345678901234567890123456789011'
fe1e6     61502020         byte    "  Parallax P2  .:.:--TAQOZ--:.:.  V",0
fe20a     d04c013f         word    _WORD,@taqoz_version,FETCH,PRTAST
fe212     2e237e23         byte    "#~#.#--",0
fe21a     d054013f         word    _WORD,@taqoz_name,_4,CTYPE
fe222     d076f809         word    w+9,SPACES,_WORD,@taqoz_time,FETCH,PRTAST
fe22e     342d7c36         byte    "6|-4|",0
fe234     d0e3             word    CRLF+ex
                   
                   
                   {
                   00.2488: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
                   DICTIONARY
                   00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
                   00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
                   00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P..SWAPu..2SWAP
                   00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
                   }
                   
fe236     d68ed0e2 WORDS   word    CRLF,ATNAMES
fe23a     ec66feb2         word    rg+spincnt,CLRL
fe23e     00e0feb2 .l0     word    rg+spincnt,WFETCH,w+70,GT,_IF+03,CRLF,rg+spincnt,CLRW
fe24e     fc1100de         word    DUPCFT,_IF+17
fe252     d150feb4         word    rg+spincnt+2,WINC
                           '       track width '
fe256     f81f00de         word    DUPCFT,w+cntm,_AND,INC,rg+spincnt,WPLUSST
fe262     00da0073         word    DUP,CFETCHINC,w+cntm,_AND,CTYPE,SPACE,NFACPA,INC2,.l0+ex
fe274     feb40069         word    DROP,rg+spincnt+2,WFETCH,SPACE,PRTDEC+ex
                   
                   {
                   PRT3S   word    LHASH,HASH,HASH,HASH,w+".",HOLD,HASHS,RHASH,PSTR+ex
                   
                   PRTF    word    CLKHZ,_WORD,10000,UDIVIDE,DUP,w+100,UMOD,_IF+02
                           word    PRT3S,.L0+ex
                           word    w+100,UDIVIDE,PRINT
                   .L0     word    PRTSTR
                           byte    "MHz",0
                           word    EXIT
                   }
                   
fe27e              ELAPSED
fe27e     01c7eaa2 LAPCAL  word    LAPFETCH,LAP,LAP,LAPFETCH,MINUS,EXIT
                   
                   
                   ' .LAP          LAP@  LAP LAP LAP@ -  DUP DEC . ."  cycles = "
fe28a     e27e     PRTLAP  word    LAPCAL
fe28c     d2860073 PRTCYC  word    DUP,DECIMAL,PRINT,PRTSTR
fe294     63796320         byte    " cycles = ",0,0
                           ''      DUP CLKHZ < IF 100 * 3 >> ELSE
fe2a0     d2320073 REPLAP  word    DUP,CLKHZ,LT,_IF+17,w+100,MULTIPLY,_3,_SHR,.L0+ex
                           ''      CLKHZ U// PRINT DOT #1000 CLKHZ */ PRINT ." sec" EXIT THEN
fe2b2     00cad232         word    CLKHZ,UDIVMOD,PRINT,DOT,w+1000,CLKHZ,MULDIV,PRINT,PRTSTR
fe2c4     00636573         byte    "sec",0
fe2c8     0063             word    EXIT
                           ''      DUP #999999 > IF #1,000,000 U// PRINT DOT  #1000 U/ PRINT ." ms " EXIT THEN
fe2ca     d22c0073 .L0     word    DUP,W1000000,EQGT,_IF+11,W1000000,UDIVMOD,PRINT,DOT,w+1000,UDIVIDE,PRINT,PRTSTR
fe2e2     0020736d         byte    "ms ",0
fe2e6     0063             word    EXIT
                           '       DUP #999 > IF #1,000 U// PRINT DOT PRINT ." us" EXIT THEN
fe2e8     fbe80073 .L1     word    DUP,w+1000,EQGT,_IF+09,w+1000,UDIVMOD,PRINT,DOT,PRINT,PRTSTR
fe2fc     00207375         byte    "us ",0
fe300     0063             word    EXIT
                           '       PRINT ." ns "
fe302     d5bada8a .L2     word    PRINT,PRTSTR
fe306     0020736e         byte    "ns ",0
fe30a     0063             word    EXIT
                   
                   ' .ms           LAP@ LAP LAP LAP@ - ~l ;
fe30c     e2a1e27e PRTMS   word    LAPCAL,REPLAP+ex
                   
                   
                   
                   
fe310     0000ed42 _datorg long    endcode&$FFFF
fe314     0000ed42 _datptr long    endcode&$FFFF
                   
fe318     e314013f ATDAT   word    _WORD,_datptr,FETCHX+ex
fe31e     013f0073 DATORG  word    DUP,_WORD,_datorg
fe324     013f00ec         word    STORE,_WORD,_datptr,STOREX+ex
                   
                   ' pub res ( bytes -- )                  _datptr +! ;
fe32c     e314013f dres    word    _WORD,_datptr,PLUSST,EXIT
                   
                   ' pre words                             [C] GRAB 2* [C] BYTES ;
                   ' pre LONGS                             [C] GRAB 4* [C] BYTES ;
                   ' pre BYTES ( bytes <name> -- )         [C] GRAB DATPTR SWAP res [C] DATCON ;
fe334     00aed63e dlongs  word    GRAB,_SHL1
fe338     00aed63e dwords  word    GRAB,_SHL1
fe33c     e318d63e dbytes  word    GRAB,ATDAT,SWAP,dres,_DATCON+ex
fe346     e33df801 dbyte   word    _1,dbytes+ex
fe34a     e33df802 dword   word    _2,dbytes+ex
fe34e     e33df804 dlong   word    _4,dbytes+ex
                   
                   
                   
                   
fe352     fe20f801 _ECHO   word    w+echo,rg+fflags,ROT,BITST,EXIT
                   
                   ' TAQOZ marks the start of a block of source code to be compiled in block mode
                   '
fe35c              _TAQOZ
fe35c     e1e4             word    PRTVER
                           ''      disable background keypoll during load & reset error count
fe35e     ec72fe14         word    rg+keypoll,CLRW,rg+errors,CLRW
                           ''      remember code position for reporting
fe366     fe9ad688         word    ATHERE,rg+fromhere,STORE
                           ''      reset line# to 1 to active
fe36c     feaef801         word    _1,rg+linenum,WSTORE,_0,_ECHO
                           ''      backup dictionary pointer
                   ''        word    ATNAMES,rg+oldnames,STORE
                           ''      time the load
fe376     feb2eaf6         word    _GETCNT,rg+spincnt,STOREX+ex
                   
                   ' end of block load mode  TAQOZ <source> END
                   '
fe37c     e3520141 _END    word    _TRUE,_ECHO
                           ''      read linenum and clear to exit line mode
fe380     00e0feae         word    rg+linenum,WFETCH,rg+linenum,CLRW
fe388     dc02d0e2         word    CRLF,PRTDEC,PRTSTR
fe38e     6e696c20         byte    " lines and ",0
fe39a     fe9ad688         word    ATHERE,rg+fromhere,FETCH,MINUS,PRTDECL,PRTSTR
fe3a6     74796220         byte    " bytes compiled,  with ",0
fe3be     00e0feac         word    rg+errors,WFETCH,PRTDEC,PRTSTR
fe3c6     72726520         byte    " errors in ",0
                           ''      report compile time
fe3d2     feb2eaf6         word    _GETCNT,rg+spincnt,FETCH,MINUS,CLKKHZ,UDIVIDE,PRTDECL,PRTSTR
fe3e2     0020736d         byte    "ms ",0
fe3e6     d107f802         word    _2,CLRFLG+ex
                   
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''
                   '                SERIAL FLASH
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''
                   
                   
                           ''( &cs.so.si.ck -- )
fe3ea     e3f8013f SFPINS  word    _WORD,_sfpins,STOREX+ex
                   
fe3f0     f806e43e SFWE    word    SFBSY,w+6,SFINS
fe3f6     013d     SFINS   word    _LONG
fe3f8     3d3a3b3c _sfpins long    flashpins
fe3fc     01b8ebaa         word    SPIPINS,SPICE,SPIWR8,EXIT
                           '' SFWE ( ins -- )
fe404     d0b7f804 SFWD    word    _4,SPINNER+ex
                   
fe408     f805     SFSTAT  word    _5
fe40a     f800e3f6 SFRD1   word    SFINS,_0,SPIRD,SPIX+ex
                   
                   
                           ''( Read serial Flash serial number )
fe412     e3f6f84b SFSID   word    w+$4B,SFINS
fe416     018ff800 SFRDD   word    _0,SPIRDL,SPIRDL
fe41c     018ff800 SFRDL   word    _0,SPIRDL,SPIX+ex
                           ''( Read serial Flash Jedec ID )
fe422     e3f6f89f SFJID   word    w+$9F,SFINS,SFRDL+ex
fe428     d800e422 PRTSF   word    SFJID,PRTL,SPACE,SFSID,PRTL,SCORE,PRTL+ex
                   
                           ''( addr -- )
fe436     f820     SFER4   word    w+$20
fe438     01b2e3f0 SFER    word    SFWE,SPIWM,SPICE
fe43e     00b7e408 SFBSY   word    SFSTAT,_ZEQ,_UNTIL+03,EXIT
                   
                           ''( addr -- )
fe446     e439f852 SFER32  word    w+$52,SFER+ex
                           '' SFER64K ( addr -- )
fe44a     e439f8d8 SFER64  word    w+$D8,SFER+ex
                   
fe44e     e3f0f8c7 SFERALL word    w+$C7,SFWE,SPIX+ex
                   
                           '' SFWRPAGE ( src dst -- )
fe454     e3f0f802 SFWRPAGE word   w+$02,SFWE,SPIWM,w+256,SPITX,SPIX+ex
                   
                   
                           '' BACKUP the first 64K of memory into flash
fe460     0073e422 BACKUP  word    SFJID,DUP,INC,_AND,ZEXIT        'EXIT IF BLANK ID'
                           '' Write block 0 to Flash block 0
fe46a     e44ad244         word    BRORG,SFER64
fe46e     e4ac013f         word    _WORD,brstr,FETCH,_4,STORE
fe478     d244f800         word    _0,BRORG,w+64,KB
                           ''SFWRS ( hubsrc sfdst cnt -- )
fe480     007e0082 SFWRS   word    ROT,SWAP,ADO,IX,OVER,SFWRPAGE,SPINNER,w+256,PLUS,w+256,PLOOP,DROPEX+ex
fe498     0191f800 SFRDW   word    _0,SPIRD,_0,SPIRD,_SHL8,ORX+ex
                           '' SFR ( addr -- )
fe4a4     e3f6f803 SFRD    word    _3,SFINS,SPIWM,EXIT
                   
fe4ac     4f514154 brstr   byte    "TAQO"
                           '' RESTORE TAQOZ from FLASH by copying to $1.0000 first'
fe4b0     008ad244 RESTORE word    BRORG,INC4,SFFETCH,_WORD,brstr,FETCH,_EQ,ZEXIT
                   ''      word    BRORG,_WORD,$1000,PLUS,_WORD,$1000,_WORD,$F000,SFRDS,EXIT
fe4c0     1000013f         word    _WORD,$1000,BRORG,OVERPLUS,SWAP,_WORD,$F000
                           '' ( sfadr dst cnt -- ) '' read block from SF to RAM
fe4ce     e4a40082 SFRDS   word    ROT,SFRD,SPIRX
fe4d4     006301b8 SPIX    word    SPICE,EXIT
                   {
                   
                   '' SFRDS ( sfsrc hubdst bytes -- )
                   SFRDS   word    ROT,SFRD,ADO,_0,SPIRD,IX,CSTORE,LOOP,SPIX+ex
                   }
                   
                           '' SFC@
fe4d8              SFCFETCH
fe4d8     f800e4a4         word    SFRD,_0,SPIRD,SPIX+ex
                           ''pub SFW@
fe4e0              SFWFETCH
fe4e0     e498e4a4         word    SFRD,SFRDW,SPIX+ex
                   
                           ''pub SF@ ( addr -- long )
fe4e6     e498e4a4 SFFETCH word    SFRD,SFRDW,SFRDW,_SHL16,_OR,SPIX+ex
                   
                           '' SF  Select Serial Flash as memory for DUMP words
fe4f2     e4d8d83a SF      word    SETDMP,SFCFETCH,SFWFETCH,SFFETCH
                   
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   '''''''''''''''''''''''''' SD CARD SUPPORT '''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   CON
                   SDCS    = w|sd_cs
                   SDCK    = w|sd_ck
                   SDBUFS  = $10000
                   
                   dtk     = w|$FE
                   
                   BLKSIZ  = w|512
                   DAT
                   
fe4fa     014d     _sdpins word    CONL
fe4fc     3c3a3b3d         long    sdpins
                   
                   
fe500     014d     SDBUF   word    CONL
fe502     00010000         long    SDBUFS
                   
                   ' pub SD? ( -- flg )            *SDCS PIN L 200 WAIT F 200 WAIT R H ;
fe506     eb06f83c SDQ     word    SDCS,_PIN,L,w+200,WAIT,F,w+200,WAIT,R,H,EXIT
                   
                   ' pri SDCLK
fe51c     01a40141 SDCLK   word    MINUS1,SPIWR8,EXIT
fe522     e51c     SDCLK3  word    SDCLK
fe524     e51de51c SDCLK2  word    SDCLK,SDCLK+ex
                   
                   ' pri TOKEN ( marker -- flgX )
fe528     4e20013f TOKEN   word    _WORD,20000
fe52c     f8000077 tklp    word    OVER,_0,SPIRD,_NEQ,_IF+07,DEC,DUP,_ZEQ,_IF+02,NIP,EXIT
fe542     e52d             word    tklp+ex
fe544     ffff0068         word    DROP2,TRUE,EXIT
                   
                   ' pub ACMD ( data acmd -- res )
fe54a     f837f800 ACMD    word    _0,w+55,CMD,DROP
                   ' pub CMD    ( data cmd -- res )
fe552     f8350073 CMD     word    DUP,w+sdcmd,CSTORE
fe558     ebaae4fa         word    _sdpins,SPIPINS,SDCLK
fe55e     01b001a2         word    SPIWRC,SPIWRL
fe562     00ddf834         word    w+sdcrc,CFETCH,SPIWR8,RSTCRC
fe56a     fbe8f800 SDRES   word    _0,w+1000,FOR,SPIRD,BITS8,DUP,w+$FF,_NEQ,QNEXT,DROP,EXIT
                   'SDRES  word    _0,SPIRD,BITS8,DUP,w+$FF,_NEQ,_UNTIL+06,EXIT
                   
                   
                   ' pri STAT@ ( -- stat )
fe580     f80df800 SDSTAT  word    _0,w+13,CMD,SDRES,_SHL8,ORX+ex
                   {
                   '' pri SDERR? ( -- flg ; return SD bit flag errors)
                   SDERRQ  word    _0,SDQ,_ZEQ,_1,_AND,_OR
                           word    w+_sdrd,FETCH,_ZEQ,_2,_AND,_OR
                           word    w+_sdwr,FETCH,_ZEQ,_4,_AND,_OR
                           word    w+ocr,FETCH,_ZEQ,_8,_AND,_OR
                           word    EXIT
                   }
                   '' pri SD4@ ( -- long )
fe58c     0191f800 SDRD4   word    _0,SPIRD,SPIRD,SPIRD,SPIRD,EXIT
                   '' pri SDDAT! ( adr -- ) read info into memory
fe598     e528f8fe SDDATST word    dtk,TOKEN,_IF+08,w+16,ADO,_0,SPIRD,IX,CSTORE,LOOP,SDCLK3+ex
fe5ae     d091             word    DROPEX+ex
                   
fe5b0     f895     RSTCRC  word    w+$95
fe5b2     00e4f834 SETCRC  word    w+sdcrc,CSTORE,EXIT
fe5b8     ec7af835 INITSX  word    w+sdcmd,SETC
fe5bc     010df805         word    _5,FOR,RSTCRC,_0,_0,CMD,_1,_EQ,QNEXT,ZEXIT
fe5d0     010df805         word    _5,FOR,w+$87,SETCRC,w+$1AA,_8,CMD,_1,_EQ,QNEXT,ZEXIT
fe5e6     f9aae58c         word    SDRD4,w+$1AA,_EQ,ZEXIT
fe5ee     013ff800         word    _0,_WORD,1000,_0,DO
fe5f8     00b0f81e         word    w+30,MASK,w+41,ACMD,_IF+09,SPICE,SDCK,_PIN,w+200,FOR,H,L,forNEXT,isd1+ex
fe614     0128008c         word    INC,LEAVE
fe618     00610116 isd1    word    LOOP,ZEXIT
fe61c     f83af800         word    _0,w+58,CMD,IFEXIT,SDRD4,DUP,w+ocr,STORE,ZEXIT
fe62e     f80af800         word    _0,w+10,CMD,_ZEQ,_IF+02,w+cid,SDDATST
fe63c     f809f800         word    _0,w+9,CMD,_ZEQ,ZEXIT,w+csd,SDDATST+ex
                   
                   '' Initialise the SD card in SPI mode and return with the OCR
                   '' pub !SD ( -- ocr|false )
fe64a     ebaae4fa INITSD  word    _sdpins,SPIPINS
fe64e     f8a1f810         word    w+sdvars,w+(sdend-sdvars),ERASE
fe654     f804e500         word    SDBUF,_4,_SHL9,ERASE    ' erase all n file buffers
fe65c     f810f856         word    w+_sector,w+16,w+$FF,CFILL
fe664     fc0ae506         word    SDQ,_IF+10,SDCLK3,w+20,FOR,INITSX,w+sdcmd,CFETCH,w+9,_EQ,QNEXT,DROP
fe67c     d165f810         word    w+ocr,FETCHX+ex
                   
                   ''  Write from src to xdst in the SD
                   '' pub SDWR    ( src sect -- flg  )
fe680     e522     SDWR    word    SDCLK3
fe682     e552f818         word    w+24,CMD,_ZEQ,_IF+11
fe68a     f8fee522         word    SDCLK3,dtk,SPIWR8,BLKSIZ,SPITX
fe694     e528f800         word    _0,TOKEN,w+$FF,TOKEN,_AND,sdwr1+ex
fe6a0     f800             word    _FALSE
fe6a2     f83a0073 sdwr1   word    DUP,w+_sdwr,STORE,SPIX+ex
                   
                   '' pub FLUSH ( force -- )               wrflg C@ OR IF SDBUF @sector @ SDWR DROP wrflg C~ THEN ;
fe6aa     00ddf842 FLUSH   word    w+wrflg,CFETCH,_OR,ZEXIT
fe6b2     f856e500         word    SDBUF,w+_sector,FETCH,SDWR,DROP,w+wrflg,CLRC,EXIT
                   
                   '' pri SDRDBK ( dst -- )        BLKSIZ SPIRX sdsum ! 0 SPIRD SPIRD 1 OR ;
fe6c2     0183fa00 SDRDBK  word    BLKSIZ,SPIRX,w+sdsum,STORE,_0,SPIRD,SPIRD,_1,ORX+ex
                   { pri SDRDBLK ( dst -- crc|flg )
                           BLKSIZ SPI>BUF
                           --- read crc and force as true flag
                           0 SPIRD SPIRD 1 OR
                           ;
                   }
                   '' pub SECTOR ( sect -- sdbuf )
fe6d4     f8560073 SECTOR  word    DUP,w+_sector,FETCH,_EQ,_IF+02,DROP,SDBUF+ex
fe6e2     e6aaf800 SECTORF word    _0,FLUSH,DUP,w+_sector,STORE,SDBUF,SDRD,SDBUF,EXIT
                   '' pub SDRD    ( sector dst --  )
fe6f4     f811007e SDRD    word    SWAP,w+17,CMD,DUP,_ZEQ,_IF+11
fe700     e56a0069         word    DROP,SDRES,dtk,_EQ,_IF+02,SDRDBK,sdrd1+ex
fe70e     e580e524         word    SDCLK2,SDSTAT,DROP2,_0
fe716     0073e51c sdrd1   word    SDCLK,DUP,w+_sdrd,STORE,w+seccrc,STORE,SPIX+ex
                   
                   
                   '' pub SDRDS    ( sector dst cnt -- crc | false )
                                   ' convert cnt to sectors '
fe724     d67cfa00 SDRDS   word    BLKSIZ,_ALIGN,_SHR9
                                   '   multiblock read   --  command not accepted '
fe72a     007e0081         word    ROT2,SWAP,w+18,CMD,_IF+03,DROP2,_FALSE,.sd1+ex
                                   ' process read token and read block if available '
fe73a     f8fee56a         word    SDRES,dtk,_EQ,_IF+09,SWAP,FOR,DUP,SDRDBK,DROP,BLKSIZ,PLUS,forNEXT,.sd1+ex
                                   ' ELSE '
fe754     e5240068         word    DROP2,SDCLK2,SDSTAT,DROP,SPICE,_FALSE
fe760     01b8e51c .sd1    word    SDCLK,SPICE
fe764     f8360073         word    DUP,w+_sdrd,STORE
fe76a     f80cf800         word    _0,w+12,CMD,_ZEQ,_UNTIL+05,SPIX+ex
                   
                   '' SDWRS ( hubsrc sdadr cnt -- )
fe776     d67cfa00 SDWRS   word    BLKSIZ,_ALIGN,_SHR9
fe77c     0073010a         word    ADO,DUP,IX,SECTOR,BLKSIZ,CMOVE
fe788     e6aaf801         word    _1,FLUSH,BLKSIZ,PLUS,LOOP,DROPEX+ex
                   
                   
                   
fe794     ec7af842 SDADRW  word    w+wrflg,SETC
                   '' pub SDADR ( xaddr -- addr )  L>S ( @SECTOR + ) SECTOR SDBUF + ;
fe798     f8a7ec1a SDADR   word    L2S,w+opensect,FETCH,PLUS,SECTOR,PLUS,EXIT
                   '' pub SD@ ( xaddr -- long )    RDSDA @ ;
fe7a6     00e1e798 SDFETCH word    SDADR,FETCH,EXIT
fe7ac     00ece794 SDSTORE word    SDADRW,STORE,EXIT
fe7b2     00dde798 SDCFETCH word   SDADR,CFETCH,EXIT
fe7b8     00e4e794 SDCSTORE word   SDADRW,CSTORE,EXIT
fe7be     00e0e798 SDWFETCH word   SDADR,WFETCH,EXIT
fe7c4     e7b2d83a SD      word    SETDMP,SDCFETCH,SDWFETCH,SDFETCH
                   
                   
                   '' @FAT ( fat# -- sector )
fe7cc     00e1f8d5 ATFAT   word    w+sectfat,FETCH,MULTIPLY
fe7d2     f8bfe7e2         word    ATBOOT,w+rsvd,WFETCH,PLUS,PLUS,EXIT
fe7de     d165f90b ATROOT  word    w+rootdir,FETCHX+ex
fe7e2     d165f86f ATBOOT  word    w+partitions+8,FETCHX+ex
                   '' cd! ( sect str -- )
                   ' CDST  word    w+cwdsect,STOREX+ex
                   
fe7e6     e6e2e7e2 RDFAT   word    ATBOOT,SECTORF,w+fat32,w+90,CMOVE
                           'word   w+sectclust,CFETCH,ENCODE,w+clshift,CSTORE
fe7f0     00e0f8bf         word    w+rsvd,WFETCH,w+sectfat,FETCH,w+fats,CFETCH,MULTIPLY
fe7fe     00e1f8dd         word    w+rootcl,FETCH,DEC2
fe804     0086e826         word    CLSECT2,PLUS,PLUS
fe80a     00ecf90b         word    w+rootdir,STORE
                                   '' save time by precalculating FAT table addresses
fe80e     e7ccf800         word    _0,ATFAT,w+fat1,STORE,_1,ATFAT,w+fat1+4,STORE
fe81e     0063             word    EXIT
                   '' CLUST>SECT ( clust# -- sector )
fe820     00e1f8dd CLSECT  word    w+rootcl,FETCH,MINUS
fe826     00ddf8be CLSECT2 word    w+sectclust,CFETCH,MULTIPLY,ATBOOT,PLUS,EXIT
                   
fe832     0061e506 AMOUNT  word    SDQ,ZEXIT,w+mounted,CFETCH,IFEXIT
fe83c     00b7e64a MOUNT   word    INITSD,_ZEQ,_IF+01,ERRSTR+ex
fe844     e6e2f800         word    _0,SECTORF,w+$1FE,PLUS,WFETCH,_WORD,$AA55,_EQ
fe854     0061             word    ZEXIT
fe856     f86af8b1         word    w+fat32,w+(fatend-fat32),ERASE
fe85c     e500f9be         word    w+$1BE,SDBUF,PLUS,w+partitions,w+64,CMOVE
fe868     e966e7e6         word    RDFAT,ROOT,w+mounted,SETC
fe870     f808f814 PRTFAT  word    w+cid,_8,ATYPE
fe876     f8f4d058         word    SPACE,w+serial,FETCH,PRTLONG,SPACE
fe880     f80bf8f8         word    w+volname,w+11,CTYPE
fe886     00ddf8be         word    w+sectclust,CFETCH,_SHR1,PRINT,w+"k",EMIT
fe892     f8d1d058         word    SPACE,w+sdsize,FETCH,W+11,_SHR,PRTDECL,w+"M",EMIT+ex
                   
                   ' DIR '
fe8a2     e832     PRTDIR  word    AMOUNT
fe8a4     e968f800         word    _0,FOPEN,CRLF,PRTFAT
fe8ac     00abe7de         word    ATROOT,_SHL9,w+sectclust,CFETCH,_SHL9,ADO
fe8b8     e7a60103         word    IX,SDFETCH,_IF+(.L2-.L1)/2
fe8be     0103d0e2 .L1     word    CRLF,IX,SDADR,DUP,w+8,CTYPE
fe8ca     f8080073         word    DUP,_8,PLUS,DUP,CFETCH,w+$20,_NEQ,_IF+05
fe8da     0073d0f4         word    DOT,DUP,_3,CTYPE,.L0+ex
fe8e4     d076f804         word    _4,SPACES
fe8e8     007ed058 .L0     word    SPACE,SWAP,FSECT,PRTL
fe8f0     0103d074         word    SPACES3,IX,SDADR,PRTDATE
fe8f8     f814d074         word    SPACES3,w+fsize-8,PLUS,FETCH,PRTDECL
fe902     0113f820 .L2     word    w+32,PLOOP,CRLF+ex
                   
                   '' .DATE ( diradr -- )
fe908     f8180073 PRTDATE word    DUP,w+fdate,PLUS,WFETCH
fe910     009e0073         word    DUP,_SHR9,_WORD,1980,PLUS,PRTDEC4
fe91c     f8050073         word    DUP,_5,_SHR,BITS4,PRTDEC2,w+$1F,_AND,PRTDEC2
                           ''
fe92c     0086f816         word    w+ftime,PLUS,WFETCH,DUP,w+11,_SHR,PRTDEC2
fe93a     009bf805         word    _5,_SHR,w+$3F,_AND,PRTDEC2+ex
                   
                   
                   
                   ' FSECT ( diradr -- sector )'
fe944     0075f81a FSECT   word    w+fclstl,OVERPLUS,WFETCH,SWAP,w+fclsth,PLUS,WFETCH,W2L
fe954     00e1f8dd C2S     word    w+rootcl,FETCH,MINUS,w+sectclust,CFETCH,MULTIPLY,ATROOT,PLUS,EXIT
                   
fe966     e7de     ROOT    word    ATROOT
                   ' FOPEN ( sect -- )
fe968     ec66f8ab FOPEN   word    w+_fread,CLRL,w+opensect,STOREX+ex
                   
fe970     fe12e968 FLOAD   word    FOPEN,rg+ukey,WFETCH,w+fkey,WSTORE
fe97a     e980013f         word    _WORD,FGET,SETKEY+ex
                   
fe980     00e1f8ab FGET    word    w+_fread,FETCH,SDCFETCH,QDUP,_ZEQ
fe98a     f8affc08         word    _IF+08,w+fkey,WFETCH,QDUP
fe992     d0aafc04         word    _IF+04,SETKEY,w+fkey,CLRW,FALX+ex
fe99c     d15df8ab         word    w+_fread,LINC+ex
                   
                   ' FREAD ( sdsrc hubdst bytes -- )'
fe9a0     010ad67a FREAD   word    _ALIGNL,ADO,IX,OVERPLUS,SDFETCH,IX,STORE
fe9ae     0113f804 FLOOP   word    _4,PLOOP,DROP,EXIT
                   
                   ' FWRITE ( hubsrc sddst bytes -- )'
fe9b6     010ad67a FWRITE  word    _ALIGNL,ADO,IX,OVERPLUS,FETCH,IX,SDSTORE,FLOOP+ex
                   {
                   ' RENAME THE CURRENTLY OPEN FILE'
                   RENAME
                   : FNAME         GETWORD
                   FNAME   word    GETWORD
                   
                   To print a file:
                   $1B780 FOPEN 0 SD PRINT$
                   
                   }
                   
                   
                   
                   
                   ''''''''''''''''''''''''''''''
                   '       SD CARD
                   ''''''''''''''''''''''''''''''
                   
fe9c6 010                  org     $0010 '...$0110'
fe9c6 010          sdvars
fe9c6 010          ocr             res     4
fe9c6 014          cid             res     16
fe9c6 024          csd             res     16
fe9c6 034          sdcrc           res     1
fe9c6 035          sdcmd           res     1
fe9c6 036          _sdrd           res     4
fe9c6 03a          _sdwr           res     4
                   
fe9c6 03e          sdsum           res     4
fe9c6 042          wrflg
fe9c6 042          wrflgs          res     4
                   
fe9c6 046          seccrc          res     16
fe9c6 056          _sector         res     16
fe9c6 066          mounted         res     1
                   
fe9c6 067          partitions      res     64
fe9c6 0a7          opensect        res     4       ' starting sector of open file'
fe9c6 0ab          _fread          res     4
fe9c6 0af          fkey            res     2
fe9c6 0b1          sdend
                   
                   ''''''''''''''''''''''''''''''
                   '       FAT32
                   ''''''''''''''''''''''''''''''
                   
fe9c6 0b1          fat32
fe9c6 0b1                          res     3
fe9c6 0b4          oemname         res     8
                   ''                res   8
fe9c6 0bc          bytesect        res     2
                   ''                res   2
fe9c6 0be          sectclust       res     1
fe9c6 0bf          rsvd            res     2
fe9c6 0c1          fats            res     1
fe9c6 0c2                          res     15
fe9c6 0d1          sdsize          res     4       ' Number of sectors * byte/sect (512) = capacity'
                   ''                res   4
fe9c6 0d5          sectfat         res     4       ' Number of sectors per FAT table'
fe9c6 0d9                          res     2       ' fatflags'
fe9c6 0db                          res     2       ' fatver'
fe9c6 0dd          rootcl          res     4       ' Cluster Number of the Start of the Root Directory'
fe9c6 0e1                          res     2       ' info = Sector Number of the FileSystem Information Sector  (from part start)
fe9c6 0e3                          res     2       ' boot = Sector Number of the Backup Boot Sector (from part start)
fe9c6 0e5                          res     12
                   ' offset 64
fe9c6 0f1                          res     3
fe9c6 0f4          serial          res     4       ' serial number of partition
fe9c6 0f8          volname         res     11      ' volume name
fe9c6 103          fatname         res     8       ' always FAT32 - (don't trust)
                   ' 96 '
                   ''''''''''''''''''''''''''''''
                   ' create room for some system variables in this table
                   
fe9c6 10b          rootdir         res     4       ' sector address of root directory
fe9c6 10f          fat1            res     4
fe9c6 113          fat2            res     4
fe9c6 117          cwdsect         res     4
                   'cwdstr         res     16
fe9c6 11b          fatend
                   
                   ''''''''''''''''''''''''''''''
                   '       DIRECTORY STRUCTURE'
                   ''''''''''''''''''''''''''''''
fe9c6 000                          org 0
                   
fe9c6 000          fnam            res     8
fe9c6 008          fext            res     3
fe9c6 00b          fatr            res     1
fe9c6 00c                          res     1       ' MUST BE 00'
fe9c6 00d          fcms            res     1
fe9c6 00e          fctime          res     2
fe9c6 010          fcdate          res     2
fe9c6 012          fadate          res     2
fe9c6 014          fclsth          res     2
fe9c6 016          ftime           res     2
fe9c6 018          fdate           res     2
fe9c6 01a          fclstl          res     2
fe9c6 01c          fsize           res     4
                   
                   '
                   '***************************************** HUBEXEC CODE ***************************
                   '
fe9c6                              orgh
fe9c6                              alignw
fe9c6              _hubexec
                   
                   ' !SP - init the data stack pointer
fe9c6     f6042200 INITSP          mov     datptr,#datstk
fe9ca     f6042e00                 mov     depth,#0
fe9ce     ff6f56df         _ret_   mov     tos,##$DEADBEEF                 ' marker
fe9d2     060442ef 
                   
                   {
                                   dirl    #rx_pin                 'disable receiver
                                   wrpin   #%00_11111_0,#rx_pin    'configure rx_pin for asynchronous receive, always input
                   
                                   wrpin   #%01_11110_0,#tx_pin    'configure tx_pin for asynchronous transmit, always output
                                   dirh    #tx_pin                 'enable transmitter
                   }
                   
fe9d6              InitTaqoz
fe9d6     fd601601                 cogid   fx
fe9da     fed0f3ec                 loc     PTRA,#@IDLE&$FFFF               ' default startup into Instruction Pointer
fe9de     fb9c160c                 tjnz    fx,#INITSTKS
                   ' COG 0 CONSOLE '
fe9e2     fd647c41                 dirh    #tx_pin                         'set tx output high
fe9e6     fc2c1a3e                 wypin   #$0D,#tx_pin
fe9ea     fed0f4a0                 loc     PTRA,#@TERMINAL&$FFFF
fe9ee     fd647e41                 dirh    #rx_pin
                                   'setse1 #%001_111111
fe9f2     fa9c3c3f                 rdpin   rxz,#rx_pin wc                   ' clear rx?
fe9f6     fd640025                 setint1 #0
fe9fa     f6044000                 mov     rxwrC,#0
fe9fe     fc64400c                 wrlong  rxwrC,#rxrd
                   
fea02     fd677e20                 setse1  #%110<<6+rx_pin                 'set se1 to trigger on  rx char event?????
fea06     ff0007f5                 mov     ijmp1,##@taqoz_rxisr            'set int1 jump vector to receive buffer
fea0a     f607e822 
fea0e     fd640825                 setint1 #4
                   
fea12     fdbfffb0 INITSTKS        call    #INITSP
fea16     f6042630 INITLP          mov     lpptr,#lpstk
fea1a     f6042420                 mov     braptr,#brastk
fea1e     06042840 INITRP  _ret_   mov     retptr,#retstk
                   
                   ' ( SERIAL RECEIVE INTERRUPT SERVICE ROUTINE )'
fea22     f0643a08 taqoz_rxisr     shl     rxlong,#8
fea26     fa8c3c3f                 rdpin   rxz,#rx_pin                      ' recv byte (bits31:24) from rx pin
fea2a     f0443c18                 shr     rxz,#24
fea2e     f5483a1e                 or      rxlong,rxz wz
fea32     ff0d8d8d                 cmp     rxlong,##$1B1B1B1B wz           ' esc esc esc esc break'
fea36     f20c3b1b 
fea3a     acec0000         if_z    coginit #0,#0   ''#@RESET
                   
fea3e     ff0d0d0d 		cmp	rxlong,##$1A1A1A1A wz		' check for sequence '
fea42     f20c3a1a 
fea46     a9c43c1c 	if_z	decod	rxz,#28				' reboot via hub'
fea4a     ad603c00 	if_z	hubset	rxz
fea4e     f6003e20                 mov     rxwrP,rxwrC
fea52     f1043f80                 add     rxwrP,#rxbuffers
fea56     fc403c1f                 wrbyte  rxz,rxwrP
fea5a     fc443cf0 		wrbyte	rxz,#lastkey			' write directly to global variable in low hub'
fea5e     ff000007                 incmod  rxwrC,##rxsize-1
fea62     f704407f 
fea66     fc54400e                 wrword  rxwrC,#rxwr
fea6a     fb3bfff5                 reti1
                   
                   
fea6e     fae4180c READRX          rdword  r0,#rxrd
fea72     f2081820                 cmp     r0,rxwrC wz
fea76     ad900018         if_z    jmp     #@rr1
fea7a     f6001a0c                 mov     r1,r0
fea7e     f1041b80                 add     r1,#rxbuffers
fea82     fac0140d                 rdbyte  acc,r1
fea86     ff000007                 incmod  r0,##rxsize-1
fea8a     f704187f 
fea8e     fc54180c                 wrword  r0,#rxrd
fea92     fd800142 rr1             jmp     #PUSHACC
                   
fea96     fd640025 DEBUGGER        setint1 #0
fea9a     fd8fca88                 jmp     #\_Start_Monitor        ' \ forces absolute address '
                   
                   
                   
                   ' Registers can be used just like variables and the interpreted kernel uses some for itself
                   ' 128+ bytes are reserved. Since the registers are pointed to by "regptr" they can relocated
                   ' REG ( index -- addr ) Find the address of the register
fea9e     01004209 ATREG   _ret_           add     tos,regptr
                   
feaa2     f6001615 LAPFETCH                mov     fx,lap1
feaa6     f1801616                         sub     fx,lap2
feaaa     fd800143                         jmp     #pushx
                   
                   ' COGSTOP ( cog -- )
feaae     fd604203 _COGSTOP                cogstop tos
feab2     fd800069                         jmp     #DROP
                   
                   ' COGINIT ( addr cog -- )
feab6     fce04222                         coginit tos,tos1
feaba     fd800068                         jmp     #DROP2
                   
                   ' COGATN ( mask -- )
feabe     fd60423f _COGATN                 cogatn  tos
feac2     fd800069                         jmp     #DROP
                   
                   ' POLLATN ( -- flg )
feac6     fd701c24 _POLLATN                pollatn wc
feaca     c1841401                 if_c    sub     acc,#1
feace     fd800142                         jmp     #PUSHACC
                   
                   '' SETEDG ( edge pin -- ) add 4 to edge for lock
fead2     f0644406 _SETEDG                 shl     tos+1,#6
fead6     f1004222                         add     tos,tos+1
feada     fd604220                         setse1  tos
feade     fd800068                         jmp     #DROP2
                   
                   '' POLLEDG ( -- flg )
feae2     fd700824 _POLLEDG                pollse1 wc
feae6     c1841401                 if_c    sub     acc,#1
feaea     fd800142                         jmp     #PUSHACC
                   
feaee              WAIT ''( clks -- )
feaee     fd60421f                         waitx   tos
feaf2     fd800069                         jmp     #DROP
                   
feaf6     fd60161a _GETCNT                 GETCT   fx
feafa     fd800143                         jmp     #PUSHX
                   
                   
                   
                   
                   ' some smartpin support for high level
                   ' @PIN ( -- pin )
feafe     f6001618 _ATPIN                  mov     fx,pinreg
feb02     fd800143                         jmp     #PUSHX
                   
                   '' PIN ( pin -- )
feb06     f6003021 _PIN                    mov     pinreg,tos
feb0a     fd800069                         jmp     #DROP
                   
feb0e     f6003221 _CLK                    mov     tepin,tos
feb12     fd800069                         jmp     #DROP
                   
                   ' WRACK ( data -- )     Write smartpin data and wait for empty then ack
feb16     fc204218 WRACK                   wypin   tos,pinreg
feb1a     fd703040 .wait                   testp   pinreg  wc              '..wait for buffer empty
feb1e     3d9ffff8                 if_nc   jmp     #.wait
feb22     fc080218                         akpin   pinreg                  '..acknowledge pin
feb26     fd800069                         jmp     #DROP
                   
feb2a     fd605468 _RND                    xoro32  seed
feb2e     f600162a                         mov     fx,seed
feb32     fd800143                         jmp     #PUSHX
                   
                   ' SKIPNZ ( flg -- ) Skip if flg is true ( replace 0= IF xxx THEN )
feb36     fb944201 SKIPNZ                  tjz     tos,#.L0
feb3a     f107f002                         add     PTRA,#2
feb3e     fd800069 .L0                     jmp     #DROP
                   
                   
                   
                   ' > ( n1 n2 -- flg )
feb42     f2504222 GT                      cmps    tos,tos1 wc
feb46     fd90000c                         jmp     #CFLG
                   ' < ( n1 n2 -- flg )
feb4a     f2504421 LT                      cmps    tos1,tos wc
feb4e     fd900004                         jmp     #CFLG
                   ' U< ( u1 u2 -- flg )
feb52     f2104421 _ULT                    cmp     tos1,tos wc
feb56     f1a04422 CFLG                    subx    tos1,tos1
feb5a     fd800069                         jmp     #DROP
                   
                   
                   ' main division sub - called both by U/ and U//
                   ' double div, single divisor
                   ' By specifing bits and left justifying the routine can be adapted and run faster
                   ' CLKHZ 1234 LAP U// LAP .LAP  27.400us ok --> 18.800us
                   
                   ' UM/MOD64 ( Dbl.dividend divisor -- remainder Dbl.quotient)
feb5e     f6041420 UMDIVMOD64      mov     ACC,#32
feb62     f1041420 UMDIVMOD32      add     ACC,#32
feb66     f6001821                 mov     R0, tos         ' R0 = divisor
feb6a     f6001a23                 mov     R1, tos2                ' R1R2 = dividend
feb6e     f6001c22                 mov     R2, tos1
feb72     f6044600                 mov     tos2, #0                                ' remainder
                   
feb76     f0741a01 udmlp           shl     R1, #1 wc                       ' dividend msb
feb7a     f0b41c01                 rcl     R2, #1 wc
feb7e     f0a44601                 rcl     tos2, #1                        ' hi bit from dividend
feb82     f2f0460c                 cmpsub  tos2, R0   wc                   ' cmp divisor ( R0 - tos & c set if tos => R0 )
feb86     f0b44401                 rcl     tos1, #1 wc                             ' R1 = quotient l
feb8a     f0a44201                 rcl     tos, #1                         ' R2 = quotient h
feb8e     0b6c15f9         _ret_   djnz    ACC,#udmlp
                   
                   ' DSWAP ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
feb92     f6001821 DSWAP                   mov     R0,tos
feb96     f6001a22                         mov     R1,tos1
feb9a     f6004223                         mov     tos,tos2
feb9e     f6004424                         mov     tos1,tos3
feba2     f600460c                         mov     tos2,R0
feba6     0600480d                 _ret_   mov     tos3,R1
                   
                   
febaa              SPIPINS ' ( long --- ) sets bit numbers for SPI mode from bytes in long as cs.mi.mo.ck
febaa     fdb00030                 call    #.SPSET
febae     fd601658                 drvl    fx              ' clock low
febb2     f600040b                 mov     sck,fx          ' setup SCK clock
                                   '
febb6     fdb00024                 call    #.SPSET
febba     fd601659                 drvh    fx              ' leave high
febbe     f600060b                 mov     mosi,fx         ' setup MOSI data to slave
                                   '
febc2     fdb00018                 call    #.SPSET
febc6     fd601640                 dirl    fx              ' input
febca     f600080b                 mov     miso,fx         ' MISO
                                   '
febce     fdb0000c                 call    #.SPSET
febd2     fd601659                 drvh    fx              ' chip select high
febd6     f6000a0b                 mov     ss,fx           ' SS
febda     fd800069                 jmp     #DROP
                   
febde     f6001621 .SPSET          mov     fx,tos
febe2     f50416ff                 and     fx,#$FF
febe6     00044208         _ret_   ror     tos,#8
                   
                   
                   {
                   PAFETCH                 mov     fx,INA
                                           jmp     #PUSHX
                   PBFETCH                 mov     fx,INB
                                           jmp     #PUSHX
                   PASTORE                 mov     OUTA,tos
                                           jmp     #DROP
                   PBSTORE                 mov     OUTA,tos
                                           jmp     #DROP
                   DACLR                   andn    DIRA,tos
                                           jmp     #DROP
                   DBCLR                   andn    DIRB,tos
                                           jmp     #DROP
                   ' ( mask -- )
                   PASET                   or      OUTA,tos
                   DASET                   or      DIRA,tos
                                           jmp     #DROP
                   
                   PBSET                   or      OUTB,tos
                   DBSET                   or      DIRB,tos
                                           jmp     #DROP
                   
                   PACLR                   andn    OUTA,tos
                                           jmp     #DASET
                   PBCLR                   andn    OUTB,tos
                                           jmp     #DBSET
                   }
                   
                   { *** COG ACCESS *** }
                   
febea     f9944200 COGFETCH                alts    tos,#0
febee     06004200                 _ret_   mov     tos,0_0
                   
                   '' COG! ( long addr -- ) Store a long to cog memory
febf2              COGSTORE
febf2     f98c4200                         altd    tos,#0
febf6     f6000022                         mov     0_0,tos+1
febfa     fd800068                         jmp     #DROP2
                   
                   
febfe     fd601601 _COGID                  cogid   fx
fec02     fd800143                         jmp     #PUSHX
                   
                   
                   '' _COGINIT ( dest cog -- )
fec06     fce04222 _COGINIT                coginit tos,tos1
fec0a     fd800068                         jmp     #DROP2
                   
                   '' DELTA ( delta -- )   Calculate and set the cnt delta and waitcnt
fec0e     fda00069 DELTA                   call    #POPX
fec12     f600200b                         mov     deltaR,fx
                   '' WAITCNT ( -- )
fec16     0d60201f WAITCNTS        _ret_   waitx   deltaR          '' continue from last count (must be called before target is reached)
                   
                   
                   {
                   
                   ' OUTCLR ( iomask  -- ) Clear multiple bits on the output
                   OUTCLRA         andn    OUTA,tos
                                   or      DIRA,tos
                                   jmp     #DROP
                   
                   '' OUTSET ( iomask  -- ) Set multiple bits on the output
                   OUTSETA         or      OUTA,tos
                    ' OUTPUTS ( iomask  -- ) Set selected port pins to outputs
                                   or      DIRA,tos
                                   jmp     #DROP
                   
                   
                   ' INPUTS ( iomask -- ) Set selected port pins to inputs
                   INPUTSA         andn    DIRA,tos
                                   jmp     #DROP
                   
                   }
                   
                   
                   
                   ' L2S ( n -- lsb9 h ) specialized operation for filesystem addresses
fec1a     f6001621 L2S                     mov     fx,tos
fec1e     f50443ff                         and     tos,#$1FF
fec22     f0441609                         shr     fx,#9
fec26     fd800143                         jmp     #PUSHX
                   
                   ' L2W   word    DUP,TOW,SWAP,_SHR16,EXIT
                   
                   {
                   ' SHIFT from INPUT - Assembles with last bit received as msb - needs SHR to right justify if asynch data
                   ' SHRINP ( pin dat -- pin dat/2 )
                   SHRINP                  testp   tos1 wc
                                           rcr     tos,#1
                                           ret
                   }
                   { SHIFT to OUT -
                   This is optimized for when you are sending out multiple bits as in asynchronous serial data or I2C
                   Shift data one bit right into output via iomask - leave mask & shifted data on stack (looping)
                   400ns execution time including wordcode read and execute  or 200ns/bit with REPS }
                   {
                   ' SHROUT ( pin dat -- iomask dat/2 )
                   
                   SHROUT
                                           shr     tos,#1 wc       ' Shift right and get lsb
                                           drvc    tos1
                                           ret
                   }
                   
fec2a     fda00069 BITST                   call    #POPX
fec2e     fb941604                         tjz     fx,#CLR
                   ' SET ( mask addr -- ) Set bit(s) in hub long
fec32     fb001621 SET                     rdlong  fx,tos
fec36     f5401622                         or      fx,tos1
fec3a     fc601621                         wrlong  fx,tos
fec3e     fd800068                         jmp     #DROP2
                   
                   ' CLR ( mask addr -- ) Clear bit(s) in hub long
fec42     fb001621 CLR                     rdlong  fx,tos
fec46     f5201622                         andn    fx,tos1
fec4a     fc601621                         wrlong  fx,tos
fec4e     fd800068                         jmp     #DROP2
                   
                   ' SET? ( mask caddr -- flg ) Test single bit of a byte in memory
fec52     fb004221 BITQ                    rdlong  tos,tos
fec56     f5084421                         and     tos1,tos wz
fec5a     56004578         if_nz           mov     tos1,M1
fec5e     fd800069                         jmp     #DROP
                   
                   
                   
                   
                   ' ~~ ( addr -- )                set long
fec62     f1841401 SETL                    sub     ACC,#1
                   ' ~ ( addr -- )                 clear long
fec66     fc601421 CLRL                    wrlong  ACC,tos
fec6a     fd800069                         jmp     #DROP
                   
                   ' W~~ ( addr -- )               set word
fec6e     f1841401 SETW                    sub     ACC,#1
                   ' W~ ( addr -- )                clear word
fec72     fc501421 CLRW                    wrword  ACC,tos
fec76     fd800069                         jmp     #DROP
                   
                   ' C~~ ( addr -- )               set byte
fec7a     f1841401 SETC                    sub     ACC,#1
                   ' C~ ( addr -- )                clear byte
fec7e     fc401421 CLRC                    wrbyte  ACC,tos
fec82     fd800069                         jmp     #DROP
                   
                   
                   ' Inline vector check and exeute  !!!! needs to be able to handle hubexec !!!!
                   ' ?JMP ( adr -- )
                   
fec86     fae81621 QJMP                    rdword  fx,tos wz       ' read contents of vector
fec8a     5603f00b                 if_nz   mov     PTRA,fx
fec8e     fd800069                         jmp     #DROP
                   
                   
                   
                   ' SQRT ( d. -- sqrt )
fec92     fd304421 _SQRT                   qsqrt   tos+1,tos
fec96     fd604418                         getqx   tos+1
fec9a     fd800069                         jmp     #DROP
                   
                   
                   {
                   _INCMOD '( mod dst -- )
                                   incmod  tos,tos+1
                                   jmp     #DROP2
                   }
                   
fec9e     fd60421c _SETDACS        setdacs tos
feca2     fd800069                 jmp     #DROP
                   
                   
feca6     fd60161b _GETRND         getrnd  fx
fecaa     fd800143                 jmp     #PUSHX
                   
fecae              _HUBSET
fecae     fd604200                 hubset  tos
fecb2     fd800069                 jmp     #DROP
                   
                   
                   
                   {
                   ' WS2812 ( array ledcnt -- ) pin is in cog "pinreg" - line RET is done at HL, not here
                   ' Will transmit a whole array of 24-bit words each back to back in WS2812 timing format
                   ' line idles low and resets/synchs with low =>50us
                   ' A zero is transmitted as 400ns high by 850ns low (+/-150ns)
                   ' A one is transmitted as 800ns high by 450ns low HHL
                   ' The low period between each led is about 400ns longer but inconsequential
                   ' <30us/LED
                   wsdly         long      sys_clk/2500000
                   WSLED         rdbyte    r2,##wsdly
                                 sub       tos1,#1         ' offset for 24-bit long alignment
                   .l2           rdlong    fx,tos1          ' read next long
                                 add       tos1,#3         ' but leds are 3 bytes apart
                                 mov       r1,#24          ' write all 24 bits
                   .lp
                                 shl       fx,#1 wc         ' get next bit
                                 drvh      pinreg          ' always clock tx pin high for at least 400ns
                                 waitx     r2              ' 400ns
                                 drvc      pinreg          ' output data bit
                                 waitx     r2              ' delay again, (data is either high or low)
                                 drvl      pinreg          ' always needs to go low in the last third of the cycle
                                 waitx     r2 '-20'
                                 djnz      r1,#.lp
                                 djnz      tos,#.l2        ' read the next long as long as we can (tos = count)
                                 jmp       #DROP2          ' tx line left low to synch - discard stack parameters, all done.
                   
                   }
                   
                   {
                   ' VER ( -- verptr )
                   GETVER          loc     PA,#@version
                                   mov     fx,PA
                                   jmp     #PUSHX
                   }
                   
                   {
                   DICTIONARY
                   00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
                   00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
                   00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P..SWAPu..2SWAP
                   00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
                   }
                   {
                    ATR(765):CNT(43210),<NAME>,CFA '
                   ' Find string in dictionary is written in code and takes around 1us/word
                   ' r3 = cnt+1st char of source '
                           '    r1   r2  '
                   }
fecb6              FINDSTR '  ( cstr dict -- nfaptr | false )
fecb6     fae01e22                 rdword  r3,tos1                 ' read in count and 1st char
fecba     f6001c21 fstlp           mov     r2,tos                  ' R2 = dict word ptr '
fecbe     f6001a22                 mov     r1,tos1                 ' R1 = source
fecc2     fae8160e                 rdword  fx,r2 wz                ' read in count + 1st char'
fecc6     ad90005c         if_z    jmp     #fstfail                ' end of dictionary?'
fecca     f52416e0                 andn    fx,#$E0                 ' mask out atrs from count
fecce     f208160f                 cmp     fx,r3   wz              ' compare count+1st char '
fecd2     5d90003c         if_nz   jmp     #fstskip                ' no match, go to next word
fecd6     f600200f                 mov     r4,r3                   ' matched on cnt + 1st char'
fecda     f504201f                 and     r4,#cntm                ' now match rest if needed'
fecde     f18c2001                 sub     r4,#1 wz                ' matched if single else setup'
fece2     ad900024         if_z    jmp     #fstmatch
fece6     f1041a02                 add     r1,#2                   ' skip into 2nd char'
fecea     f1041c02                 add     r2,#2
fecee     fac0180d fstrem          rdbyte  r0,r1                   ' read in char from source '
fecf2     f1041a01                 add     r1,#1                   ' hub has to wait anyway so get ready for next source byte
fecf6     fac0160e                 rdbyte  fx,r2                   ' read in a character from the dictionary
fecfa     f1041c01                 add     r2,#1
fecfe     f208160c                 cmp     fx,r0 wz                        ' are they the same?
fed02     5d90000c          if_nz  jmp     #fstskip                ' skip if not same'
fed06     fb6c21f9                 djnz    r4,#fstrem              ' continue for remainder'
fed0a     f6004421 fstmatch        mov     tos1,tos                ' NIP
fed0e     fd800069                 jmp     #DROP                   ' found it
fed12     fac01621 fstskip         rdbyte  fx,tos                  ' read cnt to skip to next header '
fed16     f504161f                 and     fx,#cntm                        ' 03,D,U,P,CFAL,CFAH
fed1a     f100420b                 add     tos,fx
fed1e     f1044203                 add     tos,#3                  ' skip over CPA to next header'
fed22     fd9fff94                 jmp     #fstlp
fed26     f6044400 fstfail         mov     tos1,#0
fed2a     fd800069                 jmp     #DROP
                   
fed2e     f6001617 _DEPTH          mov     fx,depth
fed32     fd800143                 jmp     #PUSHX
                   
                   {
                   REGVAR          POP     fx
                                   rdbyte  fx,fx
                                   add     fx,regptr
                                   jmp     #PUSHX
                   }
                   {
                           "   ABCDEFGHIKLMNOPQRSTUVWXYZ$@!+- _abcdefghijklmnopqrstuvwxyz{|}~ #J%&'()*,./0123456789:;<=>?[\]^"
                           0 -ROT BEGIN DUP C@ WHILE OVER OVER C@ = IF 2DROP EXIT THEN ROT 1+ -ROT 1+ REPEAT
                           ;
                   }
                   {
                   ' LOOKIN ( val array -- index )
                   LOOKIN          mov     R1,tos1
                                   mov     tos1,#0                         ' init result index
                   .L0             rdbyte  fx,tos wz
                           if_z    mov     tos1,#0
                           if_z    jmp     #DROP
                                   add     tos1,#1                         ' inc result index
                                   cmp     fx,R1 wz
                           if_z    jmp     #DROP
                                   add     tos,#1
                                   jmp     #.L0
                   
                   _LOOKUP '( index array -- value )
                                   add     tos1,tos
                                   rdbyte  tos1,tos1
                                   jmp     #DROP
                   }
                   
fed36     ff0007f6 NEWCOG          coginit tos,##@RESET
fed3a     fce44342 
fed3e     fd800069                 jmp     #DROP
                   
                   
                   
                   {
                   
                   dPRTIP          call    #dCRLF
                   ''              mov     P,PTRA
                   ''              shr     P,#16
                                   call    #dPRTWORD
                                   mov     P,PTRA
                                   jmp     #dPRTWORD
                   
                   dPRTX           mov     R1,#$20
                                   call    #TX
                                   mov     P,fx
                   dPRTWORD
                                   mov     R1,P
                                   shr     R1,#12
                                   call    #HEXASC
                                   mov     R1,P
                                   shr     R1,#8
                                   call    #HEXASC
                                   mov     R1,P
                                   shr     R1,#4
                                   call    #HEXASC
                                   mov     R1,P
                                   call    #HEXASC
                                   mov     R1,#$20
                                   call    #TX
                                   ret
                   '
                   HEXASC          and     R1,#$0F
                                   add     R1,#$30
                                   cmp     R1,#$3A wc
                           if_nc   add     R1,#7
                   TX
                                   wypin   R1,#tx_pin              '..send byte
                   .wait           testp   #tx_pin         wc      '..wait for buffer empty
                    if_nc          jmp     #.wait
                                   akpin   #tx_pin                 '..acknowledge pin
                                   waitx   #200
                                   ret
                   
                   dCRLF           mov     R1,#$0D
                                   call    #TX
                                   mov     R1,#$0A
                                   jmp     #TX
                   '}
                   
                   
fed42              endcode
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   '************************************* HUB REGISTERS **************************************
                   
fed42 000                          org  0
                   ' register offsets within "registers". Access as    REG,delim   ...  REG,base ... etc
                   '
                   ' Minimum registers required for a new task - other registers after the ' ---- are not needed other than by the console
fed42 000          temp            res 12          ' general purpose
fed42 00c          double          res 4           ' hold high word of double
                   ' @16
fed42 010          uemit           res 2           ' emit vector 0 = default
fed42 012          ukey            res 2           ' key vector
fed42 014          keypoll         res 2           ' poll user routines - low priority background task
fed42 016          base            res 2           ' current number base + backup location during overrides
fed42 018          baudcnt         res 4           ' SERIN SEROUT baud cnt value where baud = clkfreq/baudcnt each cog can have it's own
fed42 01c          uswitch         res 4           ' target parameter used in CASE structures
                   ' @32
fed42 020          fflags          res 2           ' echo,linenums,ipmode,leadspaces,prset,striplf,sign,comp,defining
                   
fed42 022          keycol          res 1           ' maintains column position of key input
                   
fed42 023          wordcnt         res 1           ' length of current word (which is still null terminated)
fed42 024          wordbuf         res wordsz              ' words from the input stream are assembled here
                   ' numpad may continue to build backwards into wordbuf for special cases such as long binary numnbers
fed42 04b          numpad          res numpadsz    ' Number print format routines assemble digit characters here builds from end - 18,446,744,073,709,551,615
fed42 065          padwr           res 1           ' write index (builds characters down from lsb to msb in MODULO style)
                   
                   
                   'leader         res 1
                   
fed42 066          pflg            res 1
fed42 067          pbase           res 1
fed42 068          pfmt            res 4
                   
                   
                   
fed42 06c          delim           res 2           ' the delimiter used in text input and a save location
fed42 06e          dcnt            res 1
fed42 06f          prefix          res 1           ' NUMBER input prefix
fed42 070          uprompt         res 2           ' pointer to code to execute when Forth prompts for a new line
fed42 072          accept          res 2           ' pointer to code to execute when Forth accepts a line to interpret (0=ok)
fed42 074          keychar         res 4           ' override for key character
                   
fed42 078          suffix          res 1           ' NUMBER input suffix
fed42 079                          res 3
                   
fed42 07c          unum            res 2           ' User number processing routine - executed if number failed and UNUM <> 0
fed42 07e          ufind           res 2           ' runs extended dictionary search if set after failing precompiled dictionary search
                   
                   
                   '
                   ' ------ console only registers not required for other tasks  --- can be accessed as globals
                   '
                   
                   
                   ' these 4 variables are cleared as an array of 10 bytes
fed42 080          anumber         res 4           ' Assembled number from input
fed42 084          bnumber         res 4
fed42 088          digits          res 1           ' number of digits in current number that has just been processed
fed42 089          dpl             res 1           ' Position of the decimal point if encountered (else zero)
                   
                   'createvec      res 2           ' If set will execute user create routines rather than the kernel's (CREATE revectored)
                   
fed42 08a          dmm             res 6           ' dump "fetch' vectors to allow dump to access special devices
fed42 090          dmp             res 2           ' DUMP vector
                   
                   
                   ''''''''''''''''''''''' fixed ''''''''''''''''''''''''''''
                   
                   'rxptr          res 4           ' Pointer to the terminal receive buffer - read & write index precedes
                   'rxsz           res 2
                   
                   
fed42 092          oldnames        res 4           ' backup of names used at start of TAQOZ load
fed42 096          names           res 4           ' start of dictionary (builds down)
                   
                   
fed42 09a          fromhere        res 4           ' Used by TAQOZ word to backup current here to determine code size at end of load
fed42 09e          here            res 4           ' pointer to compilation area (overwrites VM image)
fed42 0a2          codes           res 4           ' current code compilation pointer (updates "here" or is reset by it)
                   
                   'bootsig                res 4
                   
fed42 0a6          autovec         res 4           ' user autostart address if non-zero - called from within terminal
fed42 0aa          cold            res 2           ' pattern to detect if this is a cold or warm start ($A55A )
fed42 0ac          errors          res 2
fed42 0ae          linenum         res 2
                   'lines          res 2
                   
fed42 0b0          prevch          res 2           ' used to detect LF only sequences vs CRLF to perform auto CR
                   
fed42 0b2          spincnt         res 2           ' Used by spinner to rotate busy symbol
fed42 0b4                          res 2           ' word count
                   
fed42 0b6          endreg          res 0
                   
                   '*********************************************************************************************************
                   '************************************** TACHYON COG KERNEL ***********************************************
                   '*********************************************************************************************************
                   
fed42 000                          org 0
fed42 000 fdafe9d6 RESET           call    #@InitTaqoz
fed46 001 fd9000d0                 jmp     #doNEXT
                   
                   '********************************** data *************************************
                   
                   
                   ' Registers used by PASM modules to hold parameters such as I/O masks and bit counts etc
                   ' COG 2
fed4a 002          sck
fed4a 002 00000000 REG0            long 0
fed4e 003          mosi
fed4e 003 00000000 REG1            long 0
fed52 004          miso
fed52 004 00000000 REG2            long 0
fed56 005          ss
fed56 005 00000000 REG3            long 0
fed5a 006 00000000 REG4            long 0
fed5e 007 00000000                 long 0
fed62 008 00000000                 long 0
                   
                   ' $00E0
                   ' COG 9 = TASK REGISTER POINTER
fed66 009 0000fe00 regptr          long registers                          ' used by REG
                   
fed6a 00a 00000000 ACC             long    0
fed6e 00b 00000000 fx              long    0
fed72 00c 00000000 R0              long    0
fed76 00d 00000000 R1              long    0
fed7a 00e          P
fed7a 00e 00000000 R2              long    0
fed7e 00f 00000000 R3              long    0
fed82 010          R4
fed82 010 00000000 deltaR          long    0
                   
                   
                   ' COG 17 STACK POINTERS
fed86 011 00000000 datptr          long    0                               ' data stack pointer to LUT
fed8a 012 00000000 braptr          long    0                               ' branch stack pointer to LUT
fed8e 013 00000000 lpptr           long    0
fed92 014 00000000 retptr          long    0                               ' return stack pointer to LUT
                   ' COG 21
fed96 015 00000000 lap1            long    0
fed9a 016 00000000 lap2            long    0
fed9e 017 00000000 depth           long    0
                   ' #0024
feda2 018 00000000 pinreg          long    0
feda6 019 00000000 tepin           long    0
fedaa 01a 00000014 pinticks        long    sys_clk / 1000000               ' set default 1Mbaud
                   
                   ' #0027
fedae 01b 00000000 clockpins       long 0                                  ' I/O mask for CLOCK instruction
fedb2 01c 00000000 clkdly          long 0
                   
                   ' #0029 rx isr variables
fedb6 01d 00000000 rxlong          long 0
fedba 01e 00000000 rxz              long 0
fedbe 01f 00000000 rxwrP           long 0
fedc2 020 00000000 rxwrC           long 0
                   
                   
                   
                   
                   ' *** COG STACKS ***
                   
                   ' top of data stack registers
fedc6 021 deadbee1 tos                     long    $DEADBEE1
fedca 022 deadbee2 tos1                    long    $DEADBEE2
fedce 023 deadbee3 tos2                    long    $DEADBEE3
fedd2 024 deadbee4 tos3                    long    $DEADBEE4
                   
                   ' top of loop stack registers
fedd6 025 00000000 index                   long    0
fedda 026 00000000 limit1                  long    0
fedde 027 00000000 index2                  long    0
fede2 028 00000000 limit2                  long    0
                   
fede6 029 00000000 branchadr               long    0
fedea 02a 00000001 seed                    long    1
                   
                   
fedee 02b f603f021 AJMP                    mov     PTRA,tos                ' jump to address on top of the data stack
fedf2 02c fd9000f0                         jmp     #DROP
                   
fedf6 02d fdb000ec ACALL                   call    #POPX                   ' get wordcode into X
fedfa 02e fd601a2b                         pop     R1                      ' discard return address and jump back and use interpreter
fedfe 02f fd90001c                         jmp     #doCODE
                   
                   ' main Forth wordcode interpreter - PTRA = Instruction Pointer
                   ' wordcode order: ASM,THREADED,HUBEXEC,IF,UNTIL,REG,LIT9
                   ''
                   {
                           w               =       $F800           ' wordcode offset for 10-bit literals
                           _IF             =       $FC00           ' IF relative forward branch 0 to 127 words
                           _UNTIL          =       $FC80           ' UNTIL relative reverse branch 0 to 127 words
                           opunused        =       $FD00
                           rg              =       $FE00          ' task/cog register 8-bit offset
                           fat             =       $FF00
                   }
                   
                   ' constants used by doNEXT decode
fee02 030 000001f0 cogadr                  long    496
fee06 031 0000e9c5 threaded                long    (_hubexec-1)&$FFFF
fee0a 032 0000f7ff calls                   long    $F800-1
fee0e 033 0000fbff shorts                  long    $FC00-1
fee12 034 0000fcff branches                long    $FD00-1
                   
                   
fee16 035 fd60162d doCALL                  call    fx                      ' could call cog or hub code - use ret to return
fee1a 036 fae41761 doNEXT                  rdword  fx,PTRA++               ' read word code instruction
fee1e 037 f210600b doCODE                  cmp     cogadr,fx wc            ' wordcode below $1F0 are cog addresses - just call
fee22 038 3d9ffff0         if_nc           jmp     #doCALL
fee26 039 f210620b                         cmp     threaded,fx wc          ' just call if it is asm code - either cog or in hubexec range below wordcodes
fee2a 03a 3d900030         if_nc           jmp     #THREAD                  ' if not then just execute as threaded code - needs to save IP
fee2e 03b f210640b                         cmp     calls,fx wc             ' special opcodes? (at high end for branches, short literals, registers etc)
fee32 03c 3d9fffe0         if_nc           jmp     #doCALL                 ' hubexec - execute as cog code '
fee36 03d f210660b                         cmp     shorts,fx wc                        '
fee3a 03e 3d900014         if_nc           jmp     #doSHORT                 ' LIT short 9-bit literal
fee3e 03f f210680b                         cmp     branches,fx wc
fee42 040 3d900030         if_nc           jmp     #doBRANCH               ' IF UNTIL conditional relative branch code
                   '
                   ' REG OP ( -- addr ) - the byte offset is relative to the regptr for that task
fee46 041          doREG
fee46 041 f7441608                         zerox   fx,#8
fee4a 042 f1001609                         add     fx,regptr
fee4e 043 fd900004                         jmp     #doPUSHX
fee52 044          doSHORT
fee52 044 f7441609                         zerox   fx,#9               ' push 10-bit literal
fee56 045 fdb003f4 doPUSHX                 call    #PUSHX
fee5a 046 fd9fffbc                         jmp     #doNEXT
                   
                   ' Call wordcode - Save IP and load with new IP from call
                   '
fee5e 047          THREAD
fee5e 047 f7cc1601                         test    fx,#1 wz                        ' bit0 is the jump/call bit
fee62 048 f5241601                         andn    fx,#1                   ' word align
fee66 049 ac33f014         if_z            wrlut   PTRA,retptr             ' save IP onto return stack
fee6a 04a a1042801         if_z            add     retptr,#1
fee6e 04b f603f00b                         mov     PTRA,fx                 ' jump to new wordcode (PTRA = IP)
fee72 04c fd9fffa4                         jmp     #doNEXT
                   
                   '
                   ' Conditional with 7-bit signed word displacement
fee76 04d          doBRANCH
fee76 04d fb9c4204                         tjnz    tos,#dj1                ' discard flag and continue w/o jumping
                                                                           ' take the jump - X has instruction wordcode
fee7a 04e f7cc1680                         test    fx,#$80 wz              ' reverse jump? nz
fee7e 04f f504167f                         and     fx,#$7F                         ' mask displacement
fee82 050 f0641601                         shl     fx,#1                   ' index as words
fee86 051 f3e3f00b                         sumnz   PTRA,fx                         ' +/- jump
fee8a 052 fdb00058 dj1                     call    #DROP                   ' discard condition flag
fee8e 053 fd9fff88                         jmp     #doNEXT
                   
                   {
                   dPRTPA                  mov     R1,PA
                                           jmp     #TXR1
                   }
                   
                   '###################################################################################'
                   
fee92 054 fd63f02d _ASM                    call    PTRA
fee96 055 fd900034                         jmp     #EXIT
                   
fee9a 056          STRLEN  ' ( str -- len )
fee9a 056 fc780021                         rdfast  #0,tos
fee9e 057 f6044200                         mov     tos,#0
feea2 058 fd601810 .L0                     rfbyte  R0              ' read a byte
feea6 059 f1841801                         sub     R0,#1           ' end is either a null or anything >$7F
feeaa 05a f214187e                         cmp     R0,#$7E wc
feeae 05b c1044201         if_c            add     tos,#1
feeb2 05c cd9fffec         if_c            jmp     #.L0
feeb6 05d fd64002d                         ret
                   
                   
                   ' ?EXIT ( flg -- ) Exit if flg is true
feeba 05e fdb00028 IFEXIT                  call    #POPX
feebe 05f 5d90000c         if_nz           jmp     #EXIT
feec2 060 fd64002d                         ret
                   
                   ' 0EXIT ( flg -- ) Exit if flg is false (or zero)  Used in place of IF......THEN EXIT as false would just end up exiting
feec6 061 fdb0001c ZEXIT                   call    #POPX
feeca 062 5d64002d         if_nz           ret
feece 063 f1842801 EXIT                    sub     retptr,#1
feed2 064 0aa3f014                 _ret_   rdlut   PTRA,retptr
                   
                   
                   { *** STACK OPERATORS *** }
                   
                   ' NIP ( n1 n2 -- n2 ) : 600ns
feed6 065 f6004421 NIP                     mov     tos1,tos
feeda 066 fd900008                         jmp     #DROP
                   ' 3DROP ( n1 n2 n3 -- ) : 1.2us
feede 067 fdb00004 DROP3                   call    #POPX
                   ' 2DROP ( n1 n2 -- ) : 800ns
feee2 068 fdb00000 DROP2                   call    #POPX
                   ' DROP ( n -- ) : 500ns : 400ns
feee6 069          DROP
                   ' Pop the data stack using fixed size register stack in COG memory (allows fast direct access for operations)
                   ' overflow stack in hub ram and reduces the size of the cog stack to 4
feee6 069          POPX ' wz
feee6 069 fb942e07                         tjz     depth,#_NOP     ' don't pop beyond bottom of stack
feeea 06a f6081621                         mov     fx,tos wz       ' pop old tos into X
feeee 06b f6004222                         mov     tos,tos1
feef2 06c f6004423                         mov     tos1,tos2
feef6 06d f6004624                         mov     tos2,tos3
feefa 06e f1842e01                         sub     depth,#1        ' maintain depth count
feefe 06f f1842201                         sub     datptr,#1       ' stack pointer
fef02 070 0aa04811                 _ret_   rdlut   tos3,datptr     ' pop from lut stack into register stack
fef06 071 fd64002d _NOP                    ret
                   
                   
                   ' ?DUP ( n1 -- n1 n1 | 0 ) DUP n1 if non-zero
fef0a 072 fb9443fe QDUP                    tjz     tos,#_NOP
                   ' DUP ( n1 - n1 n1 ) Duplicate the top item on the stack - 48 cycles
fef0e 073 f6001621 DUP                     mov     fx,tos                  ' Read directly from the top of the data stack
fef12 074 fd900338                         jmp     #PUSHX                  ' Push the internal X register onto the datastack
                   
fef16 075 01004222 OVERPLUS        _ret_   add     tos,tos1
                   
fef1a 076 fdb00000 DUP2                    call    #OVER
                   ' OVER ( n1 n2 -- n1 n2 n1 ) - 1us
fef1e 077 f6001622 OVER                    mov     fx,tos1                 'read second data item and push
fef22 078 fd900328                         jmp     #PUSHX
                   ' tos2 ( n1 n2 n3 -- n1 n2 n3 n1 ) Copy the tos2 item onto the stack
fef26 079 f6001623 THIRD                   mov     fx,tos2                 ' read third data item
fef2a 07a fd900320                         jmp     #PUSHX
                   ' 4TH ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 ) Copy the 4th item onto the stack - 1.2us
fef2e 07b f6001624 FOURTH                  mov     fx,tos3
fef32 07c fd900318                         jmp     #PUSHX
                   
                   
                   ' BOUNDS ( n1 n2 -- n2+n1 n1 ) == OVER + SWAP
fef36 07d f1004222 BOUNDS                  add     tos,tos1
                   ' SWAP ( n1 n2 -- n2 n1 ) Swap the top two items
fef3a 07e f6001622 SWAP                    mov     fx,tos1
fef3e 07f f6004421 SWAPX                   mov     tos1,tos
fef42 080 0600420b PUTX            _ret_   mov     tos,fx
                   
                   ' -ROT ( a b c -- c a b )
fef46 081 fdb00000 ROT2                    call    #ROT
                   ' ROT ( a b c -- b c a )
fef4a 082 f6001623 ROT                     mov     fx,tos2
fef4e 083 f6004622                         mov     tos2,tos1
fef52 084 fd9fffe8                         jmp     #SWAPX
                   
                   
                   { *** ARITHMETIC *** }
                   ' - ( n1 n2 -- n3 ) Subtract n2 from n1
fef56 085 f6604221 MINUS                   neg     tos             ' (note: save one long by negating and adding)
                   ' + ( n1 n2 -- n3 ) Add top two stack items together and replace with result
fef5a 086 f1104421 PLUS                    add     tos1,tos wc
fef5e 087 fd9fff84                         jmp     #DROP
                   
                   ' 2-
fef62 088 01844202 DEC2            _ret_   sub     tos,#2
                   ' 1-
fef66 089 01844201 DEC             _ret_   sub     tos,#1
                   
                   ' 4+
fef6a 08a 01044204 INC4            _ret_   add     tos,#4
                   ' 2+
fef6e 08b 01044202 INC2            _ret_   add     tos,#2
                   ' 1+
fef72 08c 01044201 INC             _ret_   add     tos,#1
                   
                   ' -NEGATE ( n1 sn -- n1 | -n1 ) negate n1 if the sign of sn is negative (used in signed divide op)
fef76 08d f044421f MNEGATE                 shr     tos,#31
                    ' ?NEGATE ( n1 flg -- n2 ) negate n1 if flg is true
fef7a 08e fb9443da QNEGATE                 tjz     tos,#DROP
fef7e 08f fdbfff64                         call    #POPX
                   ' NEGATE ( n1 -- n2 )  equivalent to  n2 = 0-n1
fef82 090 06604221 NEGATE          _ret_   neg     tos
                   
                   { *** BOOLEAN *** }
                   {
                   ' INVERT ( n1 -- n2 ) bitwise invert n1 and replace with result n2
                   INVERT                  add     tos,#1
                                           jmp     #NEGATE
                   }
                   ' BITS ( n1 bits -- n2 )
fef86 091 f9c04221 BITS                    decod   tos
fef8a 092 f1844201                         sub     tos,#1
fef8e 093 f5004421 _AND                    and     tos1,tos
fef92 094 fd9fff50                         jmp     #DROP
fef96 095 f5204421 _ANDN                   andn    tos1,tos
fef9a 096 fd9fff48                         jmp     #DROP
fef9e 097 f5404421 _OR                     or      tos1,tos
fefa2 098 fd9fff40                         jmp     #DROP
fefa6 099 f5604421 _XOR                    xor     tos1,tos
fefaa 09a fd9fff38                         jmp     #DROP
                   {
                   ' mainly for testing instructions'
                   _ZEROX                  zerox   tos1,tos
                                           jmp     #DROP
                   }
                   ' *** shift operators ***
                   
                   ' *** RIGHT SHIFT ***
                   ' SHR ( n1 cnt -- n2 ) Shift n1 right by count (5 lsbs )
fefae 09b f0404421 _SHR                    shr     tos1,tos
fefb2 09c fd9fff30                         jmp     #DROP
                   
                   ' 16>>
fefb6 09d 00444210 _SHR16          _ret_   shr     tos,#16
                   ' 9>>
fefba 09e 00444209 _SHR9           _ret_   shr     tos,#9
                   ' 8>>
fefbe 09f 00444208 _SHR8           _ret_   shr     tos,#8
                   
                   ' 4/
fefc2 0a0 00444202 _SHR2           _ret_   shr     tos,#2
                   
                   ' 2/ ( n1 -- n1/2 )
fefc6 0a1 00444201 _SHR1           _ret_   shr     tos,#1
                   
                   
fefca 0a2 f0004421 _ROR                    ror     tos1,tos
fefce 0a3 fd9fff14                         jmp     #DROP
fefd2 0a4 f0c04421 _SAR                    sar     tos1,tos
fefd6 0a5 fd9fff0c                         jmp     #DROP
                   
                   
                   ' *** LEFT SHIFT ***
                   ' << ( n1 bits -- n2 )
fefda 0a6 f0604421 _SHL                    shl     tos1,tos
fefde 0a7 fd9fff04                         jmp     #DROP
                   
                   ' ROL ( n1 bits -- n2 )
fefe2 0a8 f0204421 _ROL                    rol     tos1,tos
fefe6 0a9 fd9ffefc                         jmp     #DROP
                   
fefea 0aa 00644210 _SHL16          _ret_   shl     tos,#16
                   
fefee 0ab 00644209 _SHL9           _ret_   shl     tos,#9
                   ' 8<<
feff2 0ac 00644208 _SHL8           _ret_   shl     tos,#8
                   ' 4*
feff6 0ad 00644202 _SHL2           _ret_   shl     tos,#2
                   ' 2* ( n1 -- n2 ) shift n1 left one bit (equiv to multiply by 2)
feffa 0ae 00644201 _SHL1           _ret_   shl     tos,#1
                   
                   
                   
                   
                   
                   ' REV ( n1 -- n2 ) Reverse bits 0..31 --> 31..0
feffe 0af 0d604269 _REV            _ret_   rev     tos
                   
                   '_BMASK                 bmask   tos
                   
                   ' MASK ( bitpos -- bitmask  \ only the lower 5 bits of bitpos are taken, regardless of the higher bits )
ff002 0b0 09c04221 MASK            _ret_   decod   tos
                   
                   ' ENCODE ( mask -- bitpos )
ff006 0b1 07804221 ENCODE          _ret_   encod   tos
                   
                   ''      FAST MASKING
                   ' 4BITS ( n -- nibble ) mask n to a nibble
ff00a 0b2 0504420f BITS4           _ret_   and     tos,#$0F
                   ' 8BITS ( n -- nibble ) mask n to a byte
ff00e 0b3 050442ff BITS8           _ret_   and     tos,#$FF
                   ' 9BITS
ff012 0b4 050443ff BITS9           _ret_   and     tos,#$1FF
                   
                   
                   
                                           { *** COMPARISON *** }
                   
                   ' Basic instructions from which other comparison instructions are built from
                   
                   
                   ' = ( n1 n2 -- flg ) true if n1 is equal to n2 : 700ns @80
ff016 0b5 fdbffecc _EQ                     call    #POPX
ff01a 0b6 f180420b                         sub     tos,fx          ' n1 == 0 if equal
                   ' 0= ( n -- flg ) true if n = 0  : 400ns @80
ff01e 0b7 fb944202 _ZEQ                    tjz     tos,#SETTRUE
ff022 0b8 06044200                 _ret_   mov     tos,#0
                   
                   ' 0<> ( n -- flg ) true if n <> 0 (promote n to boolean) : 400ns @80
ff026 0b9 fb944201 _ZNE                    tjz     tos,#z1
ff02a 0ba 06004378 SETTRUE         _ret_   mov     tos,M1
ff02e 0bb fd64002d z1                      ret
                   
                   
                   ' <> ( n1 n2 -- flg ) true if n1 <> n2 : 600ns @80
ff032 0bc f1884421 _NEQ                    sub     tos1,tos wz
ff036 0bd 56004578                 if_nz   mov     tos1,M1
ff03a 0be fd9ffea8                         jmp     #DROP
                   
                   
                   ' 0< ( n -- flg ) true if n < 0 (negative) : 400ns @80
ff03e 0bf 00c4421f _ZLT            _ret_   sar     tos,#31
                   
                   ' NOT ( n -- !n ) invert bits of n : 350ns @80
ff042 0c0 06204221 _NOT            _ret_   not     tos
                   
                   
                   ' ABS ( n -- abs )
ff046 0c1 06404221 _ABS            _ret_   abs     tos,tos
                   
ff04a 0c2 fd004222 MULTIPLY                qmul    tos,tos1
ff04e 0c3 fd604418                         getqx   tos1
ff052 0c4 fd9ffe90                         jmp     #DROP
                   
ff056 0c5 fa004421 MUL16                   mul     tos1,tos
ff05a 0c6 fd9ffe88                         jmp     #DROP
                   
                   
                   ' UM* ( u1 u2 -- u1*u2L u1*u2H )
                   ' DESC: unsigned 32bit * 32bit multiply -- 64bit result
ff05e 0c7 fd004222 UMMUL                   qmul    tos,tos1
ff062 0c8 fd604418                         getqx   tos1
ff066 0c9 0d604219                 _ret_   getqy   tos
                   
                   
                   ' U// ( dvdn dvsr -- rem quot )
ff06a 0ca fd104421 UDIVMOD                 qdiv    tos1,tos
ff06e 0cb fd604218                         getqx   tos
ff072 0cc 0d604419                 _ret_   getqy   tos1
                   
                   ' MOD ( n1 mod -- rem )
ff076 0cd fdbffff0 UMOD                    call    #UDIVMOD
ff07a 0ce fd9ffe68                         jmp     #DROP
                   
                   
                   ' U/ ( u1 u2 -- quot )
ff07e 0cf fd104421 UDIVIDE                 qdiv    tos1,tos
ff082 0d0 fd604418                         getqx   tos1
ff086 0d1 fd9ffe5c                         jmp     #DROP
                   
                   
                   
                   ' signed MIN returns the minimum of the two values
ff08a 0d2 f3604421 _MINS                   fles    tos1,tos
ff08e 0d3 fd9ffe54                         jmp     #DROP
ff092 0d4 f3404421 _MAXS                   fges    tos1,tos
ff096 0d5 fd9ffe4c                         jmp     #DROP
                   ' unsigned MIN returns the minimum of the two values
ff09a 0d6 f3204421 _MIN                    fle     tos1,tos
ff09e 0d7 fd9ffe44                         jmp     #DROP
ff0a2 0d8 f3004421 _MAX                    fge     tos1,tos
ff0a6 0d9 fd9ffe3c                         jmp     #DROP
                   
                   { *** MEMORY *** }
                   
                   ' C@++  ( caddr -- caddr+1 byte ) fetch byte character and increment address
ff0aa 0da f6001621 CFETCHINC               mov     fx,tos                  ' dup the address
ff0ae 0db fdb0019c                         call    #PUSHX
ff0b2 0dc f1044401                         add     tos1,#1                 ' inc the backup address
                   ' C@  ( caddr -- byte ) Fetch a byte from hub memory : 500ns @80
ff0b6 0dd 0ac04221 CFETCH          _ret_   rdbyte  tos,tos
                   
                   ' DUPC@
ff0ba 0de fac01621 DUPCFT                  rdbyte  fx,tos
ff0be 0df fd90018c                         jmp     #PUSHX                  ' Push the internal fx register onto the datastack
                   
                   
                   
                   ' W@  ( waddr -- word ) Fetch a word from hub memory
ff0c2 0e0 0ae04221 WFETCH          _ret_   rdword  tos,tos
                   
                   ' @  ( addr -- long ) Fetch a long from hub memory
ff0c6 0e1 0b004221 FETCH           _ret_   rdlong  tos,tos
                   
                   ' C+!  ( n caddr -- ) add n to byte at hub addr : 1.2us @80
ff0ca 0e2 fac01621 CPLUSST                 rdbyte  fx,tos                  ' read in word from adress
ff0ce 0e3 f100440b                         add     tos1,fx                         ' add to contents of address - cascade
                   ' C!  ( n caddr -- ) store n to byte at addr : 1us @80
ff0d2 0e4 fc404421 CSTORE                  wrbyte  tos1,tos                ' write the byte using address on the tos
ff0d6 0e5 fd9ffe08                         jmp     #DROP2
                   
                   ' W+!  ( n waddr -- ) add n to word at hub addr
ff0da 0e6 fae01621 WPLUSST                 rdword  fx,tos                  ' read in word from address
ff0de 0e7 f100440b                         add     tos1,fx
                   ' W!  ( n waddr -- ) store n to word at addr
ff0e2 0e8 fc504421 WSTORE                  wrword  tos1,tos
ff0e6 0e9 fd9ffdf8                         jmp     #DROP2
                   
                   ' +!  ( n addr -- ) add n to long at hub addr
ff0ea 0ea fb001621 PLUSST                  rdlong  fx,tos                  ' read in long from address
ff0ee 0eb f100440b                         add     tos1,fx
                   ' !  ( n addr -- ) store n to long at addr
ff0f2 0ec fc604421 STORE                   wrlong  tos1,tos
ff0f6 0ed fd9ffde8                         jmp     #DROP2
                   
                   ' LUT@ ( addr -- data ) : 400ns
ff0fa 0ee 0aa04221 LUTFETCH        _ret_   rdlut   tos,tos
                   
                   ' LUT! ( data addr -- ) : 900ns
ff0fe 0ef fc304421 LUTSTORE                wrlut   tos1,tos
ff102 0f0 fd9ffddc                         jmp     #DROP2
                   
                   
                   ' BLOCK MOVE
                   '
                   ' 171219 64K in 19.866ms using rep vs 24.872ms using djnz
                   ' RCMOVE bytes from source to destination primitive - <CMOVE conditions the parameters before calling
                   ' (RCMOVE) ( src dst cnt -- ) Copy bytes from src to dst for cnt bytes starting from the ends (in reverse)
ff106 0f1 fd75e06f pRCMOVE                 modcz   _set,0 wc  'modc    $0F wc          ' set carry for decrementing (always cleared by PUSH)
                   ' (CMOVE) ( src dst cnt -- ) Copy cnt bytes from src to dst address
ff10a 0f2 fcd80821 CMOVE                   rep     @.end,tos
ff10e 0f3 fac01823                         rdbyte  R0,tos2         ' read source byte
ff112 0f4 f3844601                         sumc    tos2,#1         ' inc or dec depending upon carry
ff116 0f5 fc401822                         wrbyte  R0,tos1         ' write destination byte
ff11a 0f6 f3844401                         sumc    tos1,#1         ' inc or dec depending upon carry!!
ff11e 0f7 fd9ffdbc .end                    jmp     #DROP3
                   
                   ' ------------------------------------------------------------------------------
                   
                   ' wrfast rep code -> $6.0000 $1.0000 LAP ERASE LAP DECIMAL .LAP 131208 cycles = 1.640ms/64K
                    ' ( addr bytes -- )
ff122 0f8 fdb00124 ERASE                   call    #PUSHACC
                   ' ( addr cnt fillch -- )
ff126 0f9 fc804423 CFILL                   wrfast  tos1,tos2
ff12a 0fa fcd80222                         rep     @.L0,tos1
ff12e 0fb fd604215                         wfbyte  tos
ff132 0fc fd9ffda8 .L0                     jmp     #DROP3
                   
                   ' Test for non-zero data in memory block
                   ' DATA? ( addr longs -- flg )
ff136 0fd fc780022 DATAQ                   rdfast  #0,tos1
ff13a 0fe fcd80421                         rep     @.L0,tos
ff13e 0ff fd601612                         rflong  fx
ff142 100 f540140b                         or      ACC,fx
ff146 101 f600440a .L0                     mov     tos1,ACC
ff14a 102 fd9ffd98                         jmp     #DROP
                   
                   
                   
                   ' I ( -- index ) read the loop index
ff14e 103 f6001625 IX                      mov     fx,index
ff152 104 fd9000f8                         jmp     #PUSHX
                   ' J ( -- index ) read the loop index
ff156 105 f6001627 J                       mov     fx,index2
ff15a 106 fd9000f0                         jmp     #PUSHX
                   ' IC@ ( -- byte )
ff15e 107 fac01625 ICFETCH                 rdbyte  fx,index
ff162 108 fd9000e8                         jmp     #PUSHX
                   ' I+ ( n -- n+I ) fast index offset i.e.  table I+
ff166 109 01004225 IPLUS           _ret_   add     tos,index
                   
                   
                   { *** BRANCH & LOOP *** }
                   
                   
                   
                   ' ADO = BOUNDS DO - just a quick and direct way as BOUNDS is most often never used elsewhere
                   ' ADO ( from cnt -- )
ff16a 10a fdbffdc8 ADO             call    #BOUNDS
                   '
                                                                           ' DO ( to from -- )
ff16e 10b fdbffdc8 DO              call    #SWAP
ff172 10c fdb000a4                 call    #PUSHL                          ' PUSH index onto loop stack
                   '
                                                                           ' FOR ( count -- ) Setup FOR...NEXT loop for count
                   '
ff176 10d fc305212 FOR             wrlut   branchadr,braptr
ff17a 10e f1042401                 add     braptr,#1
ff17e 10f f60053f8                 mov     branchadr,PTRA
                   ' >L ( n -- ) Push n onto the loop stack
ff182 110 fd900094                 jmp     #PUSHL
                   
                   ' L> ( -- n ) Pop n from the loop stack
ff186 111 fdb00078 LPOP            call    #LPOPX                          ' Pop loop stack into X
ff18a 112 fd9000c0                 jmp     #PUSHX                          ' Push X onto the data stack as tos
                   
                   ' +LOOP ( n1 -- )
ff18e 113 fdbffd54 PLOOP           call    #POPX                           ' get loop increment
ff192 114 f1004a0b                 add     index,fx                                ' add to index
ff196 115 f1844a01                 sub     index,#1                        ' compensate so we can drop through to LOOP
                   ' The comparison above is between the call insn (wr) at DELTA and the jump insn (nr) at POPX_ret,
                   ' this will always be carry set. The call itself is indirect.
                   '
ff19a 116 f1044a01 LOOP            add     index,#1                        ' increment index
ff19e 117 f2584c25                 cmps    limit1,index wcz
ff1a2 118 1603f029 BRANCH  if_a    mov     PTRA,branchadr                  ' Branch to the address that is saved in branch stack
ff1a6 119 1d64002d         if_a    ret
ff1aa 11a fdb00054                 call    #LPOPX                          ' discard the limit
ff1ae 11b f1842401 POPBRANCH       sub     braptr,#1
ff1b2 11c f2142420                 cmp     braptr,#brastk wc
ff1b6 11d c6042420         if_c    mov     braptr,#brastk
ff1ba 11e faa05212                 rdlut   branchadr,braptr
ff1be 11f fd900040                 jmp     #LPOPX                          ' discard the index
                                                                                   ' then next loop and its branch address
                   
                   ' ?NEXT ( flg -- index ) Same as NEXT except terminate early if flag is true and return with flag
ff1c2 120 f6084221 QNEXT           mov     tos,tos wz
ff1c6 121 5d9fffe4         if_nz   jmp     #POPBRANCH
ff1ca 122 f19c4a01                 sub     index,#1 wcz
ff1ce 123 5603f029         if_nz   mov     PTRA,branchadr
ff1d2 124 5d9ffd10         if_nz   jmp     #DROP                           ' discard flag and continye looping
ff1d6 125 fd9fffd4                 jmp     #POPBRANCH
                   
                   ' NEXT ( -- ) Decrement count (on loop stack) and loop until 0, then pop loop stack
ff1da 126 fb644bf4 forNEXT         djz     index,#POPBRANCH                ' exit loop
ff1de 127 0603f029         _ret_   mov     PTRA,branchadr                  ' loop again
                   
                   
                   ' LEAVE -  make the loop index = to the limit so that it will leave on the next LOOP
ff1e2 128 f6004a26 LEAVE           mov     index,limit1
ff1e6 129 01844a01         _ret_   sub     index,#1
                   
                   {HELP >R ( n -- ) Push n onto the return stack }
ff1ea 12a fc304214 PUSHR           wrlut   tos,retptr
ff1ee 12b f1042801                 add     retptr,#1
ff1f2 12c fd9ffcf0                 jmp     #DROP
                   
                   {HELP R> ( -- n ) Pop n from the return stack }
ff1f6 12d f1842801 RPOP            sub     retptr,#1
ff1fa 12e faa01614                 rdlut   fx,retptr
ff1fe 12f fd90004c                 jmp     #PUSHX                          ' Push X onto the data stack as tos
                   
                   
                   
ff202 130          LPOPX
ff202 130 f6001625                 mov     fx,index
ff206 131 f6004a26                 mov     index,limit1
ff20a 132 f6004c27                 mov     limit1,index2
ff20e 133 f6004e28                 mov     index2,limit2
ff212 134 f1842601                 sub     lpptr,#1
ff216 135 0aa05013         _ret_   rdlut   limit2,lpptr
                   
                   ' 171231 - mod so that index is on top/last
                   ' limit         -> index
                   ' index         -> limit
                   ' limit2        -> indexJ
                   ' index2        -> limitJ
                   ' stack
                   
                   ' >L ( tos -- ) Push tos onto the loop stack and drop tos
ff21a 136          PUSHL
ff21a 136 fc305013                 wrlut   limit2,lpptr                    ' push bottom register to stack
ff21e 137 f1042601                 add     lpptr,#1
ff222 138 f6005027                 mov     limit2,index2                   ' ripple registers
ff226 139 f6004e26                 mov     index2,limit1
ff22a 13a f6004c25                 mov     limit1,index
ff22e 13b f6004a21                 mov     index,tos
ff232 13c fd9ffcb0                 jmp     #POPX
                   
                   
                   { *** LITERALS *** }
                   
                   ' LITERALS are stored unaligned in big endian format which faciliates cascading byte reads to accumulate the full number
                   
                   ' ( -- 32bits ) Push a 32-bit literal onto the datastack by reading in the next 4 bytes (non-aligned)
                   
ff236 13d fb041761 _LONG                   rdlong  fx,PTRA++
ff23a 13e fd900010                         jmp     #PUSHX
                   
                   ' Read an inline word literal and push it onto the stack
                   '
ff23e 13f fae41761 _WORD                   rdword  fx,PTRA++
ff242 140 fd900008                         jmp     #PUSHX
                   
                   
ff246 141          _TRUE
ff246 141 f1841401 MINUS1          sub     ACC,#1
ff24a 142 f600160a PUSHACC         mov     fx,ACC          ' Push the accumulator onto the stack then zero it
ff24e 143 f6041400 PUSHX           mov     ACC,#0          ' clear it for next operation
ff252 144 fc304811                 wrlut   tos3,datptr     ' save bottom of register stack into lut memory
ff256 145 f1042201                 add     datptr,#1
ff25a 146 f6004823                 mov     tos3,tos2       ' push 4 top items held in registers
ff25e 147 f6004622                 mov     tos2,tos1
ff262 148 f6004421                 mov     tos1,tos
ff266 149 f600420b                 mov     tos,fx          ' replace tos with X (DEFAULT)
ff26a 14a f1042e01                 add     depth,#1        ' the depth variable indexes bytes in LUT
ff26e 14b 0d74006f         _ret_   modcz   0,0 wc          ' clear C for some operations that use this to determine behaviour
                   
                   
                   
                   { *** CONSTANTS & VARIABLES *** }
                   { Constants and variables etc are standalone fragments preceded by an opcode then the parameters,
                   either a long or the addess of the parameter field.
                   They are called from the main program and only use the IP to get the result.
                   }
                   
ff272 14c 00000000 DATCON                  nop                     ' This entry is used for constants that point to the DATA area - FORGETable by signature
ff276 14d fb041700 CONL                    rdlong  fx,PTRA
ff27a 14e fdbfffd0                         call    #PUSHX
ff27e 14f fd9ffc4c                         jmp     #EXIT
                   {
                   CONW                    rdword  fx,PTRA
                                           call    #PUSHX
                                           jmp     #EXIT
                   }
                   
                   ' INLINE:
ff282 150 f60017f8 VARB                    mov     fx,PTRA
ff286 151 fdbfffc4                         call    #PUSHX
ff28a 152 fd9ffc40                         jmp     #EXIT
                   
                   
                   
                   
                   
                   
                   { *** SMART PINS *** }
                   {
                   WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#
                   WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#
                   WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#
                   RDPIN   D,S/#        - Get smart pin S/# result Z into D
                   
                   V30
                   WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
                   WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
                   WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
                   RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
                   RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
                   AKPIN   S/#        - Acknowledge pin S/#
                   
                   }
                   
                   ' 160620-2300 - MODIFIED SMARTPIN OPS TO USE "pinreg" for faster access
                   ' WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
                   ' WRPIN ( dst -- )
ff28e 153 fc004218 _WRPIN                  wrpin   tos,pinreg
ff292 154 fd9ffc50                         jmp     #DROP
                   
                   
                   ' WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
                   ' WXPIN ( dst -- )
ff296 155 fc104218 _WXPIN                  wxpin   tos,pinreg
ff29a 156 fd9ffc48                         jmp     #DROP
                   
                   
                   ' WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
                   ' WYPIN ( dst -- )
ff29e 157 fc204218 _WYPIN                  wypin   tos,pinreg
ff2a2 158 fd9ffc40                         jmp     #DROP
                   
                   
                   ' RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
                   ' RDPIN ( -- res )
ff2a6 159 fa881618 _RDPIN                  rdpin   fx,pinreg
ff2aa 15a fd9fffa0                         jmp     #PUSHX
                   
                   ' RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
                   ' RQPIN ( -- res )
ff2ae 15b fa801618 _RQPIN                  rqpin   fx,pinreg
ff2b2 15c fd9fff98                         jmp     #PUSHX
                   
                   
                   ' AKPIN   S/#        - Acknowledge pin S/#
                   ' AKPIN  ( -- )
ff2b6 15d 0c080218 _AKPIN          _ret_   wrpin   #1,pinreg
                   
                   {
                   ' BEGIN RDPIN $80 AND 0= UNTIL
                   WAITPIN                 rdpin   fx,pinreg
                                           testb   fx,#7 wz
                                   if_nz   jmp     #WAITPIN
                                           ret
                   }
                   
ff2ba 15e fd703040 WAITPIN			testp	pinreg wc
ff2be 15f 3d9ffff8 		if_nc	jmp	#WAITPIN
ff2c2 160 fd64002d 			ret
                   
                   
                   ' TXDAT ( buf cnt -- )  write buffer direct to WYPIN
ff2c6 161 fc780022 _TXDAT                  rdfast  #0,tos+1
                   ''                      rep     @.end,tos
ff2ca 162 fd601610 .L1                     rfbyte  fx
ff2ce 163 fc201618                         wypin   fx,pinreg
ff2d2 164 fd703040 .wait                   testp   pinreg  wc              '..wait for buffer empty
ff2d6 165 3d9ffff8         if_nc           jmp     #.wait
ff2da 166 fc080218                         akpin   pinreg                  '..acknowledge pin
ff2de 167 fb6c43fa                         djnz    tos,#.L1
ff2e2 168 fd9ffbfc .end                    jmp     #DROP2
                   
                   
                   
                   { *** I/O ACCESS *** }
                   
                   
                   ' Fast pin operations via PIN pinreg
                   
                   ' H - set the PIN high - fast as the parameter is in the pinreg
ff2e6 169 0d603059 H               _ret_   drvh    pinreg
                   
                   ' L - set the PIN low - fast as the parameter is in the pinreg
ff2ea 16a 0d603058 L               _ret_   drvl    pinreg
                   
ff2ee 16b 0d60305f _T              _ret_   drvnot  pinreg
                   
                   ' F - float pin
ff2f2 16c 0d603040 F               _ret_   dirl    pinreg
                   ' R - read pin
                   
ff2f6 16d fd703040 R                       testp   pinreg wc
ff2fa 16e c1841401                 if_c    sub     ACC,#1
ff2fe 16f fd9fff48                         jmp     #PUSHACC
                   
                   ' normal pin operations via stack
                   
                   ' HIGH ( pin -- )
ff302 170 fd604259 HIGH                    drvh    tos
ff306 171 fd9ffbdc                         jmp     #DROP
                   ' LOW ( pin -- )
ff30a 172 fd604258 LOW                     drvl    tos
ff30e 173 fd9ffbd4                         jmp     #DROP
                   ' FLOAT ( pin -- )
ff312 174 fd604240 _FLOAT                  dirl    tos
ff316 175 fd9ffbcc                         jmp     #DROP
                   ' PIN@ ( bit -- state )
ff31a 176 fd704240 PINTEST                 testp   tos wc
ff31e 177 05804378                 _ret_   muxc    tos,M1
                   
ff322 178 ffffffff M1                      long    -1
                   
                   
                   '************************************* SERIAL I/O **************************************
ff326 179 f6030421 SEROUT          mov     txpin,tos
ff32a 17a fd9ffbb8                 jmp     #DROP
                   
                   
ff32e 17b f6001a21 CONEMIT         mov     R1,tos
ff332 17c f607043e TXR1            mov     txpin,#tx_pin
ff336 17d fc201b82                 wypin   r1,txpin             '..send byte
ff33a 17e fd64001f                 waitx   #0
ff33e 17f fd730440 .wait           testp   txpin         wc      '..wait for buffer empty
ff342 180 3d9ffff8  if_nc          jmp     #.wait
ff346 181 fd9ffb9c                 jmp     #DROP
ff34a 182 0000003e txpin           long    tx_pin
                   
                   
                   '********************** SPI READ/WRITE *********************
                   
                   ' Read bytes in from SPI to memory
                   ' SPI>BUF ( dst cnt -- sum ) 461.7us/512
ff34e 183 fc880022 SPIRX           wrfast  #0,tos1
ff352 184 f6044400                 mov     tos1,#0
ff356 185 fcdc0a08 .L0             rep     @.end,#8                ' 8 bits
ff35a 186 fd60044f                  outnot  sck                     ' clock (low high or low high)
ff35e 187 f0a41a01 		 rcl     r1,#1                   ' shift in msb first
ff362 188 fd60044f                  outnot  sck
ff366 189 00000000 		 nop
ff36a 18a fd700840                  testp   miso wc                 ' read data from card
ff36e 18b          .end
ff36e 18b f0a41a01 		rcl     r1,#1                   ' shift in msb first
ff372 18c fd601a15                 wfbyte  r1
ff376 18d fb6c43f7                 djnz    tos,#.L0
ff37a 18e fd9ffb68                 jmp     #DROP
                   
                   
                   ' Read 32-bits from SPI'
ff37e 18f          SPIRDL
ff37e 18f fcdc1020                 rep     @sre1,#32
ff382 190 fd640231                 skip    #1
                   ' SPIRD ( dat -- dat+rd )
ff386 191          SPIRD
ff386 191 fcdc0c08                 rep     @sre1,#8                ' 8 bits
ff38a 192 fd60044f                  outnot  sck                     ' clock (low high)
ff38e 193 00000000 RWAIT		 nop
ff392 194 fd60044f                  outnot  sck
ff396 195 00000000 		 nop
ff39a 196 fd700840                  testp   miso wc                 ' read data from card
ff39e 197 f0a44201                  rcl     tos,#1                  ' shift in msb first
ff3a2 198 fd64002d sre1            ret
                   
                   
                   ' Write bytes from memory to SPI '
                   ' SPITX ( src bytes -- ) ' 474.6us/512
ff3a6 199 fd600a58 SPITXE		drvl	ss
ff3aa 19a fd600458           	drvl    sck
ff3ae 19b fc780022 SPITX           rdfast  #0,tos1
ff3b2 19c fd601610 .L0             rfbyte  fx
ff3b6 19d f0641618                 shl     fx,#24
ff3ba 19e f6041a08 		mov	r1,#8
ff3be 19f fdb00024 		call	#SPITX8
ff3c2 1a0 fb6c43fb              	djnz    tos,#.L0
ff3c6 1a1 fd9ffb18                 jmp     #DROP2
                   
                   
                   ' SMARTPINS? TRY CLOCKING ENABLED   C=1 in %CIOHHHLLL ?
                   
                   ' Write SD Command
ff3ca 1a2 f504423f SPIWRC		and     tos,#$3F
ff3ce 1a3 f5444240 		or      tos,#$40
                   ' SPIWR8 ( byte -- )
                   ' Shift 8 bits from data[0..7] out and leave data on stack (restored with other bytes zeroed)
                   '
ff3d2 1a4 f0644218 SPIWR8          shl     tos , #24               ' left justify 8-bit data s
ff3d6 1a5 f6041a08 		mov	r1,#8
ff3da 1a6 fd600a58 SPIWR		drvl	ss
ff3de 1a7 fd600458            	drvl    sck
ff3e2 1a8 fdbffb00 		call	#POPX			' POP VALUE '
ff3e6 1a9 fcd80a0d SPITX8		rep     @.L1,r1
ff3ea 1aa f0341601                  rol     fx,#1 wc               ' output next msb
ff3ee 1ab fd60064a                  outc    mosi
ff3f2 1ac fd60044f                  outnot  sck                     ' clock
ff3f6 1ad 00000000 		 nop
ff3fa 1ae fd60044f                  outnot  sck                     ' clock
ff3fe 1af fd64002d .L1            ret
                   
                   
ff402 1b0 f6041a20 SPIWRL		mov	r1,#32
ff406 1b1 fd9fffd0 		jmp	#SPIWR
ff40a 1b2 f0644208 SPIWM		shl	tos,#8
ff40e 1b3 f6041a18 		mov	r1,#24
ff412 1b4 fd9fffc4 		jmp	#SPIWR
ff416 1b5 f0644210 SPIWR16		shl	tos,#16
ff41a 1b6 f6041a10 		mov	r1,#16
ff41e 1b7 fd9fffb8 		jmp	#SPIWR
                   
ff422 1b8 fd600a59 SPICE  		drvh    ss
ff426 1b9 0d600459 	_ret_	drvh	sck			' P2 shares clock as ce with other boot devices'
                   
                   
                   ' I2C support
                   ' CLKOUT ( iobit dat -- iobit dat2 ) REG6=iomask ) Shift msb bit out,  clock high, clock low
ff42a 1ba fd604448 CLKOUT          outl    tos+1              ' ensure output will be active low
ff42e 1bb fd603658                 drvl    clockpins
ff432 1bc f0744201                 shl     tos,#1 wc
ff436 1bd fd604443                 dirnc   tos+1                   ' make it an output if it is a low else float
                   ' CLOCK ( REG6=iomask ) Toggle multiple bits on the output)
ff43a 1be fd60364f CLOCK           outnot  clockpins
ff43e 1bf fb943802                 tjz     clkdly,#ckx
ff442 1c0 f600161c                 mov     fx,clkdly
ff446 1c1 0b6c17ff         _ret_   djnz    fx,#$
ff44a 1c2 fd64002d ckx             ret
                   
                   ' $01CA
                   ' CLKIN ( iomask dat -- iomask dat2 )
ff44e 1c3 fd604440 CLKIN           dirl    tos+1
ff452 1c4 fd704440                 testp   tos+1 wc
ff456 1c5 f0a44201                 rcl     tos,#1
ff45a 1c6 fd9fffdc                 jmp     #CLOCK
                   
                   
                   ' timing utility word
ff45e 1c7 f6002c15 LAP             mov     lap2,lap1
ff462 1c8 0d602a1a         _ret_   getct   lap1
                   
                   
ff466 1c9          ENDCOG
ff466 1c9                          fit 496
                   
                   '************************************************************************************
                   '************************************** DICTIONARY **********************************
                   '************************************************************************************
                   
                   { *** DICTIONARY *** }
ff466                      orgh
ff466              romdict
                   
                   ' The count field is left blank but filled in at cold boot so that these do not need to be calculated when defining
                   '
                           ''      CNT,NAME,ATR,addr16
ff466     50554403         byte 3,         "DUP"
ff46a     0073             word DUP
ff46c     45564f04         byte 4,         "OVER"
ff471     0077             word OVER
ff473     41575304         byte 4,         "SWAP"
ff478     007e             word SWAP
ff47a     544f5203         byte 3,         "ROT"
ff47e     0082             word ROT
ff480     4f522d04         byte 4,         "-ROT"
ff485     0081             word ROT2
ff487     4f524404         byte 4,         "DROP"
ff48c     0069             word DROP
ff48e     44523303         byte 3,         "3RD"
ff492     0079             word THIRD
ff494     48543403         byte 3,         "4TH"
ff498     007b             word FOURTH
                   
ff49a     52443205         byte 5,         "2DROP"
ff4a0     0068             word DROP2
ff4a2     52443305         byte 5,         "3DROP"
ff4a8     0067             word DROP3
ff4aa     50494e03         byte 3,         "NIP"
ff4ae     0065             word NIP
ff4b0     57533205         byte 5,         "2SWAP"
ff4b6     eb92             word DSWAP
ff4b8     55443204         byte 4,         "2DUP"
ff4bd     0076             word DUP2
ff4bf     55443f04         byte 4,         "?DUP"
ff4c4     0072             word QDUP
                   
                   ' BITWISE LOGIC
ff4c6     444e4103         byte 3,         "AND"
ff4ca     0093             word _AND
ff4cc     444e4104         byte 4,         "ANDN"
ff4d1     0095             word _ANDN
ff4d3     524f02           byte 2,         "OR"
ff4d6     0097             word _OR
ff4d8     524f5803         byte 3,         "XOR"
ff4dc     0099             word _XOR
                   
                   ''        byte 5,       "ZEROX"
                   ''        word _ZEROX
                   
                   ' SHIFT'
ff4de     4c4f5203         byte 3,         "ROL"
ff4e2     00a8             word _ROL
ff4e4     524f5203         byte 3,         "ROR"
ff4e8     00a2             word _ROR
ff4ea     3e3e02           byte 2,         ">>"
ff4ed     009b             word _SHR
ff4ef     3c3c02           byte 2,         "<<"
ff4f2     00a6             word _SHL
ff4f4     52415303         byte 3,         "SAR"
ff4f8     00a4             word _SAR
ff4fa     2f3202           byte 2,         "2/"
ff4fd     00a1             word _SHR1
ff4ff     2a3202           byte 2,         "2*"
ff502     00ae             word _SHL1
ff504     2f3402           byte 2,         "4/"
ff507     00a0             word _SHR2
ff509     2a3402           byte 2,         "4*"
ff50c     00ad             word _SHL2
ff50e     3c3c3803         byte 3,         "8<<"
ff512     00ac             word _SHL8
ff514     3e363104         byte 4,         "16>>"
ff519     009d             word _SHR16
ff51b     3e3e3803         byte 3,         "8>>"
ff51f     009f             word _SHR8
ff521     3c3c3903         byte 3,         "9<<"
ff525     00ab             word _SHL9
ff527     3e3e3903         byte 3,         "9>>"
ff52b     009e             word _SHR9
                   
ff52d     56455203         byte 3,         "REV"
ff531     00af             word _REV
ff533     3c7c02           byte 2,         "|<"
ff536     00b0             word MASK
ff538     7c3e02           byte 2,         ">|"
ff53b     00b1             word ENCODE
                   
ff53d     4e3e02           byte 2,         ">N"
ff540     00b2             word BITS4
ff542     423e02           byte 2,         ">B"
ff545     00b3             word BITS8
ff547     393e02           byte 2,         ">9"
ff54a     00b4             word BITS9
ff54c     54494204         byte 4,         "BITS"
ff551     0091             word BITS
                   
                   
ff553     544f4e03         byte 3,         "NOT"
ff557     00c0             word _NOT
                   
                   ' COMPARISON
ff559     3d01             byte 1,         "="
ff55b     00b5             word _EQ
ff55d     3e3c02           byte 2,         "<>"
ff560     00bc             word _NEQ
                   
ff562     3d3002           byte 2,         "0="
ff565     00b7             word _ZEQ
ff567     3e3c3003         byte 3,         "0<>"
ff56b     00b9             word _ZNE
ff56d     3c3002           byte 2,         "0<"
ff570     00bf             word _ZLT
ff572     3c01             byte 1,         "<"
ff574     eb4a             word LT
ff576     3c5502           byte 2,         "U<"
ff579     eb52             word _ULT
ff57b     3e01             byte 1,         ">"
ff57d     eb42             word GT
ff57f     3e5502           byte 2,         "U>"
ff582     d112             word UGT
ff584     3d3c02           byte 2,         "<="
ff587     d118             word LTEQ
ff589     3e3d02           byte 2,         "=>"
ff58c     d11a             word EQGT
ff58e     54495706         byte 6,         "WITHIN"
ff595     d77e             word WITHIN
                   
ff597     50554405         byte 5,         "DUPC@"
ff59d     00de             word DUPCFT
                   
ff59f     404302           byte 2,         "C@"
ff5a2     00dd             word CFETCH
ff5a4     405702           byte 2,         "W@"
ff5a7     00e0             word WFETCH
ff5a9     4001             byte 1,         "@"
ff5ab     00e1             word FETCH
ff5ad     212b4303         byte 3,         "C+!"
ff5b1     00e2             word CPLUSST
ff5b3     214302           byte 2,         "C!"
ff5b6     00e4             word CSTORE
ff5b8     2b404304         byte 4,         "C@++"
ff5bd     00da             word CFETCHINC
ff5bf     212b5703         byte 3,         "W+!"
ff5c3     00e6             word WPLUSST
ff5c5     215702           byte 2,         "W!"
ff5c8     00e8             word WSTORE
ff5ca     212b02           byte 2,         "+!"
ff5cd     00ea             word PLUSST
ff5cf     2101             byte 1,         "!"
ff5d1     00ec             word STORE
                   
ff5d3     54494204         byte 4,         "BIT!"
ff5d8     ec2a             word BITST
ff5da     54455303         byte 3,         "SET"
ff5de     ec32             word SET
ff5e0     524c4303         byte 3,         "CLR"
ff5e4     ec42             word CLR
ff5e6     54455304         byte 4,         "SET?"
ff5eb     ec52             word BITQ
                   
                   
                   
                   ' MATHS
ff5ed     2b3102           byte 2,         "1+"
ff5f0     008c             word INC
ff5f2     2d3102           byte 2,         "1-"
ff5f5     0089             word DEC
ff5f7     2b3202           byte 2,         "2+"
ff5fa     008b             word INC2
ff5fc     2d3202           byte 2,         "2-"
ff5ff     0088             word DEC2
ff601     2b3402           byte 2,         "4+"
ff604     008a             word INC4
ff606     2b01             byte 1,         "+"
ff608     0086             word PLUS
ff60a     2d01             byte 1,         "-"
ff60c     0085             word MINUS
                   
ff60e     2a4d5503         byte 3,         "UM*"
ff612     00c7             word UMMUL
ff614     2a01             byte 1,         "*"
ff616     00c2             word MULTIPLY
ff618     2a5702           byte 2,         "W*"
ff61b     00c5             word MUL16
                   
ff61d     2f01             byte 1,         "/"
ff61f     d120             word DIVIDE
ff621     2f5502           byte 2,         "U/"
ff624     00cf             word UDIVIDE
ff626     2f2f5503         byte 3,         "U//"
ff62a     00ca             word UDIVMOD
ff62c     2f2f02           byte 2,         "//"
ff62f     00cd             word UMOD
ff631     2f2a02           byte 2,         "*/"
ff634     d132             word MULDIV
ff636     2f4d5504         byte 4,         "UM//"
ff63b     eb5e             word UMDIVMOD64
                   
ff63d     2b2b4303         byte 3,         "C++"
ff641     d144             word CINC
ff643     2d2d4303         byte 3,         "C--"
ff647     d140             word CDEC
ff649     2b2b5703         byte 3,         "W++"
ff64d     d150             word WINC
ff64f     2d2d5703         byte 3,         "W--"
ff653     d14c             word WDEC
ff655     2b2b02           byte 2,         "++"
ff658     d15c             word LINC
ff65a     2d2d02           byte 2,         "--"
ff65d     d158             word LDEC
                   
ff65f     444e5203         byte 3,         "RND"
ff663     eb2a             word _RND
ff665     54454706         byte 6,         "GETRND"
ff66c     eca6             word _GETRND
ff66e     52515304         byte 4,         "SQRT"
ff673     ec92             word _SQRT
ff675     54455307         byte 7,         "SETDACS"
ff67d     ec9e             word _SETDACS
                   
ff67f     7e01             byte 1,         "~"
ff681     ec66             word CLRL
ff683     7e7e02           byte 2,         "~~"
ff686     ec62             word SETL
ff688     7e5702           byte 2,         "W~"
ff68b     ec72             word CLRW
ff68d     7e7e5703         byte 3,         "W~~"
ff691     ec6e             word SETW
ff693     7e4302           byte 2,         "C~"
ff696     ec7e             word CLRC
ff698     7e7e4303         byte 3,         "C~~"
ff69c     ec7a             word SETC
                   
ff69e     533e4c03         byte 3,         "L>S"
ff6a2     ec1a             word L2S
ff6a4     573e02           byte 2,         ">W"
ff6a7     e1ac             word TOW
ff6a9     573e4c03         byte 3,         "L>W"
ff6ad     e1b2             word L2W
ff6af     423e5703         byte 3,         "W>B"
ff6b3     e1bc             word W2B
ff6b5     4c3e5703         byte 3,         "W>L"
ff6b9     e1d0             word W2L
ff6bb     573e4203         byte 3,         "B>W"
ff6bf     e1d2             word B2W
ff6c1     4c3e4203         byte 3,         "B>L"
ff6c5     e1c8             word B2L
                   
                   
                   
ff6c7     4e494d04         byte 4,         "MINS"
ff6cc     00d2             word _MINS
ff6ce     58414d04         byte 4,         "MAXS"
ff6d3     00d4             word _MAXS
ff6d5     4e494d03         byte 3,         "MIN"
ff6d9     00d6             word _MIN
ff6db     58414d03         byte 3,         "MAX"
ff6df     00d8             word _MAX
                   
ff6e1     53424103         byte 3,         "ABS"
ff6e5     00c1             word _ABS
                   
ff6e7     454e2d07         byte 7,         "-NEGATE"
ff6ef     008d             word MNEGATE
ff6f1     454e3f07         byte 7,         "?NEGATE"
ff6f9     008e             word QNEGATE
ff6fb     47454e06         byte 6,         "NEGATE"
ff702     0090             word NEGATE
                   
                   
                   ' CONSTANTS '
ff704     4e4f02           byte 2,         "ON"
ff707     0141             word MINUS1
ff709     55525404         byte 4,         "TRUE"
ff70e     0141             word MINUS1
ff710     312d02           byte 2,         "-1"
ff713     0141             word MINUS1
                   
ff715     4c414605         byte 5,         "FALSE"
ff71b     f800             word _0
ff71d     46464f03         byte 3,         "OFF"
ff721     f800             word _0
                   
                   
                   
                   ' STRUCTURES
ff723     544f4784         byte 4+im,      "GOTO"
ff728     d50c             word GOTO
ff72a     464982           byte 2+im,      "IF"
ff72d     d500             word _IF_
ff72f     534c4584         byte 4+im,      "ELSE"
ff734     d516             word _ELSE_
ff736     45485484         byte 4+im,      "THEN"
ff73b     d526             word _THEN_
                           'byte 5,        "ENDIF"         +im
                           'word                   _THEN_
ff73d     47454285         byte 5+im,      "BEGIN"
ff743     d4b8             word _BEGIN_
ff745     544e5585         byte 5+im,      "UNTIL"
ff74b     d4e6             word _UNTIL_
ff74d     41474185         byte 5+im,      "AGAIN"
ff753     d4da             word _AGAIN_
ff755     49485785         byte 5+im,      "WHILE"
ff75b     d500             word _IF_
ff75d     50455286         byte 6+im,      "REPEAT"
ff764     d4d4             word _REPEAT_
                   
ff766     49575306         byte 6,         "SWITCH"
ff76d     d75a             word _SWITCH
ff76f     53414305         byte 5,         "CASE@"
ff775     d75e             word SWFETCH
ff777     53414305         byte 5,         "CASE="
ff77d     d762             word ISEQ
ff77f     53414305         byte 5,         "CASE>"
ff785     d778             word ISWITHIN
ff787     45524285         byte 5+im,      "BREAK"
ff78d     d770             word ISEND
ff78f     53414384         byte 4+im,      "CASE"
ff794     d768             word _CASE
                   
                   ' LOOPS'
ff796     4f444103         byte 3,         "ADO"
ff79a     010a             word ADO
ff79c     4f4402           byte 2,         "DO"
ff79f     010b             word DO
ff7a1     4f4f4c04         byte 4,         "LOOP"
ff7a6     0116             word LOOP
ff7a8     4f4c2b05         byte 5,         "+LOOP"
ff7ae     0113             word PLOOP
ff7b0     524f4603         byte 3,         "FOR"
ff7b4     010d             word FOR
ff7b6     58454e04         byte 4,         "NEXT"
ff7bb     0126             word forNEXT
ff7bd     454e3f05         byte 5,         "?NEXT"
ff7c3     0120             word QNEXT
ff7c5     4901             byte 1,         "I"
ff7c7     0103             word IX
ff7c9     4a01             byte 1,         "J"
ff7cb     0105             word J
ff7cd     41454c05         byte 5,         "LEAVE"
ff7d3     0128             word LEAVE
ff7d5     40434903         byte 3,         "IC@"
ff7d9     0107             word ICFETCH
ff7db     2b4902           byte 2,         "I+"
ff7de     0109             word IPLUS
ff7e0     554f4206         byte 6,         "BOUNDS"
ff7e7     007d             word BOUNDS
                   
                   
                   ' -------------I/O---------------
                   
ff7e9     4801             byte 1,         "H"
ff7eb     0169             word H
ff7ed     4c01             byte 1,         "L"
ff7ef     016a             word L
ff7f1     5401             byte 1,         "T"
ff7f3     016b             word _T
ff7f5     4601             byte 1,         "F"
ff7f7     016c             word F
ff7f9     5201             byte 1,         "R"
ff7fb     016d             word R
ff7fd     47494804         byte 4,         "HIGH"
ff802     0170             word HIGH
ff804     574f4c03         byte 3,         "LOW"
ff808     0172             word LOW
ff80a     4f4c4605         byte 5,         "FLOAT"
ff810     0174             word _FLOAT
                   
ff812     4e495004         byte 4,         "PIN@"
ff817     0176             word PINTEST
                   
                   
                   ''      byte 6,         "SHROUT"
                   ''      word SHROUT
                   ''      byte 6,         "SHRINP"
                   ''      word SHRINP
                   
                   ' SMARTPIN INSTRUCTIONS
ff819     50525705         byte 5,         "WRPIN"
ff81f     0153             word _WRPIN
ff821     50585705         byte 5,         "WXPIN"
ff827     0155             word _WXPIN
ff829     50595705         byte 5,         "WYPIN"
ff82f     0157             word _WYPIN
                   
ff831     50445205         byte 5,         "RDPIN"
ff837     0159             word _RDPIN
ff839     50515205         byte 5,         "RQPIN"
ff83f     015b             word _RQPIN
ff841     504b4105         byte 5,         "AKPIN"
ff847     015d             word _AKPIN
                   
ff849     49415707         byte 7,         "WAITPIN"
ff851     015e             word WAITPIN
                   
ff853     41525705         byte 5,         "WRACK"
ff859     eb16             word WRACK
                   
                   
                   
ff85b     4e495003         byte 3,         "PIN"
ff85f     eb06             word _PIN
ff861     49504004         byte 4,         "@PIN"
ff866     eafe             word _ATPIN
                   
                   
ff868     736e02           byte 2,         "ns"
ff86b     d1c4             word ns
ff86d     575002           byte 2,         "PW"
ff870     d1d8             word PW
ff872     4c555005         byte 5,         "PULSE"
ff878     d1e2             word PULSE
ff87a     4c555006         byte 6,         "PULSES"
ff881     d1e4             word PULSES
ff883     4c494804         byte 4,         "HILO"
ff888     d1e8             word HILO
                   
                   
                   
                   ' SMARTPIN NCO/PWM
ff88a     54554404         byte 4,         "DUTY"
ff88f     d18e             word DUTY
ff891     4f434e03         byte 3,         "NCO"
ff895     d184             word NCO
ff897     5a4802           byte 2,         "HZ"
ff89a     d182             word HZ
ff89c     5a484b03         byte 3,         "KHZ"
ff8a0     d17e             word KHZ
ff8a2     5a484d03         byte 3,         "MHZ"
ff8a6     d17a             word MHZ
ff8a8     54554d04         byte 4,         "MUTE"
ff8ad     d172             word MUTE
ff8af     494c4205         byte 5,         "BLINK"
ff8b5     d1aa             word BLINK
ff8b7     4d575003         byte 3,         "PWM"
ff8bb     d1b0             word PWM
ff8bd     57415303         byte 3,         "SAW"
ff8c1     d1c0             word SAW
                   
                   
                   ' SMARTPIN ASYNCH
ff8c3     54494203         byte 3,         "BIT"
ff8c7     d1fe             word BIT
ff8c9     55414204         byte 4,         "BAUD"
ff8ce     d20a             word BAUDST
ff8d0     44585403         byte 3,         "TXD"
ff8d4     d206             word TXD
ff8d6     44585203         byte 3,         "RXD"
ff8da     d226             word RXD
                   
ff8dc     44585405         byte 5,         "TXDAT"
ff8e2     0161             word _TXDAT
                   
                   {
                           byte c,         "PA@"
                           word PAFETCH
                           byte c,         "PB@"
                           word PBFETCH
                           byte c,         "PA!"
                           word PASTORE
                           byte c,         "PB!"
                           word PBSTORE
                           byte c,         "DACLR"
                           word DACLR
                           byte c,         "DBCLR"
                           word DBCLR
                           byte c,         "PASET"
                           word PASET
                           byte c,         "DASET"
                           word DASET
                           byte c,         "PBSET"
                           word PBSET
                           byte c,         "DBSET"
                           word DBSET
                           byte c,         "PACLR"
                           word PACLR
                           byte c,         "PBCLR"
                           word PBCLR
                    }
                   
ff8e4     49415705         byte 5,         "WAITX"
ff8ea     ec0e             word DELTA
ff8ec     49415707         byte 7,         "WAITCNT"
ff8f4     ec16             word WAITCNTS
                   
                   
                   
ff8f6     42455206         byte 6,         "REBOOT"
ff8fd     d25c             word REBOOT
ff8ff     53455205         byte 5,         "RESET"
ff905     0000             word RESET
ff907     58453005         byte 5,         "0EXIT"
ff90d     0061             word ZEXIT
ff90f     49584504         byte 4,         "EXIT"
ff914     0063             word EXIT
                   ''      byte 6,         "SKIPNZ"
                   ''      word SKIPNZ
                   
ff916     504f4e03         byte 3,         "NOP"
ff91a     0071             word _NOP
ff91c     4c414304         byte 4,         "CALL"
ff921     002d             word ACALL
ff923     4d554a04         byte 4,         "JUMP"
ff928     002b             word AJMP
                   
                   
ff92a     523e02           byte 2,         ">R"
ff92d     012a             word PUSHR
ff92f     3e5202           byte 2,         "R>"
ff932     012d             word RPOP
ff934     4c3e02           byte 2,         ">L"
ff937     0136             word PUSHL
ff939     3e4c02           byte 2,         "L>"
ff93c     0111             word LPOP
ff93e     50532103         byte 3,         "!SP"
ff942     e9c6             word INITSP
ff944     50454405         byte 5,         "DEPTH"
ff94a     ed2e             word _DEPTH
                   
ff94c     474f4304         byte 4,         "COG@"
ff951     ebea             word COGFETCH
ff953     474f4304         byte 4,         "COG!"
ff958     ebf2             word COGSTORE
ff95a     54554c04         byte 4,         "LUT@"
ff95f     00ee             word LUTFETCH
ff961     54554c04         byte 4,         "LUT!"
ff966     00ef             word LUTSTORE
                   
ff968     474f4305         byte 5,         "COGID"
ff96e     ebfe             word _COGID
ff970     474f4307         byte 7,         "COGINIT"
ff978     ec06             word _COGINIT
ff97a     474f4307         byte 7,         "COGSTOP"
ff982     eaae             word _COGSTOP
                   
ff984     57454e06         byte 6,         "NEWCOG"
ff98b     ed36             word NEWCOG
                   
ff98d     474f4306         byte 6,         "COGATN"
ff994     eabe             word _COGATN
ff996     4c4f5007         byte 7,         "POLLATN"
ff99e     eac6             word _POLLATN
ff9a0     54455306         byte 6,         "SETEDG"
ff9a7     ead2             word _SETEDG
ff9a9     4c4f5007         byte 7,         "POLLEDG"
ff9b1     eae2             word _POLLEDG
                   
                   
                   
                   
ff9b3     59454b03         byte 3,         "KEY"
ff9b7     e0c2             word KEY
ff9b9     454b5704         byte 4,         "WKEY"
ff9be     e114             word WKEY
ff9c0     59454b04         byte 4,         "KEY!"
ff9c5     e0be             word PUTKEY
                   
                   ''      byte 7,         "keypoll"
                   ''      word rg+keypoll
                   
ff9c7     4e4f4303         byte 3,         "CON"
ff9cb     d094             word _CON
ff9cd     4e4f4e04         byte 4,         "NONE"
ff9d2     d0a6             word NONE
ff9d4     4d4f4303         byte 3,         "COM"
ff9d8     d09a             word _COM
                   
                   
                   ''      byte 7,         "DISCARD"
                   ''      word DISCARD
                   
ff9da     4e4f4306         byte 6,         "CONKEY"
ff9e1     e0e8             word CONKEY
ff9e3     4e4f4307         byte 7,         "CONEMIT"
ff9eb     017b             word CONEMIT
ff9ed     52455306         byte 6,         "SEROUT"
ff9f4     0179             word SEROUT
                   
ff9f6     494d4504         byte 4,         "EMIT"
ff9fb     d05a             word EMIT
ff9fd     494d4505         byte 5,         "EMITS"
ffa03     d07a             word EMITS
                   
ffa05     4c524304         byte 4,         "CRLF"
ffa0a     d0e2             word CRLF
ffa0c     524302           byte 2,         "CR"
ffa0f     d0e8             word CR
ffa11     534c4303         byte 3,         "CLS"
ffa15     d0ae             word CLS
                   {
                           byte 3,         "DOT"
                           word DOT
                   }
ffa17     41505305         byte 5,         "SPACE"
ffa1d     d058             word SPACE
ffa1f     41505306         byte 6,         "SPACES"
ffa26     d076             word SPACES
                   
                   ' DUMP MEMORY
ffa28     4d415203         byte 3,         "RAM"
ffa2c     d88a             word RAM
ffa2e     4d554405         byte 5,         "DUMP:"
ffa34     d83a             word SETDMP
ffa36     4d554404         byte 4,         "DUMP"
ffa3b     d844             word DUMP
ffa3d     4d554405         byte 5,         "DUMPW"
ffa43     d894             word DUMPW
ffa45     4d554405         byte 5,         "DUMPL"
ffa4b     d8a8             word DUMPL
ffa4d     4d554405         byte 5,         "DUMPA"
ffa53     d8c0             word DUMPA
ffa55     4d554406         byte 6,         "DUMPAW"
ffa5c     d8bc             word DUMPAW
ffa5e     445102           byte 2,         "QD"
ffa61     d872             word QD
ffa63     575102           byte 2,         "QW"
ffa66     d892             word QW
                   
ffa68     42454405         byte 5,         "DEBUG"
ffa6e     d950             word DEBUG
ffa70     69736c04         byte 4,         "lsio"
ffa75     d996             word lsio
                   
ffa77     474f4303         byte 3,         "COG"
ffa7b     d916             word _COG
ffa7d     54554c03         byte 3,         "LUT"
ffa81     d912             word _LUT
                   
ffa83     424b02           byte 2,         "KB"
ffa86     d7cc             word KB
ffa88     424d02           byte 2,         "MB"
ffa8b     d7ca             word MB
ffa8d     4d01             byte 1,         "M"
ffa8f     d7c4             word M
                   
                   
                   ' PRINTING
                   
ffa91     2e01             byte 1,         "."
ffa93     da8a             word PRT
ffa95     49525005         byte 5,         "PRINT"
ffa9b     da8a             word PRT
                   
ffa9d     53412e03         byte 3,         ".AS"
ffaa1     db9e             word PRTAS
ffaa3     53412e84         byte 4+im,      ".AS",$22
ffaa8     dbd4             word PRTASR
                   
ffaaa     45442e05         byte 5,         ".DECL"
ffab0     dbdc             word PRTDECL
ffab2     45442e05         byte 5,         ".DEC4"
ffab8     dbf0             word PRTDEC4
                   ''        byte 5,       ".DEC2"
                   ''        word PRTDEC2
                   
                   ''      byte c,         "@PAD"
                   ''      word ATPAD
ffaba     4c4f4804         byte 4,         "HOLD"
ffabf     da56             word HOLD
                   ''      byte 5,         ">CHAR"
                   ''      word BINASC
ffac1     3e2302           byte 2,         "#>"
ffac4     da7a             word RHASH
ffac6     233c02           byte 2,         "<#"
ffac9     da4e             word LHASH
ffacb     2301             byte 1,         "#"
ffacd     da5e             word HASH
ffacf     532302           byte 2,         "#S"
ffad2     da70             word HASHS
ffad4     3e443c03         byte 3,         "<D>"
ffad8     da84             word DNUM
                   
ffada     2e5502           byte 2,         "U."
ffadd     da96             word UPRT
ffadf     45442e04         byte 4,         ".DEC"
ffae4     dc02             word PRTDEC
ffae6     49422e04         byte 4,         ".BIN"
ffaeb     dab0             word PRTBIN
                   
ffaed     482e02           byte 2,         ".H"
ffaf0     d7d2             word PRTHEX
ffaf2     422e02           byte 2,         ".B"
ffaf5     d7ea             word PRTB
ffaf7     59422e05         byte 5,         ".BYTE"
ffafd     d7ec             word PRTBYTE
ffaff     572e02           byte 2,         ".W"
ffb02     d7f6             word PRTW
ffb04     4f572e05         byte 5,         ".WORD"
ffb0a     d7f8             word PRTWORD
ffb0c     4c2e02           byte 2,         ".L"
ffb0f     d800             word PRTL
ffb11     4f4c2e05         byte 5,         ".LONG"
ffb17     d802             word PRTLONG
                   
ffb19     44412e05         byte 5,         ".ADDR"
ffb1f     d8e2             word PRTADR
                   
                   
ffb21     49525006         byte 6,         "PRINT$"
ffb28     da9c             word PRINTSTR
ffb2a     4e454c04         byte 4,         "LEN$"
ffb2f     0056             word STRLEN
                   
ffb31     2281             byte 1+im,      $22
ffb33     d5b2             word _STRING_
ffb35     222e82           byte 2+im,      $2E,$22
ffb38     d5cc             word _PSTR_          ' ."
ffb3a     59544305         byte 5,         "CTYPE"
ffb40     e1d6             word CTYPE
                   
                   
                   
                   
ffb42     58453f05         byte 5,         "?EXIT"
ffb48     005e             word IFEXIT
                   
                   ''      byte c,         "MOVBYTES"
                   ''      word _MOVBYTES
                   
                   ' MEMORY BLOCKS
ffb4a     54414405         byte 5,         "DATA?"
ffb50     00fd             word DATAQ
ffb52     41524505         byte 5,         "ERASE"
ffb58     00f8             word ERASE
ffb5a     4c494604         byte 4,         "FILL"
ffb5f     00f9             word CFILL
ffb61     4f4d4305         byte 5,         "CMOVE"
ffb67     00f2             word CMOVE
ffb69     4d433c06         byte 6,         "<CMOVE"
ffb70     d790             word RCMOVE
                   
                   ' TIMING
ffb72     7301             byte 1,         "s"
ffb74     d7a4             word secs
ffb76     736d02           byte 2,         "ms"
ffb79     d7a8             word ms
ffb7b     737502           byte 2,         "us"
ffb7e     d7b8             word us
                   
                   ' LAP TIMING
ffb80     544e4304         byte 4,         "CNT@"
ffb85     eaf6             word _GETCNT
ffb87     50414c03         byte 3,         "LAP"
ffb8b     01c7             word LAP
ffb8d     50414c04         byte 4,         "LAP@"
ffb92     eaa2             word LAPFETCH
ffb94     414c2e04         byte 4,         ".LAP"
ffb99     e28a             word PRTLAP
ffb9b     736d2e03         byte 3,         ".ms"
ffb9f     e30c             word PRTMS
                   
                   
                   ' RADIX
ffba1     58454803         byte 3,         "HEX"
ffba5     d28a             word HEX
ffba7     43454403         byte 3,         "DEC"
ffbab     d286             word DECIMAL
ffbad     4e494203         byte 3,         "BIN"
ffbb1     d27e             word BIN
                   
ffbb3     532e02           byte 2,         ".S"
ffbb6     e040             word PRTSTK
                   
                   
                   ' DICTIONARY
ffbb8     524f5705         byte 5,         "WORDS"
ffbbe     e236             word WORDS
ffbc0     4f574006         byte 6,         "@WORDS"
ffbc7     d68e             word ATNAMES
ffbc9     54454704         byte 4,         "GET$"
ffbce     dd84             word _GETWORD
ffbd0     41455306         byte 6,         "SEARCH"
ffbd7     dd94             word SEARCH
ffbd9     233e2403         byte 3,         "$>#"
ffbdd     d40a             word NUMBER
                   
ffbdf     41444005         byte 5,         "@DATA"
ffbe5     e318             word ATDAT
ffbe7     52454804         byte 4,         "HERE"
ffbec     d688             word ATHERE
ffbee     45484005         byte 5,         "@HERE"
ffbf4     fe9e             word rg+here
ffbf6     4f434006         byte 6,         "@CODES"
ffbfd     fea2             word rg+codes
                   
                   ' TABLES
                   ''        byte 6,       "LOOKIN"
                   ''        word LOOKIN
                   ''        byte 6,       "LOOKUP"
                   ''        word _LOOKUP
                   
                   
                   ' VARIABLES
ffbff     6d657505         byte 5,         "uemit"
ffc05     fe10             word rg+uemit
ffc07     656b7504         byte 4,         "ukey"
ffc0c     fe12             word rg+ukey
ffc0e     61686304         byte 4,         "char"
ffc13     f8f0             word w+lastkey
ffc15     6c656405         byte 5,         "delim"
ffc1b     fe6c             word rg+delim
ffc1d     6d616e05         byte 5,         "names"
ffc23     fe96             word rg+names
                   
ffc25     53415404         byte 4,         "TASK"
ffc2a     ddbe             word TASK
ffc2c     47455203         byte 3,         "REG"
ffc30     ea9e             word ATREG
ffc32     4f574005         byte 5,         "@WORD"
ffc38     fe24             word rg+wordbuf
ffc3a     49505304         byte 4,         "SPIN"
ffc3f     d0b6             word SPINNER
                   
                   
                   ' | compile byte   || compile word   , compile long
ffc41     7c81             byte 1+im,      "|"
ffc43     d612             word CCOMP
ffc45     7c7c82           byte 2+im,      "||"
ffc48     d622             word WCOMP
ffc4a     2c81             byte 1+im,      ","
ffc4c     d626             word LCOMP
ffc4e     5d575b83         byte 3+im,      "[W]"
ffc52     d600             word COMPW
ffc54     5d225b83         byte 3+im,      "[",$22,"]"
ffc58     d5d2             word COMPSTR
                   
ffc5a     4c554e05         byte 5,         "NULL$"
ffc60     d56a             word NULLSTR
ffc62     212402           byte 2,         "$!"
ffc65     d56e             word STRST
ffc67     3d2402           byte 2,         "$="
ffc6a     d578             word STREQ
                   
                   
                   ' DEFINITIONS
                   '
                   
ffc6c     4d534103         byte 3,      "ASM"
ffc70     0054             word _ASM
                   
ffc72     524f4686         byte 6+im,      "FORGET"
ffc79     e172             word FORGET
ffc7b     45524387         byte 7+im,      "CREATE$"
ffc83     d698             word CREATEWORD
ffc85     45524386         byte 6+im,      "CREATE"
ffc8c     d6e4             word CREATE
ffc8e     52415683         byte 3+im,      "VAR"
ffc92     d6f4             word _VAR
                   
ffc94     62757083         byte 3+im,      "pub"
ffc98     d72a             word PUBDEF
ffc9a     69727083         byte 3+im,      "pri"
ffc9e     d734             word PRIDEF
ffca0     65727083         byte 3+im,      "pre"
ffca4     d730             word PREDEF
                   {
                           byte 6+im,      "module"
                           word MODDEF
                   }
ffca6     3a81             byte 1+im,      ":"
ffca8     d72a             word NEWDEF
ffcaa     3b81             byte 1+im,      ";"
ffcac     d74c             word ENDDEF
ffcae     5b81             byte 1+im,      "["
ffcb0     d750             word UNDEF
ffcb2     5d81             byte 1+im,      "]"
ffcb4     d72c             word REDEF
ffcb6     2781             byte 1+im,      "'"
ffcb8     d66e             word ATICK
                   
                   ''        byte 2+im,      ":="
                   ''        word _CON9
ffcba     3d3a82           byte 2+im,      ":="
ffcbd     d70c             word _CONST
ffcbf     213d3d03         byte 3,         "==!"
ffcc3     d6f0             word CONST
ffcc5     494c4105         byte 5,         "ALIGN"
ffccb     d67c             word _ALIGN
                   
ffccd     54414486         byte 6+im,      "DATCON"
ffcd4     d71a             word _DATCON
                   
ffcd6     4c4c4105         byte 5,         "ALLOT"
ffcdc     d632             word ALLOT
                   
ffcde     67726f03         byte 3,         "org"
ffce2     e31e             word DATORG
ffce4     74796285         byte 5+im,      "bytes"
ffcea     e33c             word dbytes
ffcec     726f7785         byte 5+im,      "words"
ffcf2     e338             word dwords
ffcf4     6e6f6c85         byte 5+im,      "longs"
ffcfa     e334             word dlongs
ffcfc     74796284         byte 4+im,      "byte"
ffd01     e346             word dbyte
ffd03     726f7784         byte 4+im,      "word"
ffd08     e34a             word dword
ffd0a     6e6f6c84         byte 4+im,      "long"
ffd0f     e34e             word dlong
ffd11     73657203         byte 3,         "res"
ffd15     e32c             word dres
                   
ffd17     5d435b83         byte 3+im,      "[C]"
ffd1b     d756             word COMPILES
ffd1d     41524784         byte 4+im,      "GRAB"
ffd22     d63e             word GRAB
                   
                   
                   ' FIELDS ( NAME-FIELD  CODE-POINTER CODE-FIELD )
ffd24     41464e84         byte 4+im,      "NFA'"
ffd29     d654             word _NFATICK
ffd2b     41504303         byte 3,         "CPA"
ffd2f     d658             word NFACPA
ffd31     41464303         byte 3,         "CFA"
ffd35     d664             word NFACFA
                   
                   
                   ' COMMENTS
ffd37     5c81             byte 1+im,      "\"
ffd39     e11e             word COMMENT
ffd3b     2d2d2d83         byte 3+im,      "---"
ffd3f     e11e             word COMMENT
ffd41     2881             byte 1+im,      "("
ffd43     e136             word PAREN
ffd45     7b81             byte 1+im,      "{"
ffd47     e150             word BRACE
ffd49     7d81             byte 1+im,      "}"
ffd4b     0071             word _NOP
                   
                   ' CONDITIONAL COMPILATION ( conditionally ignore as comment )
                   
ffd4d     4e464986         byte 6+im,      "IFNDEF"
ffd54     e14c             word IFNDEF
ffd56     44464985         byte 5+im,      "IFDEF"
ffd5c     e144             word IFDEF
                   
                   
                   ''        byte 4,       "IDLE"
                   ''        word IDLE
                   
                   ''        byte 4,       ".VER"
                   ''        word PRTVER
ffd5e     51415405         byte 5,         "TAQOZ"
ffd64     e35c             word _TAQOZ
ffd66     52455404         byte 4,         "TERM"
ffd6b     de8e             word TERMINAL
ffd6d     54554184         byte 4+im,      "AUTO"
ffd72     ddec             word AUTORUN
                   
ffd74     49505305         byte 5,         "SPIRD"
ffd7a     0191             word SPIRD
ffd7c     49505306         byte 6,         "SPIRDL"
ffd83     018f             word SPIRDL
ffd85     49505305         byte 5,         "SPIWB"
ffd8b     01a4             word SPIWR8
ffd8d     49505305         byte 5,         "SPICE"
ffd93     01b8             word SPICE
ffd95     49505305         byte 5,         "SPIWC"
ffd9b     01a2             word SPIWRC
ffd9d     49505305         byte 5,         "SPIWW"
ffda3     01b5             word SPIWR16
ffda5     49505305         byte 5,         "SPIWM"
ffdab     01b2             word SPIWM
ffdad     49505305         byte 5,         "SPIWL"
ffdb3     01b0             word SPIWRL
ffdb5     49505307         byte 7,         "SPIPINS"
ffdbd     ebaa             word SPIPINS
ffdbf     49505305         byte 5,         "SPIRX"
ffdc5     0183             word SPIRX
ffdc7     49505306         byte 6,         "SPITXE"
ffdce     0199             word SPITXE
ffdd0     49505305         byte 5,         "SPITX"
ffdd6     019b             word SPITX
                   {
                           byte 5,         "CLKIN"
                           word CLKIN
                           byte 6,         "CLKOUT"
                           word CLKOUT
                           byte 5,         "CLOCK"
                           word CLOCK
                   
                           byte 5,         "WSLED"
                           word WSLED
                   }
                   
ffdd8     49415704         byte 4,         "WAIT"
ffddd     eaee             word WAIT
                   
ffddf     4b4c4306         byte 6,         "CLKDIV"
ffde6     d26e             word CLKDIV
ffde8     53435206         byte 6,         "RCSLOW"
ffdef     d27a             word RCSLOW
                   
                   
ffdf1     42554806         byte 6,         "HUBSET"
ffdf8     ecae             word _HUBSET
ffdfa     505702           byte 2,         "WP"
ffdfd     d264             word WP
ffdff     455702           byte 2,         "WE"
ffe02     d260             word WE
                   
                   
ffe04     4b4c4305         byte 5,         "CLKHZ"
ffe0a     d232             word CLKHZ
                   ''        byte 6,       "CLKMHZ"
                   ''        word CLKMHZ
                   
                   {
                           byte 7,         "BUFFERS"
                           word BUFFERS
                           byte 3,         "ROM"
                           word ROM
                           byte 6,         "IRQVEC"
                           word IRQVEC
                   
                           byte 4,         "PTRA"
                           word w+PTRA
                           byte 4,         "PTRB"
                           word w+PTRB
                           byte 4,         "DIRA"
                           word w+DIRA
                           byte 4,         "DIRB"
                           word w+DIRB
                           byte 4,         "OUTA"
                           word w+OUTA
                           byte 4,         "OUTB"
                           word w+OUTB
                           byte 3,         "INA"
                           word w+INA
                           byte 3,         "INB"
                           word w+INB
                   }
                   
ffe0c     52524505         byte 5,         "ERROR"
ffe12     e016             word ERROR
                   
ffe14     50465306         byte 6,         "SFPINS"
ffe1b     e3ea             word SFPINS
ffe1d     3f465303         byte 3,         "SF?"
ffe21     e408             word SFSTAT
ffe23     57465304         byte 4,         "SFWE"
ffe28     e3f0             word SFWE
ffe2a     49465305         byte 5,         "SFINS"
ffe30     e3f6             word SFINS
ffe32     57465304         byte 4,         "SFWD"
ffe37     e404             word SFWD
ffe39     53465305         byte    5,      "SFSID"
ffe3f     e412             word SFSID
ffe41     4a465305         byte    5,      "SFJID"
ffe47     e422             word SFJID
ffe49     45465305         byte    5,      "SFER4"
ffe4f     e436             word SFER4
ffe51     45465306         byte    6,      "SFER32"
ffe58     e446             word SFER32
ffe5a     45465306         byte    6,      "SFER64"
ffe61     e44a             word SFER64
ffe63     45465307         byte    7,      "SFERASE"
ffe6b     e44e             word SFERALL
ffe6d     57465306         byte    6,      "SFWRPG"
ffe74     e454             word SFWRPAGE
                   
ffe76     43414206         byte    6,      "BACKUP"
ffe7d     e460             word BACKUP
ffe7f     53455207         byte    7,      "RESTORE"
ffe87     e4b0             word RESTORE
ffe89     52465305         byte    5,      "SFRDS"
ffe8f     e4ce             word SFRDS
                   
ffe91     57465305         byte    5,      "SFWRS"
ffe97     e480             word SFWRS
ffe99     43465304         byte    4,      "SFC@"
ffe9e     e4d8             word SFCFETCH
ffea0     57465304         byte    4,      "SFW@"
ffea5     e4e0             word SFWFETCH
ffea7     40465303         byte    3,      "SF@"
ffeab     e4e6             word SFFETCH
ffead     465302           byte    2,      "SF"
ffeb0     e4f2             word SF
ffeb2     46532e03         byte    3,      ".SF"
ffeb6     e428             word PRTSF
                   
                   
ffeb8     42445305         byte 5,         "SDBUF"
ffebe     e500             word SDBUF
ffec0     70647306         byte 6,         "sdpins"
ffec7     e4fa             word _sdpins
ffec9     554f4d05         byte 5,         "MOUNT"
ffecf     e83c             word MOUNT
ffed1     52494403         byte 3,         "DIR"
ffed5     e8a2             word PRTDIR
ffed7     44532103         byte 3,         "!SD"
ffedb     e64a             word INITSD
ffedd     58532103         byte 3,         "!SX"
ffee1     e5b8             word INITSX
ffee3     3f445303         byte 3,         "SD?"
ffee7     e506             word SDQ
ffee9     444d4303         byte 3,         "CMD"
ffeed     e552             word CMD
ffeef     4d434104         byte 4,         "ACMD"
ffef4     e54a             word ACMD
                   ''      byte 3,         "csd"
                   ''      word csd
ffef6     64696303         byte 3,         "cid"
ffefa     f814             word w+cid
ffefc     57445304         byte 4,         "SDWR"
fff01     e680             word SDWR
fff03     52445305         byte 5,         "SDRDS"
fff09     e724             word SDRDS
fff0b     57445305         byte 5,         "SDWRS"
fff11     e776             word SDWRS
fff13     554c4605         byte 5,         "FLUSH"
fff19     e6aa             word FLUSH
fff1b     504f4605         byte 5,         "FOPEN"
fff21     e968             word FOPEN
fff23     4f4c4605         byte 5,         "FLOAD"
fff29     e970             word FLOAD
fff2b     45474604         byte 4,         "FGET"
fff30     e980             word FGET
fff32     45524605         byte 5,         "FREAD"
fff38     e9a0             word FREAD
fff3a     52574606         byte 6,         "FWRITE"
fff41     e9b6             word FWRITE
                   
fff43     43455306         byte 6,         "SECTOR"
fff4a     e6d4             word SECTOR
fff4c     52445304         byte 4,         "SDRD"
fff51     e6f4             word SDRD
fff53     52445305         byte 5,         "SDRDS"
fff59     e724             word SDRDS
fff5b     41445305         byte 5,         "SDADR"
fff61     e798             word SDADR
fff63     40445303         byte 3,         "SD@"
fff67     e7a6             word SDFETCH
fff69     21445303         byte 3,         "SD!"
fff6d     e7ac             word SDSTORE
fff6f     43445304         byte 4,         "SDC@"
fff74     e7b2             word SDCFETCH
fff76     43445304         byte 4,         "SDC!"
fff7b     e7b8             word SDCSTORE
fff7d     57445304         byte 4,         "SDW@"
fff82     e7be             word SDWFETCH
fff84     445302           byte 2,         "SD"
fff87     e7c4             word SD
                   
                   ''      byte 5,         "RDFAT"
                   ''      word RDFAT
fff89     41464004         byte 4,         "@FAT"
fff8e     e7cc             word ATFAT
fff90     4f424005         byte 5,         "@BOOT"
fff96     e7e2             word ATBOOT
fff98     4f524005         byte 5,         "@ROOT"
fff9e     e7de             word ATROOT
                   ''      byte 7,         "CL>SECT"
                   ''      word CLSECT
fffa0     74616603         byte 3,         "fat"
fffa4     f8b1             word w+fat32
                   
                   
fffa6     444e4503         byte 3,         "END"
fffaa     e37c             word _END
fffac     00000000         long    0
fffb0              enddict
fffb0                      alignl
                   
                   ' feel free to go to the end of memory $FFFFF
                   
                   {{
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |                                                   TERMS OF USE: MIT License                                                  |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |
                   |files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
                   |modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
                   |is furnished to do so, subject to the following conditions:                                                                   |
                   |                                                                                                                              |
                   |The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
                   |                                                                                                                              |
                   |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
                   |WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
                   |COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
                   |ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   }}
