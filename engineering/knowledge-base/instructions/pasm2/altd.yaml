mnemonic: "ALTD"
syntax:
  - "ALTD D"
  - "ALTD D,{#}S"
group: "register_indirection"
description: "Alter D field of next instruction to D[8:0]. With S operand: Alter D field of next instruction to (D + S) & $1FF. D += sign-extended S[17:9]."

operation:
  basic_operation: "Modify destination field of following instruction"
  flag_effects:
    carry_flag: "Not affected"
    zero_flag: "Not affected"
  conditions:
    - "Only affects the immediately following instruction"
    - "S is sign-extended from S[17:9] when present"
    - "Result is masked to 9 bits ($1FF)"
    - "D register is modified when S operand is used"

timing:
  base_clocks: 2
  cog_lut_timing: 2
  hub_timing: 2
  timing_notes:
    - "All Register Indirection instructions execute in 2 clock cycles"

flags:
  affects_c: false
  affects_z: false
  flag_options: []
  flag_meanings: {}

operands:
  destination:
    type: "register"
    range: "0..511 for cog/LUT registers"
    description: "Register containing destination field override"
  source:
    type: "register_or_immediate"
    register_range: "0..511 for cog/LUT registers"
    immediate_range: "9-bit signed for base offset"
    description: "Optional offset to add to destination field"

variants:
  - syntax: "ALTD D"
    description: "Set next instruction's destination to D[8:0]"
    specific_operation: "NEXT_INST.DEST = D[8:0]"
  - syntax: "ALTD D,{#}S"
    description: "Set destination field and update D register"
    specific_operation: "NEXT_INST.DEST = (D + S) & $1FF, D += sign_extend(S[17:9])"

examples:
  - title: "Basic Destination Alteration"
    description: "Dynamically select destination register"
    code: |
      MOV dest_reg, #42     ' Target register R42
      ALTD dest_reg         ' Next instruction targets R42
      MOV 0, value_reg      ' Actually becomes: MOV R42, value_reg
    explanation: "MOV instruction destination changed from R0 to R42"
  - title: "Array Access Pattern"
    description: "Access array elements with computed index"
    code: |
      MOV array_ptr, #array_base
      MOV index, #3         ' Access element 3
      ALTD array_ptr, index ' Set destination to array_base + 3
      MOV 0, new_value      ' Store to array[3]
    explanation: "Implements array[index] = new_value using indirection"
  - title: "Loop with Advancing Pointer"
    description: "Fill array using auto-incrementing destination"
    code: |
      MOV dest_ptr, #100    ' Start at register 100
      MOV loop_count, #8    ' Process 8 elements
      loop:
        ALTD dest_ptr, #1   ' Target current, advance pointer
        MOV 0, fill_value   ' Store value, dest_ptr now points to next
        DJNZ loop_count, #loop
    explanation: "Fills registers 100-107 with fill_value"

related_instructions:
  - "ALTS"
  - "ALTR"
  - "ALTI"
  - "ALTB"
  - "ALTGB"
  - "ALTGN"
  - "ALTGW"
  - "ALTSB"
  - "ALTSN"
  - "ALTSW"

special_behaviors:
  - "Only affects the single instruction immediately following"
  - "Can create runtime-computed register addresses"
  - "S operand form updates D register for easy pointer advancement"
  - "Enables array access and dynamic register allocation"
  - "Masking to $1FF limits register addresses to valid range"

notes:
  - "Essential for implementing arrays and data structures"
  - "Enables runtime-computed memory access patterns"
  - "More efficient than computed jumps for data access"
  - "Part of comprehensive register indirection system"

source_references:
  datasheet_section: "6.8 Register Indirection Instructions"
  page_references: ["Datasheet Register Indirection instruction table"]
  extraction_notes: "Extracted from pasm2-complete-instruction-tables.md Register Indirection section"