mnemonic: "QMUL"
syntax:
  - "QMUL {#}D,{#}S"
group: "cordic_solver"
description: "Begin CORDIC unsigned multiplication of D * S. GETQX/GETQY retrieves lower/upper product."

operation:
  basic_operation: "Start CORDIC multiplication D * S"
  flag_effects:
    carry_flag: "Not affected"
    zero_flag: "Not affected"
  conditions:
    - "Begins asynchronous CORDIC operation"
    - "Results retrieved via GETQX (lower 32 bits) and GETQY (upper 32 bits)"
    - "Operation completes in background while other instructions execute"
    - "GETQX/GETQY will wait if result not ready"

timing:
  base_clocks: "2...9"
  cog_lut_timing: "2...9"
  hub_timing: "2...9"
  conditional_timing:
    start_operation: "2...9 clocks"
    result_retrieval: "2...58 clocks (via GETQX/GETQY)"
  timing_notes:
    - "Start timing varies with CORDIC availability"
    - "Result retrieval waits for completion if needed"
    - "Can execute other instructions while CORDIC computes"

flags:
  affects_c: false
  affects_z: false
  flag_options: []
  flag_meanings: {}

operands:
  destination:
    type: "register_or_immediate"
    register_range: "0..511 for cog/LUT registers"
    immediate_range: "32-bit value (with AUGS if needed)"
    description: "First multiplicand"
  source:
    type: "register_or_immediate"
    register_range: "0..511 for cog/LUT registers"
    immediate_range: "32-bit value (with AUGS if needed)"
    description: "Second multiplicand"

variants:
  - syntax: "QMUL {#}D,{#}S"
    description: "Start unsigned multiplication of D * S"
    specific_operation: "CORDIC_RESULT = D * S (64-bit product)"

examples:
  - title: "Basic 32Ã—32 Multiplication"
    description: "Multiply two 32-bit values"
    code: |
      QMUL factor1, factor2   ' Start multiplication
      ' ... other work can be done here ...
      GETQX result_low        ' Get lower 32 bits
      GETQY result_high       ' Get upper 32 bits
    explanation: "Computes 64-bit product of two 32-bit values"
  - title: "Immediate Multiplication"
    description: "Multiply register by constant"
    code: |
      QMUL value_reg, #1000   ' Multiply by 1000
      GETQX result_low        ' Get result (fits in 32 bits for small values)
    explanation: "Scales a value by constant factor using CORDIC"
  - title: "Pipeline Multiple Operations"
    description: "Overlap CORDIC operations with other work"
    code: |
      QMUL a1, b1            ' Start first multiplication
      ' Do other computation while CORDIC works
      ADD temp1, temp2
      SUB temp3, temp4
      GETQX prod1_low        ' Get first result
      GETQY prod1_high
      QMUL a2, b2           ' Start second multiplication
    explanation: "Maximizes efficiency by overlapping CORDIC with other operations"

related_instructions:
  - "GETQX"
  - "GETQY"
  - "QDIV"
  - "QFRAC"
  - "QSQRT"
  - "QROTATE"
  - "QVECTOR"
  - "QLOG"
  - "QEXP"

special_behaviors:
  - "CORDIC solver operates asynchronously in background"
  - "Result is 64-bit product accessible as two 32-bit words"
  - "GETQX/GETQY will stall if CORDIC operation not complete"
  - "Only one CORDIC operation can be active per cog"
  - "Starting new CORDIC operation cancels previous incomplete operation"

notes:
  - "Provides high-precision multiplication beyond basic MUL instruction"
  - "Essential for applications requiring full 64-bit products"
  - "CORDIC solver shared across multiple mathematical operations"
  - "Efficient for complex arithmetic when pipelined properly"

source_references:
  datasheet_section: "6.9 CORDIC Solver Instructions"
  page_references: ["Datasheet CORDIC instruction table"]
  extraction_notes: "Extracted from pasm2-complete-instruction-tables.md CORDIC Solver section"