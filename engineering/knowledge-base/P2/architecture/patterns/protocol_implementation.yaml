# Protocol Implementation Pattern
# Pattern for implementing communication protocols on P2

pattern_id: "protocol_implementation"
pattern_name: "Protocol Implementation Pattern"
category: "hardware_utilization"
prevalence: 75.0  # 547 of 730 files (75.0%)

selection_criteria:
  description: "Use this pattern when implementing communication protocols, data exchange standards, or structured data transmission"
  indicators:
    - "Need for standardized communication interfaces"
    - "Data exchange with external devices or systems"
    - "Implementation of industry standard protocols"
    - "Custom protocol development for specific applications"
    - "Multi-device communication coordination"
  decision_factors:
    - "Communication requirements exceed simple point-to-point data transfer"
    - "Need for error detection, correction, or retransmission"
    - "Standardized protocol compliance required"
    - "Complex data formatting or framing needed"

structural_signature:
  characteristics:
    - "State machines for protocol state management"
    - "Packet/frame parsing and generation"
    - "Error detection and handling mechanisms"
    - "Timing constraints for protocol compliance"
    - "Buffering for protocol data assembly/disassembly"
  code_patterns:
    - "Protocol state enumeration and switching"
    - "Packet header and payload processing"
    - "CRC or checksum calculation and verification"
    - "Timeout handling for protocol timeouts"
    - "Frame synchronization and delimiter detection"

implementation_template: |
  CON
    ' Protocol states
    STATE_IDLE = 0
    STATE_START = 1
    STATE_HEADER = 2
    STATE_PAYLOAD = 3
    STATE_CHECKSUM = 4
    
    ' Protocol constants
    FRAME_START = $AA
    MAX_PAYLOAD = 64
    
  VAR
    byte protocol_state
    byte rx_buffer[MAX_PAYLOAD + 4]  ' Header + payload + checksum
    byte rx_index, expected_length
    word checksum
    
  PUB protocol_init()
    protocol_state := STATE_IDLE
    rx_index := 0
    
  PUB protocol_process_byte(data) : result
    case protocol_state
      STATE_IDLE:
        if data == FRAME_START
          protocol_state := STATE_START
          rx_index := 0
          checksum := 0
          
      STATE_START:
        expected_length := data
        if expected_length <= MAX_PAYLOAD
          protocol_state := STATE_HEADER
          rx_buffer[rx_index++] := data
          checksum += data
        else
          protocol_state := STATE_IDLE  ' Invalid length
          
      STATE_HEADER:
        rx_buffer[rx_index++] := data
        checksum += data
        if rx_index >= expected_length + 1
          protocol_state := STATE_CHECKSUM
          
      STATE_CHECKSUM:
        if data == (checksum & $FF)
          result := process_received_packet(@rx_buffer, expected_length)
        protocol_state := STATE_IDLE
        
    return result

resource_profile:
  memory_usage:
    code_size: "moderate to large (protocol logic and state machines)"
    variable_space: "significant (buffers, state variables, protocol data)"
    stack_depth: "moderate (nested protocol function calls)"
  performance:
    execution_speed: "depends on protocol complexity"
    throughput: "varies with protocol overhead"
    latency: "protocol-dependent (framing and processing delays)"
  complexity:
    implementation: "moderate to high (protocol-specific logic)"
    maintainability: "good when well-structured"
    testability: "good (clear protocol states and transitions)"

composition_rules:
  compatible_patterns:
    - "buffer_management" (for protocol data buffering)
    - "timing_control" (for protocol timing requirements)
    - "state_machine" (for protocol state management)
    - "cog_management" (for dedicated protocol COGs)
  incompatible_patterns:
    - None (protocols can be implemented with various architectures)
  synergies:
    - "Buffer management essential for packet assembly"
    - "Timing control critical for protocol compliance"
    - "State machines natural fit for protocol logic"

protocol_categories:
  serial_protocols:
    description: "Point-to-point serial communication protocols"
    examples: "UART, RS-232, RS-485"
    characteristics:
      - "Byte-oriented transmission"
      - "Start/stop bits or synchronous framing"
      - "Simple state machines"
    
  synchronous_protocols:
    description: "Clock-synchronized communication protocols"
    examples: "SPI, I2C, CAN"
    characteristics:
      - "Clock-driven data transfer"
      - "Master/slave or multi-master topologies"
      - "Hardware timing dependencies"
    
  packet_protocols:
    description: "Packet-based communication protocols"
    examples: "Ethernet, Wi-Fi, custom packet formats"
    characteristics:
      - "Frame-based data transmission"
      - "Complex state machines"
      - "Error detection and recovery"
    
  streaming_protocols:
    description: "Continuous data stream protocols"
    examples: "Audio streaming, video protocols"
    characteristics:
      - "Real-time data flow"
      - "Minimal protocol overhead"
      - "Timing-critical processing"

real_examples:
  typical_applications:
    - "UART communication with PC or microcontrollers"
    - "SPI interface to sensors and peripherals"
    - "I2C device control and monitoring"
    - "Custom protocols for specific applications"
    - "Network communication (TCP/IP stack implementations)"
    - "Industrial protocols (Modbus, Profibus)"
  protocol_complexity:
    - "Simple: Basic UART with minimal framing"
    - "Moderate: SPI with command/response structure"
    - "Complex: Full TCP/IP stack implementation"

statistics:
  total_files: 547
  percentage_of_codebase: 75.0
  protocol_type_distribution:
    uart_serial: 298      # ~54% of protocol files
    spi: 201              # ~37% of protocol files
    i2c: 167              # ~31% of protocol files
    custom: 134           # ~24% of protocol files
    network: 89           # ~16% of protocol files

pattern_variations:
  simple_protocols:
    description: "Basic protocol implementations with minimal features"
    characteristics:
      - "Simple state machines"
      - "Basic error detection"
      - "Minimal buffering requirements"
    
  robust_protocols:
    description: "Full-featured protocol implementations"
    characteristics:
      - "Complex state machines with error recovery"
      - "Advanced error detection and correction"
      - "Sophisticated buffering and flow control"
    
  layered_protocols:
    description: "Multi-layer protocol stacks"
    characteristics:
      - "Separation of physical, data link, and application layers"
      - "Protocol abstraction and modularity"
      - "Complex inter-layer communication"

implementation_strategies:
  state_machine_approach:
    description: "Protocol logic implemented as state machines"
    pros: "Clear logic flow, easy to debug and test"
    cons: "Can become complex for sophisticated protocols"
    
  event_driven_approach:
    description: "Protocol processing driven by events"
    pros: "Flexible, responsive to protocol events"
    cons: "More complex coordination, potential race conditions"
    
  table_driven_approach:
    description: "Protocol behavior defined in lookup tables"
    pros: "Easy to modify, data-driven configuration"
    cons: "Less efficient, potential memory overhead"

error_handling:
  detection_mechanisms:
    - "Checksums and CRC calculations"
    - "Frame synchronization verification"
    - "Timeout detection for incomplete transfers"
    - "Protocol violation detection"
    
  recovery_strategies:
    - "Automatic retransmission on errors"
    - "Graceful degradation for partial failures"
    - "Protocol reset and resynchronization"
    - "Error reporting to higher layers"

timing_considerations:
  protocol_timing:
    description: "Meeting protocol timing requirements"
    challenges:
      - "Bit rate accuracy for serial protocols"
      - "Setup and hold times for synchronous protocols"
      - "Timeout handling for packet protocols"
    
  real_time_constraints:
    description: "Real-time protocol processing requirements"
    solutions:
      - "Dedicated COGs for time-critical protocols"
      - "Hardware assistance with Smart Pins"
      - "Interrupt-driven processing where appropriate"

anti_patterns:
  common_mistakes:
    - "Ignoring protocol timing requirements"
    - "Inadequate error detection and recovery"
    - "Poor state machine design with unclear transitions"
    - "Blocking protocol operations affecting system responsiveness"
    - "Insufficient buffering for protocol data"
  warning_signs:
    - "Frequent protocol errors or timeouts"
    - "Poor protocol performance or throughput"
    - "Difficulty debugging protocol issues"
    - "Protocol implementation affecting other system functions"
    - "Non-compliance with protocol standards"

testing_strategies:
  unit_testing:
    description: "Testing individual protocol components"
    techniques:
      - "State machine testing with various input sequences"
      - "Error injection testing for robustness"
      - "Boundary condition testing"
    
  integration_testing:
    description: "Testing protocol with real communication partners"
    techniques:
      - "Loopback testing for basic functionality"
      - "Cross-platform compatibility testing"
      - "Performance and stress testing"
    
  protocol_analysis:
    description: "Analysis of protocol behavior and performance"
    tools:
      - "Protocol analyzers and logic analyzers"
      - "Software simulation and emulation"
      - "Performance profiling and optimization"

evolution_pressure:
  increasing_complexity:
    description: "More sophisticated protocol requirements"
    drivers: "Higher data rates, more features, better reliability"
    solutions: "Layered architectures, hardware assistance, protocol processors"
    
  standardization_pressure:
    description: "Need for standard protocol compliance"
    drivers: "Interoperability, certification requirements"
    solutions: "Standard protocol libraries, compliance testing, formal verification"