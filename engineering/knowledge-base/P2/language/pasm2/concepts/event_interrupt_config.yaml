concept: event_interrupt_configuration
title: Event and Interrupt Configuration
category: event_handling
description: Hardware event detection and interrupt handling with 4 interrupt levels and 16 event sources
documentation_source: enhanced
documentation_level: comprehensive

overview: |
  P2 provides sophisticated event and interrupt handling with 16 selectable event sources per cog,
  4 interrupt levels with dedicated vectors, and both polling and interrupt-driven responses.
  Events can trigger interrupts, wake from WAIT, or be polled. Each cog has independent event configuration.
  
  Debug infrastructure uses interrupts extensively for breakpoints and single-stepping.

interrupt_system:
  interrupt_levels:
    INT0:
      priority: "Lowest"
      vector: "IJMP0"
      return: "RETI0 or RESI0"
      
    INT1:
      priority: "Low"
      vector: "IJMP1"
      return: "RETI1 or RESI1"
      typical_use: "Timer interrupts"
      
    INT2:
      priority: "High"
      vector: "IJMP2"
      return: "RETI2 or RESI2"
      typical_use: "Pin events, Smart Pin ready"
      
    INT3:
      priority: "Highest (Debug)"
      vector: "IJMP3"
      return: "RETI3 or RESI3"
      reserved_use: "Debug monitor ISR"
      critical_note: "Used by Spin2 debugger infrastructure"

  interrupt_operations:
    SETINT1:
      syntax: "SETINT1 #event"
      operation: "Configure INT1 event source"
      example: "SETINT1 #1  ' INT1 triggered by event 1"
      
    SETINT2:
      syntax: "SETINT2 #event"
      operation: "Configure INT2 event source"
      
    SETINT3:
      syntax: "SETINT3 #event"
      operation: "Configure INT3 event source"
      debug_use: |
        ' Debug monitor setup
        setint3 #0              ' Disable initially
        mov     ijmp3, ##debug_isr
        setint3 #BRK_EVENT     ' Enable on BRK
      source: Spin2_debugger.spin2
      
    STALLI:
      syntax: "STALLI"
      operation: "Stall interrupts (disable)"
      use: "Critical sections"
      
    ALLOWI:
      syntax: "ALLOWI"
      operation: "Allow interrupts (enable)"
      use: "Exit critical section"
    
    NIXINT1_3:
      syntax: "NIXINT1/2/3"
      operation: "Cancel pending interrupt"
      debug_use: "Clear pending debug interrupts"

  return_instructions:
    RETI0_3:
      syntax: "RETI0/1/2/3 {WC/WZ/WCZ}"
      operation: "Return from interrupt, restore C/Z if specified"
      behavior: "Pop address from internal stack, restore flags"
      example: "RETI1 WCZ  ' Return and restore both flags"
      
    RESI0_3:
      syntax: "RESI0/1/2/3"
      operation: "Resume from interrupt (continue interrupted code)"
      behavior: "Like RETI but continues interrupted instruction"
      use: "For interrupts that don't fully handle event"

debug_isr_architecture:
  complete_preservation:
    description: "Debug ISR must preserve ALL state"
    code: |
      debug_isr
              ' Save every single register (comprehensive)
              setq    #$1F            ' Save 32 registers
              wrlong  0, ptra++       ' Save $000-$01F
              
              ' Save special registers
              mov     save_pa, pa
              mov     save_pb, pb
              mov     save_ptra, ptra
              mov     save_ptrb, ptrb
              
              ' Save interrupt state
              getbrk  save_brk   wcz  ' Get break info
              
              ' Debug processing...
              
              ' Restore everything in reverse
              sub     ptra, #32*4
              setq    #$1F
              rdlong  0, ptra
              
              mov     pa, save_pa
              mov     pb, save_pb
              mov     ptra, save_ptra
              mov     ptrb, save_ptrb
              
              reti3   wcz             ' Return with flags
    source: Spin2_debugger.spin2
  
  breakpoint_handling:
    description: "Process breakpoints and debug commands"
    code: |
      ' Identify breakpoint type
              getbrk  brk_code   wz   ' Get breakpoint code
              
              ' Dispatch on code
              cmp     brk_code, #BP_TRACE    wz
      if_z    jmp     #handle_trace
              cmp     brk_code, #BP_WATCH    wz
      if_z    jmp     #handle_watch
              cmp     brk_code, #BP_STEP     wz
      if_z    jmp     #handle_step
              
              ' Default: halt for debugger
              jmp     #debug_prompt
    source: Spin2_debugger.spin2
  
  dynamic_code_overlay:
    description: "Load debug commands dynamically"
    challenge: "Limited COG RAM requires overlays"
    solution: |
      ' Load debug command handler overlay
      load_debug_cmd
              loc     ptra, #\debug_cmd_table
              add     ptra, cmd_offset
              setq    #16-1           ' Load 16 longs
              rdlong  overlay_area, ptra
              
              ' Execute overlay
              call    #overlay_area
              
              ' Return to main debug loop
    source: Spin2_debugger.spin2

event_sources:
  selectable_events:
    0: "Never (disabled)"
    1: "CT-passed-CT1 (CT >= CT1)"
    2: "CT-passed-CT2 (CT >= CT2)"
    3: "CT-passed-CT3 (CT >= CT3)"
    4: "SE1 event occurred"
    5: "SE2 event occurred"
    6: "SE3 event occurred"
    7: "SE4 event occurred"
    8: "Pin pattern matched"
    9: "Pin pattern not matched"
    10: "Hub FIFO ready"
    11: "Hub FIFO empty"
    12: "ATN from other cog"
    13: "LOCK acquired"
    14: "LOCK lost"
    15: "External event"
    16_debug: "BRK instruction (INT3)"

  event_configuration:
    SETSE1:
      syntax: "SETSE1 #mode"
      operation: "Configure selectable event 1"
      modes: "Pin edge, state, Smart Pin ready, etc."
      
    SETSE2:
      syntax: "SETSE2 #mode"
      operation: "Configure selectable event 2"
      
    SETSE3:
      syntax: "SETSE3 #mode"
      operation: "Configure selectable event 3"
      
    SETSE4:
      syntax: "SETSE4 #mode"
      operation: "Configure selectable event 4"

  pattern_detection:
    SETPAT:
      syntax: "SETPAT mask, match"
      operation: "Configure pin pattern detection"
      use: "Trigger on specific pin combinations"
      
    ADDCT1_3:
      syntax: "ADDCT1/2/3 value, #delta"
      operation: "Set timer compare value"
      use: "Schedule future events"

event_operations:
  polling:
    POLLATN:
      syntax: "POLLATN {WC}"
      operation: "Poll for attention, clear if set"
      
    POLLCT1_3:
      syntax: "POLLCTx {WC}"
      operation: "Poll for CT >= CTx"
      
    POLLPAT:
      syntax: "POLLPAT {WC}"
      operation: "Poll for pin pattern"
      
    POLLSE1_4:
      syntax: "POLLSEx {WC}"
      operation: "Poll selectable event"

  waiting:
    WAITINT:
      syntax: "WAITINT"
      operation: "Wait for any interrupt"
      
    WAITCT1:
      syntax: "WAITCT1"
      operation: "Wait for CT >= CT1"
      
    WAITCT2:
      syntax: "WAITCT2"
      operation: "Wait for CT >= CT2"
      
    WAITCT3:
      syntax: "WAITCT3"
      operation: "Wait for CT >= CT3"
      
    WAITPAT:
      syntax: "WAITPAT"
      operation: "Wait for pin pattern"
      
    WAITSE1_4:
      syntax: "WAITSEx"
      operation: "Wait for selectable event x"
      
    WAITATN:
      syntax: "WAITATN"
      operation: "Wait for attention signal"

interrupt_context:
  saved_on_interrupt:
    - "PC (program counter)"
    - "C flag"
    - "Z flag"
    - "Execution mode (cog/LUT/hub)"
    
  not_saved:
    - "General registers"
    - "PTRA/PTRB"
    - "Q register"
    - "Must be saved by ISR if needed"

  context_preservation:
    code: |
      isr1:
        ' Save registers if needed
        PUSHA work_reg
        ' ISR body
        POPA work_reg
        RETI1 WCZ        ' Restore flags

common_patterns:
  timer_interrupt:
    code: |
      ' Setup timer interrupt
      GETCT base_time
      ADDCT1 base_time, ##period
      MOV IJMP1, ##timer_isr
      SETINT1 #1       ' CT >= CT1
      
      timer_isr:
        ' Handle timer
        ADDCT1 base_time, ##period  ' Next interval
        ' Timer processing
        RETI1
    description: "Periodic timer interrupt"

  pin_event:
    code: |
      ' Setup pin edge detection
      SETSE1 #%01_000000 | pin  ' Rising edge on pin
      MOV IJMP2, ##pin_handler
      SETINT2 #4       ' SE1 event
      
      pin_handler:
        ' Handle pin event
        AKPIN pin        ' Acknowledge Smart Pin
        RETI2
    description: "Pin change interrupt"

  attention_handler:
    code: |
      ' Setup attention interrupt
      MOV IJMP3, ##atn_handler
      SETINT3 #12      ' ATN event
      
      atn_handler:
        ' Check which cog sent ATN
        POLLATN WC
        ' Process message
        RETI3
    description: "Inter-cog communication"

  debug_monitor:
    description: "Complete debug monitor setup"
    code: |
      ' Claim debug lock
      locktry #15         wc
      if_nc   jmp #debug_in_use
      
      ' Setup debug ISR
      loc     pa, #\debug_isr_hub
      setq    #256-1
      rdlong  debug_isr_cog, pa
      
      ' Configure INT3 for debug
      mov     ijmp3, ##debug_isr_cog
      setint3 #BRK_EVENT
      
      ' Debug monitor ready
    source: Spin2_debugger.spin2

  critical_section:
    code: |
      STALLI           ' Disable interrupts
      ' Critical code that must not be interrupted
      ' Access shared resources
      ALLOWI           ' Re-enable interrupts
    description: "Interrupt-safe code section"

priority_and_nesting:
  priority_rules:
    - "INT3 highest priority, can interrupt INT2/1/0"
    - "INT2 can interrupt INT1/0"
    - "INT1 can interrupt INT0"
    - "Same level cannot interrupt itself"
    - "Debug (INT3) can interrupt everything"
    
  nesting_depth:
    - "Maximum 4 levels deep (one per interrupt)"
    - "Each level has own return address"
    - "Flags saved per level"
    - "Debug ISR must handle full nesting"

  latency:
    response_time: "3-4 cycles from event to ISR"
    factors:
      - "Current instruction completion"
      - "Pipeline state"
      - "Higher priority interrupts"
    debug_impact: "Debug ISR adds ~20 cycles overhead"

best_practices:
  interrupt_design:
    - "Keep ISRs short and fast"
    - "Save/restore only needed registers"
    - "Use CALLA/CALLB in ISR for leaf functions"
    - "Clear event sources in ISR"
    - "Test with all interrupt combinations"
    - "Reserve INT3 for debug infrastructure"
    
  event_selection:
    - "Use polling for non-critical events"
    - "Use interrupts for time-critical events"
    - "Configure before enabling interrupts"
    - "Document event assignments clearly"
    - "Use lock[15] with debug interrupts"
    
  debugging:
    - "Add markers at ISR entry/exit"
    - "Track interrupt nesting depth"
    - "Verify flag preservation"
    - "Test maximum interrupt rate"
    - "Use GETBRK to identify debug context"

limitations:
  - "Only 4 interrupt levels"
  - "16 event sources per cog"
  - "No interrupt priority modification"
  - "Cannot interrupt AUGS/AUGD pairs"
  - "REP blocks delay interrupts"
  - "SETQ blocks are atomic"
  - "Debug ISR size limited by COG RAM"

references:
  - silicon_doc: Events and Interrupts section
  - instruction_set: Event/Interrupt instructions
  - Spin2_debugger.spin2: Complete debug ISR implementation
  - application_notes: Interrupt handling patterns