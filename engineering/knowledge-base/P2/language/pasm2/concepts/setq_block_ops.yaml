concept: setq_block_operations
title: SETQ/SETQ2 Block Operations
category: memory_operations
description: Hardware-accelerated block memory transfers and operations using SETQ/SETQ2 prefixes
documentation_source: enhanced
documentation_level: comprehensive

overview: |
  SETQ and SETQ2 are prefix instructions that modify the next instruction to perform block operations.
  They enable fast, hardware-accelerated transfers between hub and cog/LUT memory, block arithmetic,
  and multi-long operations. These are essential for efficient data movement and initialization.
  
  Critical for waveform tables, debug state preservation, and high-speed data processing.

setq_instructions:
  SETQ:
    function: "Set block count for cog RAM operations"
    syntax: "SETQ #count-1"
    range: "0-511 (transfer 1-512 longs)"
    target: "Cog RAM ($000-$1FF)"
    encoding: "9-bit immediate or register"
    example: |
      SETQ #15           ' Setup for 16 longs
      RDLONG 0, PTRA     ' Read 16 longs from hub to cog[0..15]

  SETQ2:
    function: "Set block count for LUT RAM operations"
    syntax: "SETQ2 #count-1"
    range: "0-511 (transfer 1-512 longs)"
    target: "LUT RAM ($200-$3FF in logical space)"
    encoding: "9-bit immediate or register"
    critical_note: "SETQ2 targets LUT, SETQ targets COG - don't confuse!"
    example: |
      SETQ2 #255         ' Setup for 256 longs
      RDLONG 0, PTRB     ' Read 256 longs from hub to LUT[0..255]
      ' Note: Use 0 for LUT start, not $200!

block_operations:
  hub_to_cog_transfer:
    instruction: "SETQ + RDLONG"
    operation: "Read multiple longs from hub to cog"
    syntax: |
      SETQ #count-1
      RDLONG first_cog_reg, hub_address
    timing: "2 + count cycles"
    example: |
      SETQ #31           ' 32 longs
      RDLONG buffer, ##source_data
      ' Reads hub[source_data..source_data+127] to cog[buffer..buffer+31]
    debug_use: |
      ' Save all COG registers for debug
      setq    #$1F            ' 32 registers
      wrlong  0, save_ptr     ' Save $000-$01F
    source: Spin2_debugger.spin2

  cog_to_hub_transfer:
    instruction: "SETQ + WRLONG"
    operation: "Write multiple longs from cog to hub"
    syntax: |
      SETQ #count-1
      WRLONG first_cog_reg, hub_address
    timing: "2 + count cycles"
    example: |
      SETQ #63           ' 64 longs
      WRLONG results, PTRA
      ' Writes cog[results..results+63] to hub[PTRA..PTRA+255]

  hub_to_lut_transfer:
    instruction: "SETQ2 + RDLONG"
    operation: "Read multiple longs from hub to LUT"
    syntax: |
      SETQ2 #count-1
      RDLONG 0, hub_address  ' Use 0 for LUT start!
    critical_pattern: |
      ' Load complete waveform table to LUT
      load_sine_table
              mov     ptra, ##sine_table_hub
              setq2   #512-1          ' Full LUT
              rdlong  0, ptra         ' Load to LUT[0..511]
              ret
      
      ' Later access via RDLUT
              rdlut   value, phase    ' Single-cycle lookup
    source: waveform_generation

  lut_to_hub_transfer:
    instruction: "SETQ2 + WRLONG"
    operation: "Write multiple longs from LUT to hub"
    syntax: |
      SETQ2 #count-1
      WRLONG 0, hub_address  ' Use 0 for LUT start!
    debug_pattern: |
      ' Save debug trace from LUT to HUB
      save_trace
              setq2   #256-1          ' 256 trace entries
              wrlong  0, trace_buffer ' LUT[0..255] to HUB
              ret
    source: Spin2_debugger.spin2

production_patterns:
  motor_commutation_tables:
    description: "Load motor control patterns to LUT"
    code: |
      ' Load commutation patterns for BLDC motor
      load_commutation
              loc     ptra, #\motor_patterns
              setq2   #64-1           ' 64 patterns
              rdlong  0, ptra         ' Load to LUT[0..63]
              
      ' Access during motor control
              shl     hall_state, #3  ' 8 bytes per state
              rdlut   pattern, hall_state
              
              ' Apply pattern to PWM outputs
              and     pattern, #$3F
              call    #set_pwm_outputs
    source: isp_bldc_motor.spin2
    
  debug_state_preservation:
    description: "Complete COG state save/restore"
    code: |
      debug_save_state
              ' Save first 32 registers
              setq    #$1F
              wrlong  0, ptra++
              
              ' Save next 32 registers  
              setq    #$1F
              wrlong  $20, ptra++
              
              ' Save special registers individually
              wrlong  pa, ptra++
              wrlong  pb, ptra++
              wrlong  ptra_save, ptra++
              wrlong  ptrb_save, ptra++
              
      debug_restore_state
              ' Restore in reverse order
              sub     ptra, #4*4      ' Back to specials
              rdlong  ptrb_save, --ptra
              rdlong  ptra_save, --ptra
              rdlong  pb, --ptra
              rdlong  pa, --ptra
              
              ' Restore main registers
              sub     ptra, #64*4
              setq    #$1F
              rdlong  $20, ptra[32]
              setq    #$1F
              rdlong  0, ptra
    source: Spin2_debugger.spin2
    
  waveform_buffer_management:
    description: "Use LUT as waveform buffer"
    code: |
      ' Process audio/waveform data via LUT
      process_waveform
              ' Load samples to LUT for processing
              setq2   #128-1
              rdlong  0, sample_ptr
              
              ' Process in LUT (faster than HUB)
              mov     index, #0
      .loop   rdlut   sample, index
              ' Apply DSP operations
              sar     sample, #1      ' Volume control
              add     sample, dc_offset
              wrlut   sample, index
              incmod  index, #127
              tjnz    index, #.loop
              
              ' Write processed data back
              setq2   #128-1
              wrlong  0, output_ptr
    source: audio_processing
    
  flash_loader_buffers:
    description: "Fast flash programming buffers"
    code: |
      ' Load flash page to COG for programming
      load_flash_page
              setq    #128-1          ' 512 bytes = 128 longs
              rdlong  page_buffer, data_ptr
              
              ' Program page to flash
              call    #flash_write_enable
              call    #flash_page_program
              
              ' Verify programming
              setq    #128-1
              rdlong  verify_buffer, data_ptr
              ' Compare buffers...
    source: flash_loader.spin2

special_operations:
  block_math:
    description: "SETQ modifies certain math operations"
    operations:
      MUXQ:
        syntax: "SETQ mask + MUXQ dest, source"
        operation: "dest = (dest & !mask) | (source & mask)"
        use: "Masked merge operation"
      
      COGINIT:
        syntax: "SETQ #ptra_ptrb + COGINIT #cog, #address"
        operation: "Initialize cog with PTRA/PTRB values"
        encoding: "PTRA[19:0] in bits 19:0, PTRB[19:0] in bits 39:20"

  augmented_operations:
    with_AUGS:
      description: "AUGS + SETQ for 32-bit counts"
      example: |
        AUGS #>>1000      ' Upper bits
        SETQ #1000 & $1FF ' Lower 9 bits
        RDLONG 0, hub_ptr ' Read 1001 longs
    
    with_AUGD:
      description: "AUGD + SETQ for special modes"
      operation: "Enables alternate block modes"

block_fill:
  cog_fill:
    instruction: "SETQ + WRLONG immediate"
    operation: "Fill cog registers with value"
    syntax: |
      SETQ #count-1
      WRLONG #value, #first_reg
    example: |
      SETQ #15
      WRLONG #0, #buffer  ' Clear 16 cog registers

  hub_fill:
    instruction: "SETQ + WRLONG with immediate"
    operation: "Fill hub memory with value"
    syntax: |
      SETQ #count-1
      WRLONG value_reg, hub_address
    note: "Use FBLOCK for faster hub fills"

performance:
  transfer_rates:
    hub_to_cog: "1 long per cycle after 2-cycle setup"
    cog_to_hub: "1 long per cycle after 2-cycle setup"
    hub_to_lut: "1 long per cycle after 2-cycle setup"
    lut_to_hub: "1 long per cycle after 2-cycle setup"

  efficiency:
    small_transfers: "2 + N cycles for N longs"
    large_transfers: "Approaches 1 cycle per long"
    vs_loop: "10-20x faster than RDLONG/WRLONG loop"
    lut_advantage: "LUT access is single-cycle after load"

  limitations:
    - "Maximum 512 longs per operation"
    - "Must be contiguous memory"
    - "Cannot cross cog/LUT boundary"
    - "Interrupts delayed during transfer"
    - "LUT addressing starts at 0, not $200 for SETQ2"

common_patterns:
  array_copy:
    code: |
      SETQ #array_size-1
      RDLONG dest_array, source_ptr
    description: "Copy entire array"

  buffer_clear:
    code: |
      SETQ #buffer_size-1
      WRLONG #0, #buffer_start
    description: "Clear buffer to zero"

  context_save:
    code: |
      SETQ #31              ' Save 32 registers
      WRLONG 0, context_ptr ' Save cog[0..31]
    description: "Save register context"

  context_restore:
    code: |
      SETQ #31              ' Restore 32 registers
      RDLONG 0, context_ptr ' Restore cog[0..31]
    description: "Restore register context"

  lut_table_load:
    code: |
      SETQ2 #255            ' Half of LUT
      RDLONG 0, ##sine_table ' Note: 0, not $200!
    description: "Load lookup table"

  fast_memcpy:
    code: |
      .copy_loop
        SETQ #127           ' 128 longs = 512 bytes
        RDLONG temp_buffer, src_ptr
        ADD src_ptr, ##512
        SETQ #127
        WRLONG temp_buffer, dst_ptr
        ADD dst_ptr, ##512
        DJNZ count, #.copy_loop
    description: "Fast memory copy routine"

advanced_usage:
  partial_transfers:
    description: "Transfer subset of registers"
    example: |
      MOV count, actual_size
      SUB count, #1
      SETQ count          ' Dynamic count
      RDLONG buffer, PTRA

  strided_access:
    description: "Cannot do strided - must be contiguous"
    workaround: "Use multiple SETQ operations"
    example: |
      ' Copy every 4th long
      MOV index, #0
      .loop
        RDLONG temp, source_ptr
        ADD source_ptr, #16    ' Skip 3 longs
        ALTD index, #buffer
        MOV 0-0, temp
        ADD index, #1
        DJNZ count, #.loop

  interrupt_blocking:
    description: "Block transfers are atomic"
    behavior: "Interrupts delayed until complete"
    consideration: "Keep transfers small for responsiveness"
    debug_impact: "Debug ISR must wait for completion"

debugging:
  verification:
    - "Check SETQ count is N-1, not N"
    - "Verify address alignment"
    - "Confirm no boundary crossing"
    - "Test with small counts first"
    - "Remember: LUT uses 0, not $200 with SETQ2"

  common_errors:
    off_by_one: "Using count instead of count-1"
    boundary_cross: "Transfer across cog/LUT boundary"
    wrong_prefix: "SETQ for LUT, SETQ2 for cog"
    lut_addressing: "Using $200 instead of 0 with SETQ2"

best_practices:
  - "Always use count-1 in SETQ/SETQ2"
  - "Align transfers to long boundaries"
  - "Use for initialization and bulk copies"
  - "Consider interrupt latency impact"
  - "Document transfer sizes clearly"
  - "Test boundary conditions"
  - "Use LUT for frequently accessed tables"
  - "Preserve debug state with SETQ blocks"

references:
  - silicon_doc: SETQ/SETQ2 block operations
  - instruction_set: SETQ/SETQ2 encoding
  - flash_loader.spin2: Buffer management
  - Spin2_debugger.spin2: State preservation
  - isp_bldc_motor.spin2: LUT table usage
  - optimization_guide: Fast memory transfers