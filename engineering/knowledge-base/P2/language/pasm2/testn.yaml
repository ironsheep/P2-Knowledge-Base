instruction: TESTN
syntax: TESTN Dest, {#}Src {WC|WZ|WCZ}
encoding:
- "EEEE 0111111 CZI DDDDDDDDD SSSSSSSSS                   \u2014         Parity of (D & !S)     (D & !S)\
  \ = 0               2"
- "EEEE 1101011 CZL DDDDDDDDD 001000000                  \u2014            IN[D[5:0]]         IN[D[5:0]]\
  \                2"
- "EEEE 1101011 CZL DDDDDDDDD 001000010                  \u2014        C AND IN[D[5:0]] Z AND IN[D[5:0]]\
  \                2"
- "EEEE 1101011 CZL DDDDDDDDD 001000100                  \u2014         C OR IN[D[5:0]]    Z OR IN[D[5:0]]\
  \              2"
- "EEEE 1101011 CZL DDDDDDDDD 001000110                  \u2014        C XOR IN[D[5:0]] Z XOR IN[D[5:0]]\
  \                2"
- "EEEE 1101011 CZL DDDDDDDDD 001000001                  \u2014            !IN[D[5:0]]        !IN[D[5:0]]\
  \               2"
- "EEEE 1101011 CZL DDDDDDDDD 001000011                  \u2014        C AND !IN[D[5:0]] Z AND !IN[D[5:0]]\
  \              2"
- "EEEE 1101011 CZL DDDDDDDDD 001000101                  \u2014         C OR !IN[D[5:0]]   Z OR !IN[D[5:0]]\
  \             2"
- "EEEE 1101011 CZL DDDDDDDDD 001000111                  \u2014        C XOR !IN[D[5:0]] Z XOR !IN[D[5:0]]\
  \              2"
- EEEE 1011101 00I DDDDDDDDD SSSSSSSSS                        PC    1
- EEEE 1011101 10I DDDDDDDDD SSSSSSSSS                        PC    1
timing:
  cycles: 1
  type: fixed
group: Bit Operation Instruction - Test D by bitwise ANDing with !S to affect flags only.
description: "TESTN determines the parity (number of high (1) bits) and the zero or non-zero state of\
  \ Dest bitwise ANDed with Result: The parity and zero-state of Dest bitwise ANDed with !Src is stored\
  \ in the C and Z flags. C = parity of (D & !S).\n\nTESTN determines the parity (number of high (1) bits)\
  \ and the zero or non-zero state of Dest bitwise ANDed with\n\n!Src and stores the results in the C\
  \ and/or Z \uFB02ag.\n\nIf the WC or WCZ effect is speci\uFB01ed, the C \uFB02ag is set (1) if the number\
  \ of high (1) bits in Dest ANDed with !Src is\n\nodd, or is cleared (0) if it is even.\n\nIf the WZ\
  \ or WCZ effect is speci\uFB01ed, the Z \uFB02ag is set (1) if Dest ANDed with !Src is zero, or is cleared\
  \ (0) if it is not\n\nzero.\n\nTESTP / TESTPN\n\nTest pin or pin not\n\nI/O Pin Instruction - Test pin\
  \ and either store, AND, OR, or XOR the result or inverse result into C/Z.\n\nTESTP    {#}Dest WC|WZ\n\
  \nTESTP    {#}Dest ANDC|ANDZ\n\nTESTP    {#}Dest ORC|ORZ\n\nTESTP    {#}Dest XORC|XORZ\n\nTESTPN {#}Dest\
  \ WC|WZ\n\nTESTPN {#}Dest ANDC|ANDZ\n\nTESTPN {#}Dest ORC|ORZ\n\nTESTPN {#}Dest XORC|XORZ\n\nResult:\
  \ The state of the I/O pin described by Dest is read, possibly inverted, and either stored as-is, or\
  \ bitwise\n\nANDed, ORed, or XORed into C or Z.\n\n\u25CF   Dest is the register or 6-bit literal whose\
  \ value identi\uFB01es the I/O pin to test.\n\n\u25CF   WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ\
  \ is a required effect to update or bitwise manipulate the C\n\nor Z \uFB02ag.\n\nCOND INSTR       \
  \ FX     DEST          SRC           Write            C Flag            Z Flag              Clocks\n\
  \nEEEE 1101011 CZL DDDDDDDDD 001000000                  \u2014            IN[D[5:0]]         IN[D[5:0]]\
  \                2\n\nEEEE 1101011 CZL DDDDDDDDD 001000010                  \u2014        C AND IN[D[5:0]]\
  \ Z AND IN[D[5:0]]                2\n\nEEEE 1101011 CZL DDDDDDDDD 001000100                  \u2014\
  \         C OR IN[D[5:0]]    Z OR IN[D[5:0]]              2\n\nEEEE 1101011 CZL DDDDDDDDD 001000110\
  \                  \u2014        C XOR IN[D[5:0]] Z XOR IN[D[5:0]]                2\n\nEEEE 1101011\
  \ CZL DDDDDDDDD 001000001                  \u2014            !IN[D[5:0]]        !IN[D[5:0]]        \
  \       2\n\nEEEE 1101011 CZL DDDDDDDDD 001000011                  \u2014        C AND !IN[D[5:0]] Z\
  \ AND !IN[D[5:0]]              2\n\nEEEE 1101011 CZL DDDDDDDDD 001000101                  \u2014   \
  \      C OR !IN[D[5:0]]   Z OR !IN[D[5:0]]             2\n\nEEEE 1101011 CZL DDDDDDDDD 001000111   \
  \               \u2014        C XOR !IN[D[5:0]] Z XOR !IN[D[5:0]]              2\n\nRelated: TESTB and\
  \ TESTBN\n\nTESTP or TESTPN reads the state (0/1) of the I/O pin designated by Dest, possibly inverts\
  \ that result, and either\n\nstores it as-is, or bitwise ANDs, ORs, or XORs it into the C or Z \uFB02\
  ag. Dest[5:0] indicates the pin number (0\u201363) to\n\ntest.\n\nIf the WC or WZ effect is speci\uFB01\
  ed, the C or Z \uFB02ag is overwritten with the state or inverse state of the pin.\n\nIf the ANDC or\
  \ ANDZ effect is speci\uFB01ed, the C or Z \uFB02ag is bitwise ANDed with the state or inverse state\
  \ of the pin.\n\nIf the ORC or ORZ effect is speci\uFB01ed, the C or Z \uFB02ag is bitwise ORed with\
  \ the state or inverse state of the pin.\n\nIf the XORC or XORZ effect is speci\uFB01ed, the C or Z\
  \ \uFB02ag is bitwise XORed with the state or inverse state of the pin.\n\nTJF / TJNF\n\nTest, jump\
  \ if full or not full\n\nFlow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or\
  \ not full (<> -1; <> $FFFF_FFFF).\n\nTJF        Dest, {#}Src\n\nTJNF Dest, {#}Src\n\nResult: Dest is\
  \ tested and if it's full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute\
  \ (Src)\n\naddress.\n\n\u25CF    Dest is a register whose value is tested for full or not full.\n\n\u25CF\
  \    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative\
  \ address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR\
  \             FX      DEST           SRC             Write       C Flag             Z Flag         \
  \    Clocks\n\nEEEE 1011101 00I DDDDDDDDD SSSSSSSSS                        PC    1\n\n\u2014       \
  \           \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011101 01I DDDDDDDDD SSSSSSSSS      \
  \                  PC1         \u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\n\
  1\n\nPC is written only when Dest is full (or not full in syntax 2).\n\nTJF or TJNF tests the value\
  \ in Dest and jumps to the address described by Src if the result is full (-1; $FFFF_FFFF;\n\nin syntax\
  \ 1) or not full (<> -1; <> $FFFF_FFFF; in syntax 2).\n\nThe address (Src) can be absolute or relative.\
  \ To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify\
  \ a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions)\
  \ or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288\
  \ to\n\n+524287). Offsets are relative to the instruction following the TJF / TJNF. The signed offset\
  \ value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution\
  \ mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code\
  \ not required).\n\nTJS / TJNS\n\nTest, jump if signed or not signed\n\nFlow Control Instruction - Test\
  \ value and jump if signed or not signed.\n\nTJS        Dest, {#}Src\n\nTJNS Dest, {#}Src\n\nResult:\
  \ Dest is tested and if it's signed (or not signed in syntax 2), PC is set to a new relative (#Src)\
  \ or absolute\n\n(Src) address.\n\n\u25CF    Dest is a register whose value is tested for sign or no\
  \ sign.\n\n\u25CF    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the\
  \ absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\
  \nCOND INSTR             FX      DEST           SRC             Write       C Flag             Z Flag\
  \             Clocks\n\nEEEE 1011101 10I DDDDDDDDD SSSSSSSSS                        PC    1\n\n\u2014\
  \                  \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011101 11I DDDDDDDDD SSSSSSSSS\
  \                        PC    1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u2013\
  20\n\n1\n\nPC is written only when Dest is signed (or not signed in syntax 2).\n\nTJS or TJNS tests\
  \ the value in Dest and jumps to the address described by Src if the result is signed (Dest[31] = 1)\n\
  \nor not signed (Dest[31] = 0).\n\nThe address (Src) can be absolute or relative. To specify an absolute\
  \ address, Src must be a register containing a\n\n20-bit address value. To specify a relative address,\
  \ use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or\
  \ insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets\
  \ are relative to the instruction following the TJS / TJNS. The signed offset value is in units of\n\
  \nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied\
  \ by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required)."
flags_affected:
  C:
    formula: parity of (D & !S)
  Z:
    formula: ((D & !S) == 0)
parameters:
- Dest is the register whose value will be tested.
- Src is an optional register, 9-bit literal, or 32-bit augmented literal whose inverse value is ANDed
  with Dest.
- "WC, WZ, and WCZ are optional effects to update \uFB02ags."
- "Dest is the register or 6-bit literal whose value identi\uFB01es the I/O pin to test."
- "WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the\
  \ C or Z \uFB02ag."
- Dest is a register whose value is tested for full or not full.
- 'Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative
  address to set PC to. Use # for relative addressing; omit # for absolute addressing.'
- Dest is a register whose value is tested for sign or no sign.
- 'Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative
  address to set PC to. Use # for relative addressing; omit # for absolute addressing.'
related:
- TESTB
- TESTBN
documentation_source: PASM2 Manual 2022/11/01 Pages 31-147
documentation_level: comprehensive
compiler_operand_format:
  name: operand_ds
  pattern: D,S/#
  description: Destination register, Source register or immediate value
  valueType: 0
compiler_encoding:
  operandFormat: 0
enhancement_source: PNUT_TS_v2.0_complete_operand_integration_2025-09-13
last_updated: '2025-09-19'
brief_description: Test not
category: "Bit Operation Instruction - Test D by bitwise ANDing with !S to affect \uFB02ags only."
result: Dest is tested and if it's signed (or not signed in syntax 2), PC is set to a new relative (#Src)
  or absolute
syntax_variants:
- TESTN Dest, {#}Src {WC|WZ|WCZ}
- TESTN determines the parity (number of high (1) bits) and the zero or non-zero state of Dest bitwise
  ANDed with
manual_extraction_date: '2025-01-19'
