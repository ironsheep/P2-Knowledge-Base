{
  "meta": {
    "version": "1.1.0",
    "release_date": "2025-09-13",
    "completeness": 0.95,
    "stable": false,
    "breaking_changes_expected": true,
    "sources": {
      "primary": "P2 Documentation v35 - Rev B/C Silicon by Chip Gracey",
      "instruction_set": "P2 Instructions v35 Spreadsheet",
      "contributors": [
        "Chip Gracey (cgracey@parallax.com)",
        "Parallax Inc."
      ],
      "pasm2": "engineering/knowledge-base/P2/language/pasm2/",
      "spin2": "engineering/knowledge-base/P2/language/spin2/"
    },
    "last_updated": "2025-09-13T14:04:24.689333"
  },
  "architecture": {
    "cogs": {
      "count": 8,
      "type": "symmetric",
      "memory_per_cog": "512 longs (2KB) COG RAM",
      "registers_per_cog": "$000-$1FF",
      "execution": "2-clock instructions typical"
    },
    "hub": {
      "memory_size": "512KB",
      "access_method": "Egg Beater - 8-way interleaved",
      "slice_rotation": "Every clock cycle",
      "long_access": "Random: 9-16 clocks, Sequential: 2 clocks"
    },
    "smart_pins": {
      "count": 64,
      "modes": 32,
      "status": "partial_documentation",
      "note": "Complete documentation pending from Jon Titus"
    },
    "cordic": {
      "pipeline_stages": 54,
      "operations": [
        "rotate",
        "vector",
        "multiply",
        "divide",
        "sqrt",
        "log",
        "exp"
      ],
      "precision": "32-bit"
    },
    "clock": {
      "internal_rc": "~24MHz",
      "pll_range": "3.125MHz to 500MHz",
      "xi_input": "DC to 200MHz",
      "max_sysclock": "180MHz typical"
    }
  },
  "instructions": {
    "total_count": 352,
    "source": "engineering/knowledge-base/P2/language/pasm2/",
    "extraction_date": "2025-09-13T14:04:24.689333",
    "categories": {
      "Math and Logic": {
        "count": 26,
        "description": "Math and Logic",
        "instructions": {
          "CRCBIT": {
            "mnemonic": "CRCBIT",
            "syntax": "CRCBIT  D,{#}S",
            "encoding": "EEEE 1001110 10I DDDDDDDDD SSSSSSSSS",
            "description": "Iterate CRC value in D using C and polynomial in S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SUMZ": {
            "mnemonic": "SUMZ",
            "syntax": "SUMZ    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Sum +/-S into D by Z.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D +/- S)"
              },
              "Z": {
                "formula": "1 then D = D - S, else D = D + S"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SUMC": {
            "mnemonic": "SUMC",
            "syntax": "SUMC    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Sum +/-S into D by C.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 then D = D - S, else D = D + S"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RGBEXP": {
            "mnemonic": "RGBEXP",
            "syntax": "RGBEXP  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100111",
            "description": "Expand 5:6:5 RGB value in D[15:0] into 8:8:8 value in D[31:8].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "AND": {
            "mnemonic": "AND",
            "syntax": "AND     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "AND S into D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "WRC": {
            "mnemonic": "WRC",
            "syntax": "WRC     D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101100",
            "description": "Write 0 or 1 to D, according to C.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MERGEW": {
            "mnemonic": "MERGEW",
            "syntax": "MERGEW  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100011",
            "description": "Merge bits of words in D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WRZ": {
            "mnemonic": "WRZ",
            "syntax": "WRZ     D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101110",
            "description": "Write 0 or 1 to D, according to Z.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MERGEB": {
            "mnemonic": "MERGEB",
            "syntax": "MERGEB  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100001",
            "description": "Merge bits of bytes in D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MOVBYTS": {
            "mnemonic": "MOVBYTS",
            "syntax": "MOVBYTS D,{#}S",
            "encoding": "EEEE 1001111 11I DDDDDDDDD SSSSSSSSS",
            "description": "Move bytes within D, per S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MUXC": {
            "mnemonic": "MUXC",
            "syntax": "MUXC    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Mux C into each D bit that is '1' in S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "TESTB": {
            "mnemonic": "TESTB",
            "syntax": "TESTB   D,{#}S         WC/WZ",
            "encoding": "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Z = C/Z XOR D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR D[S[4:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MUXZ": {
            "mnemonic": "MUXZ",
            "syntax": "MUXZ    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Mux Z into each D bit that is '1' in S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "BITC": {
            "mnemonic": "BITC",
            "syntax": "BITC    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "BITZ": {
            "mnemonic": "BITZ",
            "syntax": "BITZ    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MODC": {
            "mnemonic": "MODC",
            "syntax": "MODC    c               {WC}",
            "encoding": "EEEE 1101011 C01 0cccc0000 001101111",
            "description": "C = cccc[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "cccc[{C,Z}]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MODZ": {
            "mnemonic": "MODZ",
            "syntax": "MODZ    z               {WZ}",
            "encoding": "EEEE 1101011 0Z1 00000zzzz 001101111",
            "description": "Z = zzzz[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "zzzz[{C,Z}]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SEUSSR": {
            "mnemonic": "SEUSSR",
            "syntax": "SEUSSR  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100101",
            "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Reverse pattern.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "BITH": {
            "mnemonic": "BITH",
            "syntax": "BITH    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RGBSQZ": {
            "mnemonic": "RGBSQZ",
            "syntax": "RGBSQZ  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100110",
            "description": "Squeeze 8:8:8 RGB value in D[31:8] into 5:6:5 value in D[15:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "LOC": {
            "mnemonic": "LOC",
            "syntax": "LOC     PA/PB/PTRA/PTRB,#{\\}A",
            "encoding": "EEEE 11101WW RAA AAAAAAAAA AAAAAAAAA",
            "description": "R = 1, address = PC + A, else address = A.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "XORO32": {
            "mnemonic": "XORO32",
            "syntax": "XORO32  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101000",
            "description": "Iterate D with xoroshiro32+ PRNG algorithm and put PRNG result into next instruction's S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SEUSSF": {
            "mnemonic": "SEUSSF",
            "syntax": "SEUSSF  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100100",
            "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Forward pattern.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SPLITW": {
            "mnemonic": "SPLITW",
            "syntax": "SPLITW  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100010",
            "description": "Split odd/even bits of D into words.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SPLITB": {
            "mnemonic": "SPLITB",
            "syntax": "SPLITB  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100000",
            "description": "Split every 4th bit of D into bytes.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "CRCNIB": {
            "mnemonic": "CRCNIB",
            "syntax": "CRCNIB  D,{#}S",
            "encoding": "EEEE 1001110 11I DDDDDDDDD SSSSSSSSS",
            "description": "Q = Q << 4.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETNIB instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETNIB instruction.",
        "instructions": {
          "ALTSN": {
            "mnemonic": "ALTSN",
            "syntax": "ALTSN   D,{#}S",
            "encoding": "EEEE 1001010 101 DDDDDDDDD 000000000",
            "description": "ALTSN should be followed by SETNIB\u2014 it modifies the SETNIB instruction's Dest and Num values, enabling code Result: The next instruction's pipelined Dest and Num values are altered to be (Src + Dest[11:3]) & $1FF, or just Dest[11:3] for syntax 2, and Dest[2:0], respectively.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 12-bit value is the index, or the full nibble address, for the SETNIB instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[11:3]) for SETNIB) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Set template D field for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template D field for ALTI.",
        "instructions": {
          "SETD": {
            "mnemonic": "SETD",
            "syntax": "SETD    D,{#}S",
            "encoding": "EEEE 1001101 10I DDDDDDDDD SSSSSSSSS",
            "description": "SETD copies Src[8:0] to the D field of the template, Dest, to be used with an ALTI instruction. Bits outside the D Result: The D field [17:9] of template Dest is set to Src[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction.",
              "Src is a register or 9-bit literal whose value (Src[8:0]) is copied to the D field of Dest."
            ],
            "related": [
              "SETS",
              "SETR",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-NCO-rollover event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-NCO-rollover event flag.",
        "instructions": {
          "POLLXRO": {
            "mnemonic": "POLLXRO",
            "syntax": "POLLXRO          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001100 000100100",
            "description": "POLLXRO copies the state of the streamer NCO rollover event flag into C and/or Z and then clears the flag (unless Result: Streamer-NCO-rollover event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXRO",
              "JXRO",
              "JNXRO"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Pins": {
        "count": 12,
        "description": "Pins",
        "instructions": {
          "OUTZ": {
            "mnemonic": "OUTZ",
            "syntax": "OUTZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001100",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "OUTC": {
            "mnemonic": "OUTC",
            "syntax": "OUTC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001010",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DIRC": {
            "mnemonic": "DIRC",
            "syntax": "DIRC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000010",
            "description": "Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DIRZ": {
            "mnemonic": "DIRZ",
            "syntax": "DIRZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000100",
            "description": "Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DIRH": {
            "mnemonic": "DIRH",
            "syntax": "DIRH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000001",
            "description": "Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "OUTH": {
            "mnemonic": "OUTH",
            "syntax": "OUTH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001001",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "FLTZ": {
            "mnemonic": "FLTZ",
            "syntax": "FLTZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010100",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "FLTC": {
            "mnemonic": "FLTC",
            "syntax": "FLTC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010010",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DRVZ": {
            "mnemonic": "DRVZ",
            "syntax": "DRVZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011100",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DRVC": {
            "mnemonic": "DRVC",
            "syntax": "DRVC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011010",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DRVH": {
            "mnemonic": "DRVH",
            "syntax": "DRVH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011001",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "FLTH": {
            "mnemonic": "FLTH",
            "syntax": "FLTH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010001",
            "description": "Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and to an output level of random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and to an output level of random low/high.",
        "instructions": {
          "FLTRND": {
            "mnemonic": "FLTRND",
            "syntax": "FLTRND  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010110",
            "description": "FLTRND sets the I/O pin(s) designated by Dest to the input direction and with output level(s) set randomly low and Result: The I/O pins described by Dest are set to the input direction and each output level is set randomly low or high; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to the input direction and with output level(s) set randomly to low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if CORDIC-read-but-empty event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if CORDIC-read-but-empty event flag set or clear.",
        "instructions": {
          "JNQMT": {
            "mnemonic": "JNQMT",
            "syntax": "JNQMT   {#}S",
            "encoding": "EEEE 1011110 01I 000011111 SSSSSSSSS",
            "description": "JQMT or JNQMT checks the cog's CORDIC results event flag and jumps to the address described by Src if the flag Result: If CORDIC-read-but-empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry and zero flags left into value (2-bit rotate left).": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry and zero flags left into value (2-bit rotate left).",
        "instructions": {
          "RCZL": {
            "mnemonic": "RCZL",
            "syntax": "RCZL    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101011",
            "description": "RCZL shifts Dest's binary value left by two places and sets Dest[1] to C and Dest[0] to Z. Result: The bits of Dest are shifted left by two places and C and Z are inserted as new LSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "D[31], Z = D[30]",
                "when": "D"
              },
              "Z": {
                "formula": "D[30]",
                "when": "D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate the carry and zero flags left into.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values.",
        "instructions": {
          "CMP": {
            "mnemonic": "CMP",
            "syntax": "CMP     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMP compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - S)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "CMPR",
              "CMPX",
              "CMPS",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "CMP D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 64,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1600
              },
              "category": "Arithmetic",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one signed value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one signed value from another.",
        "instructions": {
          "SUBS": {
            "mnemonic": "SUBS",
            "syntax": "SUBS    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUBS subtracts the signed Src from the signed Dest and stores the result into the Dest register. If Src is a 9-bit Result: Difference of signed Dest and signed Src is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - S)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUB",
              "SUBX",
              "SUBSX",
              "ADDS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to !Z.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to !Z.",
        "instructions": {
          "NEGNZ": {
            "mnemonic": "NEGNZ",
            "syntax": "NEGNZ   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110111 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "NEGNZ negates Src (syntax 1) or Dest (syntax 2) if !Z = 1 and stores the result in the Dest register. If !Z = 0, the Src Result: The Src or Dest value, possibly negated according to !Z, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of result"
              },
              "Z": {
                "formula": "0 then D = -D, else D = D"
              }
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to !C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if !C=0) or negated value (if !C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "NEGZ",
              "NEGC",
              "NEGNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Miscellaneous": {
        "count": 7,
        "description": "Miscellaneous",
        "instructions": {
          "SETQ": {
            "mnemonic": "SETQ",
            "syntax": "SETQ    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000101000",
            "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set block transfer. Also used before MUXQ/COGINIT/QDIV/QFRAC/QROTATE/WAITxxx.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "GETCT": {
            "mnemonic": "GETCT",
            "syntax": "GETCT   D               {WC}",
            "encoding": "EEEE 1101011 C00 DDDDDDDDD 000011010",
            "description": "T=0 on reset, CT++ on every clock.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "same"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETQ2": {
            "mnemonic": "SETQ2",
            "syntax": "SETQ2   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000101001",
            "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set LUT block transfer.\n\nSETQ2 enables block transfers to/from LUT RAM instead of COG RAM:\n- SETQ2 + RDLONG: Block read from HUB to LUT\n- SETQ2 + WRLONG: Block write from LUT to HUB\n- Fast bulk data movement for lookup tables\n- Essential for waveform tables and large datasets\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "WAITX": {
            "mnemonic": "WAITX",
            "syntax": "WAITX   {#}D     {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 000011111",
            "description": "Wait for D+1 clock cycles. Stalls the cog for precise timing delays.\nZ = 0 after completion.\n\nCritical for bit-banging protocols, PWM generation, and timing-sensitive\noperations where precise delays are required.\n",
            "timing": {
              "cycles": "2 + D",
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": 0
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "PUSH": {
            "mnemonic": "PUSH",
            "syntax": "PUSH    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000101010",
            "description": "Push D onto stack.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POP": {
            "mnemonic": "POP",
            "syntax": "POP     D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000101011",
            "description": "Pop stack (K).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "K[31]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "GETRND": {
            "mnemonic": "GETRND",
            "syntax": "GETRND\u00a0 D\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000011011",
            "description": "Get RND into D/C/Z.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "RND[31], Z = RND[30], unique per cog"
              },
              "Z": {
                "formula": "RND[30], unique per cog"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Interrupt Instruction - Trigger breakpoint in specified cog.": {
        "count": 1,
        "description": "Interrupt Instruction - Trigger breakpoint in specified cog.",
        "instructions": {
          "COGBRK": {
            "mnemonic": "COGBRK",
            "syntax": "COGBRK  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110101",
            "description": "COGBRK triggers an asynchronous breakpoint in a designated cog. The COGBRK instruction must be executed Result: If in the Debug ISR, trigger an asynchronous breakpoint in cog identified by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal whose value (lower 3-bits) indicates which cog to trigger."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values plus carry flag.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values plus carry flag.",
        "instructions": {
          "CMPX": {
            "mnemonic": "CMPX",
            "syntax": "CMPX    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMPX compares the unsigned values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (D == S + C)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to compare with that of Src plus C.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to !C.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to !C.",
        "instructions": {
          "NEGNC": {
            "mnemonic": "NEGNC",
            "syntax": "NEGNC   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110101 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "NEGNC negates Src (syntax 1) or Dest (syntax 2) if !C = 1 and stores the result in the Dest register. If !C = 0, the Src Result: The Src or Dest value, possibly negated according to !C, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "0 then D = -D, else D = D"
              }
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to !C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if !C=0) or negated value (if !C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "NEGC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETBYTE instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETBYTE instruction.",
        "instructions": {
          "ALTSB": {
            "mnemonic": "ALTSB",
            "syntax": "ALTSB   D,{#}S",
            "encoding": "EEEE 1001011 001 DDDDDDDDD 000000000",
            "description": "ALTSB should be followed by SETBYTE\u2014 it modifies the SETBYTE instruction's Dest and Num values, enabling.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 11-bit value is the index, or the full byte address, for the SETBYTE instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[10:2]) for SETBYTE) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if zero or not zero.": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if zero or not zero.",
        "instructions": {
          "TJNZ": {
            "mnemonic": "TJNZ",
            "syntax": "TJNZ    D,{#}S",
            "encoding": "EEEE 1011100 11I DDDDDDDDD SSSSSSSSS",
            "description": "Dest is tested and if it's zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register whose value is tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two signed values plus carry flag.": {
        "count": 1,
        "description": "Math Instruction - Compare two signed values plus carry flag.",
        "instructions": {
          "CMPSX": {
            "mnemonic": "CMPSX",
            "syntax": "CMPSX   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMPSX compares the signed values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (D == S + C)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub RAM - Read": {
        "count": 5,
        "description": "Hub RAM - Read",
        "instructions": {
          "RDBYTE": {
            "mnemonic": "RDBYTE",
            "syntax": "RDBYTE  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "C = MSB of byte.",
            "timing": {
              "cycles": 9,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of byte"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RDWORD": {
            "mnemonic": "RDWORD",
            "syntax": "RDWORD  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "C = MSB of word.",
            "timing": {
              "cycles": 9,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of word"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RDLONG": {
            "mnemonic": "RDLONG",
            "syntax": "RDLONG  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "C = MSB of long.",
            "timing": {
              "cycles": 9,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "RDLONG D,S/#/PTRA/PTRB",
              "encoding": {
                "bits": 32,
                "opcode": 352,
                "effects": 3,
                "operandFormat": 15,
                "rawValue": 32608
              },
              "category": "Memory and I/O",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POPB": {
            "mnemonic": "POPB",
            "syntax": "POPB    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 111011111",
            "description": "C = MSB of long.",
            "timing": {
              "cycles": 9,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POPA": {
            "mnemonic": "POPA",
            "syntax": "POPA    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 101011111",
            "description": "C = MSB of long.",
            "timing": {
              "cycles": 9,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Interrupts": {
        "count": 10,
        "description": "Interrupts",
        "instructions": {
          "GETBRK": {
            "mnemonic": "GETBRK",
            "syntax": "GETBRK  D          WC/WZ/WCZ",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000110101",
            "description": "Get breakpoint/cog status into D according to WC/WZ/WCZ.\n\nFlag modes determine what information is retrieved:\n- WCZ: D = 32-bit ISR call address\n- WC: D = 8-bit COG ID in D[7:0]\n- WZ: D = 8-bit breakpoint code in D[7:0]\n- No flags: D = 16-bit skip pattern in D[15:0]\n\nEssential for debug infrastructure and multi-COG coordination.\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "TRGINT1": {
            "mnemonic": "TRGINT1",
            "syntax": "TRGINT1",
            "encoding": "EEEE 1101011 000 000100010 000100100",
            "description": "Trigger INT1, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETINT3": {
            "mnemonic": "SETINT3",
            "syntax": "SETINT3 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100111",
            "description": "Set INT3 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "NIXINT1": {
            "mnemonic": "NIXINT1",
            "syntax": "NIXINT1",
            "encoding": "EEEE 1101011 000 000100101 000100100",
            "description": "Cancel INT1.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETINT2": {
            "mnemonic": "SETINT2",
            "syntax": "SETINT2 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100110",
            "description": "Set INT2 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "NIXINT3": {
            "mnemonic": "NIXINT3",
            "syntax": "NIXINT3",
            "encoding": "EEEE 1101011 000 000100111 000100100",
            "description": "Cancel INT3.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETINT1": {
            "mnemonic": "SETINT1",
            "syntax": "SETINT1 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100101",
            "description": "Set INT1 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "NIXINT2": {
            "mnemonic": "NIXINT2",
            "syntax": "NIXINT2",
            "encoding": "EEEE 1101011 000 000100110 000100100",
            "description": "Cancel INT2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "TRGINT2": {
            "mnemonic": "TRGINT2",
            "syntax": "TRGINT2",
            "encoding": "EEEE 1101011 000 000100011 000100100",
            "description": "Trigger INT2, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "TRGINT3": {
            "mnemonic": "TRGINT3",
            "syntax": "TRGINT3",
            "encoding": "EEEE 1101011 000 000100100 000100100",
            "description": "Trigger INT3, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Color Space Converter": {
        "count": 5,
        "description": "Color Space Converter",
        "instructions": {
          "SETCY": {
            "mnemonic": "SETCY",
            "syntax": "SETCY   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111000",
            "description": "Set the colorspace converter \\\"CY\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETCFRQ": {
            "mnemonic": "SETCFRQ",
            "syntax": "SETCFRQ {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111011",
            "description": "Set the colorspace converter \\\"CFRQ\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETCQ": {
            "mnemonic": "SETCQ",
            "syntax": "SETCQ   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111010",
            "description": "Set the colorspace converter \\\"CQ\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETCI": {
            "mnemonic": "SETCI",
            "syntax": "SETCI   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111001",
            "description": "Set the colorspace converter \\\"CI\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETCMOD": {
            "mnemonic": "SETCMOD",
            "syntax": "SETCMOD {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111100",
            "description": "Set the colorspace converter \\\"CMOD\\\" parameter to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Hub FIFO - Read": {
        "count": 5,
        "description": "Hub FIFO - Read",
        "instructions": {
          "RFVAR": {
            "mnemonic": "RFVAR",
            "syntax": "RFVAR   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010011",
            "description": "C = 0.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": 0
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RFVARS": {
            "mnemonic": "RFVARS",
            "syntax": "RFVARS  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010100",
            "description": "C = MSB of value.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of value"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RFWORD": {
            "mnemonic": "RFWORD",
            "syntax": "RFWORD  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010001",
            "description": "C = MSB of word.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of word"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RFLONG": {
            "mnemonic": "RFLONG",
            "syntax": "RFLONG  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010010",
            "description": "C = MSB of long.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RFBYTE": {
            "mnemonic": "RFBYTE",
            "syntax": "RFBYTE  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010000",
            "description": "C = MSB of byte.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of byte"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Events - Branch": {
        "count": 23,
        "description": "Events - Branch",
        "instructions": {
          "JINT": {
            "mnemonic": "JINT",
            "syntax": "JINT    {#}S",
            "encoding": "EEEE 1011110 01I 000000000 SSSSSSSSS",
            "description": "Jump to S** if INT event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JSE3": {
            "mnemonic": "JSE3",
            "syntax": "JSE3    {#}S",
            "encoding": "EEEE 1011110 01I 000000110 SSSSSSSSS",
            "description": "Jump to S** if SE3 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JSE2": {
            "mnemonic": "JSE2",
            "syntax": "JSE2    {#}S",
            "encoding": "EEEE 1011110 01I 000000101 SSSSSSSSS",
            "description": "Jump to S** if SE2 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNSE4": {
            "mnemonic": "JNSE4",
            "syntax": "JNSE4   {#}S",
            "encoding": "EEEE 1011110 01I 000010111 SSSSSSSSS",
            "description": "Jump to S** if SE4 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JPAT": {
            "mnemonic": "JPAT",
            "syntax": "JPAT    {#}S",
            "encoding": "EEEE 1011110 01I 000001000 SSSSSSSSS",
            "description": "Jump to S** if PAT event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNCT1": {
            "mnemonic": "JNCT1",
            "syntax": "JNCT1   {#}S",
            "encoding": "EEEE 1011110 01I 000010001 SSSSSSSSS",
            "description": "Jump to S** if CT1 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNSE3": {
            "mnemonic": "JNSE3",
            "syntax": "JNSE3   {#}S",
            "encoding": "EEEE 1011110 01I 000010110 SSSSSSSSS",
            "description": "Jump to S** if SE3 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JXRO": {
            "mnemonic": "JXRO",
            "syntax": "JXRO    {#}S",
            "encoding": "EEEE 1011110 01I 000001100 SSSSSSSSS",
            "description": "Jump to S** if XRO event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JQMT": {
            "mnemonic": "JQMT",
            "syntax": "JQMT    {#}S",
            "encoding": "EEEE 1011110 01I 000001111 SSSSSSSSS",
            "description": "Jump to S** if QMT event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JCT1": {
            "mnemonic": "JCT1",
            "syntax": "JCT1    {#}S",
            "encoding": "EEEE 1011110 01I 000000001 SSSSSSSSS",
            "description": "Jump to S** if CT1 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JSE4": {
            "mnemonic": "JSE4",
            "syntax": "JSE4    {#}S",
            "encoding": "EEEE 1011110 01I 000000111 SSSSSSSSS",
            "description": "Jump to S** if SE4 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNSE2": {
            "mnemonic": "JNSE2",
            "syntax": "JNSE2   {#}S",
            "encoding": "EEEE 1011110 01I 000010101 SSSSSSSSS",
            "description": "Jump to S** if SE2 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNSE1": {
            "mnemonic": "JNSE1",
            "syntax": "JNSE1   {#}S",
            "encoding": "EEEE 1011110 01I 000010100 SSSSSSSSS",
            "description": "Jump to S** if SE1 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JCT2": {
            "mnemonic": "JCT2",
            "syntax": "JCT2    {#}S",
            "encoding": "EEEE 1011110 01I 000000010 SSSSSSSSS",
            "description": "Jump to S** if CT2 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JXMT": {
            "mnemonic": "JXMT",
            "syntax": "JXMT    {#}S",
            "encoding": "EEEE 1011110 01I 000001010 SSSSSSSSS",
            "description": "Jump to S** if XMT event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JCT3": {
            "mnemonic": "JCT3",
            "syntax": "JCT3    {#}S",
            "encoding": "EEEE 1011110 01I 000000011 SSSSSSSSS",
            "description": "Jump to S** if CT3 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JXFI": {
            "mnemonic": "JXFI",
            "syntax": "JXFI    {#}S",
            "encoding": "EEEE 1011110 01I 000001011 SSSSSSSSS",
            "description": "Jump to S** if XFI event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JFBW": {
            "mnemonic": "JFBW",
            "syntax": "JFBW    {#}S",
            "encoding": "EEEE 1011110 01I 000001001 SSSSSSSSS",
            "description": "Jump to S** if FBW event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JXRL": {
            "mnemonic": "JXRL",
            "syntax": "JXRL    {#}S",
            "encoding": "EEEE 1011110 01I 000001101 SSSSSSSSS",
            "description": "Jump to S** if XRL event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JATN": {
            "mnemonic": "JATN",
            "syntax": "JATN    {#}S",
            "encoding": "EEEE 1011110 01I 000001110 SSSSSSSSS",
            "description": "Jump to S** if ATN event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNCT2": {
            "mnemonic": "JNCT2",
            "syntax": "JNCT2   {#}S",
            "encoding": "EEEE 1011110 01I 000010010 SSSSSSSSS",
            "description": "Jump to S** if CT2 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JSE1": {
            "mnemonic": "JSE1",
            "syntax": "JSE1    {#}S",
            "encoding": "EEEE 1011110 01I 000000100 SSSSSSSSS",
            "description": "Jump to S** if SE1 event flag is set.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "JNCT3": {
            "mnemonic": "JNCT3",
            "syntax": "JNCT3   {#}S",
            "encoding": "EEEE 1011110 01I 000010011 SSSSSSSSS",
            "description": "Jump to S** if CT3 event flag is clear.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear CORDIC-read-but-empty event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear CORDIC-read-but-empty event flag.",
        "instructions": {
          "POLLQMT": {
            "mnemonic": "POLLQMT",
            "syntax": "POLLQMT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001111 000100100",
            "description": "POLLQMT copies the state of the CORDIC-read-but-empty event flag into C and/or Z and then clears the flag Result: CORDIC-read-but-empty event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "JQMT",
              "JNQMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context in PA/PB/PTRA/PTRB/D.": {
        "count": 1,
        "description": "Flow Control Instruction - Call a subroutine; store return context in PA/PB/PTRA/PTRB/D.",
        "instructions": {
          "CALLD": {
            "mnemonic": "CALLD",
            "syntax": "CALLD   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 11100WW RAA AAAAAAAAA AAAAAAAAA",
            "description": "CALLD records the current state of the C and Z flags and the address of the next instruction (PC + 1 if Cog/LUT Result: Write current C and Z flags and address of the next instruction into either PA, PB, PTRA, PTRB, or Dest, set PC to new relative or absolute address (in Addr or Src), and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [
              "PA|PB|PTRA|PTRB is the special register to store the current C and Z flags and next address into.",
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register to write the current C and Z flags and the address of the next instruction into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to and optional new C and Z states. Use # for relative addressing; omit # for absolute addressing.",
              "WC, WZ, or WCZ are optional effects to update the flags from Src's upper bit states."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Start an available cog, or restart a cog by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Start an available cog, or restart a cog by ID.",
        "instructions": {
          "COGINIT": {
            "mnemonic": "COGINIT",
            "syntax": "COGINIT {#}D,{#}S       {WC}",
            "encoding": "EEEE 1100111 CLI DDDDDDDDD SSSSSSSSS",
            "description": "COGINIT starts a new (unused) cog, a new pair of cogs (that may share LUT memory), or a specific cog by ID, to Result: Target cog is started, according to Dest, to execute code from Src. The code pointer (Src) is written to the target Cog's PTRB, and optionally a data pointer or user value is written to its PTRA (if previous SETQ is provided).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal describing the type of launch and possibly the ID of the desired cog to launch. If Dest is a register and WC is given, Dest is also where the ID of the launched cog will be written.",
              "WC is an optional effect to update the C flag with the success (0) or fail (1) status and triggers Dest to be overwritten with new cog's ID."
            ],
            "related": [
              "COGID",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Streamer": {
        "count": 6,
        "description": "Streamer",
        "instructions": {
          "XSTOP": {
            "mnemonic": "XSTOP",
            "syntax": "XSTOP",
            "encoding": "EEEE 1100101 011 000000000 000000000",
            "description": "Stop streamer immediately.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "XINIT": {
            "mnemonic": "XINIT",
            "syntax": "XINIT   {#}D,{#}S",
            "encoding": "EEEE 1100101 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Issue streamer command immediately, zeroing phase.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced_from_code_study",
            "documentation_level": "comprehensive"
          },
          "XCONT": {
            "mnemonic": "XCONT",
            "syntax": "XCONT   {#}D,{#}S",
            "encoding": "EEEE 1100110 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Buffer new streamer command to be issued on final NCO rollover of current command, continuing phase.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "XZERO": {
            "mnemonic": "XZERO",
            "syntax": "XZERO   {#}D,{#}S",
            "encoding": "EEEE 1100101 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Buffer new streamer command to be issued on final NCO rollover of current command, zeroing phase.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "GETXACC": {
            "mnemonic": "GETXACC",
            "syntax": "GETXACC D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 000011110",
            "description": "Get the streamer's Goertzel X accumulator into D and the Y accumulator into the next instruction's S, clear accumulators.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETXFRQ": {
            "mnemonic": "SETXFRQ",
            "syntax": "SETXFRQ {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000011101",
            "description": "Set streamer NCO frequency to D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Compare two unsigned values, get MSB of difference.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values, get MSB of difference.",
        "instructions": {
          "CMPM": {
            "mnemonic": "CMPM",
            "syntax": "CMPM    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMPM compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of (D - S)"
              },
              "Z": {
                "formula": "(D == S)",
                "when": "Result[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer NCO rollover event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if streamer NCO rollover event flag set or clear.",
        "instructions": {
          "JNXRO": {
            "mnemonic": "JNXRO",
            "syntax": "JNXRO   {#}S",
            "encoding": "EEEE 1011110 01I 000011100 SSSSSSSSS",
            "description": "If streamer NCO rollover event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETWORD instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETWORD instruction.",
        "instructions": {
          "ALTSW": {
            "mnemonic": "ALTSW",
            "syntax": "ALTSW   D,{#}S",
            "encoding": "EEEE 1001011 101 DDDDDDDDD 000000000",
            "description": "ALTSW should be followed by SETWORD\u2014 it modifies the SETWORD instruction's Dest and Num values, enabling Result: The next instruction's pipelined Dest and Num fields are altered to be (Src + Dest[9:1]) & $1FF, or just Dest[9:1] for syntax 2, and Dest[0], respectively.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[9:1]) for SETWORD) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Smart Pins": {
        "count": 8,
        "description": "Smart Pins",
        "instructions": {
          "SETDACS": {
            "mnemonic": "SETDACS",
            "syntax": "SETDACS {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000011100",
            "description": "DAC3 = D[31:24], DAC2 = D[23:16], DAC1 = D[15:8], DAC0 = D[7:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RDPIN": {
            "mnemonic": "RDPIN",
            "syntax": "RDPIN   D,{#}S          {WC}",
            "encoding": "EEEE 1010100 C1I DDDDDDDDD SSSSSSSSS",
            "description": "C = modal result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "modal result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RQPIN": {
            "mnemonic": "RQPIN",
            "syntax": "RQPIN   D,{#}S          {WC}",
            "encoding": "EEEE 1010100 C0I DDDDDDDDD SSSSSSSSS",
            "description": "C = modal result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "modal result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WXPIN": {
            "mnemonic": "WXPIN",
            "syntax": "WXPIN   {#}D,{#}S",
            "encoding": "EEEE 1100000 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set \\\"X\\\" of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ overrides S[10:6].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WYPIN": {
            "mnemonic": "WYPIN",
            "syntax": "WYPIN   {#}D,{#}S",
            "encoding": "EEEE 1100001 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Set \"Y\" register of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins.\nWraps within A/B pins. Prior SETQ overrides S[10:6].\n\nThe Y register serves multiple purposes:\n- For PWM modes: Sets the base period\n- For SPI/serial: Controls data to transmit\n- For counter modes: Sets count value\n- For ADC modes: Initiates conversions\n- Writing Y also acknowledges pin completion\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "SETSCP": {
            "mnemonic": "SETSCP",
            "syntax": "SETSCP  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 001110000",
            "description": "Set four-channel oscilloscope enable to D[6] and set input pin base to D[5:2].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WRPIN": {
            "mnemonic": "WRPIN",
            "syntax": "WRPIN   {#}D,{#}S",
            "encoding": "EEEE 1100000 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Set mode of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. \nWraps within A/B pins. Prior SETQ overrides S[10:6].\n\n**CRITICAL REQUIREMENT**: Smart pins MUST be reset (DIR=0) before configuring with WRPIN.\nThis ensures the smart pin is in a known state and prevents configuration conflicts.\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "GETSCP": {
            "mnemonic": "GETSCP",
            "syntax": "GETSCP  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001110001",
            "description": "Get four-channel oscilloscope samples into D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Create unsigned 16-bit scale value for next instruction's S value.": {
        "count": 1,
        "description": "Math Instruction - Create unsigned 16-bit scale value for next instruction's S value.",
        "instructions": {
          "SCA": {
            "mnemonic": "SCA",
            "syntax": "SCA     D,{#}S          {WZ}",
            "encoding": "EEEE 1010001 0ZI DDDDDDDDD SSSSSSSSS",
            "description": "SCA multiplies the lower 16-bits of each of Dest and Src together, right shifts the 32-bit product by 16 (to scale Result: The upper 16 bits of the unsigned product from the 16-bit Dest and Src multiplication is substituted as the next instruction's Src value and optionally the Z flag is updated to the zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the 16-bit value to multiply with Src.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose value is multiplied with Dest.",
              "WZ is an optional effect to update the Z flag."
            ],
            "related": [
              "SCAS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a word left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a word left into a value.",
        "instructions": {
          "ROLWORD": {
            "mnemonic": "ROLWORD",
            "syntax": "ROLWORD D,{#}S,#N",
            "encoding": "EEEE 1001010 000 DDDDDDDDD 000000000",
            "description": "ROLWORD reads the word identified by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW Result: Word Num (0\u20131) of Src, or a word from a source described by prior ALTGW instruction, is rotated left into Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the word into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target word to read.",
              "Num is a 1-bit literal identifying the nibble ID (0\u20131) of Src to read."
            ],
            "related": [
              "ALTGW",
              "ROLNIB",
              "ROLBYTE",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Bitwise OR a value with another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise OR a value with another.",
        "instructions": {
          "OR": {
            "mnemonic": "OR",
            "syntax": "OR      D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "OR performs a bitwise OR of the value in Src into that of Dest. Result: Dest OR Src is stored in Dest and flags are optionally updated with parity and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register containing the value to bitwise OR with Src and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be bitwise ORed into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Test": {
        "count": 3,
        "description": "Branch S - Test",
        "instructions": {
          "TJF": {
            "mnemonic": "TJF",
            "syntax": "TJF     D,{#}S",
            "encoding": "EEEE 1011101 00I DDDDDDDDD SSSSSSSSS",
            "description": "D = $FFFF_FFFF).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "TJS": {
            "mnemonic": "TJS",
            "syntax": "TJS     D,{#}S",
            "encoding": "EEEE 1011101 10I DDDDDDDDD SSSSSSSSS",
            "description": "Test D and jump to S** if D is signed (D[31] = 1).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "TJZ": {
            "mnemonic": "TJZ",
            "syntax": "TJZ     D,{#}S",
            "encoding": "EEEE 1011100 10I DDDDDDDDD SSSSSSSSS",
            "description": "Test D and jump to S** if D is zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Get bit position of top-most 1 of Src or Dest into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get bit position of top-most 1 of Src or Dest into Dest.",
        "instructions": {
          "ENCOD": {
            "mnemonic": "ENCOD",
            "syntax": "ENCOD   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111100 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "ENCOD stores the bit position value (0\u201431) of the top-most high bit (1) of Src, or Dest, into Dest. If the value to Result: The bit position value of the top-most high bit (1) in Src, or Dest, is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "(S != 0)",
                "when": "D"
              },
              "Z": {
                "when": "S"
              }
            },
            "parameters": [
              "Dest is the register in which to store the encoded bit position value and optionally begins by containing the 32-bit value it is encoding (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is to be encoded into a bit position.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context on the stack and copy D into PA or PB.": {
        "count": 1,
        "description": "Flow Control Instruction - Call a subroutine; store return context on the stack and copy D into PA or PB.",
        "instructions": {
          "CALLPB": {
            "mnemonic": "CALLPB",
            "syntax": "CALLPB  {#}D,{#}S",
            "encoding": "EEEE 1011010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "CALLPA and CALLPB records the current state of the C and Z flags and the address of the next instruction (PC + 1 Result: Push current C and Z flags and address of the next instruction onto the hardware stack, copy D to PA or PB, and set PC to new relative or absolute address.",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register, 9-bit literal, or 32-bit augmented literal whose value is copied to PA or PB.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate bits right.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate bits right.",
        "instructions": {
          "ROR": {
            "mnemonic": "ROR",
            "syntax": "ROR     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ROR rotates Dest's binary value right by Src places (0\u201331 bits). All LSBs rotated out are moved into the new Result: The bits of Dest are rotated right by Src bits; any departing LSBs are moved into MSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate right by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Adjust signed value by other Z-negated or !Z-negated value.": {
        "count": 1,
        "description": "Math Instruction - Adjust signed value by other Z-negated or !Z-negated value.",
        "instructions": {
          "SUMNZ": {
            "mnemonic": "SUMNZ",
            "syntax": "SUMNZ   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUMZ or SUMNZ adjusts the signed Dest value by Src or -Src (depending on Z or !Z) and stores the result into the Result: The sum of signed Dest and either Src or -Src (according to Z) is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D +/- S)"
              },
              "Z": {
                "formula": "0 then D = D - S, else D = D + S"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0 or !Z=0) or negated value (if Z=1 or !Z=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUMC",
              "SUMNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Events - Poll": {
        "count": 7,
        "description": "Events - Poll",
        "instructions": {
          "POLLCT1": {
            "mnemonic": "POLLCT1",
            "syntax": "POLLCT1          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000001 000100100",
            "description": "Get CT1 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLSE4": {
            "mnemonic": "POLLSE4",
            "syntax": "POLLSE4          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000111 000100100",
            "description": "Get SE4 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLSE3": {
            "mnemonic": "POLLSE3",
            "syntax": "POLLSE3          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000110 000100100",
            "description": "Get SE3 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLSE2": {
            "mnemonic": "POLLSE2",
            "syntax": "POLLSE2          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000101 000100100",
            "description": "Get SE2 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLSE1": {
            "mnemonic": "POLLSE1",
            "syntax": "POLLSE1          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000100 000100100",
            "description": "Get SE1 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLCT2": {
            "mnemonic": "POLLCT2",
            "syntax": "POLLCT2          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000010 000100100",
            "description": "Get CT2 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "POLLCT3": {
            "mnemonic": "POLLCT3",
            "syntax": "POLLCT3          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000011 000100100",
            "description": "Get CT3 event flag into C/Z, then clear it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear attention flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear attention flag.",
        "instructions": {
          "WAITATN": {
            "mnemonic": "WAITATN",
            "syntax": "WAITATN          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011110 000100100",
            "description": "WAITATN waits for an attention event to occur (unless the event flag is already set), then clears the event flag Result: Wait for attention event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "COGATN",
              "POLLATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Handling Instruction - Get the attention of one or more other cogs.": {
        "count": 1,
        "description": "Event Handling Instruction - Get the attention of one or more other cogs.",
        "instructions": {
          "COGATN": {
            "mnemonic": "COGATN",
            "syntax": "COGATN  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111111",
            "description": "COGATN strobes the attention signal for one or more cogs. Dest bit positions 7:0 represent cogs 7 through 0; high Result: The attention signal of one or more cogs is strobed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal whose value (lower 8-bit pattern) indicates which cogs to signal."
            ],
            "related": [
              "POLLATN",
              "WAITATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Stop a cog by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Stop a cog by ID.",
        "instructions": {
          "COGSTOP": {
            "mnemonic": "COGSTOP",
            "syntax": "COGSTOP {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000011",
            "description": "COGSTOP terminates the cog identified by Dest[2:0]. In this dormant state, the cog ceases to execute code and Result: Cog indicated by Dest is terminated (stopped).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal indicating (in lowest 3 bits) which cog to stop."
            ],
            "related": [
              "COGINIT",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to low/high according to C or !C.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) output level to low/high according to C or !C.",
        "instructions": {
          "OUTNC": {
            "mnemonic": "OUTNC",
            "syntax": "OUTNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001011",
            "description": "OUTC or OUTNC alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Skip": {
        "count": 1,
        "description": "Branch D - Skip",
        "instructions": {
          "SKIP": {
            "mnemonic": "SKIP",
            "syntax": "SKIP \u00a0\u00a0 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110001",
            "description": "Skip instructions per D. Subsequent instructions 0..31 get cancelled for each '1' bit in D[0]..D[31].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Force signed value to be greater than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force signed value to be greater than or equal to another.",
        "instructions": {
          "FGES": {
            "mnemonic": "FGES",
            "syntax": "FGES    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "FGES sets signed Dest to signed Src if Dest is less than Src. This is also known as a limit minimum function; Result: Signed Dest is set to signed Src if Dest was less than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to limit to a minimum of signed Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose signed value is the lower limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Zero-extend value beyond designated bit.": {
        "count": 1,
        "description": "Math Instruction - Zero-extend value beyond designated bit.",
        "instructions": {
          "ZEROX": {
            "mnemonic": "ZEROX",
            "syntax": "ZEROX   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ZEROX fills the bits of Dest, above the bit indicated by Src[4:0], with zeros; i.e. zero-extending the value. This is C = MSB of result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of result"
              }
            },
            "parameters": [
              "Dest is a register containing the value to zero-extend above bit Src[4:0] and is where the result is written.",
              "Src is a register or 9-bit literal whose value (lower 5 bits) identifies the bit of Dest to zero-extend beyond.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SIGNX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force unsigned value to be greater than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force unsigned value to be greater than or equal to another.",
        "instructions": {
          "FGE": {
            "mnemonic": "FGE",
            "syntax": "FGE     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "FGE sets unsigned Dest to unsigned Src if Dest is less than Src. This is also known as a limit minimum function; Result: Unsigned Dest is set to unsigned Src if Dest was less than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the unsigned value to limit to a minimum of unsigned Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose unsigned value is the lower limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "FLE",
              "FGES",
              "FLES"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Shift bits left, extending the LSB.": {
        "count": 1,
        "description": "Bit Operation Instruction - Shift bits left, extending the LSB.",
        "instructions": {
          "SAL": {
            "mnemonic": "SAL",
            "syntax": "SAL     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SAL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to that of the original Dest[0]. Result: The bits of Dest are shifted left by Src bits, extending Dest[0] into new rightmost bits.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to arithmetically left shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to arithmetically shift left.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Lookup Table": {
        "count": 3,
        "description": "Lookup Table",
        "instructions": {
          "WRLUT": {
            "mnemonic": "WRLUT",
            "syntax": "WRLUT   {#}D,{#}S/P",
            "encoding": "EEEE 1100001 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Write D to LUT address {#}S/PTRx.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RDLUT": {
            "mnemonic": "RDLUT",
            "syntax": "RDLUT   D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "C = MSB of data.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of data"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETLUTS": {
            "mnemonic": "SETLUTS",
            "syntax": "SETLUTS {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110111",
            "description": "If D[0] = 1 then enable LUT sharing, where LUT writes within the adjacent odd/even companion cog are copied to this cog's LUT.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "I/O Pin Instruction - Test pin and either store, AND, OR, or XOR the result or inverse result into C/Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Test pin and either store, AND, OR, or XOR the result or inverse result into C/Z.",
        "instructions": {
          "TESTPN": {
            "mnemonic": "TESTPN",
            "syntax": "TESTPN  {#}D           WC/WZ",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111",
            "description": "TESTP or TESTPN reads the state (0/1) of the I/O pin designated by Dest, possibly inverts that result, and either Result: The state of the I/O pin described by Dest is read, possibly inverted, and either stored as-is, or bitwise ANDed, ORed, or XORed into C or Z. Z = C/Z XOR !IN[D[5:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR !IN[D[5:0]]",
                "when": "IN[D[5:0]]"
              }
            },
            "parameters": [
              "Dest is the register or 6-bit literal whose value identifies the I/O pin to test.",
              "WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C or Z flag."
            ],
            "related": [
              "TESTB",
              "TESTBN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch Repeat": {
        "count": 1,
        "description": "Branch Repeat",
        "instructions": {
          "REP": {
            "mnemonic": "REP",
            "syntax": "REP     {#}D,{#}S",
            "encoding": "EEEE 1100110 1LI DDDDDDDDD SSSSSSSSS",
            "description": "S = 0, repeat instructions infinitely.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Add two unsigned extended values.": {
        "count": 1,
        "description": "Math Instruction - Add two unsigned extended values.",
        "instructions": {
          "ADDX": {
            "mnemonic": "ADDX",
            "syntax": "ADDX    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ADDX sums the unsigned values of Dest and Src plus C together and stores the result into the Dest register. The Result: Sum of unsigned Src plus C and unsigned Dest is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "carry of (D + S + C)"
              },
              "Z": {
                "formula": "Z AND (result == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to add Src pluc C to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ADD",
              "ADDSX",
              "SUBX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one unsigned value from another (in reverse order to SUB).": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned value from another (in reverse order to SUB).",
        "instructions": {
          "SUBR": {
            "mnemonic": "SUBR",
            "syntax": "SUBR    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUBR subtracts the unsigned Dest from the unsigned Src and stores the result into the Dest register. This is the Result: Difference of unsigned Src and unsigned Dest is stored in Dest and optionally the C and Z flags are updated to the borrow and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (S - D)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to subtract from Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted by Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUB"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Increment value and jump if zero or not zero.": {
        "count": 1,
        "description": "Flow Control Instruction - Increment value and jump if zero or not zero.",
        "instructions": {
          "IJNZ": {
            "mnemonic": "IJNZ",
            "syntax": "IJNZ    D,{#}S",
            "encoding": "EEEE 1011100 01I DDDDDDDDD SSSSSSSSS",
            "description": "IJZ or IJNZ increments the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is incremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is incremented and tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Events - Wait": {
        "count": 7,
        "description": "Events - Wait",
        "instructions": {
          "WAITSE1": {
            "mnemonic": "WAITSE1",
            "syntax": "WAITSE1          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010100 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITCT3": {
            "mnemonic": "WAITCT3",
            "syntax": "WAITCT3          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010011 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITCT2": {
            "mnemonic": "WAITCT2",
            "syntax": "WAITCT2          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010010 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITCT1": {
            "mnemonic": "WAITCT1",
            "syntax": "WAITCT1          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010001 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITSE4": {
            "mnemonic": "WAITSE4",
            "syntax": "WAITSE4          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010111 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITSE2": {
            "mnemonic": "WAITSE2",
            "syntax": "WAITSE2          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010101 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WAITSE3": {
            "mnemonic": "WAITSE3",
            "syntax": "WAITSE3          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010110 000100100",
            "description": "Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Interrupt Instruction - Prevent further interrupts.": {
        "count": 1,
        "description": "Interrupt Instruction - Prevent further interrupts.",
        "instructions": {
          "STALLI": {
            "mnemonic": "STALLI",
            "syntax": "STALLI",
            "encoding": "EEEE 1101011 000 000100001 000100100",
            "description": "STALLI disables interrupt branching. STALLI is the complement of the ALLOWI instruction\u2014 both are used to Result: All future interrupts are disallowed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [
              "ALLOWI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub RAM - Write": {
        "count": 6,
        "description": "Hub RAM - Write",
        "instructions": {
          "PUSHA": {
            "mnemonic": "PUSHA",
            "syntax": "PUSHA   {#}D",
            "encoding": "EEEE 1100011 0L1 DDDDDDDDD 101100001",
            "description": "Write long in D[31:0] to hub address PTRA++.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WMLONG_": {
            "mnemonic": "WMLONG_",
            "syntax": "WMLONG_ D,S/#/PTRA/PTRB",
            "encoding": "TBD",
            "description": "Write memory long (alternate form). Writes long data to hub memory with specific addressing mode.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "WMLONG_ D,S/#/PTRA/PTRB",
              "encoding": {
                "bits": 32,
                "opcode": 335,
                "effects": 0,
                "operandFormat": 15,
                "rawValue": 31055
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          },
          "WRWORD": {
            "mnemonic": "WRWORD",
            "syntax": "WRWORD  {#}D,{#}S/P",
            "encoding": "EEEE 1100010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Write word in D[15:0] to hub address {#}S/PTRx.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WRBYTE": {
            "mnemonic": "WRBYTE",
            "syntax": "WRBYTE  {#}D,{#}S/P",
            "encoding": "EEEE 1100010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Write byte in D[7:0] to hub address {#}S/PTRx.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WMLONG": {
            "mnemonic": "WMLONG",
            "syntax": "WMLONG  D,{#}S/P",
            "encoding": "EEEE 1010011 11I DDDDDDDDD SSSSSSSSS",
            "description": "Write only non-$00 bytes in D[31:0] to hub address {#}S/PTRx. Prior SETQ/SETQ2 invokes cog/LUT block transfer.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "PUSHB": {
            "mnemonic": "PUSHB",
            "syntax": "PUSHB   {#}D",
            "encoding": "EEEE 1100011 0L1 DDDDDDDDD 111100001",
            "description": "Write long in D[31:0] to hub address PTRB++.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Hub FIFO - New Read": {
        "count": 1,
        "description": "Hub FIFO - New Read",
        "instructions": {
          "RDFAST": {
            "mnemonic": "RDFAST",
            "syntax": "RDFAST  {#}D,{#}S",
            "encoding": "EEEE 1100011 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Begin new fast hub read via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units\n(0 = max), S[19:0] = block start address.\n\nKey features:\n- Automatic sequential reading from HUB\n- Background FIFO refill\n- Perfect for streaming data processing\n- Essential for checksum/CRC calculations\n- Used with RFBYTE/RFWORD/RFLONG instructions\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent BITxxx instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent BITxxx instruction.",
        "instructions": {
          "ALTB": {
            "mnemonic": "ALTB",
            "syntax": "ALTB    D,{#}S",
            "encoding": "EEEE 1001100 111 DDDDDDDDD 000000000",
            "description": "ALTB should be followed by a BITxxx instruction\u2014 it modifies the BITxxx instruction's Dest value, enabling code Result: The next instruction's pipelined Dest value is altered to be (Src + Dest[13:5]) & $1FF, or just Dest[13:5] for syntax 2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D1"
              }
            },
            "parameters": [
              "Dest is the register whose 14-bit value is the index, or the full bit address, for the BITxxx instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[13:5]) for BITxxx) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Adjust signed value by other C-negated or !C-negated value.": {
        "count": 1,
        "description": "Math Instruction - Adjust signed value by other C-negated or !C-negated value.",
        "instructions": {
          "SUMNC": {
            "mnemonic": "SUMNC",
            "syntax": "SUMNC   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUMC or SUMNC adjusts the signed Dest value by Src or -Src (depending on C or !C) and stores the result into the Result: The sum of signed Dest and either Src or -Src (according to C) is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "0 then D = D - S, else D = D + S"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if C=0 or !C=0) or negated value (if C=1 or !C=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUMZ",
              "SUMNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Get current cog\u2019s ID or any cog's status by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Get current cog\u2019s ID or any cog's status by ID.",
        "instructions": {
          "COGID": {
            "mnemonic": "COGID",
            "syntax": "COGID   {#}D            {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000001",
            "description": "COGID writes the current cog's ID into Dest (if Dest is a register and WC is omitted) or sets/clears the C flag Result: Current cog's ID is written to Dest or C is set (1) or cleared (0) if the Dest cog is running or stopped. C = 1 if on.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if on"
              }
            },
            "parameters": [
              "Dest is the register where the current cog's ID will be written, or is the register or 9-bit literal whose value (lower 3-bits) indicates which cog to get the status for.",
              "WC is an optional effect to update the C flag with the Dest cog's running status."
            ],
            "related": [
              "COGINIT",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Augmentation Instruction - Augment next literal Dest to 32-bits.": {
        "count": 1,
        "description": "Augmentation Instruction - Augment next literal Dest to 32-bits.",
        "instructions": {
          "AUGD": {
            "mnemonic": "AUGD",
            "syntax": "AUGD",
            "encoding": "EEEE 11111nn nnn nnnnnnnnn nnnnnnnnn",
            "description": "AUGD is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits Result: The 23-bit value formed from Dest is queued to prefix the next literal Dest occurrence (#Dest) to form a 32-bit literal for that instruction; interrupts are also temporarily disabled..",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a 32-bit literal whose upper 23 bits are prepended to the next literal Dest occurrence."
            ],
            "related": [
              "AUGS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to low/high according to Z or !Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) output level to low/high according to Z or !Z.",
        "instructions": {
          "OUTNZ": {
            "mnemonic": "OUTNZ",
            "syntax": "OUTNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001101",
            "description": "OUTZ or OUTNZ alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a byte left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a byte left into a value.",
        "instructions": {
          "ROLBYTE": {
            "mnemonic": "ROLBYTE",
            "syntax": "ROLBYTE D,{#}S,#N",
            "encoding": "EEEE 1001000 000 DDDDDDDDD 000000000",
            "description": "ROLBYTE reads the byte identified by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB Result: Byte Num (0\u20133) of Src, or a byte from a source described by prior ALTGB instruction, is rotated left into Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the byte into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target byte to read.",
              "Num is a 2-bit literal identifying the nibble ID (0\u20133) of Src to read."
            ],
            "related": [
              "ALTGB",
              "ROLNIB",
              "ROLWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-empty event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-empty event flag.",
        "instructions": {
          "WAITXMT": {
            "mnemonic": "WAITXMT",
            "syntax": "WAITXMT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011010 000100100",
            "description": "WAITXMT waits for a streamer-empty event to occur (unless the event flag is already set), then clears the event Result: Wait for streamer-empty event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXMT",
              "JXMT",
              "JNXMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test D, or bitwise AND D with S, to affect flags.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test D, or bitwise AND D with S, to affect flags.",
        "instructions": {
          "TEST": {
            "mnemonic": "TEST",
            "syntax": "TEST    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111110 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "TEST determines the parity (number of high (1) bits) and the zero or non-zero state of Dest, or of Dest bitwise Result: The parity and zero-state of Dest, or of Dest bitwise ANDed with Src, is stored in the C and Z flags. C = parity of (D & S).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of (D & S)"
              },
              "Z": {
                "formula": "((D & S) == 0)"
              }
            },
            "parameters": [
              "Dest is the register whose value will be tested.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is ANDed with Dest.",
              "WC, WZ, and WCZ are optional effects to update flags."
            ],
            "related": [
              "TESTN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if interrupt-occurred event flag is set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if interrupt-occurred event flag is set or clear.",
        "instructions": {
          "JNINT": {
            "mnemonic": "JNINT",
            "syntax": "JNINT   {#}S",
            "encoding": "EEEE 1011110 01I 000010000 SSSSSSSSS",
            "description": "JINT or JNINT checks the cog's interrupt-occurred flag and jumps to the address described by Src if the flag is Result: If interrupt-occurred event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) low/high according to C or !C.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set bit(s) low/high according to C or !C.",
        "instructions": {
          "BITNC": {
            "mnemonic": "BITNC",
            "syntax": "BITNC   D,{#}S         {WCZ}",
            "encoding": "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITC or BITNC alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the C flag. All other Result: Dest bit(s) described by Src are set to C or !C; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - Write": {
        "count": 3,
        "description": "Hub FIFO - Write",
        "instructions": {
          "WFBYTE": {
            "mnemonic": "WFBYTE",
            "syntax": "WFBYTE  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010101",
            "description": "Used after WRFAST. Write byte in D[7:0] into FIFO.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WFWORD": {
            "mnemonic": "WFWORD",
            "syntax": "WFWORD  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010110",
            "description": "Used after WRFAST. Write word in D[15:0] into FIFO.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "WFLONG": {
            "mnemonic": "WFLONG",
            "syntax": "WFLONG  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010111",
            "description": "Used after WRFAST. Write long in D[31:0] into FIFO.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "CORDIC Solver": {
        "count": 9,
        "description": "CORDIC Solver",
        "instructions": {
          "QVECTOR": {
            "mnemonic": "QVECTOR",
            "syntax": "QVECTOR {#}D,{#}S",
            "encoding": "EEEE 1101010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Convert cartesian coordinates (X, Y) to polar coordinates (length, angle). Takes X coordinate in D and Y coordinate in S as 32-bit signed values. Results retrieved via GETQX (length) and GETQY (angle) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QFRAC": {
            "mnemonic": "QFRAC",
            "syntax": "QFRAC   {#}D,{#}S",
            "encoding": "EEEE 1101001 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Perform 64\u00f732 unsigned fractional division with D as upper 32 bits. Numerator formed from {D, SETQ value or 32'b0}, divided by S. Results retrieved via GETQX (quotient) and GETQY (remainder) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QLOG": {
            "mnemonic": "QLOG",
            "syntax": "QLOG    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000001110",
            "description": "Convert 32-bit unsigned integer to 5:27-bit logarithm format. Takes unsigned integer in D operand and produces logarithm with 5-bit whole exponent and 27-bit fractional exponent. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "GETQX": {
            "mnemonic": "GETQX",
            "syntax": "GETQX   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011000",
            "description": "C = X[31].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "X[31]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "GETQY": {
            "mnemonic": "GETQY",
            "syntax": "GETQY   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011001",
            "description": "C = Y[31].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "Y[31]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "QEXP": {
            "mnemonic": "QEXP",
            "syntax": "QEXP    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000001111",
            "description": "Convert 5:27-bit logarithm to 32-bit unsigned integer. Takes logarithm in 5:27 format (5-bit whole exponent, 27-bit fractional exponent) in D operand. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QDIV": {
            "mnemonic": "QDIV",
            "syntax": "QDIV    {#}D,{#}S",
            "encoding": "EEEE 1101000 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Perform 64\u00f732 unsigned division with 32-bit quotient and remainder. Numerator formed from {SETQ value or 32'b0, D}, divided by S. Results retrieved via GETQX (quotient) and GETQY (remainder) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QROTATE": {
            "mnemonic": "QROTATE",
            "syntax": "QROTATE {#}D,{#}S",
            "encoding": "EEEE 1101010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Rotate a 32-bit signed (X, Y) point around origin (0, 0) by a specified angle. X coordinate comes from D operand, Y coordinate from SETQ value (or 0 if SETQ not used). Angle specified in S operand. Results retrieved via GETQX (X) and GETQY (Y) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QSQRT": {
            "mnemonic": "QSQRT",
            "syntax": "QSQRT   {#}D,{#}S",
            "encoding": "EEEE 1101001 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Calculate square root of 64-bit unsigned number formed from {S, D}. Takes upper 32 bits from S operand and lower 32 bits from D operand. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Pixel Mixer": {
        "count": 5,
        "description": "Pixel Mixer",
        "instructions": {
          "MULPIX": {
            "mnemonic": "MULPIX",
            "syntax": "MULPIX  D,{#}S",
            "encoding": "EEEE 1010010 01I DDDDDDDDD SSSSSSSSS",
            "description": "F = 1.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETPIX": {
            "mnemonic": "SETPIX",
            "syntax": "SETPIX  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111110",
            "description": "Set MIXPIX mode to D[5:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETPIV": {
            "mnemonic": "SETPIV",
            "syntax": "SETPIV  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111101",
            "description": "Set BLNPIX/MIXPIX blend factor to D[7:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "BLNPIX": {
            "mnemonic": "BLNPIX",
            "syntax": "BLNPIX  D,{#}S",
            "encoding": "EEEE 1010010 10I DDDDDDDDD SSSSSSSSS",
            "description": "Alpha-blend bytes of S into bytes of D, using SETPIV value.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "MIXPIX": {
            "mnemonic": "MIXPIX",
            "syntax": "MIXPIX  D,{#}S",
            "encoding": "EEEE 1010010 11I DDDDDDDDD SSSSSSSSS",
            "description": "Mix bytes of S into bytes of D, using SETPIX and SETPIV values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Subtract one unsigned value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned value from another.",
        "instructions": {
          "SUB": {
            "mnemonic": "SUB",
            "syntax": "SUB     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUB subtracts the unsigned Src from the unsigned Dest and stores the result into the Dest register. Result: Difference of unsigned Dest and unsigned Src is stored in Dest and optionally the C and Z flags are updated to the borrow and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - S)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUBX",
              "SUBS",
              "SUBSX",
              "ADD",
              "SUBR"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Substitute next instruction's field values from template, per configuration.": {
        "count": 1,
        "description": "Indirection Instruction - Substitute next instruction's field values from template, per configuration.",
        "instructions": {
          "ALTI": {
            "mnemonic": "ALTI",
            "syntax": "ALTI    D,{#}S",
            "encoding": "EEEE 1001101 001 DDDDDDDDD 101100100",
            "description": "ALTI substitutes fields from Dest for one or more of the next instruction's pipelined Dest, Src, Result, Instr, FX, Result: The next instruction's pipelined field value values are substituted from the Dest template, and Dest is modified per Src configuration (syntax 1), or the entire Dest opcode (instruction) is executed in place of the next instruction (syntax 2).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value contains one or more of the next instruction's field substitutes or an entire 32-bit opcode for full substitution.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value describes the substitutions and Dest modifications to perform."
            ],
            "related": [
              "SETD",
              "SETS",
              "SETR",
              "ALTD",
              "ALTS",
              "ALTR"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) high (1) or low (0).": {
        "count": 1,
        "description": "Bit Operation Instruction - Set bit(s) high (1) or low (0).",
        "instructions": {
          "BITL": {
            "mnemonic": "BITL",
            "syntax": "BITL    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITH or BITL alters the Dest bit(s) designated by Src to be high (1) or low (0). All other bits are left unchanged. Result: Dest bit(s) described by Src are set high (1) or low (0); the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set high or low.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Events - Configuration": {
        "count": 8,
        "description": "Events - Configuration",
        "instructions": {
          "ADDCT1": {
            "mnemonic": "ADDCT1",
            "syntax": "ADDCT1  D,{#}S",
            "encoding": "EEEE 1010011 00I DDDDDDDDD SSSSSSSSS",
            "description": "T = D + S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETSE1": {
            "mnemonic": "SETSE1",
            "syntax": "SETSE1  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100000",
            "description": "Set SE1 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETPAT": {
            "mnemonic": "SETPAT",
            "syntax": "SETPAT  {#}D,{#}S",
            "encoding": "EEEE 1011111 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set pin pattern for PAT event. C selects INA/INB, Z selects =/!=, D provides mask value, S provides match value.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "ADDCT3": {
            "mnemonic": "ADDCT3",
            "syntax": "ADDCT3  D,{#}S",
            "encoding": "EEEE 1010011 10I DDDDDDDDD SSSSSSSSS",
            "description": "T = D + S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETSE2": {
            "mnemonic": "SETSE2",
            "syntax": "SETSE2  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100001",
            "description": "Set SE2 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETSE3": {
            "mnemonic": "SETSE3",
            "syntax": "SETSE3  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100010",
            "description": "Set SE3 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "ADDCT2": {
            "mnemonic": "ADDCT2",
            "syntax": "ADDCT2  D,{#}S",
            "encoding": "EEEE 1010011 01I DDDDDDDDD SSSSSSSSS",
            "description": "T = D + S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SETSE4": {
            "mnemonic": "SETSE4",
            "syntax": "SETSE4  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100011",
            "description": "Set SE4 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Branch S - Mod & Test": {
        "count": 3,
        "description": "Branch S - Mod & Test",
        "instructions": {
          "DJF": {
            "mnemonic": "DJF",
            "syntax": "DJF     D,{#}S",
            "encoding": "EEEE 1011011 10I DDDDDDDDD SSSSSSSSS",
            "description": "Decrement D and jump to S** if result is $FFFF_FFFF.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "IJZ": {
            "mnemonic": "IJZ",
            "syntax": "IJZ     D,{#}S",
            "encoding": "EEEE 1011100 00I DDDDDDDDD SSSSSSSSS",
            "description": "Increment D and jump to S** if result is zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "DJZ": {
            "mnemonic": "DJZ",
            "syntax": "DJZ     D,{#}S",
            "encoding": "EEEE 1011011 00I DDDDDDDDD SSSSSSSSS",
            "description": "Decrement D and jump to S** if result is zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context in the Hub long at PTRA++ or PTRB++.": {
        "count": 1,
        "description": "Flow Control Instruction - Call a subroutine; store return context in the Hub long at PTRA++ or PTRB++.",
        "instructions": {
          "CALLB": {
            "mnemonic": "CALLB",
            "syntax": "CALLB   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101111 RAA AAAAAAAAA AAAAAAAAA",
            "description": "Write current C and Z flags and address of the next instruction into the 4-byte Hub RAM location at PTRA or PTRB, increment pointer, set PC to new relative or absolute address, and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.",
            "timing": {
              "cycles": 5,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.",
              "WC, WZ, or WCZ are optional effects to update the flags from Dest's upper bit states."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Write Z or not Z to register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Write Z or not Z to register.",
        "instructions": {
          "WRNZ": {
            "mnemonic": "WRNZ",
            "syntax": "WRNZ    D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101111",
            "description": "WRZ or WRNZ writes the state or inverse state of Z (0 or 1) to Dest. Result: Dest value is replaced with state of Z or !Z.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value will be replaced with the state of Z or !Z."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and toggle to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and toggle to the opposite output level.",
        "instructions": {
          "DRVNOT": {
            "mnemonic": "DRVNOT",
            "syntax": "DRVNOT  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011111",
            "description": "DRVNOT sets the I/O pin(s) designated by Dest to the output direction and to their opposite output level(s); i.e. Result: The I/O pins described by Dest are set to the output direction and to their opposite output level(s); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to the output direction and toggle to opposite output levels.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub Control - Locks": {
        "count": 4,
        "description": "Hub Control - Locks",
        "instructions": {
          "LOCKREL": {
            "mnemonic": "LOCKREL",
            "syntax": "LOCKREL {#}D            {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000111",
            "description": "Release LOCK D[3:0]. If D is a register and WC, get current/last cog id of LOCK owner into\nD and LOCK status into C.\n\nKey features:\n- Releases previously acquired lock\n- Optional owner identification with WC\n- Essential for proper resource cleanup\n- Must balance with LOCKTRY calls\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "LOCKRET": {
            "mnemonic": "LOCKRET",
            "syntax": "LOCKRET {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000101",
            "description": "Return LOCK D[3:0] for reallocation.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "LOCKTRY": {
            "mnemonic": "LOCKTRY",
            "syntax": "LOCKTRY {#}D            {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000110",
            "description": "Try to acquire lock D[3:0]. C = 1 if got LOCK.\n\nP2 provides 16 hardware locks (0-15) for inter-COG synchronization:\n- Atomic test-and-set operation\n- Non-blocking (returns immediately)\n- Perfect for resource protection\n- Essential for multi-COG coordination\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if got LOCK"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "LOCKNEW": {
            "mnemonic": "LOCKNEW",
            "syntax": "LOCKNEW D               {WC}",
            "encoding": "EEEE 1101011 C00 DDDDDDDDD 000000100",
            "description": "C = 1 if no LOCK available.",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if no LOCK available"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-finished event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-finished event flag.",
        "instructions": {
          "WAITXFI": {
            "mnemonic": "WAITXFI",
            "syntax": "WAITXFI          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011011 000100100",
            "description": "WAITXFI waits for a streamer-finished event to occur (unless the event flag is already set), then clears the event Result: Wait for streamer-finished event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXFI",
              "JXFI",
              "JNXFI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - New Write": {
        "count": 1,
        "description": "Hub FIFO - New Write",
        "instructions": {
          "WRFAST": {
            "mnemonic": "WRFAST",
            "syntax": "WRFAST  {#}D,{#}S",
            "encoding": "EEEE 1100100 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Begin new fast hub write via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
            "timing": {
              "cycles": 2,
              "type": "conditional"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Add two signed values.": {
        "count": 1,
        "description": "Math Instruction - Add two signed values.",
        "instructions": {
          "ADDS": {
            "mnemonic": "ADDS",
            "syntax": "ADDS    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ADDS sums the two signed values of Dest and Src together and stores the result into the Dest register. If Src is a Result: Sum of signed Src and signed Dest is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D + S)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ADD",
              "ADDX",
              "ADDSX",
              "SUBS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Decrement value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).": {
        "count": 1,
        "description": "Flow Control Instruction - Decrement value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).",
        "instructions": {
          "DJNF": {
            "mnemonic": "DJNF",
            "syntax": "DJNF    D,{#}S",
            "encoding": "EEEE 1011011 11I DDDDDDDDD SSSSSSSSS",
            "description": "DJF or DJNF decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is decremented and tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values (in reverse order to CMP).": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values (in reverse order to CMP).",
        "instructions": {
          "CMPR": {
            "mnemonic": "CMPR",
            "syntax": "CMPR    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMP compares the unsigned values of Dest and Src (by subtracting Dest from Src) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (S - D)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest."
            ],
            "related": [
              "CMP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear FIFO-interface-block-wrap event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear FIFO-interface-block-wrap event flag.",
        "instructions": {
          "WAITFBW": {
            "mnemonic": "WAITFBW",
            "syntax": "WAITFBW          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011001 000100100",
            "description": "WAITFBW waits for a FIFO-interface-block-wrap event to occur (unless the event flag is already set), then clears Result: Wait for FIFO-interface-block-wrap event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "RDFAST",
              "WRFAST",
              "FBLOCK",
              "POLLFBW",
              "JFBW",
              "JNFBW"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Resume": {
        "count": 4,
        "description": "Branch S - Resume",
        "instructions": {
          "RESI1": {
            "mnemonic": "RESI1",
            "syntax": "RESI1",
            "encoding": "EEEE 1011001 110 111110100 111110101",
            "description": "Resume from INT1. (CALLD $1F4,$1F5 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RESI0": {
            "mnemonic": "RESI0",
            "syntax": "RESI0",
            "encoding": "EEEE 1011001 110 111111110 111111111",
            "description": "Resume from INT0. (CALLD $1FE,$1FF WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RESI3": {
            "mnemonic": "RESI3",
            "syntax": "RESI3",
            "encoding": "EEEE 1011001 110 111110000 111110001",
            "description": "Resume from INT3. (CALLD $1F0,$1F1 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RESI2": {
            "mnemonic": "RESI2",
            "syntax": "RESI2",
            "encoding": "EEEE 1011001 110 111110010 111110011",
            "description": "Resume from INT2. (CALLD $1F2,$1F3 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Decode value (0\u201431) into single-high-bit long.": {
        "count": 1,
        "description": "Bit Operation Instruction - Decode value (0\u201431) into single-high-bit long.",
        "instructions": {
          "DECOD": {
            "mnemonic": "DECOD",
            "syntax": "DECOD   D,{#}S",
            "encoding": "EEEE 1001110 000 DDDDDDDDD DDDDDDDDD",
            "description": "DECOD generates a 32-bit value with just one bit high, corresponding to the Src, or Dest, value (0\u201431) and stores Result: A 32-bit value, with the bit position corresponding to Src, or Dest, value (0\u201431) set high, is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the decoded value and optionally begins by containing the 5-bit bit position value it is requesting (syntax 2)."
            ],
            "related": [
              "ENCOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level high (1) or low (0).": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level high (1) or low (0).",
        "instructions": {
          "DRVL": {
            "mnemonic": "DRVL",
            "syntax": "DRVL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011000",
            "description": "DRVH or DRVL sets the I/O pin(s) designated by Dest to the output direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the output direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate bits left.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate bits left.",
        "instructions": {
          "ROL": {
            "mnemonic": "ROL",
            "syntax": "ROL     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ROL rotates Dest's binary value left by Src places (0\u201331 bits). All MSBs rotated out are moved into the new LSBs. Result: The bits of Dest are rotated left by Src bits; any departing MSBs are moved into LSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate left by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Write C or not C to register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Write C or not C to register.",
        "instructions": {
          "WRNC": {
            "mnemonic": "WRNC",
            "syntax": "WRNC    D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101101",
            "description": "Dest value is replaced with state of C or !C.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value will be replaced with the state of C or !C."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-LUT-RAM-rollover event flag": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-LUT-RAM-rollover event flag",
        "instructions": {
          "WAITXRL": {
            "mnemonic": "WAITXRL",
            "syntax": "WAITXRL          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011101 000100100",
            "description": "WAITXRL waits for a streamer-LUT-RAM-rollover event to occur (unless the event flag is already set), then clears Result: Wait for streamer-LUT-RAM-rollover event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXRL",
              "JXRL",
              "JNXRL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Return": {
        "count": 4,
        "description": "Branch S - Return",
        "instructions": {
          "RETI3": {
            "mnemonic": "RETI3",
            "syntax": "RETI3",
            "encoding": "EEEE 1011001 110 111111111 111110001",
            "description": "Return from INT3. (CALLD $1FF,$1F1 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RETI2": {
            "mnemonic": "RETI2",
            "syntax": "RETI2",
            "encoding": "EEEE 1011001 110 111111111 111110011",
            "description": "Return from INT2. (CALLD $1FF,$1F3 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RETI1": {
            "mnemonic": "RETI1",
            "syntax": "RETI1",
            "encoding": "EEEE 1011001 110 111111111 111110101",
            "description": "Return from INT1. (CALLD $1FF,$1F5 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RETI0": {
            "mnemonic": "RETI0",
            "syntax": "RETI0",
            "encoding": "EEEE 1011001 110 111111111 111111111",
            "description": "Return from INT0. (CALLD $1FF,$1FF WCZ).",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Set discrete bit pairs of a value to non-zero bit pair states of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete bit pairs of a value to non-zero bit pair states of another.",
        "instructions": {
          "MUXNITS": {
            "mnemonic": "MUXNITS",
            "syntax": "MUXNITS D,{#}S",
            "encoding": "EEEE 1001111 00I DDDDDDDDD SSSSSSSSS",
            "description": "MUXNITS copies any non-zero bit pairs from Src into the corresponding bit pairs of Dest and leaves the rest of Result: Dest bit pairs corresponding to non-zero Src bit pairs are set to those bit values; the rest are left as-is.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register whose value will be updated according to Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose non-zero bit pairs will replace the corresponding bit pairs in Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear interrupt-occurred event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear interrupt-occurred event flag.",
        "instructions": {
          "POLLINT": {
            "mnemonic": "POLLINT",
            "syntax": "POLLINT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000000 000100100",
            "description": "POLLINT copies the state of the interrupt-occurred event flag into C and/or Z and then clears the flag (unless it's Result: Interrupt-occurred event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "WAITINT",
              "JINT",
              "JNINT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Divide signed 32-bit integer by power-of-two; a.k.a shift bits right, extending the MSB.": {
        "count": 1,
        "description": "Math Instruction - Divide signed 32-bit integer by power-of-two; a.k.a shift bits right, extending the MSB.",
        "instructions": {
          "SAR": {
            "mnemonic": "SAR",
            "syntax": "SAR     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "The bits of Dest are shifted right by Src bits, extending Dest[31] (the sign bit) into new leftmost bits.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to arithmetically right shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to arithmetically shift right.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SHR",
              "SH"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) low/high according to Z or !Z.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set bit(s) low/high according to Z or !Z.",
        "instructions": {
          "BITNZ": {
            "mnemonic": "BITNZ",
            "syntax": "BITNZ   D,{#}S         {WCZ}",
            "encoding": "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITZ or BITNZ alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the Z flag. All other Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if pin pattern event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if pin pattern event flag set or clear.",
        "instructions": {
          "JNPAT": {
            "mnemonic": "JNPAT",
            "syntax": "JNPAT   {#}S",
            "encoding": "EEEE 1011110 01I 000011000 SSSSSSSSS",
            "description": "JPAT or JNPAT checks the cog's pin-pattern-detected event flag and jumps to the address described by Src if the Result: If pin pattern event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Reverse bits of value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Reverse bits of value.",
        "instructions": {
          "REV": {
            "mnemonic": "REV",
            "syntax": "REV     D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101001",
            "description": "The 32-bit pattern in Dest is reversed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register containing the bit value to reverse."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a nibble left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a nibble left into a value.",
        "instructions": {
          "ROLNIB": {
            "mnemonic": "ROLNIB",
            "syntax": "ROLNIB  D,{#}S,#N",
            "encoding": "EEEE 1000100 000 DDDDDDDDD 000000000",
            "description": "ROLNIB reads the nibble identified by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN Result: Nibble Num (0\u20137) of Src, or a nibble from a source described by prior ALTGN instruction, is rotated left into Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the nibble into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target nibble to read.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Src to read."
            ],
            "related": [
              "ALTGN",
              "ROLBYTE",
              "ROLWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch Return": {
        "count": 3,
        "description": "Branch Return",
        "instructions": {
          "RETB": {
            "mnemonic": "RETB",
            "syntax": "RETB             {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101111",
            "description": "C = L[31], Z = L[30], PC = L[19:0].",
            "timing": {
              "cycles": 11,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "L[31], Z = L[30], PC = L[19:0]"
              },
              "Z": {
                "formula": "L[30], PC = L[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RETA": {
            "mnemonic": "RETA",
            "syntax": "RETA             {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101110",
            "description": "C = L[31], Z = L[30], PC = L[19:0].",
            "timing": {
              "cycles": 11,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "L[31], Z = L[30], PC = L[19:0]"
              },
              "Z": {
                "formula": "L[30], PC = L[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "RET": {
            "mnemonic": "RET",
            "syntax": "RET              {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101101",
            "description": "C = K[31], Z = K[30], PC = K[19:0].",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "K[31], Z = K[30], PC = K[19:0]"
              },
              "Z": {
                "formula": "K[30], PC = K[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Subtract one signed extended value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one signed extended value from another.",
        "instructions": {
          "SUBSX": {
            "mnemonic": "SUBSX",
            "syntax": "SUBSX   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUBSX subtracts the signed value of Src plus C from the signed Dest and stores the result into the Dest register. Result: Difference of signed Dest and signed Src (plus C) is stored in Dest and optionally the C and Z flags are updated to the extended sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (result == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src plus C from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input/output according to Z or !Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input/output according to Z or !Z.",
        "instructions": {
          "DIRNZ": {
            "mnemonic": "DIRNZ",
            "syntax": "DIRNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000101",
            "description": "DIRZ or DIRNZ alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the Z Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to Z or !Z; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRNOT",
              "DIRRND",
              "DIRL",
              "DIRH"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter D field of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter D field of next instruction.",
        "instructions": {
          "ALTD": {
            "mnemonic": "ALTD",
            "syntax": "ALTD    D,{#}S",
            "encoding": "EEEE 1001100 011 DDDDDDDDD 000000000",
            "description": "ALTD modifies the next instruction's Dest value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax Result: The next instruction's pipelined Dest value is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to C.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to C.",
        "instructions": {
          "FLTNC": {
            "mnemonic": "FLTNC",
            "syntax": "FLTNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010011",
            "description": "FLTC or FLTNC sets the I/O pin(s) designated by Dest to the input direction and to a low/high output level Result: The I/O pins described by Dest are set to the input direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub Control - Multi": {
        "count": 1,
        "description": "Hub Control - Multi",
        "instructions": {
          "HUBSET": {
            "mnemonic": "HUBSET",
            "syntax": "HUBSET  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000000",
            "description": "Set hub configuration to D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "I/O Pin Instruction - Toggle pin(s) to the opposite direction.": {
        "count": 1,
        "description": "I/O Pin Instruction - Toggle pin(s) to the opposite direction.",
        "instructions": {
          "DIRNOT": {
            "mnemonic": "DIRNOT",
            "syntax": "DIRNOT  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111",
            "description": "DIRNOT alters the direction register's bit(s) designated by Dest to their inverse state. All other bits are left Result: The I/O pin direction bit(s), described by Dest, are toggled to their opposite state(s); the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to toggle to the opposite direction.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRRND",
              "DIRL",
              "DIRH",
              "DIRC",
              "DIRNC",
              "DIRZ",
              "DIRNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "System Control Instruction": {
        "count": 2,
        "description": "System Control Instruction",
        "instructions": {
          "DEBUG": {
            "mnemonic": "DEBUG",
            "syntax": "DEBUG",
            "encoding": "TBD",
            "description": "Debug instruction. Provides debugging functionality during program execution.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "DEBUG",
              "encoding": {
                "bits": 32,
                "opcode": 54,
                "effects": 0,
                "operandFormat": 37,
                "rawValue": 75830
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_debug",
                "pattern": "",
                "description": "Debug instruction - no operands",
                "valueType": 37
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          },
          "ASMCLK": {
            "mnemonic": "ASMCLK",
            "syntax": "ASMCLK",
            "encoding": "TBD",
            "description": "Assembly clock instruction. Controls assembly-time clock operations.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "ASMCLK",
              "encoding": {
                "bits": 32,
                "opcode": 0,
                "effects": 0,
                "operandFormat": 35,
                "rawValue": 71680
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_asmclk",
                "pattern": "",
                "description": "Assembly clock instruction",
                "valueType": 35
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Compare two signed values.": {
        "count": 1,
        "description": "Math Instruction - Compare two signed values.",
        "instructions": {
          "CMPS": {
            "mnemonic": "CMPS",
            "syntax": "CMPS    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMPS compares the signed values of Dest and Src (by subtracting Src from Dest) and optionally setting the C and Result: Greater/lesser and equality status is optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - S)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one unsigned extended value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned extended value from another.",
        "instructions": {
          "SUBX": {
            "mnemonic": "SUBX",
            "syntax": "SUBX    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUBX subtracts the unsigned value of Src plus C from the unsigned Dest and stores the result into the Dest Result: Difference of unsigned Dest and unsigned Src (plus C) is stored in Dest and optionally the C and Z flags are updated to the extended borrow and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (result == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src plus C from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUB",
              "SUBSX",
              "ADDX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) random low/high.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set bit(s) random low/high.",
        "instructions": {
          "BITRND": {
            "mnemonic": "BITRND",
            "syntax": "BITRND  D,{#}S         {WCZ}",
            "encoding": "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITRND alters the Dest bit(s) designated by Src to each be an independent random low and high value, based on Result: Dest bit(s) described by Src are each set randomly low or high; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set randomly low or high.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to Z.",
        "instructions": {
          "FLTNZ": {
            "mnemonic": "FLTNZ",
            "syntax": "FLTNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010101",
            "description": "The I/O pins described by Dest are set to the input direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry and zero flags right into value (2-bit rotate right).": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry and zero flags right into value (2-bit rotate right).",
        "instructions": {
          "RCZR": {
            "mnemonic": "RCZR",
            "syntax": "RCZR    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101010",
            "description": "RCZR shifts Dest's binary value right by two places and sets Dest[31] to C and Dest[30] to Z. Result: The bits of Dest are shifted right by two places and C and Z are inserted as new MSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "D[1], Z = D[0]",
                "when": "D"
              },
              "Z": {
                "formula": "D[0]",
                "when": "D[1]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate the carry and zero flags right into.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a value into a register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a value into a register.",
        "instructions": {
          "MOV": {
            "mnemonic": "MOV",
            "syntax": "MOV     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Mov stores the Src value into Dest. Result: The Src value is stored in Dest and optionally flags are updated with the sign bit and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "S[31]"
              }
            },
            "parameters": [
              "Dest is the register to receive the Src value.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "MOV D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 192,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1728
              },
              "category": "Data Movement",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Toggle pin(s) to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Toggle pin(s) to the opposite output level.",
        "instructions": {
          "OUTNOT": {
            "mnemonic": "OUTNOT",
            "syntax": "OUTNOT  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001111",
            "description": "OUTNOT alters the output level register's bit(s) designated by Dest to their inverse state. All other bits are left Result: The I/O pin output level bit(s), described by Dest, are toggled to their opposite state(s); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to toggle to the opposite output level.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO": {
        "count": 1,
        "description": "Hub FIFO",
        "instructions": {
          "GETPTR": {
            "mnemonic": "GETPTR",
            "syntax": "GETPTR  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 000110100",
            "description": "Get current FIFO hub pointer into D.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Bitwise XOR a value with another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise XOR a value with another.",
        "instructions": {
          "XOR": {
            "mnemonic": "XOR",
            "syntax": "XOR     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "XOR performs a bitwise XOR of the value in Src into that of Dest. Result: Dest XOR Src is stored in Dest and flags are optionally updated with parity and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register containing the value to bitwise XOR with Src and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be bitwise XORed into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Interrupt Instruction - Trigger breakpoint in current cog.": {
        "count": 1,
        "description": "Interrupt Instruction - Trigger breakpoint in current cog.",
        "instructions": {
          "BRK": {
            "mnemonic": "BRK",
            "syntax": "BRK     {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110110",
            "description": "BRK triggers a breakpoint in the current cog and either defines a breakpoint code or the\nnext breakpoint Result: If debug interrupts are enabled, a debug interrupt is triggered in the current\ncog and Dest's value becomes the debug code or the next debug condition.\n\nKey uses:\n- Software breakpoints for debugging\n- Conditional debug triggers\n- Communication with debug monitor\n- Assertion failures and error handling\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "Code/Cond.1"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and to an output level of high (1) or low (0).": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and to an output level of high (1) or low (0).",
        "instructions": {
          "FLTL": {
            "mnemonic": "FLTL",
            "syntax": "FLTL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010000",
            "description": "FLTH or FLTL sets the I/O pin(s) designated by Dest to the input direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the input direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Get the absolute value of a number.": {
        "count": 1,
        "description": "Math Instruction - Get the absolute value of a number.",
        "instructions": {
          "ABS": {
            "mnemonic": "ABS",
            "syntax": "ABS     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110010 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "ABS determines the absolute value of Src or Dest and writes the result into Dest. Result: Absolute Src (or Dest) value is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "D[31]"
              }
            },
            "parameters": [
              "Dest is the register in which to write the absolute value of Dest or Src.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose absolute value is written to Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "NEG"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input/output according to C or !C.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input/output according to C or !C.",
        "instructions": {
          "DIRNC": {
            "mnemonic": "DIRNC",
            "syntax": "DIRNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000011",
            "description": "DIRC or DIRNC alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the C Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to C or !C; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRZ",
              "DIRNZ",
              "DIRL",
              "DIRH",
              "DIRNOT",
              "DIRRND"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Interrupt Instruction - Allow interrupts.": {
        "count": 1,
        "description": "Interrupt Instruction - Allow interrupts.",
        "instructions": {
          "ALLOWI": {
            "mnemonic": "ALLOWI",
            "syntax": "ALLOWI",
            "encoding": "EEEE 1101011 000 000100000 000100100",
            "description": "ALLOWI re-enables interrupt branching; the default on cog start. ALLOWI is the complement of the STALLI Result: Any stalled and future interrupts are allowed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [
              "STALLI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Create signed 18-bit scale value for next instruction's S value.": {
        "count": 1,
        "description": "Math Instruction - Create signed 18-bit scale value for next instruction's S value.",
        "instructions": {
          "SCAS": {
            "mnemonic": "SCAS",
            "syntax": "SCAS    D,{#}S          {WZ}",
            "encoding": "EEEE 1010001 1ZI DDDDDDDDD SSSSSSSSS",
            "description": "SCAS multiplies the lower, signed 16-bits of each of Dest and Src together, right shifts the 32-bit product by 14 (to Result: The upper 18 bits of the signed product from the 16-bit Dest and Src multiplication is substituted as the next instruction's Src value and optionally the Z flag is updated to the zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the signed 16-bit value to multiply with Src.",
              "Src is a register, 9-bit literal, or signed 16-bit augmented literal whose value is multiplied with Dest."
            ],
            "related": [
              "SCA"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear pin-pattern-detected event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear pin-pattern-detected event flag.",
        "instructions": {
          "POLLPAT": {
            "mnemonic": "POLLPAT",
            "syntax": "POLLPAT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001000 000100100",
            "description": "POLLPAT copies the state of the pin-pattern-detected event flag into C and/or Z and then clears the flag (unless Result: Pin-pattern-detected event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SETPAT",
              "WAITPAT",
              "JPAT",
              "JNPAT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to Z or !Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to Z or !Z.",
        "instructions": {
          "DRVNZ": {
            "mnemonic": "DRVNZ",
            "syntax": "DRVNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011101",
            "description": "DRVZ or DRVNZ sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to C.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to C.",
        "instructions": {
          "NEGC": {
            "mnemonic": "NEGC",
            "syntax": "NEGC    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110100 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "NEGC negates Src (syntax 1) or Dest (syntax 2) if C = 1 and stores the result in the Dest register. If C = 0, the Src Result: The Src or Dest value, possibly negated according to C, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 then D = -D, else D = D"
              }
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if C=0) or negated value (if C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "NEGNC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test D by bitwise ANDing with !S to affect flags only.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test D by bitwise ANDing with !S to affect flags only.",
        "instructions": {
          "TESTN": {
            "mnemonic": "TESTN",
            "syntax": "TESTN   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "TESTN determines the parity (number of high (1) bits) and the zero or non-zero state of Dest bitwise ANDed with Result: The parity and zero-state of Dest bitwise ANDed with !Src is stored in the C and Z flags. C = parity of (D & !S).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of (D & !S)"
              },
              "Z": {
                "formula": "((D & !S) == 0)"
              }
            },
            "parameters": [
              "Dest is the register whose value will be tested.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose inverse value is ANDed with Dest.",
              "WC, WZ, and WCZ are optional effects to update flags."
            ],
            "related": [
              "TEST"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Miscellaneous Instruction - No operation, just elapse two cycles.": {
        "count": 1,
        "description": "Miscellaneous Instruction - No operation, just elapse two cycles.",
        "instructions": {
          "NOP": {
            "mnemonic": "NOP",
            "syntax": "NOP",
            "encoding": "0000 0000000 000 000000000 000000000",
            "description": "NOP simply consumes two clock cycles; no other operation is performed. Result: Two clock cycles are consumed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear attention flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear attention flag.",
        "instructions": {
          "POLLATN": {
            "mnemonic": "POLLATN",
            "syntax": "POLLATN          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001110 000100100",
            "description": "POLLATN copies the state of the attention event flag into C and/or Z and then clears the flag (unless it's being set Result: Attention event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "COGATN",
              "WAITATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instructions - Set discrete bits to Z or !Z": {
        "count": 1,
        "description": "Bit Operation Instructions - Set discrete bits to Z or !Z",
        "instructions": {
          "MUXNZ": {
            "mnemonic": "MUXNZ",
            "syntax": "MUXNZ   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "MUXZ or MUXNZ alters the Dest bit(s) designated by Src (high bits) to equal the state, or inverse state, of the Z flag. Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Flags are optionally updated with parity and zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identifies the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instructions - Set discrete bits to C or !C": {
        "count": 1,
        "description": "Bit Operation Instructions - Set discrete bits to C or !C",
        "instructions": {
          "MUXNC": {
            "mnemonic": "MUXNC",
            "syntax": "MUXNC   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "Dest bit(s) described by Src are set to C or !C; the rest are left as-is. Flags are optionally updated with parity and zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identifies the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Bitwise AND a value with another, or with the NOT of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise AND a value with another, or with the NOT of another.",
        "instructions": {
          "ANDN": {
            "mnemonic": "ANDN",
            "syntax": "ANDN    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "AND or ANDN performs a bitwise AND of the value in Src (or !Src) into that of Dest. Result: Dest AND Src (or Dest AND !Src) is stored in Dest and flags are optionally updated with parity and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register containing the value to bitwise AND with Src (or with !Src) and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (or inverse value) will be bitwise ANDed into Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if attention flag is set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if attention flag is set or clear.",
        "instructions": {
          "JNATN": {
            "mnemonic": "JNATN",
            "syntax": "JNATN   {#}S",
            "encoding": "EEEE 1011110 01I 000011110 SSSSSSSSS",
            "description": "JATN or JNATN checks the cog's attention signal and jumps to the address described by Src if attention is set (in Result: If ATN event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate a value.": {
        "count": 1,
        "description": "Math Instruction - Negate a value.",
        "instructions": {
          "NEG": {
            "mnemonic": "NEG",
            "syntax": "NEG     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110011 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "NEG negates Src (syntax 1) or Dest (syntax 2) and stores the result in the Dest register. The negation flips the Result: The Src or Dest value is negated and stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of result"
              }
            },
            "parameters": [
              "Dest is a register to receive the -Src value (syntax 1), or contains the value to negate (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose negated value is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ABS",
              "NEGC",
              "NEGNC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter Result register address of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter Result register address of next instruction.",
        "instructions": {
          "ALTR": {
            "mnemonic": "ALTR",
            "syntax": "ALTR    D,{#}S",
            "encoding": "EEEE 1001100 001 DDDDDDDDD 000000000",
            "description": "ALTR modifies the next instruction's Result address to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for Result: The next instruction's pipelined Result address (Dest address by default) is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to Z.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to Z.",
        "instructions": {
          "NEGZ": {
            "mnemonic": "NEGZ",
            "syntax": "NEGZ    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0110110 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "NEGZ negates Src (syntax 1) or Dest (syntax 2) if Z = 1 and stores the result in the Dest register. If Z = 0, the Src or Result: The Src or Dest value, possibly negated according to Z, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of result"
              },
              "Z": {
                "formula": "1 then D = -D, else D = D"
              }
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to Z.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0) or negated value (if Z=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "NEGNZ",
              "NEGC",
              "NEGNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Multiply signed 16-bit x 16-bit values.": {
        "count": 1,
        "description": "Math Instruction - Multiply signed 16-bit x 16-bit values.",
        "instructions": {
          "MULS": {
            "mnemonic": "MULS",
            "syntax": "MULS    D,{#}S          {WZ}",
            "encoding": "EEEE 1010000 1ZI DDDDDDDDD SSSSSSSSS",
            "description": "MULS multiplies the signed lower 16-bits of each of Dest and Src together and stores the 32-bit signed product Result: The 32-bit signed product of the signed 16-bit Dest and Src multiplication is stored into Dest and optionally the Z flag is updated to the Dest or Src zero status. D = signed (D[15:0] * S[15:0]).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "(S == 0) | (D == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the signed 16-bit value to multiply with Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or signed 16-bit augmented literal whose value is multiplied into Dest.",
              "WZ is an optional effect to update the Z flag."
            ],
            "related": [
              "MUL",
              "SCA",
              "QMUL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Jump": {
        "count": 1,
        "description": "Branch D - Jump",
        "instructions": {
          "JMPREL": {
            "mnemonic": "JMPREL",
            "syntax": "JMPREL  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110000",
            "description": "Jump ahead/back by D instructions. For cogex, PC += D[19:0]. For hubex, PC += D[17:0] << 2.",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to C or !C.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to C or !C.",
        "instructions": {
          "DRVNC": {
            "mnemonic": "DRVNC",
            "syntax": "DRVNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011011",
            "description": "DRVC or DRVNC sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and toggle to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and toggle to the opposite output level.",
        "instructions": {
          "FLTNOT": {
            "mnemonic": "FLTNOT",
            "syntax": "FLTNOT  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010111",
            "description": "FLTNOT sets the I/O pin(s) designated by Dest to the input direction and to their opposite output level(s); i.e. Result: The I/O pins described by Dest are set to the input direction and to their opposite output level(s); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to the input direction and toggle to opposite output levels.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a word to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a word to new value.",
        "instructions": {
          "SETWORD": {
            "mnemonic": "SETWORD",
            "syntax": "SETWORD D,{#}S,#N",
            "encoding": "EEEE 1001001 00I 000000000 SSSSSSSSS",
            "description": "SETWORD stores Src[15:0] into the word identified by Num within Dest, or the word and register described by a Result: Src[15:0] is written to word Num (0\u20131) of Dest, or to another register word described by prior ALTSW instruction.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to modify a word.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose bits [15:0] will be stored in the designated location.",
              "Num is a 1-bit literal identifying the word ID (0\u20131) of Dest to modify."
            ],
            "related": [
              "ALTSW",
              "SETNIB",
              "SETBYTE",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Add two unsigned values.": {
        "count": 1,
        "description": "Math Instruction - Add two unsigned values.",
        "instructions": {
          "ADD": {
            "mnemonic": "ADD",
            "syntax": "ADD     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ADD sums the two unsigned values of Dest and Src together and stores the result into the Dest register. Result: Sum of unsigned Src and unsigned Dest is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "carry of (D + S)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ADDX",
              "ADDS",
              "ADDSX",
              "SUB"
            ],
            "compiler_info": {
              "syntax": "ADD D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 32,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1568
              },
              "category": "Arithmetic",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if signed or not signed.": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if signed or not signed.",
        "instructions": {
          "TJNS": {
            "mnemonic": "TJNS",
            "syntax": "TJNS    D,{#}S",
            "encoding": "EEEE 1011101 11I DDDDDDDDD SSSSSSSSS",
            "description": "TJS or TJNS tests the value in Dest and jumps to the address described by Src if the result is signed (Dest[31] = 1) Result: Dest is tested and if it's signed (or not signed in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register whose value is tested for sign or no sign.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin (Smart Logic) Instruction - Acknowledge smart pin(s).": {
        "count": 1,
        "description": "I/O Pin (Smart Logic) Instruction - Acknowledge smart pin(s).",
        "instructions": {
          "AKPIN": {
            "mnemonic": "AKPIN",
            "syntax": "AKPIN   {#}S",
            "encoding": "EEEE 1100000 01I 000000001 SSSSSSSSS",
            "description": "AKPIN acknowledges the Smart Pin(s) designated by Src. This lowers the corresponding IN signal(s) so that Result: One or more Smart Pins is acknowledged; lowering their corresponding IN signal(s).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 11-bit augmented literal whose value identifies the Smart Pin(s) to acknowledge."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETBYTE / ROLBYTE instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETBYTE / ROLBYTE instruction.",
        "instructions": {
          "ALTGB": {
            "mnemonic": "ALTGB",
            "syntax": "ALTGB   D,{#}S",
            "encoding": "EEEE 1001011 011 DDDDDDDDD 000000000",
            "description": "ALTGB should be followed by GETBYTE or ROLBYTE\u2014 it modifies the GETBYTE / ROLBYTE instruction's\nSrc and Result: The next instruction's pipelined Src and Num fields are altered to be (Src + Dest[10:2])\n& $1FF, or just Dest[10:2] for syntax 2, and Dest[1:0], respectively.\n\nPerfect for:\n- Table lookups (commutation tables, sine tables)\n- String processing with auto-increment\n- Byte array traversal\n- Character mapping and translation\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 11-bit value is the index, or the full byte address, for the GETBYTE / ROLBYTE instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[10:2]) for GETBYTE / ROLBYTE) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a nibble from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a nibble from a value.",
        "instructions": {
          "GETNIB": {
            "mnemonic": "GETNIB",
            "syntax": "GETNIB  D,{#}S,#N",
            "encoding": "EEEE 1000010 000 DDDDDDDDD 000000000",
            "description": "GETNIB reads the nibble identified by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN Result: Nibble Num (0\u20137) of Src, or a nibble from a source described by prior ALTGN instruction, is written to Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the nibble.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target nibble to read.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Src to read."
            ],
            "related": [
              "ALTGN",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force unsigned value to be less than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force unsigned value to be less than or equal to another.",
        "instructions": {
          "FLE": {
            "mnemonic": "FLE",
            "syntax": "FLE     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "FLE sets unsigned Dest to unsigned Src if Dest is greater than Src. This is also known as a limit maximum Result: Unsigned Dest is set to unsigned Src if Dest was greater than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the unsigned value to limit to a maximum of unsigned Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose unsigned value is the upper limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "FGE",
              "FLES",
              "FGES"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Sign-extend value beyond designated bit.": {
        "count": 1,
        "description": "Math Instruction - Sign-extend value beyond designated bit.",
        "instructions": {
          "SIGNX": {
            "mnemonic": "SIGNX",
            "syntax": "SIGNX   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SIGNX fills the bits of Dest, above the bit indicated by Src[4:0], with the value of that identified bit; i.e. Result: The Dest value is sign-extended above the bit indicated by Src and is stored in Dest. Optionally the C and Z flags are updated to the resulting MSB and zero status. C = MSB of result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of result"
              }
            },
            "parameters": [
              "Dest is a register containing the value to sign-extend above bit Src[4:0] and is where the result is written.",
              "Src is a register or 9-bit literal whose value (lower 5 bits) identifies the bit of Dest to zero-extend beyond.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ZEROX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETWORD / ROLWORD instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETWORD / ROLWORD instruction.",
        "instructions": {
          "ALTGW": {
            "mnemonic": "ALTGW",
            "syntax": "ALTGW   D,{#}S",
            "encoding": "EEEE 1001011 111 DDDDDDDDD 000000000",
            "description": "ALTGW should be followed by GETWORD or ROLWORD\u2014 it modifies the GETWORD / ROLWORD instruction's Src and Result: The next instruction's pipelined Src and Num fields are altered to be (Src + Dest[9:1]) & $1FF, or just Dest[9:1] for syntax 2, and Dest[0], respectively.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 10-bit value is the index, or the full word address for the GETWORD / ROLWORD instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[9:1]) for GETWORD / ROLWORD) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - New Block": {
        "count": 1,
        "description": "Hub FIFO - New Block",
        "instructions": {
          "FBLOCK": {
            "mnemonic": "FBLOCK",
            "syntax": "FBLOCK  {#}D,{#}S",
            "encoding": "EEEE 1100100 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set next block for when block wraps. D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry flag left into value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry flag left into value.",
        "instructions": {
          "RCL": {
            "mnemonic": "RCL",
            "syntax": "RCL     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "The bits of Dest are shifted left by Src bits, inserting C as new LSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate carry left by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-NCO-rollover event flag": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-NCO-rollover event flag",
        "instructions": {
          "WAITXRO": {
            "mnemonic": "WAITXRO",
            "syntax": "WAITXRO          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011100 000100100",
            "description": "WAITXRO waits for a streamer-NCO-rollover event to occur (unless the event flag is already set), then clears the Result: Wait for streamer-NCO-rollover event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXRO",
              "JXRO",
              "JNXRO"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter S field of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter S field of next instruction.",
        "instructions": {
          "ALTS": {
            "mnemonic": "ALTS",
            "syntax": "ALTS    D,{#}S",
            "encoding": "EEEE 1001100 101 DDDDDDDDD 000000000",
            "description": "ALTS modifies the next instruction's Src value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax Result: The next instruction's pipelined Src value is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).",
        "instructions": {
          "TJNF": {
            "mnemonic": "TJNF",
            "syntax": "TJNF    D,{#}S",
            "encoding": "EEEE 1011101 01I DDDDDDDDD SSSSSSSSS",
            "description": "TJF or TJNF tests the value in Dest and jumps to the address described by Src if the result is full (-1; $FFFF_FFFF; Result: Dest is tested and if it's full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Dest is a register whose value is tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get 1..32-bit mask into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get 1..32-bit mask into Dest.",
        "instructions": {
          "BMASK": {
            "mnemonic": "BMASK",
            "syntax": "BMASK   D,{#}S",
            "encoding": "EEEE 1001110 010 DDDDDDDDD DDDDDDDDD",
            "description": "BMASK generates an LSB-justified bit mask (all ones) of Src+1 or Dest+1 length and stores it in Dest. The size Result: Bit mask of size Src+1, or Dest+1 (1\u201432 bits) is stored into Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the generated bit mask and optionally begins by containing the 5-bit mask size it is requesting (syntax 2).",
              "Src is an optional register or 5-bit literal whose value is the size of the bit mask to generate."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETNIB / ROLNIB instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETNIB / ROLNIB instruction.",
        "instructions": {
          "ALTGN": {
            "mnemonic": "ALTGN",
            "syntax": "ALTGN   D,{#}S",
            "encoding": "EEEE 1001010 111 DDDDDDDDD 000000000",
            "description": "ALTGN should be followed by GETNIB or ROLNIB\u2014 it modifies the GETNIB / ROLNIB instruction's Src and Num Result: The next instruction's pipelined Src and Num values are altered to be (Src + Dest[11:3]) & $1FF, or just Dest[11:3] for syntax 2, and Dest[2:0], respectively.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 12-bit value is the index, or the full nibble address, for the next GETNIB / ROLNIB instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[11:3]) for GETNIB / ROLNIB) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch A - Call": {
        "count": 1,
        "description": "Branch A - Call",
        "instructions": {
          "CALLA": {
            "mnemonic": "CALLA",
            "syntax": "CALLA   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101110 RAA AAAAAAAAA AAAAAAAAA",
            "description": "R = 1 then PC += A, else PC = A.",
            "timing": {
              "cycles": 5,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Add two signed extended values.": {
        "count": 1,
        "description": "Math Instruction - Add two signed extended values.",
        "instructions": {
          "ADDSX": {
            "mnemonic": "ADDSX",
            "syntax": "ADDSX   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0001011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "ADDSX sums the signed values of Dest and Src plus C together and stores the result into the Dest register. The Result: Sum of signed Src plus C and signed Dest is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D + S + C)"
              },
              "Z": {
                "formula": "Z AND (result == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to add Src pluc C to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "ADD",
              "ADDX",
              "ADDSX",
              "SUBSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test bit of D or !D and either store, AND, OR, or XOR the result into flags.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test bit of D or !D and either store, AND, OR, or XOR the result into flags.",
        "instructions": {
          "TESTBN": {
            "mnemonic": "TESTBN",
            "syntax": "TESTBN  D,{#}S         WC/WZ",
            "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "TESTB or TESTBN reads the state (0/1) of a bit in Dest designated by Src, possibly inverts that result, and either Result: The state of Dest's bit Src is read, possibly inverted, and either stored as-is, or bitwise ANDed, ORed, or XORed into C or Z. Z = C/Z XOR !D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR !D[S[4:0]]",
                "when": "IN[D[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have a single bit tested.",
              "Src is a register or 5-bit literal whose value identifies the bit (0\u201331) of Dest to test."
            ],
            "related": [
              "TESTP",
              "TESTPN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation / Math Instruction - Shift bits left; a.k.a. multiply 32-bit integer by power-of-two.": {
        "count": 1,
        "description": "Bit Operation / Math Instruction - Shift bits left; a.k.a. multiply 32-bit integer by power-of-two.",
        "instructions": {
          "SHL": {
            "mnemonic": "SHL",
            "syntax": "SHL     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SHL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to 0. This is useful for Result: The bits of Dest are shifted left by Src bits, inserting zeros (0) as new rightmost bits.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to left shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to shift left.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a byte to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a byte to new value.",
        "instructions": {
          "SETBYTE": {
            "mnemonic": "SETBYTE",
            "syntax": "SETBYTE D,{#}S,#N",
            "encoding": "EEEE 1000110 00I 000000000 SSSSSSSSS",
            "description": "SETBYTE stores Src[7:0] into the byte identified by Num within Dest, or the byte and register described by a prior Result: Src[7:0] is written to byte Num (0\u20133) of Dest, or to another register byte described by prior ALTSB instruction.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to modify a byte.",
              "Src is a register or 8-bit literal whose bits [7:0] will be stored in the designated location.",
              "Num is a 2-bit literal identifying the nibble ID (0\u20133) of Dest to modify."
            ],
            "related": [
              "ALTSB",
              "SETNIB",
              "SETWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Set template S field for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template S field for ALTI.",
        "instructions": {
          "SETS": {
            "mnemonic": "SETS",
            "syntax": "SETS    D,{#}S",
            "encoding": "EEEE 1001101 11I DDDDDDDDD SSSSSSSSS",
            "description": "SETS copies Src[8:0] to the S field of the template, Dest, to be used with an ALTI instruction. Bits outside the S Result: The S field [8:0] of template Dest is set to Src[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction."
            ],
            "related": [
              "SETD",
              "SETR",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Color Manipulation Instruction - Add RGB colors with full saturation.": {
        "count": 1,
        "description": "Color Manipulation Instruction - Add RGB colors with full saturation.",
        "instructions": {
          "ADDPIX": {
            "mnemonic": "ADDPIX",
            "syntax": "ADDPIX  D,{#}S",
            "encoding": "EEEE 1010010 00I DDDDDDDDD SSSSSSSSS",
            "description": "ADDPIX sums individual RGB (reg, green, blue) color values of Src into that of Dest and stores the result in the Result: Src color value bytes are added into Dest color value bytes with full saturation.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register containing the RGB color value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose RGB color value bytes are added into Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get number of 1s from Dest or Src into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get number of 1s from Dest or Src into Dest.",
        "instructions": {
          "ONES": {
            "mnemonic": "ONES",
            "syntax": "ONES    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111101 CZ0 DDDDDDDDD DDDDDDDDD",
            "description": "ONES tallies the number of high bits of Src, or Dest, and stores the count into Dest. Result: The number of high bits in Src, or Dest, is stored in Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "LSB of result"
              }
            },
            "parameters": [
              "Dest is the register in which to store the number of high bits found and optionally it begins by containing the value to check (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is to be checked for ones.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Multiply unsigned 16-bit x 16-bit values.": {
        "count": 1,
        "description": "Math Instruction - Multiply unsigned 16-bit x 16-bit values.",
        "instructions": {
          "MUL": {
            "mnemonic": "MUL",
            "syntax": "MUL     D,{#}S          {WZ}",
            "encoding": "EEEE 1010000 0ZI DDDDDDDDD SSSSSSSSS",
            "description": "The 32-bit unsigned product of the 16-bit Dest and Src multiplication is stored into Dest and optionally the Z flag is updated to the Dest or Src zero status. D = unsigned (D[15:0] * S[15:0]).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "(S == 0) | (D == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the 16-bit value to multiply with Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose value is multiplied into Dest.",
              "WZ is an optional effect to update the Z flag."
            ],
            "related": [
              "MULS",
              "SCA",
              "QMUL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation / Math Instruction - Shift bits right; a.k.a. divide unsigned 32-bit integer by power-of-two.": {
        "count": 1,
        "description": "Bit Operation / Math Instruction - Shift bits right; a.k.a. divide unsigned 32-bit integer by power-of-two.",
        "instructions": {
          "SHR": {
            "mnemonic": "SHR",
            "syntax": "SHR     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SHR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to 0. This is useful for Result: The bits of Dest are shifted right by Src bits, inserting zeros (0) as new leftmost bits.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to right shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to shift right.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output (high; 1) or input (low; 0).": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output (high; 1) or input (low; 0).",
        "instructions": {
          "DIRL": {
            "mnemonic": "DIRL",
            "syntax": "DIRL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000000",
            "description": "DIRH or DIRL alters the direction register's bit(s) designated by Dest to be high (1) or low (0); i.e. set to the output Result: The I/O pin direction bit(s), described by Dest, are set high (1; output) or low (0; input); the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRZ",
              "DIRNZ",
              "DIRNOT",
              "DIRRND"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Decrement with modulus.": {
        "count": 1,
        "description": "Math Instruction - Decrement with modulus.",
        "instructions": {
          "DECMOD": {
            "mnemonic": "DECMOD",
            "syntax": "DECMOD  D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "DECMOD compares Dest with 0\u2014 if not equal, it decrements Dest; otherwise it sets Dest equal to Src. If Dest Result: If Dest was not equal to 0, it is decremented by 1; otherwise Dest is reset to Src. Optionally, C and Z are updated to indicate reset and zero result status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D = D - 1 and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the value to decrement down to 0 with modulus, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is the modulus limit to apply to Dest's decrement operation.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "INCMOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to random low/high.",
        "instructions": {
          "DRVRND": {
            "mnemonic": "DRVRND",
            "syntax": "DRVRND  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011110",
            "description": "DRVRND sets the I/O pin(s) designated by Dest to the output direction and with output level(s) set randomly low Result: The I/O pins described by Dest are set to the output direction and each output level is set randomly low or high; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to the output direction and with output level(s) set randomly to low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Call": {
        "count": 1,
        "description": "Branch S - Call",
        "instructions": {
          "CALLPA": {
            "mnemonic": "CALLPA",
            "syntax": "CALLPA  {#}D,{#}S",
            "encoding": "EEEE 1011010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Call to S** by pushing {C, Z, 10'b0, PC[19:0]} onto stack, copy D to PA.",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Increment with modulus.": {
        "count": 1,
        "description": "Math Instruction - Increment with modulus.",
        "instructions": {
          "INCMOD": {
            "mnemonic": "INCMOD",
            "syntax": "INCMOD  D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0111000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "INCMOD compares Dest with Src\u2014 if not equal, it increments Dest; otherwise it sets Dest equal to 0. If Dest Result: If Dest was not equal to Src, it is incremented by 1; otherwise Dest is reset to 0. Optionally, C and Z are updated to indicate reset and zero result status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D = D + 1 and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the value to increment up to Src with modulus, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is the modulus limit to apply to Dest's increment operation."
            ],
            "related": [
              "DECMOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear pin-pattern-detected event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear pin-pattern-detected event flag.",
        "instructions": {
          "WAITPAT": {
            "mnemonic": "WAITPAT",
            "syntax": "WAITPAT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011000 000100100",
            "description": "WAITPAT waits for a pin-pattern-detected event to occur (unless the event flag is already set), then clears the Result: Wait for pin-pattern-detected event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [],
            "related": [
              "SETPAT",
              "POLLPAT",
              "JPAT",
              "JNPAT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry flag right into value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry flag right into value.",
        "instructions": {
          "RCR": {
            "mnemonic": "RCR",
            "syntax": "RCR     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0000100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "RCR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to C. Result: The bits of Dest are shifted right by Src bits, inserting C as new MSBs.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate carry right by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a byte from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a byte from a value.",
        "instructions": {
          "GETBYTE": {
            "mnemonic": "GETBYTE",
            "syntax": "GETBYTE D,{#}S,#N",
            "encoding": "EEEE 1000111 000 DDDDDDDDD 000000000",
            "description": "GETBYTE reads the byte identified by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB Result: Byte Num (0\u20133) of Src, or a byte from a source described by prior ALTGB instruction, is written to Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the byte.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target byte to read.",
              "Num is a 2-bit literal identifying the byte ID (0\u20133) of Src to read."
            ],
            "related": [
              "ALTGB",
              "GETNIB",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values and subtract the second if it is lesser or equal.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values and subtract the second if it is lesser or equal.",
        "instructions": {
          "CMPSUB": {
            "mnemonic": "CMPSUB",
            "syntax": "CMPSUB  D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0010111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "CMPSUB compares the unsigned values of Dest and Src, and if Src is less than or equal to Dest then it is Result: Dest is decremented by Src unless it is less than Src, and the comparison results are optionally written to the C and Z flags.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with Src and is the destination written to if a subtraction is performed.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared with and possibly subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set discrete bits of a value to that of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete bits of a value to that of another.",
        "instructions": {
          "MUXQ": {
            "mnemonic": "MUXQ",
            "syntax": "MUXQ    D,{#}S",
            "encoding": "EEEE 1001111 10I DDDDDDDDD SSSSSSSSS",
            "description": "MUXQ copies all bits from Src corresponding to high (1) bits of Q into the corresponding\nbits of Dest. All other bits remain unchanged.\n\nCritical for parallel bit operations, especially RGB LED driving where\nmultiple data lines need simultaneous updates.\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register whose bits will be updated according to Q and Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose select bits will replace the corresponding bits in Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-finished event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-finished event flag.",
        "instructions": {
          "POLLXFI": {
            "mnemonic": "POLLXFI",
            "syntax": "POLLXFI          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001011 000100100",
            "description": "Streamer-finished event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXFI",
              "JXFI",
              "JNXFI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if FIFO interface block wrap event flag is set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if FIFO interface block wrap event flag is set or clear.",
        "instructions": {
          "JNFBW": {
            "mnemonic": "JNFBW",
            "syntax": "JNFBW   {#}S",
            "encoding": "EEEE 1011110 01I 000011001 SSSSSSSSS",
            "description": "JFBW or JNFBW checks the cog's FIFO interface block wrap flag and jumps to the address described by Src if the Result: If FIFO interface block wrap event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-empty event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-empty event flag.",
        "instructions": {
          "POLLXMT": {
            "mnemonic": "POLLXMT",
            "syntax": "POLLXMT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001010 000100100",
            "description": "POLLXMT copies the state of the streamer-empty event flag into C and/or Z and then clears the flag (unless it's Result: Streamer-empty event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXMT",
              "JXMT",
              "JNXMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a nibble to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a nibble to new value.",
        "instructions": {
          "SETNIB": {
            "mnemonic": "SETNIB",
            "syntax": "SETNIB  D,{#}S,#N",
            "encoding": "EEEE 1000000 00I 000000000 SSSSSSSSS",
            "description": "SETNIB stores Src[3:0] into the nibble identified by Num within Dest, or the nibble and register described by a prior Result: Src[3:0] is written to nibble Num (0\u20137) of Dest, or to another register nibble described by prior ALTSN instruction.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register in which to modify a nibble.",
              "Src is a register or 4-bit literal whose bits [3:0] will be stored in the designated location.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Dest to modify."
            ],
            "related": [
              "ALTSN",
              "SETBYTE",
              "SETWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Decrement, jump if zero or not zero.": {
        "count": 1,
        "description": "Flow Control Instruction - Decrement, jump if zero or not zero.",
        "instructions": {
          "DJNZ": {
            "mnemonic": "DJNZ",
            "syntax": "DJNZ    D,{#}S",
            "encoding": "EEEE 1011011 01I DDDDDDDDD SSSSSSSSS",
            "description": "DJZ or DJNZ decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) output level to random low/high.",
        "instructions": {
          "OUTRND": {
            "mnemonic": "OUTRND",
            "syntax": "OUTRND  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001110",
            "description": "OUTRND alters the output level register's bit(s) designated by Dest to be random low and high, based on bit(s) Result: The I/O pin output level bit(s), described by Dest, are each set randomly low or high; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the pins set randomly to low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer LUT RAM rollover event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if streamer LUT RAM rollover event flag set or clear.",
        "instructions": {
          "JNXRL": {
            "mnemonic": "JNXRL",
            "syntax": "JNXRL   {#}S",
            "encoding": "EEEE 1011110 01I 000011101 SSSSSSSSS",
            "description": "JXRL or JNXRL checks the cog's streamer LUT RAM rollover event flag and jumps to the address described by Src Result: If streamer LUT RAM rollover event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Jump+Skip": {
        "count": 1,
        "description": "Branch D - Jump+Skip",
        "instructions": {
          "SKIPF": {
            "mnemonic": "SKIPF",
            "syntax": "SKIPF\u00a0\u00a0 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110010",
            "description": "Skip cog/LUT instructions fast per D. Like SKIP, but instead of cancelling instructions, the PC leaps over them.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Bit Operation Instruction - Toggle bit(s) to the opposite state.": {
        "count": 1,
        "description": "Bit Operation Instruction - Toggle bit(s) to the opposite state.",
        "instructions": {
          "BITNOT": {
            "mnemonic": "BITNOT",
            "syntax": "BITNOT  D,{#}S         {WCZ}",
            "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITNOT alters the Dest bit(s) designated by Src to their inverse state. All other bits are left unchanged. Result: Dest bit(s) described by Src are toggled to their opposite state(s); the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits toggled.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force signed value to be less than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force signed value to be less than or equal to another.",
        "instructions": {
          "FLES": {
            "mnemonic": "FLES",
            "syntax": "FLES    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "FLES sets signed Dest to signed Src if Dest is greater than Src. This is also known as a limit maximum function; Result: Signed Dest is set to signed Src if Dest was greater than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to limit to a maximum of signed Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose signed value is the upper limit to force upon Dest."
            ],
            "related": [
              "FGES",
              "FLE",
              "FGE"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to random input/output.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to random input/output.",
        "instructions": {
          "DIRRND": {
            "mnemonic": "DIRRND",
            "syntax": "DIRRND  {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000110",
            "description": "DIRRND alters the direction register's bit(s) designated by Dest to be random low and high (input and output), Result: The I/O pin direction bit(s), described by Dest, are each set randomly low or high (input or output); the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the pins set randomly to inputs or outputs.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-LUT-RAM-rollover event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-LUT-RAM-rollover event flag.",
        "instructions": {
          "POLLXRL": {
            "mnemonic": "POLLXRL",
            "syntax": "POLLXRL          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001101 000100100",
            "description": "Streamer-LUT-RAM-rollover event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXRL",
              "JXRL",
              "JNXRL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set discrete nibbles of a value to non-zero nibble states of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete nibbles of a value to non-zero nibble states of another.",
        "instructions": {
          "MUXNIBS": {
            "mnemonic": "MUXNIBS",
            "syntax": "MUXNIBS D,{#}S",
            "encoding": "EEEE 1001111 01I DDDDDDDDD SSSSSSSSS",
            "description": "MUXNIBS copies any non-zero nibbles from Src into the corresponding nibbles of Dest and leaves the rest of Result: Dest nibbles corresponding to non-zero Src nibbles are set to those nibble values; the rest are left as-is.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register whose value will be updated according to Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose non-zero nibbles will replace the corresponding nibbles in Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear interrupt-occurred event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear interrupt-occurred event flag.",
        "instructions": {
          "WAITINT": {
            "mnemonic": "WAITINT",
            "syntax": "WAITINT          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010000 000100100",
            "description": "WAITINT waits for an interrupt-occurred event to occur (unless the event flag is already set), then clears the event Result: Wait for interrupt-occurred event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "POLLINT",
              "JINT",
              "JNINT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer empty event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if streamer empty event flag set or clear.",
        "instructions": {
          "JNXMT": {
            "mnemonic": "JNXMT",
            "syntax": "JNXMT   {#}S",
            "encoding": "EEEE 1011110 01I 000011010 SSSSSSSSS",
            "description": "JXMT or JNXMT checks the cog's streamer empty event flag and jumps to the address described by Src if the flag Result: If streamer empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to high (1) or low (0).": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) output level to high (1) or low (0).",
        "instructions": {
          "OUTL": {
            "mnemonic": "OUTL",
            "syntax": "OUTL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001000",
            "description": "OUTH or OUTL alters the output level register's bit(s) designated by Dest to be high (1) or low (0). All other bits Result: The I/O pin output level bit(s), described by Dest, are set high (1) or low (0); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a word from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a word from a value.",
        "instructions": {
          "GETWORD": {
            "mnemonic": "GETWORD",
            "syntax": "GETWORD D,{#}S,#N",
            "encoding": "EEEE 1001001 100 DDDDDDDDD 000000000",
            "description": "GETWORD reads the word identified by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW Result: Word Num (0\u20131) of Src, or a word from a source described by prior ALTGW instruction, is written to Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the word.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target word to read.",
              "Num is a 1-bit literal identifying the word ID (0\u20131) of Src to read."
            ],
            "related": [
              "ALTGW",
              "GETNIB",
              "GETBYTE",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flag Modification Instruction - Modify C and/or Z flag(s) according to modifier mode and current state(s).": {
        "count": 1,
        "description": "Flag Modification Instruction - Modify C and/or Z flag(s) according to modifier mode and current state(s).",
        "instructions": {
          "MODCZ": {
            "mnemonic": "MODCZ",
            "syntax": "MODCZ   c,z      {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 0cccczzzz 001101111",
            "description": "MODC, MODZ, or MODCZ sets or clears the C and/or Z flag based on the mode described by the given Modifier Result: The C and/or Z flag is set or cleared according to the given Modifier and the current state of the C and/or Z flags. C = cccc[{C,Z}], Z = zzzz[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "cccc[{C,Z}], Z = zzzz[{C,Z}]"
              },
              "Z": {
                "formula": "zzzz[{C,Z}]"
              }
            },
            "parameters": [
              "CModifer is a Modifier symbol for the designated mode to apply to the C flag.",
              "ZModifer is a Modifier symbol for the designated mode to apply to the Z flag.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Augmentation Instruction - Augment next literal Src to 32-bits.": {
        "count": 1,
        "description": "Augmentation Instruction - Augment next literal Src to 32-bits.",
        "instructions": {
          "AUGS": {
            "mnemonic": "AUGS",
            "syntax": "AUGS",
            "encoding": "EEEE 11110nn nnn nnnnnnnnn nnnnnnnnn",
            "description": "AUGS is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits Result: The 23-bit value formed from Src is queued to prefix the next literal Src occurrence (#Src) to form a 32-bit literal for that instruction; interrupts are also temporarily disabled.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a 32-bit literal whose upper 23 bits are prepended to the next literal Src occurrence."
            ],
            "related": [
              "AUGD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear FIFO-interface-block-wrap event flag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear FIFO-interface-block-wrap event flag.",
        "instructions": {
          "POLLFBW": {
            "mnemonic": "POLLFBW",
            "syntax": "POLLFBW          {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001001 000100100",
            "description": "POLLFBW copies the state of the FIFO-interface-block-wrap event flag into C and/or Z and then clears the flag Result: FIFO-interface-block-wrap event flag is optionally copied into C and/or Z, then it is cleared.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "RDFAST",
              "WRFAST",
              "FBLOCK",
              "WAITFBW",
              "JFBW",
              "JNFBW"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer finished event flag set or clear.": {
        "count": 1,
        "description": "Event Branch Instruction - Jump if streamer finished event flag set or clear.",
        "instructions": {
          "JNXFI": {
            "mnemonic": "JNXFI",
            "syntax": "JNXFI   {#}S",
            "encoding": "EEEE 1011110 01I 000011011 SSSSSSSSS",
            "description": "JXFI or JNXFI checks the cog's streamer finished event flag and jumps to the address described by Src if the Result: If streamer finished event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Set template Result field for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template Result field for ALTI.",
        "instructions": {
          "SETR": {
            "mnemonic": "SETR",
            "syntax": "SETR    D,{#}S",
            "encoding": "EEEE 1001101 01I DDDDDDDDD SSSSSSSSS",
            "description": "SETR copies Src[8:0] to the Result field of the template, Dest, to be used with an ALTI instruction. Bits outside the Result: The Result field [27:19] of template Dest is set to Src[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction.",
              "Src is a register or 9-bit literal whose value (Src[8:0]) is copied to the D field of Dest."
            ],
            "related": [
              "SETD",
              "SETS",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      }
    }
  },
  "condition_codes": {
    "supported": true,
    "flags": [
      "C",
      "Z"
    ],
    "prefixes": {
      "_RET_": "Execute if returning",
      "IF_": "Execute conditionally",
      "IF_C": "Execute if Carry set",
      "IF_NC": "Execute if Carry clear",
      "IF_Z": "Execute if Zero set",
      "IF_NZ": "Execute if Zero clear"
    }
  },
  "memory_model": {
    "cog_ram": {
      "size": "512 longs",
      "addressing": "$000-$1FF",
      "special_registers": "$1F0-$1FF"
    },
    "lut_ram": {
      "size": "512 longs",
      "addressing": "$200-$3FF",
      "shared_access": true
    },
    "hub_ram": {
      "size": "512KB",
      "addressing": "$00000-$7FFFF",
      "byte_addressable": true
    }
  },
  "gaps": {
    "boot_process": {
      "status": "missing",
      "workaround": "Use serial boot for development",
      "needed_from": "Chip Gracey"
    },
    "usb_support": {
      "status": "missing",
      "workaround": "Use serial communication",
      "needed_from": "Parallax"
    },
    "smart_pins_complete": {
      "status": "partial",
      "available_modes": 10,
      "total_modes": 32,
      "workaround": "Use documented modes only",
      "pending_from": "Jon Titus documentation"
    },
    "bytecode_interpreter": {
      "status": "missing",
      "workaround": "Use PASM2 or external compiler",
      "needed_from": "Chip Gracey"
    },
    "streamer_fifo": {
      "status": "partial",
      "workaround": "Use basic RDFAST/WRFAST",
      "needed_from": "Documentation team"
    }
  },
  "discovery": {
    "has_architecture": true,
    "has_instruction_set": true,
    "has_memory_model": true,
    "has_pin_control": true,
    "has_cordic": true,
    "has_interrupts": true,
    "has_boot_process": false,
    "has_usb": false,
    "has_complete_timing": false,
    "has_all_smart_pins": false,
    "has_bytecode": false
  },
  "code_generation_ready": {
    "basic_assembly": true,
    "hub_memory_access": true,
    "pin_control": true,
    "cog_launching": true,
    "cordic_math": true,
    "smart_pins_basic": true,
    "interrupts": false,
    "usb": false,
    "boot_configuration": false
  },
  "spin2": {
    "version": "2.1.0",
    "source": "engineering/knowledge-base/P2/language/spin2/",
    "extraction_date": "2025-09-13T14:04:24.689333",
    "categories": {
      "keywords": {
        "count": 36,
        "elements": {
          "LOOKDOWNZ": {
            "keyword": "LOOKDOWNZ",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns zero-based index of matching value in list\n",
            "syntax": "LOOKDOWNZ(value : list)",
            "examples": [
              "index := LOOKDOWNZ(color : RED, GREEN, BLUE)"
            ]
          },
          "FROM": {
            "keyword": "FROM",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Starting value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "STEP": {
            "keyword": "STEP",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Increment value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end STEP increment\n  statements\n",
            "examples": [
              "REPEAT i FROM 0 TO 100 STEP 5\n  process(i)"
            ]
          },
          "RETURN": {
            "keyword": "RETURN",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Return from method with optional value\n",
            "syntax": "RETURN [value]",
            "examples": [
              "RETURN",
              "RETURN result"
            ]
          },
          "ELSEIFNOT": {
            "keyword": "ELSEIFNOT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch with negated condition\n",
            "syntax": "ELSEIFNOT condition\n  statements\n",
            "examples": [
              "ELSEIFNOT flag\n  result := \"false case\""
            ]
          },
          "IF": {
            "keyword": "IF",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution based on expression\n",
            "syntax": "IF condition\n  statements\n",
            "examples": [
              "IF temperature > 80\n  turn_on_fan()"
            ]
          },
          "IFNOT": {
            "keyword": "IFNOT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution with negated condition\n",
            "syntax": "IFNOT condition\n  statements\n",
            "examples": [
              "IFNOT sensor_active\n  error_handler()"
            ]
          },
          "ELSEIF": {
            "keyword": "ELSEIF",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch in IF statement\n",
            "syntax": "ELSEIF condition\n  statements\n",
            "examples": [
              "ELSEIF x > 10\n  result := \"high\""
            ]
          },
          "OBJ": {
            "keyword": "OBJ",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Object section - declares object instances\n",
            "syntax": "OBJ\n  name : \"filename\"\n",
            "examples": [
              "OBJ\n  serial : \"FullDuplexSerial\""
            ]
          },
          "CON": {
            "keyword": "CON",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Constants section - defines named constant values\n",
            "syntax": "CON\n  identifier = expression\n",
            "examples": [
              "CON\n  LED_PIN = 56\n  BAUD_RATE = 115200"
            ]
          },
          "OTHER": {
            "keyword": "OTHER",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in CASE statement\n",
            "syntax": "CASE expression\n  value1: statements\n  OTHER: statements\n",
            "examples": [
              "CASE status\n  0: handle_success()\n  OTHER: handle_error()"
            ]
          },
          "NEXT": {
            "keyword": "NEXT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Continue to next iteration of loop\n",
            "syntax": "NEXT",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  IF i == 5\n    NEXT\n  process(i)"
            ]
          },
          "FILE": {
            "keyword": "FILE",
            "type": "keyword",
            "category": "Special",
            "description": "Compiler directive for file inclusion\n",
            "syntax": "FILE filename",
            "examples": [
              "FILE \"config.spin2\""
            ]
          },
          "QUIT": {
            "keyword": "QUIT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Exit loop immediately\n",
            "syntax": "QUIT",
            "examples": [
              "REPEAT\n  IF error_condition\n    QUIT\n  process_data()"
            ]
          },
          "BYTE": {
            "keyword": "BYTE",
            "type": "keyword",
            "category": "Data Types",
            "description": "8-bit unsigned integer type (0-255)\n",
            "syntax": "BYTE variable[count]",
            "examples": [
              "BYTE flag",
              "BYTE buffer[128]"
            ]
          },
          "ABORT": {
            "keyword": "ABORT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Abort method execution with optional error value\n",
            "syntax": "ABORT [expression]",
            "examples": [
              "ABORT",
              "ABORT error_code"
            ]
          },
          "REPEAT": {
            "keyword": "REPEAT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop construct with various forms\n",
            "syntax": "REPEAT [count]\nREPEAT variable FROM start TO end [STEP increment]\nREPEAT WHILE condition\nREPEAT UNTIL condition\n",
            "examples": [
              "REPEAT 10",
              "REPEAT i FROM 1 TO 100 STEP 2",
              "REPEAT WHILE sensor_active"
            ]
          },
          "CASE_FAST": {
            "keyword": "CASE_FAST",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Optimized case statement for sequential values\n",
            "syntax": "CASE_FAST expression\n  value: statements\n",
            "examples": [
              "CASE_FAST status\n  0: handle_ok()\n  1: handle_error()"
            ]
          },
          "TO": {
            "keyword": "TO",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Ending value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "DAT": {
            "keyword": "DAT",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Data section - contains data and inline assembly\n",
            "syntax": "DAT\n  label type value\n",
            "examples": [
              "DAT\n  message BYTE \"Hello World\", 0"
            ]
          },
          "VAR": {
            "keyword": "VAR",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Variables section - declares instance variables\n",
            "syntax": "VAR\n  type variable[count]\n",
            "examples": [
              "VAR\n  LONG counter\n  BYTE buffer[256]"
            ]
          },
          "STRING": {
            "keyword": "STRING",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Convert expression to string representation\n",
            "syntax": "STRING(expression)",
            "examples": [
              "text := STRING(number)"
            ]
          },
          "WORD": {
            "keyword": "WORD",
            "type": "keyword",
            "category": "Data Types",
            "description": "16-bit unsigned integer type (0-65535)\n",
            "syntax": "WORD variable[count]",
            "examples": [
              "WORD address",
              "WORD lookup_table[128]"
            ]
          },
          "BYTEFIT": {
            "keyword": "BYTEFIT",
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a byte constant\n",
            "examples": [
              "CON\n  SMALL_VALUE = BYTEFIT(200)"
            ]
          },
          "LONG": {
            "keyword": "LONG",
            "type": "keyword",
            "category": "Data Types",
            "description": "32-bit signed integer type\n",
            "syntax": "LONG variable[count]",
            "examples": [
              "LONG counter",
              "LONG data_buffer[256]"
            ]
          },
          "LOOKDOWN": {
            "keyword": "LOOKDOWN",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns index of matching value in list\n",
            "syntax": "LOOKDOWN(value : list)",
            "examples": [
              "index := LOOKDOWN(day : \"Mon\", \"Tue\", \"Wed\")"
            ]
          },
          "UNTIL": {
            "keyword": "UNTIL",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue until condition becomes true\n",
            "syntax": "REPEAT UNTIL condition\n  statements\n",
            "examples": [
              "REPEAT UNTIL sensor_triggered\n  check_sensor()"
            ]
          },
          "WITH": {
            "keyword": "WITH",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Object context specifier for method calls\n",
            "syntax": "WITH object",
            "examples": [
              "WITH serial\n  str(\"Hello World\")"
            ]
          },
          "CASE": {
            "keyword": "CASE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Multi-way branch based on expression value\n",
            "syntax": "CASE expression\n  value1: statements\n  value2: statements\n",
            "examples": [
              "CASE day\n  1: month_name := \"January\"\n  2: month_name := \"February\""
            ]
          },
          "LOOKUP": {
            "keyword": "LOOKUP",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given index\n",
            "syntax": "LOOKUP(index : list)",
            "examples": [
              "day_name := LOOKUP(day : \"Sun\", \"Mon\", \"Tue\")"
            ]
          },
          "PRI": {
            "keyword": "PRI",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Private method declaration - accessible only within object\n",
            "syntax": "PRI method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PRI calculate_sum(a, b) : result\n  result := a + b"
            ]
          },
          "LOOKUPZ": {
            "keyword": "LOOKUPZ",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given zero-based index\n",
            "syntax": "LOOKUPZ(index : list)",
            "examples": [
              "color := LOOKUPZ(index : RED, GREEN, BLUE)"
            ]
          },
          "WORDFIT": {
            "keyword": "WORDFIT",
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a word constant\n",
            "examples": [
              "CON\n  MID_VALUE = WORDFIT(32000)"
            ]
          },
          "WHILE": {
            "keyword": "WHILE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue while condition remains true\n",
            "syntax": "REPEAT WHILE condition\n  statements\n",
            "examples": [
              "REPEAT WHILE data_available\n  process_data()"
            ]
          },
          "PUB": {
            "keyword": "PUB",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Public method declaration - accessible from other objects\n",
            "syntax": "PUB method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PUB start(pin) : success\n  configure_pin(pin)\n  success := TRUE"
            ]
          },
          "ELSE": {
            "keyword": "ELSE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in IF statement\n",
            "syntax": "ELSE\n  statements\n",
            "examples": [
              "ELSE\n  result := 0"
            ]
          }
        }
      },
      "operators": {
        "count": 74,
        "elements": {
          "^^": {
            "operator": "^^",
            "type": "operator",
            "description": "Logical XOR operator\n",
            "category": "Bitwise",
            "examples": [
              "IF state1 ^^ state2\n  toggle()"
            ]
          },
          "?": {
            "operator": "?",
            "type": "operator",
            "description": "Conditional selection\n",
            "category": "Ternary"
          },
          "FRAC": {
            "operator": "FRAC",
            "type": "operator",
            "description": "Calculate fraction\n",
            "category": "Math",
            "examples": [
              "frac := dividend FRAC divisor"
            ]
          },
          ":": {
            "operator": ":",
            "type": "operator",
            "description": "Conditional selection\n",
            "category": "Ternary"
          },
          "!&&": {
            "operator": "!&&",
            "type": "operator",
            "description": "Boolean AND/NAND\n",
            "category": "Logical AND"
          },
          "+<": {
            "operator": "+<",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "ROR": {
            "operator": "ROR",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "-.": {
            "operator": "-.",
            "type": "operator",
            "description": "Integer/float subtraction\n",
            "category": "Subtract"
          },
          ">=": {
            "operator": ">=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "/.": {
            "operator": "/.",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "SCA": {
            "operator": "SCA",
            "type": "operator",
            "description": "Scale value (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "scaled := value SCA factor"
            ]
          },
          "+.": {
            "operator": "+.",
            "type": "operator",
            "description": "Integer/float addition\n",
            "category": "Add"
          },
          "SIGNX": {
            "operator": "SIGNX",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "NOT": {
            "operator": "NOT",
            "type": "operator",
            "description": "Logical NOT (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF NOT ready\n  wait()"
            ]
          },
          "+>=": {
            "operator": "+>=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "&&": {
            "operator": "&&",
            "type": "operator",
            "description": "Boolean AND/NAND\n",
            "category": "Logical AND"
          },
          ">": {
            "operator": ">",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "+<=>": {
            "operator": "+<=>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "??": {
            "operator": "??",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "ADDBITS": {
            "operator": "ADDBITS",
            "type": "operator",
            "description": "Add bit count to pin number\n",
            "category": "Pin",
            "examples": [
              "pin_range := start_pin ADDBITS bit_count"
            ]
          },
          "BMASK": {
            "operator": "BMASK",
            "type": "operator",
            "description": "Create bit mask from bit count (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "mask := BMASK(8)  // Returns $FF"
            ]
          },
          "FABS": {
            "operator": "FABS",
            "type": "operator",
            "description": "Floating point absolute value\n",
            "category": "Math",
            "examples": [
              "distance := FABS(float_difference)"
            ]
          },
          "XOR": {
            "operator": "XOR",
            "type": "operator",
            "description": "Logical XOR (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF state1 XOR state2\n  toggle()"
            ]
          },
          "ABS": {
            "operator": "ABS",
            "type": "operator",
            "description": "` `^^` `ENCOD` `DECOD` `ONES` `SQRT` `QLOG` `QEXP`\n",
            "category": "\\"
          },
          "SCAS": {
            "operator": "SCAS",
            "type": "operator",
            "description": "Scale value signed (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "scaled := value SCAS factor"
            ]
          },
          "<#": {
            "operator": "<#",
            "type": "operator",
            "description": "Max/min limiting\n",
            "category": "Limit"
          },
          "<=": {
            "operator": "<=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ">=.": {
            "operator": ">=.",
            "type": "operator",
            "description": "Floating point greater than or equal comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF temp >=. threshold\n  activate()"
            ]
          },
          "REV": {
            "operator": "REV",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "QLOG": {
            "operator": "QLOG",
            "type": "operator",
            "description": "Quick logarithm (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "log_val := QLOG(value)"
            ]
          },
          "<>>": {
            "operator": "<>>",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "+<=": {
            "operator": "+<=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ":=": {
            "operator": ":=",
            "type": "operator",
            "description": "Assignment operator\n",
            "category": "Assignment",
            "examples": [
              "variable := value",
              "result := calculate(x, y)"
            ]
          },
          "SAR": {
            "operator": "SAR",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "--": {
            "operator": "--",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "ROL": {
            "operator": "ROL",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "#>": {
            "operator": "#>",
            "type": "operator",
            "description": "Max/min limiting\n",
            "category": "Limit"
          },
          "||": {
            "operator": "||",
            "type": "operator",
            "description": "Logical OR operator\n",
            "category": "Bitwise",
            "examples": [
              "IF error || timeout\n  abort()"
            ]
          },
          "++": {
            "operator": "++",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "AND": {
            "operator": "AND",
            "type": "operator",
            "description": "Logical AND (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF ready AND enabled\n  start()"
            ]
          },
          "===": {
            "operator": "===",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "-": {
            "operator": "-",
            "type": "operator",
            "description": "Integer/float subtraction\n",
            "category": "Subtract"
          },
          "...": {
            "operator": "...",
            "type": "operator",
            "category": "Special",
            "description": "Line continuation operator - allows a single logical line to span multiple physical lines in SPIN2\n",
            "syntax": [
              "statement ... continuation",
              "expression part1 + part2 + ...",
              "          part3 + part4"
            ],
            "examples": [
              "result := value1 + value2 + ...\n          value3 + value4\n",
              "IF condition1 AND condition2 AND ...\n   condition3 AND condition4\n  ' Execute if all conditions true\n",
              "REPEAT count FROM 1 TO 100 STEP ...\n                  increment_value\n"
            ],
            "notes": [
              "The three dots must be the last non-comment item on the line",
              "The continuation appears on the next line with appropriate indentation",
              "Comments can appear after the ellipsis"
            ],
            "documentation_source": "SPIN2 Language Reference",
            "documentation_level": "comprehensive"
          },
          "<<": {
            "operator": "<<",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "+>": {
            "operator": "+>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "QEXP": {
            "operator": "QEXP",
            "type": "operator",
            "description": "Quick exponential (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "exp_val := QEXP(value)"
            ]
          },
          "+//": {
            "operator": "+//",
            "name": "Unsigned Modulo Add",
            "category": "arithmetic_operators",
            "description": "Add with unsigned modulo (circular arithmetic)",
            "documentation_source": "code_analysis",
            "documentation_level": "comprehensive",
            "created": "2025-09-09",
            "overview": "The +// operator performs addition with unsigned modulo, creating circular\narithmetic perfect for buffer management and wrap-around counters. This is\na key operator for implementing circular queues and ring buffers in Spin2.\n",
            "syntax": {
              "format": "result := value +// modulus",
              "parameters": {
                "value": "The value to operate on",
                "modulus": "The wrap-around point (result will be 0 to modulus-1)"
              },
              "returns": "Value modulo modulus"
            },
            "operation": {
              "description": "Performs (value % modulus) where % is unsigned modulo.\nResult ranges from 0 to (modulus - 1).\nEquivalent to: value // modulus\n",
              "formula": "result = value MOD modulus (unsigned)"
            },
            "examples": {
              "circular_buffer_increment": {
                "description": "Increment buffer index with wrap-around",
                "code": "VAR\n  LONG head, tail\n  BYTE buffer[32]\n\nPUB addByte(data)\n  ' Calculate next tail position\n  nextTail := (tail + 1) +// 32\n  \n  ' Check if buffer full\n  if nextTail == head\n    return FALSE  ' Buffer full\n    \n  ' Add data and update tail\n  buffer[tail] := data\n  tail := nextTail\n  return TRUE\n",
                "source": "P2-OctoSerial pattern"
              },
              "modulo_arithmetic": {
                "description": "Various modulo operations",
                "code": "' Simple wrap-around\nindex := (index + 1) +// BUFFER_SIZE\n\n' Increment by N with wrap\nposition := (position + step) +// MAX_POSITION\n\n' Calculate distance in circular buffer\ndistance := (head - tail) +// BUFFER_SIZE\n"
              },
              "queue_management": {
                "description": "Circular queue push operation",
                "code": "PRI rxCheckInternal(portHandle) : nChar\n  nChar := NO_CHAR\n  if rxTailIdx[portHandle] <> rxHeadIdx[portHandle]\n    ' Increment with modulo\n    rxHeadIdx[portHandle] := (rxHeadIdx[portHandle] + 1) +// BUF_SIZE\n    ' Read from new head position\n    nChar := BYTE[pRxBuf[portHandle]][rxHeadIdx[portHandle]]\n",
                "source": "P2-OctoSerial"
              }
            },
            "common_patterns": {
              "buffer_sizes": [
                "Power of 2 not required (unlike & mask method)",
                "Any buffer size works: +// 30, +// 100, etc.",
                "Typically used with constants for clarity"
              ],
              "typical_usage": [
                "Circular buffer index management",
                "Ring buffer wrap-around",
                "Cyclic counter implementation",
                "Round-robin scheduling indexes"
              ]
            },
            "comparison_with_alternatives": {
              "and_mask_method": {
                "description": "Alternative using AND mask (power of 2 only)",
                "code": "' Only works with power-of-2 sizes\nindex := (index + 1) & (BUFFER_SIZE - 1)  ' BUFFER_SIZE must be 2^n\n\n' +// works with any size\nindex := (index + 1) +// BUFFER_SIZE      ' Any size works\n"
              },
              "manual_method": {
                "description": "Manual wrap-around check",
                "code": "' Manual method\nindex++\nif index >= BUFFER_SIZE\n  index := 0\n  \n' Using +// operator\nindex := (index + 1) +// BUFFER_SIZE    ' One line, same result\n"
              }
            },
            "best_practices": [
              "Use parentheses for clarity with complex expressions",
              "Define buffer sizes as constants",
              "Remember result range is 0 to (modulus-1)",
              "Consider using for all circular arithmetic"
            ],
            "related_operators": [
              {
                "//": "Unsigned divide remainder (modulo)"
              },
              {
                "+/": "Unsigned divide quotient"
              },
              {
                "%%": "Signed modulo"
              },
              {
                "&": "AND mask (alternative for power-of-2)"
              }
            ],
            "notes": [
              "More flexible than AND mask method",
              "Works with any modulus value",
              "Essential for circular buffer implementation",
              "Commonly used in multi-port/multi-resource drivers"
            ],
            "references": [
              {
                "P2-OctoSerial": "Extensive use in circular buffers"
              },
              {
                "Spin2 documentation": "Arithmetic operators"
              },
              "Production code patterns from Iron Sheep Productions"
            ]
          },
          "/": {
            "operator": "/",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "<=.": {
            "operator": "<=.",
            "type": "operator",
            "description": "Floating point less than or equal comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF count <=. limit\n  continue()"
            ]
          },
          "OR": {
            "operator": "OR",
            "type": "operator",
            "description": "Logical OR (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF error OR timeout\n  abort()"
            ]
          },
          "<=>": {
            "operator": "<=>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "*.": {
            "operator": "*.",
            "type": "operator",
            "description": "Integer/float multiply\n",
            "category": "Multiply"
          },
          "ZEROX": {
            "operator": "ZEROX",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "+": {
            "operator": "+",
            "type": "operator",
            "description": "Integer/float addition\n",
            "category": "Add"
          },
          "ENCOD": {
            "operator": "ENCOD",
            "type": "operator",
            "description": "Encode highest bit position (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "bit_pos := ENCOD(mask)"
            ]
          },
          "==": {
            "operator": "==",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "<": {
            "operator": "<",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ":=:": {
            "operator": ":=:",
            "type": "operator",
            "description": "Swap operator\n",
            "category": "Assignment",
            "examples": [
              "a :=: b  // swap values of a and b"
            ]
          },
          "SQRT": {
            "operator": "SQRT",
            "type": "operator",
            "description": "Integer square root\n",
            "category": "Math",
            "examples": [
              "side := SQRT(area)"
            ]
          },
          "+/": {
            "operator": "+/",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "? :": {
            "operator": "? :",
            "type": "operator",
            "description": "Ternary conditional operator\n",
            "category": "Assignment",
            "examples": [
              "result := condition ? true_value : false_value"
            ]
          },
          "//": {
            "operator": "//",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          ">.": {
            "operator": ">.",
            "type": "operator",
            "description": "Floating point greater than comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF speed >. max_speed\n  slow_down()"
            ]
          },
          "<>.": {
            "operator": "<>.",
            "type": "operator",
            "description": "Floating point inequality comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF result <>. 0.0\n  handle_error()"
            ]
          },
          "<.": {
            "operator": "<.",
            "type": "operator",
            "description": "Floating point less than comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF x <. y\n  smaller := x"
            ]
          },
          "DECOD": {
            "operator": "DECOD",
            "type": "operator",
            "description": "Decode bit position to mask (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "mask := DECOD(5)  // Returns $20"
            ]
          },
          "FSQRT": {
            "operator": "FSQRT",
            "type": "operator",
            "description": "Floating point square root\n",
            "category": "Math",
            "examples": [
              "side := FSQRT(float_area)"
            ]
          },
          "<>": {
            "operator": "<>",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "ONES": {
            "operator": "ONES",
            "type": "operator",
            "description": "Count number of 1 bits (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "count := ONES(%10110101)  // Returns 5"
            ]
          },
          "*": {
            "operator": "*",
            "type": "operator",
            "description": "Integer/float multiply\n",
            "category": "Multiply"
          },
          "ADDPINS": {
            "operator": "ADDPINS",
            "type": "operator",
            "description": "Add pin count to pin number\n",
            "category": "Pin",
            "examples": [
              "pin_range := start_pin ADDPINS pin_count"
            ]
          },
          ">>": {
            "operator": ">>",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "==.": {
            "operator": "==.",
            "type": "operator",
            "description": "Floating point equality comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF value ==. target\n  found()"
            ]
          }
        }
      },
      "methods": {
        "count": 87,
        "elements": {
          "GETCRC": {
            "method": "GETCRC",
            "type": "method",
            "description": "Calculate CRC using hardware CRC engine\n",
            "category": "Miscellaneous",
            "syntax": "crc := GETCRC(DataAddress, Polynomial, Count)",
            "parameters": [
              {
                "name": "DataAddress",
                "type": "address",
                "description": "Address of data to calculate CRC for"
              },
              {
                "name": "Polynomial",
                "type": "long",
                "description": "CRC polynomial to use"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to process"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Calculated CRC value"
            },
            "examples": [
              {
                "code": "' Calculate CRC-32\ncrc32 := GETCRC(@data, $EDB88320, size)\n",
                "description": "Calculate standard CRC-32"
              },
              {
                "code": "' Calculate CRC-16\ncrc16 := GETCRC(@buffer, $8005, length) & $FFFF\n",
                "description": "Calculate CRC-16"
              },
              {
                "code": "' Verify data integrity\ncalculated := GETCRC(@packet, polynomial, packet_size)\nif calculated == expected_crc\n  ' Data is valid\n",
                "description": "Verify data with CRC"
              }
            ],
            "notes": [
              "Uses P2's hardware CRC engine",
              "Common polynomials: CRC-32=$EDB88320, CRC-16=$8005",
              "Processes byte by byte",
              "Fast hardware implementation",
              "Initial CRC value is 0",
              "Result may need masking for < 32-bit CRCs"
            ],
            "timing": {
              "description": "Hardware accelerated",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "BYTEMOVE",
              "STRCOMP"
            ],
            "see_also": [
              "CRC calculation",
              "Data integrity",
              "Error detection"
            ]
          },
          "LONGFILL": {
            "method": "LONGFILL",
            "category": "memory_operations",
            "type": "method",
            "description": "Fill a specified region of hub RAM with a 32-bit long value.\nEfficiently sets multiple consecutive longs to the same value.\nCommonly used for clearing arrays, initializing data structures, and setting patterns.\n",
            "syntax": "LONGFILL(Destination, Value, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for correct operation.\nStarting address for the fill operation.\n"
              },
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit value to fill with.\nCan be any long value.\nCommon values: 0 (clear), -1 ($FFFFFFFF), pointers, patterns.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to fill (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "timing": {
              "performance": "~8 + (count * 2) clock cycles",
              "optimization": "Uses efficient hub block operations",
              "vs_loop": "5-10x faster than manual loop"
            },
            "examples": [
              {
                "code": "VAR\n  LONG buffer[256]\n  \nPUB clear_buffer()\n  LONGFILL(@buffer, 0, 256)\n",
                "description": "Clear array of longs"
              },
              {
                "code": "VAR\n  LONG stack[64]\n  \nPUB init_stack()\n  LONGFILL(@stack, $DEAD_BEEF, 64)\n  ' Helps identify stack overflow\n",
                "description": "Initialize stack with marker pattern"
              },
              {
                "code": "VAR\n  LONG pointers[100]\n  \nPUB init_pointers()\n  LONGFILL(@pointers, @default_handler, 100)\n",
                "description": "Initialize function pointer table"
              },
              {
                "code": "' Initialize mailbox system\nDAT\n  mailboxes LONG 0[8]\n  \nPUB clear_mailboxes()\n  LONGFILL(@mailboxes, -1, 8)  ' -1 = empty\n",
                "description": "Initialize inter-cog mailboxes"
              },
              {
                "code": "' Create test pattern\nVAR\n  LONG pattern[1000]\n  \nPUB create_patterns()\n  LONGFILL(@pattern[0], $12345678, 500)\n  LONGFILL(@pattern[500], $87654321, 500)\n",
                "description": "Create diagnostic patterns"
              }
            ],
            "common_uses": [
              "Array initialization",
              "Stack initialization",
              "Clearing data structures",
              "Setting default values",
              "Pattern generation",
              "Memory testing"
            ],
            "typical_values": {
              "0": "Clear/zero memory",
              "-1": "All bits set ($FFFFFFFF)",
              "$DEADBEEF": "Debug marker",
              "$BADC0DE": "Error marker",
              "pointer": "Function/data pointers"
            },
            "memory_patterns": {
              "debug": "LONGFILL(@memory, $DEADBEEF, count)\n' Easy to spot in debugger\n",
              "cleared": "LONGFILL(@memory, 0, count)\n' Standard initialization\n",
              "invalid": "LONGFILL(@memory, -1, count)\n' Mark as uninitialized\n"
            },
            "related_methods": [
              "BYTEFILL - Fill with byte value",
              "WORDFILL - Fill with word value",
              "LONGMOVE - Copy longs",
              "LONGCOMP - Compare longs"
            ],
            "performance_notes": [
              "Much faster than loops for large counts",
              "Optimized hub operations",
              "Alignment critical for correctness",
              "Count > 4 shows significant speedup"
            ],
            "notes": [
              "Count is in LONGS, not bytes",
              "Destination should be long-aligned",
              "Full 32-bit value is written",
              "Count of 0 is safe (no operation)",
              "Cannot fill cog or LUT RAM directly"
            ],
            "alignment_requirement": "CRITICAL: Destination must be long-aligned\nGood: LONG buffer[100]  ' Aligned by declaration\nBad:  BYTE buffer[400]  ' May not be aligned\nFix:  LONG buffer[100]  ' Use proper type\n",
            "warnings": [
              "Count is LONGS not BYTES",
              "Misalignment causes incorrect results",
              "Ensure destination has enough space",
              "Overwrites existing data"
            ],
            "see_also": [
              "language/spin2/methods/bytefill.yaml",
              "language/spin2/methods/wordfill.yaml",
              "language/spin2/methods/longmove.yaml"
            ]
          },
          "LOOKDOWNZ": {
            "method": "LOOKDOWNZ",
            "type": "method",
            "description": "Find 0-based index of value in list\n",
            "category": "Lookup Operations",
            "syntax": "index := LOOKDOWNZ(Value : Match0, Match1, ..., MatchN)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "0-based index of match, or -1 if not found"
            },
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWNZ(30 : 10, 20, 30, 40, 50)\n' Returns 2 (30 is at index 2)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Menu option mapping\nselection := LOOKDOWNZ(key : \"Q\", \"S\", \"L\", \"H\")\ncase selection\n  0: quit_program()\n  1: save_file()\n  2: load_file()\n  3: show_help()\n",
                "description": "Map key to action"
              },
              {
                "code": "' Validate input range\nif LOOKDOWNZ(value : 0..9, 16..25, 32..47) >= 0\n  ' Value is in valid range\n  process_value(value)\n",
                "description": "Check if value in valid ranges"
              }
            ],
            "notes": [
              "Returns 0-based index (0 = first match)",
              "Returns -1 if value not found",
              "Supports ranges with .. operator",
              "Searches left to right, returns first match",
              "Inverse operation of LOOKUPZ",
              "More common than LOOKDOWN for array-style operations"
            ],
            "related": [
              "LOOKDOWN",
              "LOOKUPZ",
              "LOOKUP"
            ],
            "see_also": [
              "Value searching",
              "Zero-based indexing",
              "Input validation"
            ]
          },
          "GETCT": {
            "method": "GETCT",
            "category": "timing",
            "type": "method",
            "description": "Get the current 32-bit system counter value.\nThe system counter increments once per clock cycle continuously from boot.\nWraps around from $FFFF_FFFF to $0000_0000 approximately every 21 seconds at 200MHz.\nEssential for precise timing measurements and delays.\n",
            "syntax": "GETCT() : Count",
            "parameters": "none",
            "returns": {
              "name": "Count",
              "type": "long",
              "description": "Current 32-bit system counter value.\nIncrements at system clock frequency.\nWraps from $FFFF_FFFF to $0000_0000.\n"
            },
            "timing": {
              "execution": "2 clock cycles",
              "precision": "Single clock cycle resolution",
              "wrap_time": "(2^32 / CLKFREQ) seconds",
              "examples": [
                "200MHz: ~21.47 seconds",
                "180MHz: ~23.86 seconds",
                "160MHz: ~26.84 seconds",
                "80MHz: ~53.69 seconds"
              ]
            },
            "examples": [
              {
                "code": "start := GETCT()\n' ... do something ...\nelapsed := GETCT() - start\n' elapsed now contains clock cycles\n",
                "description": "Measure execution time"
              },
              {
                "code": "' Convert cycles to microseconds\nstart := GETCT()\nprocess_data()\nelapsed_us := (GETCT() - start) / (CLKFREQ / 1_000_000)\n",
                "description": "Time measurement in microseconds"
              },
              {
                "code": "' Wait for exact 1 second\ntarget := GETCT() + CLKFREQ\nWAITCT(target)\n",
                "description": "Precise 1-second delay"
              },
              {
                "code": "' Create 10Hz precise loop\nnext_time := GETCT()\nREPEAT\n  next_time += CLKFREQ / 10\n  WAITCT(next_time)\n  do_10hz_task()\n",
                "description": "Precise periodic execution"
              },
              {
                "code": "' Timeout pattern\ntimeout := GETCT() + (CLKFREQ / 1000) * 100  ' 100ms timeout\nREPEAT WHILE (GETCT() - timeout) < 0\n  IF PINREAD(0)\n    ' Got response\n    QUIT\n' Timed out\n",
                "description": "Implement timeout"
              }
            ],
            "underlying_pasm": {
              "instruction": "GETCT",
              "description": "Direct access to CNT register"
            },
            "common_uses": [
              "Execution time measurement",
              "Creating precise delays with WAITCT",
              "Timeout implementation",
              "Performance profiling",
              "Timestamp generation",
              "Periodic task scheduling",
              "Bit-rate timing generation"
            ],
            "related_methods": [
              "WAITCT - Wait for specific counter value",
              "POLLCT - Check if counter value passed",
              "WAITMS - Simple millisecond delay",
              "WAITUS - Simple microsecond delay",
              "GETMS - Get milliseconds since boot",
              "GETSEC - Get seconds since boot"
            ],
            "notes": [
              "Counter runs continuously from boot",
              "Wraps around every 2^32 clocks",
              "Subtraction handles wrap correctly",
              "All cogs see same counter value",
              "Not affected by cog start/stop",
              "Resolution equals clock period"
            ],
            "wraparound_handling": "The 32-bit subtraction naturally handles wraparound:\nIf end_time < start_time (wrapped), the result is still correct\nExample: $0000_0010 - $FFFF_FFF0 = $20 (32 clocks elapsed)\n",
            "precision_considerations": [
              "Single clock accuracy when reading",
              "Hub access may add 0-7 clock variance",
              "Use WAITCT for cycle-accurate delays",
              "GETCT itself takes 2 clocks to execute"
            ],
            "see_also": [
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/pollct.yaml",
              "language/spin2/methods/getms.yaml",
              "language/pasm2/getct.yaml"
            ]
          },
          "NAN": {
            "method": "NAN",
            "type": "method",
            "description": "Check if floating-point value is Not-a-Number\n",
            "category": "Miscellaneous",
            "syntax": "result := NAN(FloatValue)",
            "parameters": [
              {
                "name": "FloatValue",
                "type": "float",
                "description": "Floating-point value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if NaN, FALSE (0) otherwise"
            },
            "examples": [
              {
                "code": "' Check for NaN\nif NAN(result)\n  ' Handle invalid result\n  result := 0.0\n",
                "description": "Check and handle NaN"
              },
              {
                "code": "' Validate calculation\nvalue := sqrt(-1.0)  ' Creates NaN\nif NAN(value)\n  debug(\"Invalid operation\")\n",
                "description": "Detect invalid math operation"
              },
              {
                "code": "' Filter NaN from data\nrepeat i from 0 to count-1\n  if not NAN(data[i])\n    process(data[i])\n",
                "description": "Skip NaN values in processing"
              }
            ],
            "notes": [
              "NaN results from invalid floating-point operations",
              "Examples: 0.0/0.0, sqrt(-1), inf-inf",
              "NaN != NaN in comparisons",
              "Any operation with NaN produces NaN",
              "IEEE 754 floating-point standard",
              "Important for robust float handling"
            ],
            "timing": {
              "description": "Immediate bit check",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "Float math operators"
            ],
            "see_also": [
              "Floating-point operations",
              "IEEE 754 standard",
              "Error handling"
            ]
          },
          "SETREGS": {
            "method": "SETREGS",
            "type": "method",
            "description": "Copy hub RAM to cog registers\n",
            "category": "Miscellaneous",
            "syntax": "SETREGS(HubAddress, CogAddress, Count)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM source address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Load PASM code into cog\nSETREGS(@pasm_code, $100, 50)  ' Load 50 longs\n",
                "description": "Load PASM code to cog RAM"
              },
              {
                "code": "' Restore saved registers\nVAR\n  LONG saved_regs[16]\n\nSETREGS(@saved_regs, $1F0, 16)  ' Restore $1F0-$1FF\n",
                "description": "Restore cog register state"
              },
              {
                "code": "' Initialize PASM variables\nVAR\n  LONG init_data[10]\n\nrepeat i from 0 to 9\n  init_data[i] := i * 100\nSETREGS(@init_data, $100, 10)\n",
                "description": "Set PASM variables in cog"
              }
            ],
            "notes": [
              "Copies from hub RAM to cog RAM",
              "Cog addresses are 0-511 (2KB)",
              "Each register is 32 bits (1 long)",
              "Can overwrite running code - use caution",
              "Useful for loading PASM code/data",
              "Count must not exceed remaining registers"
            ],
            "timing": {
              "description": "Hub transfer operation",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "GETREGS",
              "REGLOAD",
              "REGEXEC"
            ],
            "see_also": [
              "Cog memory access",
              "PASM loading",
              "Dynamic code loading"
            ]
          },
          "COGINIT": {
            "method": "COGINIT",
            "category": "cog_management",
            "type": "method",
            "description": "Start PASM2 code in a specified or available cog.\nLoads PASM2 code from hub RAM into cog RAM and begins execution.\nReturns the cog number that was started, or -1 if no cog was available.\nThis is the primary method for launching parallel processing cores.\n",
            "syntax": "COGINIT(CogNum, PASMaddr, PTRAvalue) : CogID",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- COGEXEC_NEW or NEWCOG (-1): Start any available cog\n- Bit 5 set: Execute from hub RAM (HUBEXEC mode)\n"
              },
              {
                "name": "PASMaddr",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute.\nUse @ operator to get address of code label.\nMust be long-aligned for cog execution.\n"
              },
              {
                "name": "PTRAvalue",
                "type": "long",
                "description": "Initial value for PTRA register in new cog.\nTypically used to pass parameter block address.\nCan be any 32-bit value.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using COGEXEC_NEW)\n"
            },
            "execution_modes": {
              "cogexec": "Default mode - code copied to cog RAM and executed there\nLimited to 512 longs (2KB) of code/data\nFastest execution, deterministic timing\n",
              "hubexec": "Set bit 5 of CogNum - code executes directly from hub RAM\nUnlimited code size (512KB hub RAM)\nSlightly slower, subject to hub timing variations\n"
            },
            "examples": [
              {
                "code": "DAT\n  ORG 0\nblink_code\n  DIRH  #56\n.loop\n  OUTNOT #56\n  WAITX ##25_000_000\n  JMP   #.loop\n  \nPUB start_blinker()\n  cog := COGINIT(COGEXEC_NEW, @blink_code, 0)\n  IF cog == -1\n    ' Failed to start\n",
                "description": "Start PASM blinker in any available cog"
              },
              {
                "code": "VAR\n  LONG params[4]\n  \nPUB start_driver()\n  params[0] := @buffer\n  params[1] := buffer_size\n  params[2] := pin_number\n  params[3] := 0  ' command\n  \n  COGINIT(COGEXEC_NEW, @driver_code, @params)\n",
                "description": "Start driver with parameter block"
              },
              {
                "code": "' Stop and restart cog 1 with new code\nCOGINIT(1, @new_code, @config)\n",
                "description": "Start specific cog (stops if running)"
              },
              {
                "code": "' Start hub execution mode\nCOGINIT(COGEXEC_NEW_PAIR | HUBEXEC, @hub_code, @data)\n",
                "description": "Start code in hub execution mode"
              }
            ],
            "common_uses": [
              "Launch parallel processing tasks",
              "Start hardware drivers",
              "Create dedicated I/O handlers",
              "Implement real-time controllers",
              "Run timing-critical code",
              "Parallel data processing"
            ],
            "related_methods": [
              "COGSPIN - Start Spin2 code in a cog",
              "COGSTOP - Stop a running cog",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running"
            ],
            "memory_layout": "Cog RAM after COGINIT:\n$000-$1F7: Your PASM code/data (504 longs)\n$1F8-$1FF: Special registers (PTRA, PTRB, etc.)\n",
            "notes": [
              "Code must start with ORG 0 for cog execution",
              "PTRA is set before code starts executing",
              "All cog registers cleared except PTRA",
              "Cog starts at address 0",
              "Previous cog contents completely replaced",
              "Cannot start Spin2 code with COGINIT (use COGSPIN)"
            ],
            "limitations": [
              "Maximum 496 longs of code+data in COGEXEC mode",
              "Only 8 cogs available total",
              "Cannot determine which cog when using COGEXEC_NEW",
              "No automatic cleanup if cog crashes"
            ],
            "see_also": [
              "language/pasm2/org.yaml",
              "language/spin2/methods/cogspin.yaml",
              "language/spin2/methods/cogstop.yaml",
              "architecture/cog.yaml"
            ]
          },
          "COGSPIN": {
            "method": "COGSPIN",
            "category": "cog_management",
            "type": "method",
            "description": "Start a Spin2 method in a specified or available cog.\nLoads the Spin2 interpreter into the cog and begins executing the specified method.\nReturns the cog number that was started, or -1 if no cog was available.\nEssential for parallel Spin2 execution.\n",
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive",
            "syntax": "COGSPIN(CogNum, Method({Parameters}), StackAddress) : CogID",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- NEWCOG or -1: Start any available cog\n"
              },
              {
                "name": "Method({Parameters})",
                "type": "method_call",
                "description": "Spin2 method to execute with optional parameters.\nMethod name followed by parameters in parentheses.\nCan be in current object or another object.\n"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Hub address of stack space for the new cog.\nUse @stack_array to get address.\nMinimum 32 longs recommended, more for complex code.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using NEWCOG)\n"
            },
            "stack_requirements": {
              "minimum": "32 longs (128 bytes)",
              "typical": "64-128 longs (256-512 bytes)",
              "factors": [
                "Method call depth",
                "Local variable count",
                "Parameter count",
                "Expression complexity"
              ]
            },
            "examples": [
              {
                "code": "VAR\n  LONG stack[64]\n  LONG cog_id\n  \nPUB main()\n  cog_id := COGSPIN(NEWCOG, worker(), @stack)\n  IF cog_id == -1\n    ' Failed to start\n    \nPRI worker()\n  REPEAT\n    ' Do work in parallel\n    PINTOGGLE(56)\n    WAITMS(500)\n",
                "description": "Start worker method in new cog"
              },
              {
                "code": "VAR\n  LONG stack1[64], stack2[64]\n  LONG sensor_data\n  \nPUB start_sensors()\n  COGSPIN(NEWCOG, read_sensor(0, @sensor_data), @stack1)\n  COGSPIN(NEWCOG, read_sensor(1, @sensor_data), @stack2)\n  \nPRI read_sensor(pin, ptr)\n  REPEAT\n    LONG[ptr][pin] := read_adc(pin)\n    WAITMS(10)\n",
                "description": "Multiple sensor readers with parameters"
              },
              {
                "code": "OBJ\n  serial : \"serial_driver\"\n  \nVAR\n  LONG serial_stack[128]\n  \nPUB init()\n  ' Start serial driver in separate cog\n  COGSPIN(NEWCOG, serial.rx_handler(), @serial_stack)\n",
                "description": "Start object method in new cog"
              },
              {
                "code": "VAR\n  LONG cog_stacks[4][64]\n  \nPUB parallel_process()\n  REPEAT i FROM 0 TO 3\n    COGSPIN(NEWCOG, process_chunk(i), @cog_stacks[i])\n",
                "description": "Launch multiple parallel processors"
              },
              {
                "code": "' Multi-COG Flash FS stress test pattern\nCON\n  NUM_TESTER_COGS = 7\n  STACK_SIZE_LONGS = 64\n  \nDAT\n  ' Per-COG stacks in DAT for persistence\n  stacks  LONG  0[NUM_TESTER_COGS * STACK_SIZE_LONGS]\n  results BYTE  0[8]  ' One per COG\n  lock    LONG  -1    ' Shared resource lock\n  \nPUB stress_test() | idx\n  ' Initialize lock for file system access\n  lock := LOCKNEW()\n  \n  ' Launch test COGs with indexed stacks\n  REPEAT idx FROM 0 TO NUM_TESTER_COGS-1\n    COGSPIN(NEWCOG, fs_tester(idx), @stacks[idx * STACK_SIZE_LONGS])\n  \n  ' Monitor results\n  REPEAT\n    show_results()\n    WAITMS(1000)\n    \nPRI fs_tester(cog_index) | handle\n  ' Each COG performs random file operations\n  REPEAT\n    ' Random delay to create contention\n    WAITMS(GETRND() & $FF)\n    \n    ' Acquire lock for file system access\n    REPEAT WHILE NOT LOCKTRY(lock)\n    \n    ' Perform file operation\n    handle := open(\"test.dat\", \"r\")\n    IF handle >= 0\n      ' Read/write operations\n      results[cog_index]++\n      close(handle)\n    \n    ' Release lock\n    LOCKREL(lock)\n",
                "description": "Multi-COG flash filesystem stress test",
                "source": "P2-FLASH-FS"
              }
            ],
            "method_execution": {
              "interpreter": "Each cog gets its own Spin2 interpreter",
              "isolation": "Methods run independently",
              "variables": [
                "VAR variables are shared between cogs",
                "Local variables are private to each cog",
                "DAT section is shared"
              ]
            },
            "common_uses": [
              "Parallel task execution",
              "Background monitoring",
              "Concurrent I/O handling",
              "Multi-threaded applications",
              "Separate UI and processing",
              "Real-time event handlers",
              "Multi-COG stress testing",
              "Parallel file system access"
            ],
            "production_patterns": {
              "multi_cog_with_locks": {
                "description": "Pattern for safe multi-COG resource access",
                "pattern": "1. Allocate shared lock in DAT\n2. Create per-COG stacks in DAT\n3. Launch COGs with indexed stack addresses\n4. Use LOCKTRY/LOCKREL for resource protection\n5. Track per-COG results/status\n",
                "source": "P2-FLASH-FS"
              },
              "indexed_stack_allocation": {
                "description": "Efficient stack allocation for multiple COGs",
                "code": "DAT\n  stacks LONG 0[NUM_COGS * STACK_SIZE]\n  \nPUB start_cogs() | i\n  REPEAT i FROM 0 TO NUM_COGS-1\n    COGSPIN(NEWCOG, worker(i), @stacks[i * STACK_SIZE])\n",
                "benefits": [
                  "Predictable memory layout",
                  "Easy to adjust stack sizes",
                  "Persistent across method calls"
                ]
              }
            },
            "related_methods": [
              "COGINIT - Start PASM code in a cog",
              "COGSTOP - Stop a running cog",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running",
              "LOCKNEW - Allocate lock for synchronization",
              "LOCKTRY - Try to acquire lock",
              "LOCKREL - Release lock"
            ],
            "synchronization": {
              "shared_variables": "Use locks for thread-safe access",
              "communication": "Use hub RAM for data exchange",
              "coordination": "Use COGATN/POLLATN for signaling",
              "file_system_access": "Must use locks for flash FS operations"
            },
            "notes": [
              "Method runs until it returns or cog is stopped",
              "Stack overflow causes undefined behavior",
              "Each cog has independent method call stack",
              "Parameters are passed by value",
              "Cannot share local variables between cogs",
              "Flash FS requires lock protection for multi-COG access"
            ],
            "best_practices": [
              "Always check return value for -1",
              "Size stack appropriately for method complexity",
              "Use locks for shared variable access",
              "Initialize shared data before starting cogs",
              "Stop cogs cleanly when done",
              "Use DAT for persistent stack allocation",
              "Implement proper lock cleanup on errors"
            ],
            "warnings": [
              "Stack overflow is not detected",
              "Insufficient stack causes crashes",
              "VAR variables need synchronization",
              "No automatic resource cleanup",
              "File system not thread-safe without locks"
            ],
            "see_also": [
              "language/spin2/methods/coginit.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/locknew.yaml",
              "language/spin2/constructs/method_definition.yaml",
              "concepts/multi_cog_synchronization.yaml"
            ]
          },
          "CLKSET": {
            "method": "CLKSET",
            "type": "method",
            "description": "Safely set new clock mode and frequency\n",
            "category": "Miscellaneous",
            "syntax": "CLKSET(Mode, Frequency)",
            "parameters": [
              {
                "name": "Mode",
                "type": "long",
                "description": "Clock mode configuration bits"
              },
              {
                "name": "Frequency",
                "type": "long",
                "description": "New clock frequency in Hz"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Set to 200MHz with PLL\nCLKSET(clkmode_pll, 200_000_000)\n",
                "description": "Set high-speed PLL mode"
              },
              {
                "code": "' Drop to RCFAST for low power\nCLKSET(clkmode_rcfast, 20_000_000)\n",
                "description": "Switch to internal RC oscillator"
              },
              {
                "code": "' Dynamic frequency scaling\nif battery_low\n  CLKSET(clkmode_pll, 80_000_000)  ' Reduce to 80MHz\nelse\n  CLKSET(clkmode_pll, 180_000_000)  ' Normal 180MHz\n",
                "description": "Adjust clock for power management"
              }
            ],
            "notes": [
              "Performs safe clock transition",
              "Updates clkfreq variable automatically",
              "Temporarily switches to RCFAST during transition",
              "Mode bits configure PLL, crystal, dividers",
              "Affects all timing-dependent operations",
              "Maximum frequency depends on chip specs",
              "Use predefined clkmode_ constants"
            ],
            "timing": {
              "description": "Clock stabilization delay",
              "cycles": "~10-20ms for PLL lock"
            },
            "related": [
              "HUBSET",
              "WAITMS",
              "GETCT"
            ],
            "see_also": [
              "Clock configuration",
              "PLL setup",
              "Power management"
            ]
          },
          "PINHIGH": {
            "method": "PINHIGH",
            "aliases": [
              "PINH"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) high (output mode, logic 1).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) high (OUT=1).\nThis is equivalent to the PASM2 DIRH instruction.\n",
            "syntax": "PINHIGH(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive high. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINHIGH(56)",
                "description": "Drive pin 56 high (typically an LED pin)"
              },
              {
                "code": "PINHIGH(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 high simultaneously"
              },
              {
                "code": "PINHIGH(15..8)",
                "description": "Drive pins 8 through 15 high (note: reverse range)"
              },
              {
                "code": "CON\n  LED = 56\nPUB main()\n  PINHIGH(LED)\n",
                "description": "Use a constant for the pin number"
              }
            ],
            "underlying_pasm": {
              "instruction": "DIRH",
              "description": "Internally uses DIRH instruction which sets DIR=1 and OUT=1"
            },
            "common_uses": [
              "Turn on LEDs",
              "Set control signals high",
              "Drive communication pins to idle state",
              "Activate chip select or enable lines"
            ],
            "related_methods": [
              "PINLOW - Drive pin(s) low",
              "PINTOGGLE - Toggle pin state",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "Pin will remain high until explicitly changed",
              "Multiple pins can be controlled simultaneously"
            ],
            "see_also": [
              "language/pasm2/dirh.yaml",
              "language/spin2/methods/pinlow.yaml",
              "language/spin2/methods/pintoggle.yaml"
            ]
          },
          "WAITATN": {
            "method": "WAITATN",
            "type": "method",
            "description": "Wait for attention signal from another cog\n",
            "category": "COG Management",
            "syntax": "WAITATN()",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for signal from another cog\nWAITATN()  ' Block until ATN received\n' Process the signal\n",
                "description": "Simple cog synchronization"
              },
              {
                "code": "' Worker cog waiting for commands\nrepeat\n  WAITATN()  ' Wait for command signal\n  command := shared_variable\n  process_command(command)\n",
                "description": "Command-driven worker cog"
              },
              {
                "code": "' Multi-stage synchronization\n' Stage 1\ndo_work_stage1()\nsignal_complete()  ' Tell master\nWAITATN()         ' Wait for next stage\n' Stage 2\ndo_work_stage2()\n",
                "description": "Multi-stage cog coordination"
              }
            ],
            "notes": [
              "Blocks execution until ATN signal received",
              "ATN flag is cleared after WAITATN returns",
              "Another cog uses COGATN to send the signal",
              "Each cog has its own ATN flag",
              "More efficient than polling shared variables",
              "Use POLLATN for non-blocking check"
            ],
            "timing": {
              "description": "Waits until ATN signal received",
              "cycles": "Variable based on when signal arrives"
            },
            "related": [
              "COGATN",
              "POLLATN",
              "COGID"
            ],
            "see_also": [
              "Cog communication",
              "Inter-cog signaling",
              "Synchronization"
            ]
          },
          "COGATN": {
            "method": "COGATN",
            "category": "cog_management",
            "type": "method",
            "description": "Strobe the attention signal to one or more cogs.\nSets attention flags that can be polled or waited on by target cogs.\nProvides fast inter-cog signaling without using hub RAM.\nEssential for event notification and synchronization.\n",
            "syntax": "COGATN(CogMask)",
            "parameters": [
              {
                "name": "CogMask",
                "type": "long",
                "description": "16-bit mask specifying which cogs to signal:\n- Bits 0-7: Target cog selection (1 = signal that cog)\n- Bits 8-15: Must be zero\n- Can signal multiple cogs simultaneously\n- Use (1 << cog_num) to signal specific cog\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles",
              "signal_propagation": "Immediate to all specified cogs",
              "latency": "Target cog sees signal on next instruction"
            },
            "examples": [
              {
                "code": "' Signal cog 3\nCOGATN(1 << 3)\n",
                "description": "Signal single cog"
              },
              {
                "code": "' Signal cogs 0, 2, and 4\nCOGATN(%00010101)\n",
                "description": "Signal multiple cogs"
              },
              {
                "code": "' Broadcast to all other cogs\nCOGATN($FF ^ (1 << COGID()))\n",
                "description": "Signal all cogs except self"
              },
              {
                "code": "VAR\n  LONG worker_cogs\n  \nPUB signal_workers()\n  ' Signal all registered workers\n  COGATN(worker_cogs)\n  \nPUB register_worker()\n  worker_cogs |= (1 << COGID())\n",
                "description": "Dynamic cog group signaling"
              },
              {
                "code": "' Producer-consumer pattern\nPUB producer()\n  REPEAT\n    produce_data()\n    COGATN(1 << consumer_cog)  ' Data ready\n    \nPUB consumer()\n  REPEAT\n    WAITATN()  ' Wait for signal\n    process_data()\n",
                "description": "Producer-consumer synchronization"
              }
            ],
            "signal_mechanism": {
              "hardware": "Dedicated attention network between cogs",
              "persistence": "Signal is edge-triggered (strobe)",
              "clearing": "Automatically cleared when polled/waited",
              "queueing": "No queueing - multiple signals before check are seen as one"
            },
            "common_uses": [
              "Event notification",
              "Work ready signals",
              "Synchronization barriers",
              "Interrupt simulation",
              "Wake sleeping cogs",
              "Broadcast communications"
            ],
            "receiving_methods": {
              "polling": "IF POLLATN()\n  ' Attention was signaled\n  \n",
              "waiting": "WAITATN()  ' Block until signaled\n",
              "pasm": "POLLATN WC  ' Check and clear\nWAITATN     ' Wait for signal\n"
            },
            "related_methods": [
              "POLLATN - Check for attention signal",
              "WAITATN - Wait for attention signal",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running"
            ],
            "synchronization_patterns": [
              {
                "pattern": "Barrier synchronization",
                "code": "VAR\n  BYTE ready_count\n  \nPUB barrier()\n  ready_count++\n  IF ready_count == 8\n    COGATN($FF)  ' Release all\n    ready_count := 0\n  ELSE\n    WAITATN()    ' Wait for release\n"
              },
              {
                "pattern": "Request-response",
                "code": "PUB request_service(cog)\n  COGATN(1 << cog)\n  WAITATN()  ' Wait for completion signal\n"
              },
              {
                "pattern": "Round-robin scheduling",
                "code": "PUB scheduler()\n  REPEAT cog FROM 0 TO 7\n    COGATN(1 << cog)  ' Give time slice\n    WAITMS(10)\n"
              }
            ],
            "notes": [
              "Cannot signal yourself (no effect)",
              "Signal doesn't queue - multiple signals merge",
              "No payload - just a signal",
              "Target cog must be running to receive",
              "More efficient than hub RAM polling"
            ],
            "best_practices": [
              "Use for time-critical signaling",
              "Combine with hub RAM for data passing",
              "Clear attention before waiting again",
              "Document signal meanings clearly",
              "Use masks for group operations"
            ],
            "limitations": [
              "No data payload",
              "No delivery guarantee if cog not waiting",
              "Single bit per cog - no message types",
              "No built-in acknowledgment"
            ],
            "see_also": [
              "language/spin2/methods/pollatn.yaml",
              "language/spin2/methods/waitatn.yaml",
              "language/pasm2/cogatn.yaml",
              "architecture/cog_attention.yaml"
            ]
          },
          "COGSTOP": {
            "method": "COGSTOP",
            "category": "cog_management",
            "type": "method",
            "description": "Stop a specified cog immediately.\nThe cog stops executing and becomes available for reuse.\nAll pins controlled by the cog are released to float state.\nNo effect if the cog is already stopped.\n",
            "syntax": "COGSTOP(CogNum)",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to stop:\n- 0-7: Stop specific cog\n- Can use COGID() to stop current cog\n- Invalid numbers have no effect\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "Immediate",
              "effect": "Cog stops within 1-2 clock cycles",
              "cleanup": "Pins released immediately"
            },
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB stop_driver()\n  IF driver_cog => 0\n    COGSTOP(driver_cog)\n    driver_cog := -1\n",
                "description": "Stop a driver cog and mark as stopped"
              },
              {
                "code": "' Emergency stop all other cogs\nREPEAT cog FROM 0 TO 7\n  IF cog <> COGID()\n    COGSTOP(cog)\n",
                "description": "Stop all cogs except current"
              },
              {
                "code": "' Self-termination\nCOGSTOP(COGID())\n' Code never reaches here\n",
                "description": "Stop current cog (suicide)"
              },
              {
                "code": "PUB restart_cog(n, code_addr, param)\n  COGSTOP(n)  ' Ensure stopped first\n  RETURN COGINIT(n, code_addr, param)\n",
                "description": "Restart a specific cog with new code"
              }
            ],
            "effects": {
              "immediate": [
                "Cog execution halts",
                "Cog RAM contents preserved but inaccessible",
                "Cog becomes available for COGINIT"
              ],
              "pin_control": [
                "All DIR bits cleared (pins become inputs)",
                "Smart pin modes disabled",
                "Pin states float"
              ],
              "resources": [
                "Locks owned by cog are NOT released",
                "Hub RAM is NOT affected",
                "Other cogs continue running"
              ]
            },
            "common_uses": [
              "Clean shutdown of drivers",
              "Resource management",
              "Error recovery",
              "Dynamic cog allocation",
              "Power saving (stopped cogs use less power)"
            ],
            "related_methods": [
              "COGINIT - Start a cog",
              "COGSPIN - Start Spin2 in a cog",
              "COGID - Get current cog number",
              "COGCHK - Check if cog is running"
            ],
            "notes": [
              "Safe to call on already-stopped cog",
              "Cannot stop cog -1 (no effect)",
              "Stopping current cog ends execution immediately",
              "No cleanup code runs in stopped cog",
              "Locks must be manually released before stopping"
            ],
            "best_practices": [
              "Track cog numbers in variables",
              "Set cog variable to -1 after stopping",
              "Release locks before stopping cog",
              "Stop dependent cogs in correct order",
              "Ensure pins are in safe state first"
            ],
            "warnings": [
              "Stopping a cog doesn't clean up its resources",
              "Pins float - may need pull-up/down resistors",
              "Cannot recover cog state after stopping",
              "No notification to other cogs"
            ],
            "see_also": [
              "language/spin2/methods/coginit.yaml",
              "language/spin2/methods/cogid.yaml",
              "language/spin2/methods/cogchk.yaml"
            ]
          },
          "BYTEMOVE": {
            "method": "BYTEMOVE",
            "category": "memory_operations",
            "type": "method",
            "description": "Copy a specified number of bytes from source to destination in hub RAM.\nHandles overlapping regions correctly (safe for moving data within same buffer).\nAutomatically determines forward or reverse copy direction to prevent data corruption.\n",
            "syntax": "BYTEMOVE(Destination, Source, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to copy.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "small_copy": "~8 + (2 * count) clock cycles",
              "large_copy": "Optimized for larger transfers",
              "overlap_handling": "Automatic, no performance penalty"
            },
            "direction_logic": {
              "forward_copy": "When Dest < Source or Dest >= Source + Count",
              "reverse_copy": "When Dest > Source and Dest < Source + Count",
              "purpose": "Prevents overwriting source data before it's copied"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[100]\n  BYTE backup[100]\n  \nPUB save_buffer()\n  BYTEMOVE(@backup, @buffer, 100)\n",
                "description": "Create backup copy of buffer"
              },
              {
                "code": "' Shift array elements right by 1\nVAR\n  BYTE array[50]\n  \nPUB insert_at_beginning(value)\n  BYTEMOVE(@array[1], @array[0], 49)\n  array[0] := value\n",
                "description": "Insert element at array beginning"
              },
              {
                "code": "' Copy string with length check\nPUB safe_strcopy(dest, source, max_len)\n  len := STRSIZE(source) <# (max_len - 1)\n  BYTEMOVE(dest, source, len)\n  BYTE[dest][len] := 0  ' Null terminate\n",
                "description": "Safe string copy with size limit"
              },
              {
                "code": "' Scroll buffer up one line (80 chars)\nVAR\n  BYTE screen[25][80]\n  \nPUB scroll_up()\n  BYTEMOVE(@screen[0], @screen[1], 24 * 80)\n  BYTEFILL(@screen[24], \" \", 80)\n",
                "description": "Scroll text display"
              },
              {
                "code": "' Extract substring\nPUB substring(dest, source, start, length)\n  BYTEMOVE(dest, source + start, length)\n  BYTE[dest][length] := 0\n",
                "description": "Extract portion of string"
              }
            ],
            "common_uses": [
              "Buffer copying",
              "String manipulation",
              "Array operations",
              "Data structure copying",
              "Screen/display scrolling",
              "Ring buffer management"
            ],
            "overlap_examples": {
              "safe_right_shift": "' Move data 10 bytes to the right\nBYTEMOVE(@buffer[10], @buffer[0], 90)\n' Copies in reverse to prevent corruption\n",
              "safe_left_shift": "' Move data 10 bytes to the left\nBYTEMOVE(@buffer[0], @buffer[10], 90)\n' Copies forward, no overlap issue\n"
            },
            "related_methods": [
              "WORDMOVE - Copy words",
              "LONGMOVE - Copy longs",
              "BYTEFILL - Fill with byte value",
              "BYTECOMP - Compare bytes",
              "BYTESWAP - Swap byte regions"
            ],
            "performance_notes": [
              "Optimized for common cases",
              "Handles alignment automatically",
              "Bulk transfers use efficient hub operations",
              "Small copies have minimal overhead"
            ],
            "notes": [
              "Safe for overlapping regions",
              "Direction chosen automatically",
              "Count of 0 is safe (no operation)",
              "No bounds checking on addresses",
              "Works with any hub RAM location"
            ],
            "warnings": [
              "No automatic null termination for strings",
              "Ensure destination has enough space",
              "Address validation is programmer's responsibility",
              "Cannot copy to/from cog or LUT RAM"
            ],
            "see_also": [
              "language/spin2/methods/wordmove.yaml",
              "language/spin2/methods/longmove.yaml",
              "language/spin2/methods/bytefill.yaml",
              "language/spin2/methods/strsize.yaml"
            ]
          },
          "WAITMS": {
            "method": "WAITMS",
            "category": "timing",
            "type": "method",
            "description": "Delay execution for a specified number of milliseconds.\nProvides a simple timing delay that automatically accounts for the system clock frequency.\nMore convenient than WAITCT for simple delays as it handles the math internally.\n",
            "syntax": "WAITMS(Milliseconds)",
            "parameters": [
              {
                "name": "Milliseconds",
                "type": "long",
                "description": "Number of milliseconds to delay (1-4,294,967 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "accuracy": "Within one system clock tick",
              "resolution": "1 millisecond",
              "calculation": "Uses CLKFREQ/1000 internally",
              "overhead": "Minimal setup overhead (~10 cycles)"
            },
            "examples": [
              {
                "code": "WAITMS(1000)",
                "description": "Delay for 1 second"
              },
              {
                "code": "REPEAT\n  PINHIGH(56)\n  WAITMS(500)\n  PINLOW(56)\n  WAITMS(500)\n",
                "description": "Blink LED at 1Hz"
              },
              {
                "code": "VAR\n  LONG delay_time\nPUB variable_delay()\n  delay_time := 100\n  REPEAT 10\n    PINTOGGLE(56)\n    WAITMS(delay_time)\n    delay_time += 50\n",
                "description": "Variable delay that increases each iteration"
              },
              {
                "code": "' Debounce a button\nIF PINREAD(0)\n  WAITMS(50)  ' Debounce delay\n  IF PINREAD(0)\n    ' Button really pressed\n",
                "description": "Button debouncing"
              }
            ],
            "underlying_implementation": {
              "description": "Internally calculates: WAITX((CLKFREQ/1000) * milliseconds - 1)\nAutomatically adjusts for system clock frequency.\n",
              "related_pasm": "WAITX instruction"
            },
            "common_uses": [
              "LED blinking and indicators",
              "Button debouncing",
              "Timing between operations",
              "Simple animation delays",
              "Sensor reading intervals",
              "Communication protocol delays"
            ],
            "related_methods": [
              "WAITUS - Delay for microseconds",
              "WAITCT - Wait for specific system counter value",
              "GETCT - Get current system counter",
              "POLLCT - Check if counter value passed"
            ],
            "notes": [
              "Blocks execution - cog cannot do other work during delay",
              "Not suitable for precise timing critical operations",
              "Maximum delay ~4,294 seconds (71 minutes)",
              "For delays less than 1ms, use WAITUS",
              "For cycle-accurate timing, use WAITCT",
              "Delay is relative to call time, not absolute"
            ],
            "limitations": [
              "1ms minimum resolution",
              "Blocking operation",
              "Subject to small jitter from hub timing"
            ],
            "see_also": [
              "language/spin2/methods/waitus.yaml",
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/getct.yaml",
              "language/pasm2/waitx.yaml"
            ]
          },
          "COGID": {
            "method": "COGID",
            "category": "cog_management",
            "type": "method",
            "description": "Get the ID number of the currently executing cog.\nReturns a value from 0 to 7 identifying which cog is running this code.\nEssential for cog self-identification and coordination.\n",
            "syntax": "COGID() : CogNum",
            "parameters": "none",
            "returns": {
              "name": "CogNum",
              "type": "long",
              "description": "Current cog's ID number (0-7).\nAlways returns valid cog number.\n"
            },
            "timing": {
              "execution": "2 clock cycles",
              "deterministic": "Yes - always same timing"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE cog_status[8]\n  \nPUB mark_ready()\n  cog_status[COGID()] := 1\n",
                "description": "Mark current cog as ready in status array"
              },
              {
                "code": "PUB self_stop()\n  ' Clean up resources\n  release_pins()\n  ' Stop myself\n  COGSTOP(COGID())\n",
                "description": "Cog self-termination"
              },
              {
                "code": "DAT\n  cog_mailbox LONG 0[8]\n  \nPUB get_my_mailbox() : address\n  address := @cog_mailbox[COGID()]\n",
                "description": "Get mailbox for current cog"
              },
              {
                "code": "PUB debug_print()\n  SEND(\"Cog \", COGID(), \" reporting\", 13)\n",
                "description": "Identify cog in debug output"
              },
              {
                "code": "PUB stop_all_except_me()\n  REPEAT n FROM 0 TO 7\n    IF n <> COGID()\n      COGSTOP(n)\n",
                "description": "Stop all other cogs"
              }
            ],
            "common_uses": [
              "Cog self-identification",
              "Accessing cog-specific data",
              "Debug output identification",
              "Self-termination",
              "Cog coordination",
              "Resource allocation by cog"
            ],
            "related_methods": [
              "COGSTOP - Stop a cog",
              "COGCHK - Check if cog is running",
              "COGINIT - Start PASM in a cog",
              "COGSPIN - Start Spin2 in a cog"
            ],
            "typical_patterns": [
              {
                "pattern": "Per-cog data structures",
                "code": "VAR\n  LONG cog_data[8][10]  ' 10 longs per cog\n  \nPUB my_data() : ptr\n  ptr := @cog_data[COGID()]\n"
              },
              {
                "pattern": "Cog-specific pin assignments",
                "code": "PUB my_led_pin() : pin\n  pin := 56 + COGID()  ' Each cog gets unique LED\n"
              },
              {
                "pattern": "Synchronized startup",
                "code": "VAR\n  BYTE ready_flags\n  \nPUB wait_all_ready()\n  ready_flags |= (1 << COGID())  ' Set my bit\n  REPEAT UNTIL ready_flags == $FF  ' Wait for all 8\n"
              }
            ],
            "notes": [
              "Always returns 0-7, never -1",
              "Cog 0 always starts first at boot",
              "Value doesn't change during cog's lifetime",
              "Can be called from PASM via Spin2",
              "Useful for multicore coordination"
            ],
            "underlying_pasm": {
              "instruction": "COGID",
              "description": "Direct register read of cog ID"
            },
            "see_also": [
              "language/pasm2/cogid.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/cogchk.yaml",
              "architecture/cog.yaml"
            ]
          },
          "PINFLOAT": {
            "method": "PINFLOAT",
            "aliases": [
              "PINF"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Float specified pin(s) to high-impedance state (input mode).\nClears the direction bit(s) to input (DIR=0), releasing the pin from being driven.\nThe pin becomes an input and can be read or driven by external circuitry.\nThis is equivalent to the PASM2 FLTL instruction.\n",
            "syntax": "PINFLOAT(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to float. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINFLOAT(0)",
                "description": "Float pin 0 to high-impedance"
              },
              {
                "code": "PINFLOAT(0 ADDPINS 7)",
                "description": "Float pins 0 through 7 (release bus)"
              },
              {
                "code": "' Charlieplexing example\nPINFLOAT(0 ADDPINS 7)  ' Float all pins first\nPINHIGH(3)             ' Drive one pin high\nPINLOW(0)              ' Drive another low\n' Others remain floating\n",
                "description": "Prepare pins for Charlieplexing LED matrix"
              },
              {
                "code": "' I2C bus release\nPINFLOAT(28 ADDPINS 1)  ' Release SDA and SCL (pins 28, 29)\n",
                "description": "Release I2C bus pins"
              }
            ],
            "underlying_pasm": {
              "instruction": "FLTL",
              "description": "Internally uses FLTL instruction which sets DIR=0"
            },
            "common_uses": [
              "Release shared bus lines",
              "Configure pins as inputs",
              "Charlieplexing LED matrices",
              "Tri-state bus operations",
              "Allow pull-up/pull-down resistors to set level",
              "Switch from output to input mode"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINLOW - Drive pin(s) low",
              "PINTOGGLE - Toggle pin state",
              "PINREAD - Read floating pin state"
            ],
            "notes": [
              "Pin becomes an input and can be read with PINREAD",
              "External pull-up/pull-down resistors will determine the level",
              "Pin will not drive any current in this state",
              "Smart pin modes may still operate while DIR=0",
              "Essential for bidirectional communication protocols",
              "Multiple pins can be floated simultaneously"
            ],
            "see_also": [
              "language/pasm2/fltl.yaml",
              "language/spin2/methods/pinread.yaml",
              "language/spin2/methods/pinhigh.yaml"
            ]
          },
          "PINSTART": {
            "method": "PINSTART",
            "type": "method",
            "description": "Configure and start smart pin with mode and parameters.\nSupports pin groups via ADDPINS operator for parallel operations.\n",
            "category": "Smart Pin Operations",
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive",
            "syntax": "PINSTART(PinField, Mode, Xval, Yval)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression.\nUse ADDPINS to specify multiple consecutive pins:\n- Single pin: 16\n- Pin range: 16 ADDPINS 3 (pins 16-19)\n- Pin group: BASE_PIN ADDPINS (COUNT-1)\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "Smart pin mode configuration (P_* constants)"
              },
              {
                "name": "Xval",
                "type": "long",
                "description": "X parameter for smart pin mode"
              },
              {
                "name": "Yval",
                "type": "long",
                "description": "Y parameter for smart pin mode"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Start ADC on pin 16\nPINSTART(16, P_ADC | P_ADC_1X, 0, 0)\n",
                "description": "Configure pin as ADC input"
              },
              {
                "code": "' Start PWM on pin 8\nPINSTART(8, P_PWM_TRIANGLE, 1000, 500)\n",
                "description": "Configure PWM with period=1000, duty=500"
              },
              {
                "code": "' Start serial TX on pin 62\nPINSTART(62, P_ASYNC_TX | P_OE, clkfreq/115200, 0)\n",
                "description": "Configure asynchronous serial transmit"
              },
              {
                "code": "' Start quadrature encoder on pins 32-33\nPINSTART(32 ADDPINS 1, P_QUADRATURE_A, 0, 0)\n",
                "description": "Configure quadrature encoder input"
              },
              {
                "code": "' HUB75 RGB pin groups for LED panel\nCON\n  RGB_BASE = 16        ' Base pin for RGB data\n  RGB_COUNT = 6        ' 6 pins for RGB (2 per color)\n  CLK_PIN = 22\n  LAT_PIN = 23\n  OE_PIN = 24\n  \nPUB setup_hub75()\n  ' Configure 6 RGB data pins as outputs\n  PINSTART(RGB_BASE ADDPINS (RGB_COUNT-1), P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Configure control pins\n  PINSTART(CLK_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(LAT_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(OE_PIN, P_HIGH_FAST | P_OE, 0, 0)\n",
                "description": "Configure HUB75 LED panel pin groups",
                "source": "hub75_driver"
              },
              {
                "code": "' Multi-pin ADC configuration for sensor array\nCON\n  SENSOR_BASE = 8\n  SENSOR_COUNT = 8      ' 8 sensors\n  \nPUB setup_sensors() | i\n  ' Configure 8 consecutive ADC pins\n  REPEAT i FROM 0 TO SENSOR_COUNT-1\n    PINSTART(SENSOR_BASE + i, P_ADC | P_ADC_1X, 0, 0)\n    \n  ' Or using ADDPINS for group config (same mode)\n  PINSTART(SENSOR_BASE ADDPINS (SENSOR_COUNT-1), P_HIGH_1K5, 0, 0)\n",
                "description": "Configure sensor array pins",
                "source": "sensor_array"
              },
              {
                "code": "' Flash FS SPI pin configuration\nCON\n  SPI_CLK = 56\n  SPI_MOSI = 57\n  SPI_MISO = 58\n  SPI_CS = 59\n  \nPUB setup_spi()\n  ' Configure SPI pins as group\n  PINSTART(SPI_CLK ADDPINS 3, P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Then set specific modes\n  PINSTART(SPI_CLK, P_TRANSITION_OUTPUT, 1, 0)\n  PINSTART(SPI_MOSI, P_SYNC_TX | P_OE, SPI_CLK<<24 | 8, 0)\n  PINSTART(SPI_MISO, P_SYNC_RX, SPI_CLK<<24 | 8, 0)\n",
                "description": "Configure SPI pins for flash filesystem",
                "source": "P2-FLASH-FS"
              }
            ],
            "pin_field_operators": {
              "ADDPINS": {
                "syntax": "base_pin ADDPINS count",
                "description": "Creates a pin field representing consecutive pins.\nThe count is 0-based (use n-1 for n pins).\n",
                "examples": [
                  "16 ADDPINS 0  ' Single pin (16)",
                  "16 ADDPINS 3  ' 4 pins (16-19)",
                  "16 ADDPINS 7  ' 8 pins (16-23)"
                ],
                "use_cases": [
                  "Parallel data buses",
                  "LED arrays",
                  "Sensor arrays",
                  "Multi-bit I/O"
                ]
              }
            },
            "critical_requirement": {
              "reset_before_configure": true,
              "description": "**CRITICAL**: PINSTART automatically resets the smart pin (DIR=0) before configuration.\nThis is REQUIRED to ensure proper smart pin operation. Never skip this reset step.\n",
              "internal_sequence": [
                "DIR[pin] := 0     ' AUTOMATIC: Reset smart pin (REQUIRED)",
                "WRPIN(pin, Mode)  ' Configure smart pin mode",
                "WXPIN(pin, Xval)  ' Set X parameter",
                "WYPIN(pin, Yval)  ' Set Y parameter",
                "DIR[pin] := 1     ' Enable smart pin"
              ]
            },
            "notes": [
              "**CRITICAL**: Automatically performs required DIR=0 reset before configuration",
              "Complete smart pin initialization sequence with proper reset",
              "Mode constants defined in Spin2 (P_ADC, P_PWM_TRIANGLE, etc.)",
              "X and Y parameters are mode-specific",
              "Pin starts operating immediately after DIR=1",
              "Use PINCLEAR to stop and reset smart pin before reconfiguration",
              "ADDPINS allows configuring multiple pins with same mode",
              "NEVER configure a smart pin without first resetting it (DIR=0)"
            ],
            "operations": [
              "DIR[pin] := 0 (reset)",
              "WRPIN(pin, Mode) (set mode)",
              "WXPIN(pin, Xval) (set X parameter)",
              "WYPIN(pin, Yval) (set Y parameter)",
              "DIR[pin] := 1 (enable)"
            ],
            "timing": {
              "description": "Multiple hub operations",
              "cycles": "20-90 clock cycles per pin"
            },
            "related": [
              "PINCLEAR",
              "WRPIN",
              "WXPIN",
              "WYPIN",
              "PINWRITE",
              "PINREAD"
            ],
            "production_patterns": {
              "hub75_panel": {
                "description": "HUB75 RGB LED panel uses pin groups",
                "pattern": "- 6 RGB data pins configured as group\n- Control pins (CLK, LAT, OE) individual\n- Use ADDPINS for efficient setup\n- Parallel output via SETQ/MUXQ\n",
                "source": "hub75_driver"
              },
              "flash_filesystem": {
                "description": "SPI pins for flash access",
                "pattern": "- Configure pins as group first\n- Then specialize each pin's mode\n- Maintains pin locality\n",
                "source": "P2-FLASH-FS"
              }
            },
            "see_also": [
              "Smart pin modes",
              "Smart pin configuration",
              "P2 smart pin constants",
              "concepts/inline_pasm2.yaml"
            ]
          },
          "TASKNEXT": {
            "method": "TASKNEXT",
            "type": "method",
            "description": "Yield control to next task in round-robin schedule\n",
            "category": "Task Operations",
            "syntax": "TASKNEXT()",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Cooperative yield\nrepeat\n  do_work_chunk()\n  TASKNEXT()  ' Let other tasks run\n",
                "description": "Yield after work chunk"
              },
              {
                "code": "' Polling with yield\nrepeat\n  if data_ready\n    process_data()\n  TASKNEXT()  ' Don't hog CPU\n",
                "description": "Polling with cooperation"
              },
              {
                "code": "' Long computation with yields\nrepeat i from 0 to 1000\n  calculate_step(i)\n  if i // 10 == 0\n    TASKNEXT()  ' Yield every 10 iterations\n",
                "description": "Periodic yielding in long loop"
              }
            ],
            "notes": [
              "Voluntary context switch",
              "Enables cooperative multitasking",
              "Current task pauses, next task runs",
              "Returns when task gets control again",
              "Essential for task cooperation",
              "Prevents task starvation"
            ],
            "timing": {
              "description": "Context switch time",
              "cycles": "~20-40 clock cycles"
            },
            "related": [
              "TASKWAIT",
              "TASKSPIN",
              "TASKHALT"
            ],
            "see_also": [
              "Cooperative multitasking",
              "Task scheduling",
              "Context switching"
            ]
          },
          "STRSIZE": {
            "method": "STRSIZE",
            "type": "method",
            "description": "Get length of null-terminated string\n",
            "category": "String Operations",
            "syntax": "length := STRSIZE(StringAddress)",
            "parameters": [
              {
                "name": "StringAddress",
                "type": "address",
                "description": "Address of null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Number of characters (not including null terminator)"
            },
            "examples": [
              {
                "code": "' Get string length\nlen := STRSIZE(@message)\ndebug(\"Message length: \", udec(len))\n",
                "description": "Get string length"
              },
              {
                "code": "' Check if string fits in buffer\nif STRSIZE(@input) < buffer_size\n  STRCOPY(@buffer, @input, buffer_size)\n",
                "description": "Validate before copying"
              },
              {
                "code": "' Calculate total message size\ntotal := STRSIZE(@part1) + STRSIZE(@part2) + 1\n",
                "description": "Calculate combined length"
              }
            ],
            "notes": [
              "Returns character count, not byte count",
              "Does not include null terminator in count",
              "Stops counting at first null (0) byte",
              "Returns 0 for empty string (immediate null)",
              "No maximum length limit",
              "Useful for buffer allocation"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (1 per character) clock cycles"
            },
            "related": [
              "STRCOMP",
              "STRCOPY",
              "STRING"
            ],
            "see_also": [
              "String operations",
              "String measurement",
              "Buffer sizing"
            ]
          },
          "QSIN": {
            "method": "QSIN",
            "type": "method",
            "description": "Calculate sine of angle using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "sine := QSIN(Angle, Length)",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Sine value scaled by Length"
            },
            "examples": [
              {
                "code": "' Calculate sine of 30 degrees\nsine := QSIN($1555_5555, 1000)  ' 30\u00b0 with scale 1000\n' Result: sine \u2248 500\n",
                "description": "Basic sine calculation"
              },
              {
                "code": "' Generate sine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QSIN(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate sine wave plot"
              },
              {
                "code": "' Vertical position for circular motion\ny_pos := center_y + QSIN(angle, radius)\n",
                "description": "Calculate Y position on circle"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0",
              "Result = Length \u00d7 sin(Angle)",
              "Full 32-bit precision",
              "38-clock cycle operation",
              "Handles all quadrants correctly"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QCOS",
              "ROTXY",
              "POLXY"
            ],
            "see_also": [
              "CORDIC operations",
              "Trigonometric functions",
              "Waveform generation"
            ]
          },
          "REGLOAD": {
            "method": "REGLOAD",
            "type": "method",
            "description": "Load PASM2 code from hub to cog registers\n",
            "category": "Miscellaneous",
            "syntax": "REGLOAD(HubAddress)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Load PASM code\nREGLOAD(@pasm_routines)\n' Code now in cog, ready to CALL\n",
                "description": "Load PASM for later execution"
              },
              {
                "code": "' Update PASM code\nmodify_pasm(@buffer)  ' Modify code\nREGLOAD(@buffer)      ' Reload it\nresult := CALL($100)  ' Execute at cog address\n",
                "description": "Dynamic code modification"
              },
              {
                "code": "' Load different routines\nif mode == 1\n  REGLOAD(@fast_routines)\nelse\n  REGLOAD(@accurate_routines)\n",
                "description": "Conditional code loading"
              }
            ],
            "notes": [
              "Loads code but doesn't execute",
              "Use CALL to execute after loading",
              "Overwrites cog registers",
              "Preserves Spin2 interpreter area",
              "Maximum 496 longs can be loaded",
              "Useful for swapping PASM routines"
            ],
            "timing": {
              "description": "Hub to cog transfer",
              "cycles": "~8 + (size * 2) clock cycles"
            },
            "related": [
              "REGEXEC",
              "CALL",
              "SETREGS"
            ],
            "see_also": [
              "Code loading",
              "PASM2 management",
              "Dynamic routines"
            ]
          },
          "LONGSWAP": {
            "method": "LONGSWAP",
            "type": "method",
            "description": "Swap long values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "LONGSWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing long to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing long to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two long values\nLONGSWAP(@value1, @value2)\n",
                "description": "Exchange long values between variables"
              },
              {
                "code": "' Reverse long order in array\nrepeat i from 0 to size/2-1\n  LONGSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using long swapping"
              },
              {
                "code": "' Swap register values\nLONGSWAP(@reg_a, @reg_b)\n",
                "description": "Exchange 32-bit register values"
              }
            ],
            "notes": [
              "Atomically exchanges the 32-bit long values",
              "Both addresses must be long-aligned (addresses divisible by 4)",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange",
              "Each long is 4 bytes"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "BYTESWAP",
              "WORDSWAP",
              "LONGMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation",
              "Register operations"
            ]
          },
          "WORDMOVE": {
            "method": "WORDMOVE",
            "type": "method",
            "description": "Copy words from one memory location to another\n",
            "category": "Memory Operations",
            "syntax": "WORDMOVE(DestAddress, SourceAddress, Count)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM destination starting address for word copy"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Hub RAM source starting address for word copy"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words (16-bit values) to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Copy 100 words from source to destination\nWORDMOVE(@dest_array, @source_array, 100)\n",
                "description": "Copy 100 words between arrays"
              },
              {
                "code": "' Shift array elements up by one word\nWORDMOVE(@array[1], @array[0], 99)\n",
                "description": "Shift array elements with overlap handling"
              }
            ],
            "notes": [
              "Automatically handles overlapping source and destination regions",
              "Copies in appropriate direction to preserve data integrity",
              "Each word is 2 bytes (16 bits)",
              "Addresses must be word-aligned for optimal performance",
              "Count of 0 copies no data"
            ],
            "timing": {
              "description": "Varies based on count and hub timing",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTEMOVE",
              "LONGMOVE",
              "WORDFILL"
            ],
            "see_also": [
              "Memory block operations",
              "Hub RAM access"
            ]
          },
          "LOCKREL": {
            "method": "LOCKREL",
            "type": "method",
            "description": "Release a captured lock\n",
            "category": "Lock Operations",
            "syntax": "LOCKREL(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to release (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Basic lock usage pattern\nrepeat until LOCKTRY(lock_id)\n' Critical section - exclusive access\nmodify_shared_data()\nLOCKREL(lock_id)  ' Release for other cogs\n",
                "description": "Standard lock/unlock pattern"
              },
              {
                "code": "' Ensure lock release on error\nif LOCKTRY(lock_id)\n  result := process_data()\n  LOCKREL(lock_id)\n  if result < 0\n    abort\n",
                "description": "Release lock before error abort"
              },
              {
                "code": "' Multiple lock management\nLOCKREL(resource_a_lock)\nLOCKREL(resource_b_lock)\n",
                "description": "Release multiple locks"
              }
            ],
            "notes": [
              "Releases lock for other cogs to capture",
              "Only the cog that captured can release",
              "Safe to call even if not owner (no-op)",
              "Critical to release locks to prevent deadlock",
              "Lock becomes immediately available",
              "Does not return lock to pool (use LOCKRET for that)"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKTRY",
              "LOCKNEW",
              "LOCKRET",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Critical sections",
              "Resource sharing"
            ]
          },
          "PINTOGGLE": {
            "method": "PINTOGGLE",
            "aliases": [
              "PINT"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive and toggle specified pin(s).\nFirst sets the direction bit(s) to output (DIR=1), then inverts the current output state (OUT^=1).\nIf pin was high, it becomes low. If pin was low, it becomes high.\nThis is equivalent to the PASM2 DRVNOT instruction.\n",
            "syntax": "PINTOGGLE(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to toggle. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINTOGGLE(56)",
                "description": "Toggle pin 56 (LED will change state)"
              },
              {
                "code": "REPEAT\n  PINTOGGLE(56)\n  WAITMS(500)\n",
                "description": "Blink an LED at 1Hz"
              },
              {
                "code": "PINTOGGLE(0 ADDPINS 7)",
                "description": "Toggle pins 0 through 7 simultaneously"
              },
              {
                "code": "VAR\n  LONG status_pins\nPUB flash_status()\n  status_pins := 8 ADDPINS 3  ' Pins 8, 9, 10, 11\n  REPEAT 5\n    PINTOGGLE(status_pins)\n    WAITMS(100)\n",
                "description": "Flash multiple status LEDs"
              }
            ],
            "underlying_pasm": {
              "instruction": "DRVNOT",
              "description": "Internally uses DRVNOT instruction which sets DIR=1 and OUT^=1"
            },
            "common_uses": [
              "Blink LEDs without tracking state",
              "Generate square waves",
              "Toggle clock or strobe signals",
              "Create alternating patterns",
              "Debug output without state management"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINLOW - Drive pin(s) low",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "No need to track current pin state",
              "Multiple pins toggle independently based on their current states",
              "If pin is floating (input), it will first read the input state then toggle from that"
            ],
            "see_also": [
              "language/pasm2/drvnot.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pinlow.yaml"
            ]
          },
          "TASKHALT": {
            "method": "TASKHALT",
            "type": "method",
            "description": "Pause/halt a running task temporarily\n",
            "category": "Task Operations",
            "syntax": "TASKHALT(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to halt (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Pause a task\nTASKHALT(3)  ' Pause task 3\n' Do critical work...\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Pause and resume task"
              },
              {
                "code": "' Pause all tasks for critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKHALT(task_id)\n' Critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKRESUME(task_id)\n",
                "description": "Pause all tasks temporarily"
              },
              {
                "code": "' Conditional task pause\nif buffer_full\n  TASKHALT(producer_task)\n",
                "description": "Pause producer when buffer full"
              }
            ],
            "notes": [
              "Task is paused, not terminated",
              "State and stack preserved",
              "Use TASKRESUME to continue",
              "Task won't execute until resumed",
              "Useful for synchronization",
              "Different from TASKSTOP (which terminates)"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKRESUME",
              "TASKSTOP",
              "TASKSPIN",
              "TASKCHK"
            ],
            "see_also": [
              "Task synchronization",
              "Task pausing",
              "Critical sections"
            ]
          },
          "LONGCOMP": {
            "method": "LONGCOMP",
            "type": "method",
            "description": "Compare blocks of longs in memory\n",
            "category": "Memory Operations",
            "syntax": "result := LONGCOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all longs match, FALSE (0) if any longs differ"
            },
            "examples": [
              {
                "code": "' Compare two long arrays\nif LONGCOMP(@results1, @results2, 256)\n  ' Arrays match (256 longs)\n",
                "description": "Compare long arrays"
              },
              {
                "code": "' Verify calculation results\nif LONGCOMP(@computed, @expected, 32)\n  ' All 32 computed values match expected\n",
                "description": "Verify 32-bit calculation results"
              },
              {
                "code": "' Check for signature pattern\nif LONGCOMP(@header, @valid_signature, 4)\n  ' Found valid 4-long signature\n",
                "description": "Validate header signature"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all longs match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Addresses should be long-aligned (divisible by 4) for best performance",
              "Each long is 32 bits (4 bytes)",
              "Efficient block comparison operation",
              "Native P2 word size for fastest comparison"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTECOMP",
              "WORDCOMP",
              "LONGMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "Array operations",
              "Pattern matching"
            ]
          },
          "RDPIN": {
            "method": "RDPIN",
            "type": "method",
            "description": "Read smart pin result and clear IN flag (acknowledge)\n",
            "category": "Smart Pin Operations",
            "syntax": "result := RDPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "examples": [
              {
                "code": "' Read ADC result from pin 16\nadc_value := RDPIN(16)\n",
                "description": "Read ADC conversion result"
              },
              {
                "code": "' Read pulse width measurement\nwidth := RDPIN(8) & $7FFF_FFFF  ' Mask off C flag\n",
                "description": "Read pulse width, remove C flag"
              },
              {
                "code": "' Check C flag while reading\nvalue := RDPIN(pin)\nif value < 0  ' C flag was set (bit 31)\n  ' Handle C flag condition\n",
                "description": "Read value and check C flag state"
              }
            ],
            "notes": [
              "Clears the smart pin's IN flag after reading",
              "Bit 31 of result contains the pin's C flag state",
              "Lower 31 bits contain the smart pin measurement/result",
              "Reading acknowledges the smart pin, allowing next measurement",
              "Use RQPIN to read without acknowledging",
              "Smart pin must be configured with WRPIN/WXPIN/WYPIN first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RQPIN",
              "AKPIN",
              "WRPIN",
              "WXPIN",
              "WYPIN"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin configuration",
              "Pin I/O operations"
            ]
          },
          "ROTXY": {
            "method": "ROTXY",
            "type": "method",
            "description": "Rotate X,Y coordinates by specified angle using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "X2, Y2 := ROTXY(X, Y, Angle)",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Angle",
                "type": "long",
                "description": "Rotation angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns rotated X2 and Y2 coordinates"
            },
            "examples": [
              {
                "code": "' Rotate point 45 degrees\nx2, y2 := ROTXY(100, 0, $2000_0000)  ' 45\u00b0 = $20000000\n' Result: x2 \u2248 71, y2 \u2248 71\n",
                "description": "Rotate point by 45 degrees"
              },
              {
                "code": "' Animate rotating point\nangle := 0\nrepeat\n  x2, y2 := ROTXY(radius, 0, angle)\n  plot(center_x + x2, center_y + y2)\n  angle += $0100_0000  ' Increment angle\n",
                "description": "Animate point rotating around origin"
              },
              {
                "code": "' Rotate sprite vertices\nrepeat i from 0 to num_vertices-1\n  vx[i], vy[i] := ROTXY(vx[i], vy[i], rotation)\n",
                "description": "Rotate all vertices of a shape"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Full 32-bit precision maintained",
              "Handles all quadrants correctly",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "POLXY",
              "XYPOL",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Coordinate rotation",
              "2D graphics"
            ]
          },
          "SEND": {
            "method": "SEND",
            "type": "method",
            "description": "Send data bytes using configured output method\n",
            "category": "Miscellaneous",
            "syntax": "SEND(DataItems...)",
            "parameters": [
              {
                "name": "DataItems",
                "type": "variable",
                "description": "One or more data items to send (bytes, strings, arrays)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Send single byte\nSEND($41)  ' Send 'A'\n",
                "description": "Send single byte"
              },
              {
                "code": "' Send string\nSEND(STRING(\"Hello, World!\"))\n",
                "description": "Send string constant"
              },
              {
                "code": "' Send multiple items\nSEND($0D, $0A, STRING(\"Ready\"), $0D, $0A)\n",
                "description": "Send mixed data types"
              },
              {
                "code": "' Send array data\nSEND(BYTE[@buffer, 10])  ' Send 10 bytes from buffer\n",
                "description": "Send array contents"
              }
            ],
            "notes": [
              "Output method must be configured first",
              "Typically used with serial drivers",
              "Can send bytes, words, longs, strings, arrays",
              "Blocking operation - waits for each byte",
              "Works with user-defined output methods",
              "Common for debug output"
            ],
            "timing": {
              "description": "Depends on output method",
              "cycles": "Variable based on driver"
            },
            "related": [
              "RECV",
              "DEBUG"
            ],
            "see_also": [
              "Serial communication",
              "Debug output",
              "Data transmission"
            ]
          },
          "CALL": {
            "method": "CALL",
            "type": "method",
            "description": "Call inline PASM2 code from Spin2\n",
            "category": "Miscellaneous",
            "syntax": "result := CALL(PASMAddress)",
            "parameters": [
              {
                "name": "PASMAddress",
                "type": "address",
                "description": "Address of PASM2 code to execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in PASM result register"
            },
            "examples": [
              {
                "code": "' Call inline PASM routine\nresult := CALL(@pasm_code)\n\nDAT\npasm_code\n  mov result1, #42\n  ret\n",
                "description": "Call simple PASM routine"
              },
              {
                "code": "' Pass parameters via PTRA/PTRB\nPTRA := @input_data\nPTRB := @output_buffer\nCALL(@process_data)\n",
                "description": "Call PASM with parameters"
              },
              {
                "code": "' Fast calculation in PASM\nvalue := CALL(@fast_multiply)\n\nDAT\nfast_multiply\n  mov pa, ptra\n  mov pb, ptrb\n  mul pa, pb\n  mov result1, pa\n  ret\n",
                "description": "PASM for fast math"
              }
            ],
            "notes": [
              "Executes PASM2 code in current cog",
              "PASM must end with RET instruction",
              "Parameters passed via PTRA/PTRB registers",
              "Result returned in result1 register",
              "Preserves Spin2 interpreter state",
              "Useful for performance-critical code",
              "PASM code must be in DAT section"
            ],
            "timing": {
              "description": "PASM execution time + call overhead",
              "cycles": "~20 + PASM cycles"
            },
            "related": [
              "REGEXEC",
              "REGLOAD",
              "COGINIT"
            ],
            "see_also": [
              "Inline assembly",
              "PASM2 programming",
              "Performance optimization"
            ]
          },
          "RQPIN": {
            "method": "RQPIN",
            "type": "method",
            "description": "Read smart pin result without clearing IN flag\n",
            "category": "Smart Pin Operations",
            "syntax": "result := RQPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "examples": [
              {
                "code": "' Peek at smart pin value without acknowledging\ncurrent_count := RQPIN(24)\n",
                "description": "Read current value without affecting measurement"
              },
              {
                "code": "' Monitor ADC without clearing ready flag\nif PINREAD(16)  ' Check if new data ready\n  preview := RQPIN(16)  ' Preview value\n  if preview > threshold\n    actual := RDPIN(16)  ' Now acknowledge\n",
                "description": "Preview value before deciding to acknowledge"
              },
              {
                "code": "' Check multiple pins without acknowledging\nrepeat pin from 8 to 15\n  values[pin] := RQPIN(pin)\n",
                "description": "Read multiple smart pins without clearing flags"
              }
            ],
            "notes": [
              "Does NOT clear the smart pin's IN flag",
              "Bit 31 contains the pin's C flag state",
              "Lower 31 bits contain the smart pin measurement/result",
              "Useful for peeking at current value without affecting operation",
              "Pin continues to assert IN flag after RQPIN",
              "Use RDPIN to read and acknowledge",
              "Smart pin must be configured with WRPIN/WXPIN/WYPIN first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RDPIN",
              "AKPIN",
              "WRPIN",
              "PINREAD"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin monitoring",
              "Non-destructive reading"
            ]
          },
          "WAITUS": {
            "method": "WAITUS",
            "category": "timing",
            "type": "method",
            "description": "Delay execution for a specified number of microseconds.\nProvides microsecond-resolution timing delay that automatically accounts for system clock frequency.\nMore precise than WAITMS for short delays.\n",
            "syntax": "WAITUS(Microseconds)",
            "parameters": [
              {
                "name": "Microseconds",
                "type": "long",
                "description": "Number of microseconds to delay (1-4,294,967,295 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "accuracy": "Within one system clock tick",
              "resolution": "1 microsecond (at frequencies >= 1MHz)",
              "calculation": "Uses CLKFREQ/1_000_000 internally",
              "overhead": "Minimal setup overhead (~10 cycles)",
              "minimum_useful": "~2 microseconds at 200MHz"
            },
            "examples": [
              {
                "code": "WAITUS(10)",
                "description": "Delay for 10 microseconds"
              },
              {
                "code": "' Generate 50% duty cycle square wave\nREPEAT\n  PINHIGH(0)\n  WAITUS(10)\n  PINLOW(0)\n  WAITUS(10)\n",
                "description": "50kHz square wave (20\u00b5s period)"
              },
              {
                "code": "' Pulse width generation\nPUB pulse(pin, width_us)\n  PINHIGH(pin)\n  WAITUS(width_us)\n  PINLOW(pin)\n",
                "description": "Generate precise pulse width"
              },
              {
                "code": "' Bit-banged serial timing\nPUB send_bit(value)\n  PINWRITE(TX_PIN, value)\n  WAITUS(104)  ' 9600 baud bit time\n",
                "description": "Serial bit timing at 9600 baud"
              },
              {
                "code": "' I2C clock stretching\nPINHIGH(SCL)\nWAITUS(5)  ' Setup time\ndata := PINREAD(SDA)\nWAITUS(5)  ' Hold time\nPINLOW(SCL)\n",
                "description": "I2C timing compliance"
              }
            ],
            "underlying_implementation": {
              "description": "Internally calculates: WAITX((CLKFREQ/1_000_000) * microseconds - 1)\nAutomatically adjusts for system clock frequency.\nAt lower frequencies, resolution degrades.\n",
              "related_pasm": "WAITX instruction"
            },
            "common_uses": [
              "Pulse width generation",
              "Bit-banged communication protocols",
              "Sensor timing requirements",
              "Setup and hold times",
              "Servo control pulses",
              "Ultrasonic sensor timing",
              "Fine-grained delays"
            ],
            "related_methods": [
              "WAITMS - Delay for milliseconds",
              "WAITCT - Wait for specific system counter value",
              "GETCT - Get current system counter",
              "POLLCT - Check if counter value passed"
            ],
            "notes": [
              "Blocks execution - cog cannot do other work during delay",
              "Resolution limited by clock frequency (1\u00b5s requires \u22651MHz clock)",
              "For delays > 1000\u00b5s, consider using WAITMS",
              "For cycle-accurate timing, use WAITCT",
              "Very short delays may be dominated by overhead",
              "Delay is relative to call time, not absolute"
            ],
            "limitations": [
              "1\u00b5s minimum resolution (at sufficient clock speed)",
              "Blocking operation",
              "Subject to small jitter from hub timing",
              "Resolution degrades at low clock frequencies"
            ],
            "clock_frequency_impact": [
              "200MHz: 1\u00b5s = 200 clocks (excellent resolution)",
              "80MHz: 1\u00b5s = 80 clocks (good resolution)",
              "20MHz: 1\u00b5s = 20 clocks (marginal resolution)",
              "1MHz: 1\u00b5s = 1 clock (poor resolution)"
            ],
            "see_also": [
              "language/spin2/methods/waitms.yaml",
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/getct.yaml",
              "language/pasm2/waitx.yaml"
            ]
          },
          "TASKWAIT": {
            "method": "TASKWAIT",
            "type": "method",
            "description": "Wait for specific condition with task yielding\n",
            "category": "Task Operations",
            "syntax": "TASKWAIT(Condition)",
            "parameters": [
              {
                "name": "Condition",
                "type": "expression",
                "description": "Boolean condition to wait for"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for flag\nTASKWAIT(ready_flag == TRUE)\n' Flag is now true\n",
                "description": "Wait for flag to be set"
              },
              {
                "code": "' Wait for buffer space\nTASKWAIT(buffer_count < MAX_SIZE)\n' Can now add to buffer\n",
                "description": "Wait for buffer availability"
              },
              {
                "code": "' Wait for multiple conditions\nTASKWAIT(data_ready AND not busy_flag)\n' Both conditions met\n",
                "description": "Wait for complex condition"
              }
            ],
            "notes": [
              "Yields to other tasks while waiting",
              "More efficient than busy waiting",
              "Condition checked between yields",
              "Returns when condition becomes true",
              "Prevents CPU hogging during waits",
              "Part of cooperative multitasking"
            ],
            "timing": {
              "description": "Depends on condition",
              "cycles": "Variable - yields while waiting"
            },
            "related": [
              "TASKNEXT",
              "WAITCT",
              "POLLCT"
            ],
            "see_also": [
              "Conditional waiting",
              "Task synchronization",
              "Efficient polling"
            ]
          },
          "QLOG": {
            "method": "QLOG",
            "type": "method",
            "description": "Calculate natural logarithm using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := QLOG(Value)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Input value (unsigned 32-bit)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Natural logarithm in 5.27 fixed-point format"
            },
            "examples": [
              {
                "code": "' Calculate natural log\nln_value := QLOG($1000_0000)  ' ln(0.0625)\n' Result in 5.27 fixed-point format\n",
                "description": "Basic logarithm calculation"
              },
              {
                "code": "' Calculate log base 10\nlog10_value := QLOG(value) * 39457 >> 17  ' Convert ln to log10\n",
                "description": "Convert natural log to log base 10"
              },
              {
                "code": "' Audio decibel calculation\ndb := QLOG(amplitude) * 1717 >> 12  ' 20*log10(amplitude)\n",
                "description": "Calculate decibels from amplitude"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Input range: 0.0625 to 2.0 (in unsigned 32-bit format)",
              "Result is natural logarithm (base e)",
              "Output in 5.27 fixed-point format",
              "38-clock cycle operation",
              "For values outside range, scale appropriately"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QEXP",
              "MULDIV64"
            ],
            "see_also": [
              "CORDIC operations",
              "Logarithmic functions",
              "Fixed-point math"
            ]
          },
          "STRCOMP": {
            "method": "STRCOMP",
            "type": "method",
            "description": "Compare two null-terminated strings\n",
            "category": "String Operations",
            "syntax": "result := STRCOMP(StringAddress1, StringAddress2)",
            "parameters": [
              {
                "name": "StringAddress1",
                "type": "address",
                "description": "Address of first null-terminated string"
              },
              {
                "name": "StringAddress2",
                "type": "address",
                "description": "Address of second null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if strings match, FALSE (0) if different"
            },
            "examples": [
              {
                "code": "' Compare two strings\nif STRCOMP(@input, STRING(\"hello\"))\n  ' Strings match\n",
                "description": "Basic string comparison"
              },
              {
                "code": "' Command parsing\nif STRCOMP(@command, STRING(\"QUIT\"))\n  quit_program()\nelseif STRCOMP(@command, STRING(\"HELP\"))\n  show_help()\n",
                "description": "Parse command strings"
              },
              {
                "code": "' Password check\nif STRCOMP(@entered_pass, @stored_pass)\n  ' Grant access\n  access_granted := TRUE\n",
                "description": "Validate password"
              }
            ],
            "notes": [
              "Case-sensitive comparison",
              "Stops at first null terminator (0)",
              "Returns TRUE (-1) for exact match",
              "Returns FALSE (0) for any difference",
              "Both strings must be null-terminated",
              "No length limit except available memory"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (2 per character) clock cycles"
            },
            "related": [
              "STRCOPY",
              "STRSIZE",
              "STRING",
              "BYTECOMP"
            ],
            "see_also": [
              "String operations",
              "String comparison",
              "Null-terminated strings"
            ]
          },
          "HUBSET": {
            "method": "HUBSET",
            "type": "method",
            "description": "Execute HUBSET instruction for low-level hub configuration\n",
            "category": "Miscellaneous",
            "syntax": "HUBSET(Value)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit configuration value for hub"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Enable debug output\nHUBSET($F0)  ' Enable debug pins\n",
                "description": "Configure debug pins"
              },
              {
                "code": "' Set clock mode bits\nHUBSET(clkmode_bits)\n",
                "description": "Direct clock configuration"
              },
              {
                "code": "' Reset specific hub feature\nHUBSET(config & !$100)  ' Clear bit 8\n",
                "description": "Modify hub configuration"
              }
            ],
            "notes": [
              "Low-level hub configuration",
              "Directly executes HUBSET instruction",
              "Affects global chip configuration",
              "Use CLKSET for safe clock changes",
              "Requires understanding of hub config bits",
              "Can affect all cogs",
              "Use with caution"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "CLKSET",
              "COGSTOP",
              "COGINIT"
            ],
            "see_also": [
              "Hub configuration",
              "Low-level control",
              "System configuration"
            ]
          },
          "SIZEOF": {
            "method": "SIZEOF",
            "type": "method",
            "description": "Get size of structure or data type in bytes\n",
            "category": "Miscellaneous",
            "syntax": "size := SIZEOF(Structure)",
            "parameters": [
              {
                "name": "Structure",
                "type": "structure_name",
                "description": "Name of structure defined in CON section"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Size in bytes of the structure"
            },
            "examples": [
              {
                "code": "CON\n  ' Define structure\n  POINT = LONG[2]  ' X, Y coordinates\n\nPUB main()\n  size := SIZEOF(POINT)  ' Returns 8 (2 longs * 4 bytes)\n",
                "description": "Get structure size"
              },
              {
                "code": "CON\n  ' Complex structure\n  HEADER = LONG + WORD[4] + BYTE[16]\n\nVAR\n  BYTE buffer[SIZEOF(HEADER)]\n",
                "description": "Allocate buffer for structure"
              },
              {
                "code": "CON\n  ' Nested structures\n  VECTOR3 = LONG[3]\n  MATRIX3 = VECTOR3[3]\n\nPUB get_size()\n  return SIZEOF(MATRIX3)  ' Returns 36 (9 longs * 4)\n",
                "description": "Size of nested structure"
              }
            ],
            "notes": [
              "Structures defined in CON section",
              "Returns total byte count",
              "Accounts for data type sizes (BYTE=1, WORD=2, LONG=4)",
              "Useful for buffer allocation",
              "Compile-time evaluation",
              "Works with arrays and nested structures"
            ],
            "timing": {
              "description": "Compile-time constant",
              "cycles": "N/A - resolved at compile time"
            },
            "related": [
              "BYTE",
              "WORD",
              "LONG"
            ],
            "see_also": [
              "Structure definitions",
              "CON section",
              "Memory allocation"
            ]
          },
          "LOCKRET": {
            "method": "LOCKRET",
            "type": "method",
            "description": "Return allocated lock to available pool\n",
            "category": "Lock Operations",
            "syntax": "LOCKRET(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to return (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Return lock when done\nLOCKRET(lock_id)\n",
                "description": "Free a lock"
              },
              {
                "code": "' Cleanup in stop method\nPUB stop()\n  if lock_id >= 0\n    LOCKRET(lock_id)\n    lock_id := -1\n",
                "description": "Clean shutdown with lock release"
              },
              {
                "code": "' Return multiple locks\nrepeat i from 0 to num_locks-1\n  LOCKRET(locks[i])\n",
                "description": "Free multiple locks"
              }
            ],
            "notes": [
              "Returns lock to available pool",
              "Lock must have been allocated with LOCKNEW",
              "Automatically releases lock if captured",
              "Safe to call even if lock not captured",
              "Important to return locks to prevent exhaustion",
              "No error if invalid lock ID"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKNEW",
              "LOCKTRY",
              "LOCKREL",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Resource cleanup",
              "Lock management"
            ]
          },
          "TASKID": {
            "method": "TASKID",
            "type": "method",
            "description": "Get the current task's ID\n",
            "category": "Task Operations",
            "syntax": "id := TASKID()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Current task ID (0-31)"
            },
            "examples": [
              {
                "code": "' Get current task ID\nmy_id := TASKID()\ndebug(\"Running as task \", udec(my_id))\n",
                "description": "Display current task ID"
              },
              {
                "code": "' Task-specific behavior\ncase TASKID()\n  0: main_task_work()\n  1: worker1_work()\n  2: worker2_work()\n",
                "description": "Task-specific execution"
              },
              {
                "code": "' Store task ID for later\nVAR\n  LONG task_ids[32]\n\ntask_ids[TASKID()] := GETCT()  ' Store start time\n",
                "description": "Track task timing"
              }
            ],
            "notes": [
              "Returns ID of currently executing task",
              "Main task is typically ID 0",
              "Useful for task-specific storage/behavior",
              "Each task has unique ID 0-31",
              "ID remains constant for task lifetime"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKCHK",
              "TASKSPIN",
              "COGID"
            ],
            "see_also": [
              "Task identification",
              "Task management",
              "Task-local storage"
            ]
          },
          "LOCKCHK": {
            "method": "LOCKCHK",
            "type": "method",
            "description": "Check lock state and ownership without affecting it\n",
            "category": "Lock Operations",
            "syntax": "state := LOCKCHK(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to check (0..15)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Lock state: bit 31 = captured flag, bits 3:0 = owner cog ID"
            },
            "examples": [
              {
                "code": "' Check if lock is free\nstate := LOCKCHK(lock_id)\nif state < 0  ' Bit 31 set\n  ' Lock is captured\n  owner := state & $F  ' Get owner cog\n",
                "description": "Check lock availability"
              },
              {
                "code": "' Verify we own the lock\nstate := LOCKCHK(lock_id)\nif (state & $F) == COGID()\n  ' We own this lock\n",
                "description": "Verify lock ownership"
              },
              {
                "code": "' Debug lock status\nstate := LOCKCHK(lock_id)\nif state < 0\n  debug(\"Lock captured by cog \", udec(state & $F))\nelse\n  debug(\"Lock is free\")\n",
                "description": "Display lock status"
              }
            ],
            "notes": [
              "Non-destructive read of lock state",
              "Bit 31: 1 = captured, 0 = free",
              "Bits 3:0: Cog ID of owner (if captured)",
              "Does not affect lock state",
              "Useful for debugging and monitoring",
              "Can check any lock without owning it"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKTRY",
              "LOCKREL",
              "LOCKNEW",
              "COGID"
            ],
            "see_also": [
              "Hardware locks",
              "Lock debugging",
              "Lock monitoring"
            ]
          },
          "GETREGS": {
            "method": "GETREGS",
            "type": "method",
            "description": "Copy cog registers to hub RAM\n",
            "category": "Miscellaneous",
            "syntax": "GETREGS(HubAddress, CogAddress, Count)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM destination address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Save cog registers\nVAR\n  LONG saved_regs[16]\n\nGETREGS(@saved_regs, $1F0, 16)  ' Save $1F0-$1FF\n",
                "description": "Save cog register state"
              },
              {
                "code": "' Debug cog registers\nVAR\n  LONG cog_dump[512]\n\nGETREGS(@cog_dump, 0, 512)  ' Dump entire cog\n",
                "description": "Complete cog memory dump"
              },
              {
                "code": "' Read PASM variables\nVAR\n  LONG pasm_vars[10]\n\nGETREGS(@pasm_vars, $100, 10)  ' Get PASM data\n",
                "description": "Read PASM variables from cog"
              }
            ],
            "notes": [
              "Copies from cog RAM to hub RAM",
              "Cog addresses are 0-511 (2KB)",
              "Each register is 32 bits (1 long)",
              "Useful for debugging PASM code",
              "Can read interpreter registers",
              "Count must not exceed remaining registers"
            ],
            "timing": {
              "description": "Hub transfer operation",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "SETREGS",
              "REGLOAD",
              "REGEXEC"
            ],
            "see_also": [
              "Cog memory access",
              "Register debugging",
              "PASM interaction"
            ]
          },
          "TASKCHK": {
            "method": "TASKCHK",
            "type": "method",
            "description": "Check if a task is running\n",
            "category": "Task Operations",
            "syntax": "result := TASKCHK(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to check (0-31)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if task is running, FALSE (0) if not"
            },
            "examples": [
              {
                "code": "' Check if task is running\nif TASKCHK(5)\n  ' Task 5 is active\n",
                "description": "Check single task status"
              },
              {
                "code": "' Count active tasks\ncount := 0\nrepeat task_id from 0 to 31\n  if TASKCHK(task_id)\n    count++\n",
                "description": "Count running tasks"
              },
              {
                "code": "' Wait for task to finish\nrepeat while TASKCHK(worker_task)\n  TASKNEXT()  ' Yield while waiting\n",
                "description": "Wait for task completion"
              }
            ],
            "notes": [
              "Non-destructive status check",
              "Returns TRUE for running or halted tasks",
              "Returns FALSE for stopped/unused tasks",
              "Useful for task monitoring",
              "Can check any task ID 0-31"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKID",
              "TASKSPIN",
              "TASKSTOP"
            ],
            "see_also": [
              "Task monitoring",
              "Task status",
              "Task management"
            ]
          },
          "TASKSTOP": {
            "method": "TASKSTOP",
            "type": "method",
            "description": "Stop and terminate a running task\n",
            "category": "Task Operations",
            "syntax": "TASKSTOP(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to stop (0-31) or THISTASK (-1) for current"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Stop specific task\nTASKSTOP(2)  ' Stop task ID 2\n",
                "description": "Stop task by ID"
              },
              {
                "code": "' Task stops itself\nPUB background_task()\n  repeat\n    if shutdown_flag\n      TASKSTOP(THISTASK)  ' Stop self\n",
                "description": "Task self-termination"
              },
              {
                "code": "' Stop all tasks except main\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKSTOP(task_id)\n",
                "description": "Stop all secondary tasks"
              }
            ],
            "notes": [
              "Immediately terminates the task",
              "Task's stack space can be reused",
              "THISTASK (-1) stops current task",
              "Main task (ID 0) typically shouldn't stop",
              "No cleanup - task stops immediately",
              "Task ID becomes available for reuse"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKSPIN",
              "TASKHALT",
              "TASKRESUME",
              "TASKCHK"
            ],
            "see_also": [
              "Task termination",
              "Task management",
              "Resource cleanup"
            ]
          },
          "WORDFILL": {
            "method": "WORDFILL",
            "type": "method",
            "description": "Fill memory with a repeated word value\n",
            "category": "Memory Operations",
            "syntax": "WORDFILL(DestAddress, Value, Count)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM starting address to begin filling"
              },
              {
                "name": "Value",
                "type": "word",
                "description": "16-bit word value to fill with"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to fill"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Clear a word array to zero\nWORDFILL(@buffer, 0, 256)\n",
                "description": "Clear 256 words to zero"
              },
              {
                "code": "' Initialize array with pattern\nWORDFILL(@data, $FFFF, 100)\n",
                "description": "Fill 100 words with $FFFF"
              },
              {
                "code": "' Set default values\nWORDFILL(@settings, $1234, 50)\n",
                "description": "Initialize settings array with default value"
              }
            ],
            "notes": [
              "Fills memory efficiently using hub operations",
              "Each word is 2 bytes (16 bits)",
              "Address should be word-aligned for best performance",
              "Count of 0 fills no memory",
              "Only lower 16 bits of Value are used"
            ],
            "timing": {
              "description": "Varies based on count and hub timing",
              "cycles": "~8 + count clock cycles typical"
            },
            "related": [
              "BYTEFILL",
              "LONGFILL",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory initialization",
              "Hub RAM operations"
            ]
          },
          "POLLATN": {
            "method": "POLLATN",
            "type": "method",
            "description": "Check for attention signal without blocking\n",
            "category": "COG Management",
            "syntax": "result := POLLATN()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if ATN signal received, FALSE (0) if not"
            },
            "examples": [
              {
                "code": "' Non-blocking check for signal\nif POLLATN()\n  ' ATN signal received\n  process_signal()\n",
                "description": "Check for signal without blocking"
              },
              {
                "code": "' Main loop with signal handling\nrepeat\n  do_main_work()\n  if POLLATN()\n    handle_interrupt()\n",
                "description": "Interruptible main loop"
              },
              {
                "code": "' Timeout waiting for ATN\ntimeout := GETCT() + clkfreq\nrepeat\n  if POLLATN()\n    ' Got signal\n    quit\n  if POLLCT(timeout)\n    ' Timeout - no signal\n    return FALSE\n",
                "description": "ATN wait with timeout"
              }
            ],
            "notes": [
              "Non-blocking alternative to WAITATN",
              "Returns immediately with TRUE/FALSE",
              "Clears ATN flag if it was set",
              "Another cog uses COGATN to send the signal",
              "Useful for cooperative multitasking",
              "Can be used in main loop for interrupt-like behavior"
            ],
            "timing": {
              "description": "Immediate return",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "WAITATN",
              "COGATN",
              "POLLCT"
            ],
            "see_also": [
              "Cog communication",
              "Non-blocking operations",
              "Inter-cog signaling"
            ]
          },
          "XYPOL": {
            "method": "XYPOL",
            "type": "method",
            "description": "Convert Cartesian coordinates to polar using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "Rho, Theta := XYPOL(X, Y)",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate (32-bit signed)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns Rho (radius) and Theta (angle)"
            },
            "examples": [
              {
                "code": "' Convert Cartesian to polar\nrho, theta := XYPOL(100, 100)  \n' Result: rho \u2248 141, theta \u2248 $2000_0000 (45\u00b0)\n",
                "description": "Basic Cartesian to polar conversion"
              },
              {
                "code": "' Calculate distance and angle to target\ndx := target_x - current_x\ndy := target_y - current_y\ndistance, angle := XYPOL(dx, dy)\n",
                "description": "Find distance and direction to target"
              },
              {
                "code": "' Convert joystick X,Y to magnitude and direction\nmagnitude, direction := XYPOL(joy_x - 128, joy_y - 128)\nif magnitude > threshold\n  move_player(direction, magnitude)\n",
                "description": "Process joystick input"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Rho (radius) is always positive",
              "Theta covers full 360\u00b0 range based on quadrant",
              "Handles all four quadrants correctly",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "POLXY",
              "ROTXY",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Polar coordinates",
              "Coordinate conversion",
              "Distance calculation"
            ]
          },
          "BYTE": {
            "method": "BYTE",
            "type": "method",
            "description": "Declare byte data or access byte-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: BYTE [Count]\nAccess: BYTE[BaseAddress][Index]\nInline: BYTE(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label BYTE Value1 {, Value2, ...}",
                "description": "Declare byte data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name BYTE [Count]",
                "description": "Declare byte variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "BYTE[Address][Index]",
                "description": "Access byte at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "BYTE(Value1, Value2, ...)",
                "description": "Create inline byte sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_bytes  BYTE  $FF, $00, $55, $AA\n",
                "description": "Declare byte data in DAT section"
              },
              {
                "code": "VAR\n  buffer  BYTE[256]  ' 256-byte array\n",
                "description": "Declare byte array in VAR section"
              },
              {
                "code": "' Write byte to hub memory\nBYTE[$1000] := $42\n\n' Read byte from hub memory  \nvalue := BYTE[$1000]\n",
                "description": "Direct hub memory byte access"
              },
              {
                "code": "' Send byte sequence\nsend(BYTE($48, $65, $6C, $6C, $6F))  ' \"Hello\"\n",
                "description": "Inline byte data creation"
              }
            ],
            "notes": [
              "BYTE is 8 bits (0-255 unsigned, -128 to 127 signed)",
              "Hub memory is byte-addressable",
              "Arrays are zero-indexed",
              "Can use @ operator to get address of byte variable",
              "Alignment is automatic in VAR section"
            ],
            "related": [
              "WORD",
              "LONG",
              "BYTEFILL",
              "BYTEMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "WXPIN": {
            "method": "WXPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the X parameter register of one or more smart pins.\nThe X register typically controls timing, frequency, or configuration parameters.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "syntax": "WXPIN(PinField, XValue)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "XValue",
                "type": "long",
                "description": "32-bit value for X register.\nInterpretation depends on smart pin mode:\n- Timing periods for serial modes\n- Frequency values for NCO modes\n- Configuration bits for special modes\n"
              }
            ],
            "returns": "none",
            "x_register_usage_by_mode": {
              "serial_modes": "Baud rate timing:\nX = (CLKFREQ / baud_rate) - 1\n",
              "pwm_modes": "PWM period:\nX = period_in_clocks - 1\n",
              "nco_modes": "Frequency value:\nX = frequency * (2^32 / CLKFREQ)\n",
              "measurement": "Measurement window:\nX = measurement_period_clocks\n"
            },
            "examples": [
              {
                "code": "' Set UART baud rate to 115200\nbaud := 115200\nx_val := CLKFREQ / baud - 1\nWXPIN(30, x_val)\n",
                "description": "Configure UART baud rate"
              },
              {
                "code": "' Set PWM period to 1000 clocks\nWXPIN(56, 999)  ' 1000 - 1\n",
                "description": "Set PWM period"
              },
              {
                "code": "' Configure 1MHz NCO frequency\nfreq := 1_000_000\nx_val := freq * ($8000_0000 / (CLKFREQ / 2))\nWXPIN(pin, x_val)\n",
                "description": "Set NCO frequency"
              },
              {
                "code": "' Set measurement window to 1 second\nWXPIN(pin, CLKFREQ)\n",
                "description": "Configure measurement period"
              },
              {
                "code": "' Configure 16-bit SPI transfer\nWXPIN(spi_pin, %1_00111)  ' 16 bits, MSB first\n",
                "description": "SPI configuration"
              }
            ],
            "mode_specific_x_values": {
              "P_ASYNC_TX": "Bit period for transmit",
              "P_ASYNC_RX": "Bit period for receive",
              "P_PULSE": "High time period",
              "P_TRANSITION": "Transition period",
              "P_NCO_FREQ": "Frequency value",
              "P_NCO_DUTY": "Base period",
              "P_PWM_TRIANGLE": "Frame period",
              "P_PWM_SAWTOOTH": "Frame period",
              "P_QUADRATURE": "Filter period",
              "P_COUNT_RISES": "Measurement period",
              "P_COUNT_HIGHS": "Measurement period"
            },
            "calculation_examples": {
              "uart_baud": "' Calculate for any baud rate\nPUB set_baud(pin, baud)\n  x := CLKFREQ / baud - 1\n  WXPIN(pin, x)\n  \n",
              "pwm_frequency": "' Set PWM by frequency\nPUB set_pwm_freq(pin, freq)\n  x := CLKFREQ / freq - 1\n  WXPIN(pin, x)\n  \n",
              "measurement_time": "' Set measurement in milliseconds\nPUB set_measure_ms(pin, ms)\n  x := CLKFREQ / 1000 * ms\n  WXPIN(pin, x)\n"
            },
            "common_uses": [
              "Setting baud rates",
              "Configuring PWM periods",
              "Setting NCO frequencies",
              "Defining measurement windows",
              "Protocol timing configuration"
            ],
            "related_methods": [
              "WRPIN - Set smart pin mode",
              "WYPIN - Set Y parameter",
              "RDPIN - Read and acknowledge",
              "RQPIN - Read without acknowledge",
              "PINSTART - Complete setup"
            ],
            "timing_considerations": [
              "X value takes effect on next period",
              "Can be changed while pin is active",
              "Some modes latch X at specific times",
              "Check mode documentation for specifics"
            ],
            "notes": [
              "X register is mode-dependent",
              "Usually represents timing or period",
              "32-bit value allows wide range",
              "Can be updated during operation",
              "Value interpretation varies by mode"
            ],
            "warnings": [
              "Must set correct mode first with WRPIN",
              "Zero may disable some functions",
              "Very small values may not work",
              "Check mode limits in documentation"
            ],
            "see_also": [
              "language/spin2/methods/wrpin.yaml",
              "language/spin2/methods/wypin.yaml",
              "language/spin2/methods/rdpin.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "TASKRESUME": {
            "method": "TASKRESUME",
            "type": "method",
            "description": "Resume a halted task\n",
            "category": "Task Operations",
            "syntax": "TASKRESUME(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to resume (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Resume paused task\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Resume single task"
              },
              {
                "code": "' Synchronized resume\nTASKHALT(worker1)\nTASKHALT(worker2)\nprepare_data()\nTASKRESUME(worker1)\nTASKRESUME(worker2)\n",
                "description": "Synchronized task resumption"
              },
              {
                "code": "' Conditional resume\nif not buffer_full\n  TASKRESUME(producer_task)\n",
                "description": "Resume producer when buffer has space"
              }
            ],
            "notes": [
              "Resumes task halted with TASKHALT",
              "Task continues from where it was halted",
              "All state preserved during halt",
              "No effect if task not halted",
              "Also called TASKCONT in some docs",
              "Part of cooperative multitasking"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKHALT",
              "TASKSPIN",
              "TASKSTOP",
              "TASKCHK"
            ],
            "see_also": [
              "Task synchronization",
              "Task resumption",
              "Cooperative multitasking"
            ]
          },
          "PINWRITE": {
            "method": "PINWRITE",
            "aliases": [
              "PINW"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) with data pattern.\nSets the direction bit(s) to output (DIR=1) and writes the data pattern to the pins (OUT=data).\nWhen multiple pins are specified, the data is written to them in parallel.\nLower bits of data correspond to lower-numbered pins in the field.\n",
            "syntax": "PINWRITE(PinField, Data)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Data",
                "type": "long",
                "description": "Data to write to the pins:\n- For single pin: 0 = low, non-zero = high\n- For multiple pins: Each bit maps to a pin\n- Bit 0 of data \u2192 lowest pin in field\n- Bit n of data \u2192 nth pin in field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINWRITE(56, 1)",
                "description": "Write high to pin 56"
              },
              {
                "code": "PINWRITE(56, 0)",
                "description": "Write low to pin 56"
              },
              {
                "code": "PINWRITE(0 ADDPINS 7, %10101010)",
                "description": "Write alternating pattern to pins 0-7"
              },
              {
                "code": "PINWRITE(7..0, $FF)",
                "description": "Write all high to pins 0-7 (reversed range)"
              },
              {
                "code": "VAR\n  BYTE pattern\nPUB animate()\n  pattern := %00000001\n  REPEAT 8\n    PINWRITE(0 ADDPINS 7, pattern)\n    pattern <<= 1\n    WAITMS(100)\n",
                "description": "Animate a moving bit pattern"
              },
              {
                "code": "' Write 4-bit value to pins 12-15\nvalue := 9  ' Binary 1001\nPINWRITE(12 ADDPINS 3, value)\n' Pin 12 = 1, Pin 13 = 0, Pin 14 = 0, Pin 15 = 1\n",
                "description": "Write multi-bit value to pin group"
              }
            ],
            "underlying_pasm": {
              "instructions": [
                "DIRH/DIRL",
                "OUTH/OUTL"
              ],
              "description": "Sets direction bits and output bits based on data"
            },
            "common_uses": [
              "Parallel data output",
              "LED pattern displays",
              "Bus data transmission",
              "7-segment display control",
              "Setting multiple control lines simultaneously",
              "Binary counter displays"
            ],
            "related_methods": [
              "PINREAD - Read data from pins",
              "PINHIGH - Drive all specified pins high",
              "PINLOW - Drive all specified pins low",
              "PINTOGGLE - Toggle pin states"
            ],
            "notes": [
              "All specified pins become outputs",
              "Overrides any smart pin modes on the pins",
              "Data is masked to the number of pins in field",
              "Unspecified bits in data are ignored",
              "Atomic operation - all pins change simultaneously",
              "Pin field order matters for multi-pin operations"
            ],
            "see_also": [
              "language/spin2/methods/pinread.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pinlow.yaml"
            ]
          },
          "GETMS": {
            "method": "GETMS",
            "type": "method",
            "description": "Get milliseconds elapsed since system boot\n",
            "category": "Timing Operations",
            "syntax": "ms := GETMS()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Milliseconds since boot (32-bit value)"
            },
            "examples": [
              {
                "code": "' Measure elapsed time\nstart_ms := GETMS()\n' Do some work...\nelapsed := GETMS() - start_ms\ndebug(\"Elapsed: \", udec(elapsed), \" ms\")\n",
                "description": "Measure operation duration"
              },
              {
                "code": "' Simple timeout\ntimeout_ms := GETMS() + 5000  ' 5 second timeout\nrepeat while GETMS() < timeout_ms\n  if check_condition()\n    quit\n",
                "description": "Implement millisecond timeout"
              },
              {
                "code": "' Display uptime\nms := GETMS()\nseconds := ms / 1000\nminutes := seconds / 60\nhours := minutes / 60\ndebug(\"Uptime: \", udec(hours), \":\", udec(minutes//60), \":\", udec(seconds//60))\n",
                "description": "Calculate and display system uptime"
              }
            ],
            "notes": [
              "Based on system counter divided by clkfreq/1000",
              "32-bit value wraps after ~49.7 days",
              "Resolution depends on clock frequency",
              "Less precise than GETCT for short intervals",
              "Good for human-scale timing (UI, timeouts)",
              "Handles clock frequency changes automatically"
            ],
            "timing": {
              "description": "Immediate calculation",
              "cycles": "~20-30 clock cycles"
            },
            "related": [
              "GETSEC",
              "GETCT",
              "WAITMS"
            ],
            "see_also": [
              "Time measurement",
              "System uptime",
              "Millisecond timing"
            ]
          },
          "GETSEC": {
            "method": "GETSEC",
            "type": "method",
            "description": "Get seconds elapsed since system boot\n",
            "category": "Timing Operations",
            "syntax": "seconds := GETSEC()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Seconds since boot (32-bit value)"
            },
            "examples": [
              {
                "code": "' Display uptime in seconds\ndebug(\"System uptime: \", udec(GETSEC()), \" seconds\")\n",
                "description": "Show system uptime"
              },
              {
                "code": "' Long-running timer\nstart_sec := GETSEC()\n' ... much later ...\nelapsed_sec := GETSEC() - start_sec\ndebug(\"Process ran for \", udec(elapsed_sec), \" seconds\")\n",
                "description": "Measure long durations"
              },
              {
                "code": "' Periodic task every 10 seconds\nnext_run := GETSEC() + 10\nrepeat\n  if GETSEC() >= next_run\n    do_periodic_task()\n    next_run += 10\n",
                "description": "Schedule periodic tasks"
              }
            ],
            "notes": [
              "Based on system counter divided by clkfreq",
              "32-bit value wraps after ~136 years",
              "1-second resolution",
              "Good for long-duration timing",
              "More convenient than GETMS for human-readable times",
              "Handles clock frequency changes automatically"
            ],
            "timing": {
              "description": "Immediate calculation",
              "cycles": "~20-30 clock cycles"
            },
            "related": [
              "GETMS",
              "GETCT",
              "WAITMS"
            ],
            "see_also": [
              "Time measurement",
              "System uptime",
              "Long-duration timing"
            ]
          },
          "BYTECOMP": {
            "method": "BYTECOMP",
            "type": "method",
            "description": "Complement bytes within a long value",
            "category": "Memory Operations",
            "syntax": "result := BYTECOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all bytes match, FALSE (0) if any bytes differ"
            },
            "examples": [
              {
                "code": "' Compare two strings\nif BYTECOMP(@string1, @string2, 10)\n  ' First 10 bytes match\n",
                "description": "Compare fixed-length byte sequences"
              },
              {
                "code": "' Verify buffer contents\nif BYTECOMP(@buffer, @expected, 256)\n  ' Buffer matches expected data\n",
                "description": "Verify buffer against expected values"
              },
              {
                "code": "' Check for pattern\nif BYTECOMP(@data[offset], @pattern, 4)\n  ' Found 4-byte pattern at offset\n",
                "description": "Search for byte pattern in data"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all bytes match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Efficient block comparison operation",
              "Case-sensitive byte-by-byte comparison"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + count clock cycles typical"
            },
            "related": [
              "WORDCOMP",
              "LONGCOMP",
              "STRCOMP",
              "BYTEMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "String operations",
              "Pattern matching"
            ]
          },
          "WYPIN": {
            "method": "WYPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the Y parameter register of one or more smart pins.\nThe Y register typically holds data to transmit, duty cycle values, or count values.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "syntax": "WYPIN(PinField, YValue)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "YValue",
                "type": "long",
                "description": "32-bit value for Y register.\nInterpretation depends on smart pin mode:\n- Data byte/word/long for serial modes\n- Duty cycle for PWM modes\n- Count value for pulse modes\n"
              }
            ],
            "returns": "none",
            "y_register_usage_by_mode": {
              "serial_modes": "Data to transmit:\nY[7:0] = byte to send (UART)\nY[15:0] = word to send (sync serial)\nY[31:0] = long to send (32-bit modes)\n",
              "pwm_modes": "Duty cycle value:\nY = high_time (0 to X value)\n",
              "pulse_modes": "Number of pulses/cycles:\nY = pulse count\n",
              "dac_modes": "Output level:\nY[15:0] = 16-bit DAC value\n"
            },
            "examples": [
              {
                "code": "' Send byte via UART\nWYPIN(30, \"A\")  ' Send character 'A'\n",
                "description": "UART transmit character"
              },
              {
                "code": "' Set 50% PWM duty cycle\nperiod := 1000\nWXPIN(56, period - 1)\nWYPIN(56, period / 2)  ' 50% duty\n",
                "description": "Set PWM duty cycle"
              },
              {
                "code": "' Output 10 pulses\nWYPIN(pin, 10)\n",
                "description": "Generate pulse burst"
              },
              {
                "code": "' Set DAC to mid-level\nWYPIN(dac_pin, $8000)  ' 16-bit mid-scale\n",
                "description": "Set DAC output level"
              },
              {
                "code": "' Send 32-bit SPI data\nWYPIN(spi_pin, data_long)\n",
                "description": "SPI data transmission"
              }
            ],
            "mode_specific_y_values": {
              "P_ASYNC_TX": "Byte to transmit (bits 7:0)",
              "P_ASYNC_RX": "Not used for receive",
              "P_PULSE": "Number of pulses",
              "P_TRANSITION": "Number of transitions",
              "P_NCO_FREQ": "Not used",
              "P_NCO_DUTY": "High time value",
              "P_PWM_TRIANGLE": "Duty cycle (0 to X)",
              "P_PWM_SAWTOOTH": "Duty cycle (0 to X)",
              "P_DAC_DITHER": "16-bit DAC value",
              "P_REPOSITORY": "32-bit value to store"
            },
            "data_transmission": {
              "uart_send": "PUB send_byte(pin, data)\n  WYPIN(pin, data)\n  REPEAT UNTIL RDPIN(pin) & $100  ' Wait for completion\n  \n",
              "pwm_update": "PUB set_duty_percent(pin, percent)\n  period := X_VALUE  ' Previously set with WXPIN\n  duty := period * percent / 100\n  WYPIN(pin, duty)\n  \n",
              "burst_output": "PUB send_burst(pin, count)\n  WYPIN(pin, count)\n  ' Pin outputs 'count' pulses\n"
            },
            "common_uses": [
              "Transmitting serial data",
              "Setting PWM duty cycles",
              "Controlling DAC output",
              "Generating pulse counts",
              "Updating output values"
            ],
            "smart_pin_data_flow": {
              "write": "WYPIN writes to Y register",
              "process": "Smart pin uses Y based on mode",
              "status": "Check completion with RDPIN",
              "next": "Write new value to Y for next operation"
            },
            "related_methods": [
              "WRPIN - Set smart pin mode",
              "WXPIN - Set X parameter",
              "RDPIN - Read and acknowledge",
              "RQPIN - Read without acknowledge",
              "AKPIN - Acknowledge smart pin"
            ],
            "notes": [
              "Y register is mode-dependent",
              "Usually represents data or count",
              "Writing Y often triggers operation",
              "Can be updated during operation",
              "Some modes auto-reload from Y"
            ],
            "timing_notes": [
              "Write takes effect based on mode",
              "Serial modes: starts transmission",
              "PWM modes: updates on next cycle",
              "Pulse modes: starts immediately"
            ],
            "warnings": [
              "Must set correct mode first with WRPIN",
              "Writing Y may trigger immediate action",
              "Check if previous operation complete",
              "Some modes have Y value limits"
            ],
            "see_also": [
              "language/spin2/methods/wrpin.yaml",
              "language/spin2/methods/wxpin.yaml",
              "language/spin2/methods/rdpin.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "AKPIN": {
            "method": "AKPIN",
            "type": "method",
            "description": "Acknowledge smart pin by clearing its IN flag\n",
            "category": "Smart Pin Operations",
            "syntax": "AKPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Acknowledge smart pin after processing\nvalue := RQPIN(16)  ' Read without acknowledge\nprocess(value)      ' Process the value\nAKPIN(16)          ' Now acknowledge\n",
                "description": "Separate read and acknowledge operations"
              },
              {
                "code": "' Clear multiple smart pin flags\nrepeat pin from 0 to 7\n  AKPIN(pin)\n",
                "description": "Acknowledge multiple smart pins"
              },
              {
                "code": "' Reset smart pin for next measurement\nif error_condition\n  AKPIN(sensor_pin)  ' Clear flag to restart\n",
                "description": "Clear flag to reset measurement"
              }
            ],
            "notes": [
              "Clears the smart pin's IN flag",
              "Allows smart pin to begin next measurement/operation",
              "Equivalent to the acknowledge part of RDPIN without reading",
              "Useful when you've already read with RQPIN",
              "Can acknowledge multiple pins using pin field ranges",
              "Smart pin must be configured and have IN flag set"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RDPIN",
              "RQPIN",
              "WRPIN",
              "PINREAD"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin acknowledgment",
              "Pin flag management"
            ]
          },
          "WAITCT": {
            "method": "WAITCT",
            "type": "method",
            "description": "Wait until system counter reaches specified tick value\n",
            "category": "Timing Operations",
            "syntax": "WAITCT(Tick)",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for specific time\ntarget := GETCT() + clkfreq/10  ' 100ms from now\nWAITCT(target)\n",
                "description": "Wait for precise timing point"
              },
              {
                "code": "' Create periodic loop\nnext_time := GETCT()\nrepeat\n  next_time += clkfreq/1000  ' 1ms period\n  WAITCT(next_time)\n  ' Do periodic task\n",
                "description": "Precise periodic timing"
              },
              {
                "code": "' Synchronize multiple cogs\nsync_time := GETCT() + clkfreq\nWAITCT(sync_time)  ' All cogs wait for same time\n",
                "description": "Multi-cog synchronization"
              }
            ],
            "notes": [
              "Blocks execution until system counter matches Tick value",
              "System counter wraps every ~53 seconds at 80MHz",
              "More precise than WAITMS/WAITUS for exact timing",
              "Handles counter wraparound correctly",
              "Use GETCT() to read current counter value",
              "Resolution is 1 system clock cycle"
            ],
            "timing": {
              "description": "Waits until exact counter match",
              "cycles": "Variable based on target tick"
            },
            "related": [
              "GETCT",
              "POLLCT",
              "WAITMS",
              "WAITUS"
            ],
            "see_also": [
              "System counter",
              "Precise timing",
              "Synchronization"
            ]
          },
          "QEXP": {
            "method": "QEXP",
            "type": "method",
            "description": "Calculate exponential (e^x) using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := QEXP(Exponent)",
            "parameters": [
              {
                "name": "Exponent",
                "type": "long",
                "description": "Exponent value in 5.27 fixed-point format"
              }
            ],
            "returns": {
              "type": "long",
              "description": "e^x result (unsigned 32-bit)"
            },
            "examples": [
              {
                "code": "' Calculate e^1\nresult := QEXP($0800_0000)  ' e^1 in 5.27 format\n' Result \u2248 2.71828...\n",
                "description": "Basic exponential calculation"
              },
              {
                "code": "' Calculate power of 10\npower10 := QEXP(x * 22713 >> 13)  ' 10^x using e^(x*ln(10))\n",
                "description": "Calculate powers of 10"
              },
              {
                "code": "' Exponential growth/decay\nvalue := initial * QEXP(rate * time >> 10) >> 22\n",
                "description": "Model exponential growth"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Input in 5.27 fixed-point format",
              "Input range: -2.77 to 0.69 (in 5.27 format)",
              "Result is e^exponent",
              "Output range: 0.0625 to 2.0",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QLOG",
              "MULDIV64"
            ],
            "see_also": [
              "CORDIC operations",
              "Exponential functions",
              "Fixed-point math"
            ]
          },
          "STRING": {
            "method": "STRING",
            "type": "method",
            "description": "Create string constant and return its address\n",
            "category": "String Operations",
            "syntax": "address := STRING(StringLiteral)",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of null-terminated string"
            },
            "examples": [
              {
                "code": "' Get address of string constant\nmsg_addr := STRING(\"Hello, World!\")\n",
                "description": "Create string constant"
              },
              {
                "code": "' Pass string to method\nsend_message(STRING(\"Error: File not found\"))\n",
                "description": "Pass string directly to method"
              },
              {
                "code": "' Use in comparison\nif STRCOMP(@input, STRING(\"YES\"))\n  proceed()\n",
                "description": "Compare with string constant"
              },
              {
                "code": "' Build menu options\noption1 := STRING(\"1. Start\")\noption2 := STRING(\"2. Settings\")\noption3 := STRING(\"3. Quit\")\n",
                "description": "Create menu strings"
              }
            ],
            "notes": [
              "Creates null-terminated string in hub RAM",
              "String is stored in DAT section",
              "Returns starting address of string",
              "Automatically adds null terminator",
              "Escape sequences supported (\\n, \\t, etc.)",
              "Multiple identical strings may share storage",
              "Read-only string constant"
            ],
            "timing": {
              "description": "Immediate - compile time",
              "cycles": "2-9 clock cycles to load address"
            },
            "related": [
              "LSTRING",
              "STRCOMP",
              "STRCOPY",
              "BYTE"
            ],
            "see_also": [
              "String constants",
              "String operations",
              "DAT section"
            ]
          },
          "PINREAD": {
            "method": "PINREAD",
            "aliases": [
              "PINR"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Read the current state of specified pin(s).\nReads the input register (IN) for the specified pins regardless of their direction.\nReturns the pin states as a value where each bit represents a pin's state.\nFor single pin: returns 0 or 1. For multiple pins: returns multi-bit value.\n",
            "syntax": "PINREAD(PinField) : PinStates",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to read. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": {
              "name": "PinStates",
              "type": "long",
              "description": "Current state of the pin(s):\n- Single pin: 0 (low) or 1 (high)\n- Multiple pins: Each bit represents a pin\n- Bit 0 = lowest numbered pin in field\n- Bit n = nth pin in field\n"
            },
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "IF PINREAD(0)\n  ' Pin 0 is high\nELSE\n  ' Pin 0 is low\n",
                "description": "Read single pin as boolean"
              },
              {
                "code": "buttons := PINREAD(0 ADDPINS 7)",
                "description": "Read 8 buttons into a byte"
              },
              {
                "code": "' Read 4-bit DIP switch\nsetting := PINREAD(12 ADDPINS 3)\n' Returns 0-15 based on switch positions\n",
                "description": "Read multi-bit value from pins"
              },
              {
                "code": "' Wait for button press (active high)\nREPEAT UNTIL PINREAD(8)\n' Button is now pressed\n",
                "description": "Poll for pin state change"
              },
              {
                "code": "' Read and decode 3-bit address\naddress := PINREAD(5..3)\nCASE address\n  0: handle_device_0()\n  1: handle_device_1()\n  2..7: handle_others()\n",
                "description": "Read and decode pin pattern"
              }
            ],
            "underlying_pasm": {
              "instruction": "TESTP",
              "description": "Internally uses TESTP or direct IN register read"
            },
            "common_uses": [
              "Read button and switch states",
              "Monitor sensor outputs",
              "Read parallel data input",
              "Check communication line states",
              "Decode address or selection pins",
              "Poll for signal changes"
            ],
            "related_methods": [
              "PINWRITE - Write data to pins",
              "PINFLOAT - Set pins to input mode",
              "AKPIN - Acknowledge smart pin",
              "RDPIN - Read smart pin result"
            ],
            "notes": [
              "Works regardless of pin direction (input or output)",
              "When reading output pins, returns the driven state",
              "Does not affect pin configuration",
              "Can read pins configured as smart pins",
              "Atomic read - all pins sampled simultaneously",
              "No debouncing - returns instantaneous state"
            ],
            "see_also": [
              "language/pasm2/testp.yaml",
              "language/spin2/methods/pinwrite.yaml",
              "language/spin2/methods/pinfloat.yaml",
              "language/spin2/methods/rdpin.yaml"
            ]
          },
          "BYTESWAP": {
            "method": "BYTESWAP",
            "type": "method",
            "description": "Swap byte values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "BYTESWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing byte to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing byte to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two byte values\nBYTESWAP(@value1, @value2)\n",
                "description": "Exchange byte values between variables"
              },
              {
                "code": "' Reverse byte order in array\nrepeat i from 0 to size/2-1\n  BYTESWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using byte swapping"
              },
              {
                "code": "' Swap bytes at specific hub addresses\nBYTESWAP($1000, $2000)\n",
                "description": "Exchange bytes at hub memory locations"
              }
            ],
            "notes": [
              "Atomically exchanges the byte values",
              "Both addresses must be valid hub RAM locations",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "WORDSWAP",
              "LONGSWAP",
              "BYTEMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation"
            ]
          },
          "RECV": {
            "method": "RECV",
            "type": "method",
            "description": "Receive data byte using configured input method\n",
            "category": "Miscellaneous",
            "syntax": "byte := RECV()",
            "parameters": [],
            "returns": {
              "type": "byte",
              "description": "Received byte value (0-255)"
            },
            "examples": [
              {
                "code": "' Receive single byte\nchar := RECV()\n",
                "description": "Receive one byte"
              },
              {
                "code": "' Build string from input\nrepeat i from 0 to 79\n  buffer[i] := RECV()\n  if buffer[i] == 13  ' Enter key\n    buffer[i] := 0\n    quit\n",
                "description": "Receive string until Enter"
              },
              {
                "code": "' Echo received data\nrepeat\n  byte_in := RECV()\n  SEND(byte_in)\n",
                "description": "Echo loop"
              },
              {
                "code": "' Wait for specific character\nrepeat until RECV() == \"!\"\n' Got start character\n",
                "description": "Wait for start marker"
              }
            ],
            "notes": [
              "Input method must be configured first",
              "Typically used with serial drivers",
              "Blocking operation - waits for byte",
              "Returns single byte (0-255)",
              "Works with user-defined input methods",
              "Common for user input and data reception"
            ],
            "timing": {
              "description": "Depends on input method",
              "cycles": "Variable - blocks until data available"
            },
            "related": [
              "SEND",
              "DEBUG"
            ],
            "see_also": [
              "Serial communication",
              "User input",
              "Data reception"
            ]
          },
          "WORD": {
            "method": "WORD",
            "type": "method",
            "description": "Declare word data or access word-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: WORD [Count]\nAccess: WORD[BaseAddress][Index]\nInline: WORD(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label WORD Value1 {, Value2, ...}",
                "description": "Declare word data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name WORD [Count]",
                "description": "Declare word variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "WORD[Address][Index]",
                "description": "Access word at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "WORD(Value1, Value2, ...)",
                "description": "Create inline word sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_words  WORD  $1234, $5678, $ABCD\n",
                "description": "Declare word data in DAT section"
              },
              {
                "code": "VAR\n  samples  WORD[1024]  ' 1024-word array\n",
                "description": "Declare word array in VAR section"
              },
              {
                "code": "' Write word to hub memory\nWORD[$2000] := $1234\n\n' Read word from hub memory  \nvalue := WORD[$2000]\n",
                "description": "Direct hub memory word access"
              },
              {
                "code": "' Process word sequence\nprocess(WORD($1000, $2000, $3000))\n",
                "description": "Inline word data creation"
              }
            ],
            "notes": [
              "WORD is 16 bits (0-65535 unsigned, -32768 to 32767 signed)",
              "Word addresses must be word-aligned (even addresses)",
              "Arrays are zero-indexed",
              "Each array index represents 2 bytes in memory",
              "Can use @ operator to get address of word variable"
            ],
            "related": [
              "BYTE",
              "LONG",
              "WORDFILL",
              "WORDMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "TASKSPIN": {
            "method": "TASKSPIN",
            "type": "method",
            "description": "Start a new Spin2 task within the current cog\n",
            "category": "Task Operations",
            "syntax": "TASKSPIN(TaskID, Method({Parameters}), StackAddress)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID (0-31) or NEWTASK (-1) for next available"
              },
              {
                "name": "Method",
                "type": "method",
                "description": "Spin2 method to run as task with optional parameters"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Address of stack space for the task"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Start a new task\nVAR\n  LONG task_stack[64]\n\nTASKSPIN(NEWTASK, background_process(), @task_stack)\n",
                "description": "Start background task"
              },
              {
                "code": "' Start specific task ID\nTASKSPIN(2, sensor_monitor(16, 1000), @sensor_stack)\n",
                "description": "Start task with ID 2"
              },
              {
                "code": "' Multiple tasks\nTASKSPIN(NEWTASK, task1(), @stack1)\nTASKSPIN(NEWTASK, task2(), @stack2)\nTASKSPIN(NEWTASK, task3(), @stack3)\n",
                "description": "Start multiple tasks"
              }
            ],
            "notes": [
              "Up to 32 tasks per cog (v47+ feature)",
              "Tasks share cog but have separate stacks",
              "Cooperative multitasking within cog",
              "NEWTASK (-1) auto-assigns next available ID",
              "Stack size depends on task complexity",
              "Tasks run in round-robin fashion"
            ],
            "timing": {
              "description": "Task switching overhead",
              "cycles": "~20-40 clock cycles per switch"
            },
            "related": [
              "TASKSTOP",
              "TASKHALT",
              "TASKRESUME",
              "TASKCHK"
            ],
            "see_also": [
              "Cooperative multitasking",
              "Task management",
              "Stack allocation"
            ]
          },
          "LONG": {
            "method": "LONG",
            "type": "method",
            "description": "Declare long data or access long-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: LONG [Count]\nAccess: LONG[BaseAddress][Index]\nInline: LONG(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label LONG Value1 {, Value2, ...}",
                "description": "Declare long data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name LONG [Count]",
                "description": "Declare long variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "LONG[Address][Index]",
                "description": "Access long at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "LONG(Value1, Value2, ...)",
                "description": "Create inline long sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_longs  LONG  $12345678, $DEADBEEF, 1_000_000\n",
                "description": "Declare long data in DAT section"
              },
              {
                "code": "VAR\n  results  LONG[512]  ' 512-long array\n",
                "description": "Declare long array in VAR section"
              },
              {
                "code": "' Write long to hub memory\nLONG[$4000] := $12345678\n\n' Read long from hub memory  \nvalue := LONG[$4000]\n",
                "description": "Direct hub memory long access"
              },
              {
                "code": "' Pass long sequence to method\ncalculate(LONG(100_000, 200_000, 300_000))\n",
                "description": "Inline long data creation"
              }
            ],
            "notes": [
              "LONG is 32 bits (full range of P2 native word size)",
              "Long addresses must be long-aligned (addresses divisible by 4)",
              "Arrays are zero-indexed",
              "Each array index represents 4 bytes in memory",
              "Can use @ operator to get address of long variable",
              "Default data type for most P2 operations"
            ],
            "related": [
              "BYTE",
              "WORD",
              "LONGFILL",
              "LONGMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "WORDCOMP": {
            "method": "WORDCOMP",
            "type": "method",
            "description": "Complement words within a long value",
            "category": "Memory Operations",
            "syntax": "result := WORDCOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all words match, FALSE (0) if any words differ"
            },
            "examples": [
              {
                "code": "' Compare two word arrays\nif WORDCOMP(@array1, @array2, 100)\n  ' Arrays match (100 words)\n",
                "description": "Compare word arrays"
              },
              {
                "code": "' Verify sensor data\nif WORDCOMP(@readings, @expected, 64)\n  ' All 64 sensor readings match expected\n",
                "description": "Verify 16-bit sensor data"
              },
              {
                "code": "' Check for word pattern\nif WORDCOMP(@data[i], @signature, 4)\n  ' Found 4-word signature at position i\n",
                "description": "Search for word pattern in data"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all words match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Addresses should be word-aligned for best performance",
              "Each word is 16 bits (2 bytes)",
              "Efficient block comparison operation"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTECOMP",
              "LONGCOMP",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "Array operations",
              "Pattern matching"
            ]
          },
          "COGCHK": {
            "method": "COGCHK",
            "category": "cog_management",
            "type": "method",
            "description": "Check if a specified cog is currently running.\nReturns -1 if the cog is running, or 0 if it's stopped.\nNon-invasive check that doesn't affect the cog's operation.\n",
            "syntax": "COGCHK(CogNum) : Running",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to check (0-7).\nValues outside 0-7 return 0.\n"
              }
            ],
            "returns": {
              "name": "Running",
              "type": "long",
              "description": "- -1 (TRUE): Cog is running\n- 0 (FALSE): Cog is stopped or invalid number\n"
            },
            "timing": {
              "execution": "2-8 clock cycles",
              "non_blocking": "Yes - doesn't wait or stall"
            },
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB ensure_driver_running()\n  IF NOT COGCHK(driver_cog)\n    driver_cog := COGINIT(NEWCOG, @driver, 0)\n",
                "description": "Restart driver if not running"
              },
              {
                "code": "PUB wait_for_cog_stop(n)\n  REPEAT WHILE COGCHK(n)\n    WAITMS(10)\n",
                "description": "Wait for cog to stop"
              },
              {
                "code": "PUB count_running_cogs() : count\n  count := 0\n  REPEAT n FROM 0 TO 7\n    IF COGCHK(n)\n      count++\n",
                "description": "Count how many cogs are running"
              },
              {
                "code": "PUB find_free_cog() : cog_num\n  REPEAT cog_num FROM 0 TO 7\n    IF NOT COGCHK(cog_num)\n      RETURN\n  RETURN -1  ' All cogs busy\n",
                "description": "Find first available cog"
              },
              {
                "code": "PUB monitor_cog_health()\n  REPEAT\n    IF NOT COGCHK(critical_cog)\n      ' Critical cog crashed!\n      handle_error()\n      restart_critical_cog()\n    WAITMS(100)\n",
                "description": "Monitor critical cog health"
              }
            ],
            "common_uses": [
              "Health monitoring",
              "Resource availability checking",
              "Graceful shutdown verification",
              "Startup synchronization",
              "Error detection",
              "Dynamic cog allocation"
            ],
            "return_value_usage": {
              "as_boolean": "IF COGCHK(n)      ' If running\nIF NOT COGCHK(n)  ' If stopped\n",
              "in_expressions": "running_count += COGCHK(n) & 1\nstatus := COGCHK(n) ? \"Running\" : \"Stopped\"\n"
            },
            "related_methods": [
              "COGID - Get current cog ID",
              "COGSTOP - Stop a cog",
              "COGINIT - Start PASM in a cog",
              "COGSPIN - Start Spin2 in a cog"
            ],
            "notes": [
              "Non-invasive - doesn't affect checked cog",
              "Can check current cog (always returns -1)",
              "Invalid cog numbers return 0 (stopped)",
              "Cannot determine what cog is running",
              "Just checks running/stopped state"
            ],
            "best_practices": [
              "Check before stopping to avoid unnecessary operations",
              "Verify startup success after COGINIT/COGSPIN",
              "Monitor critical cogs periodically",
              "Use for graceful shutdown sequences"
            ],
            "typical_patterns": [
              {
                "pattern": "Safe cog stop",
                "code": "IF COGCHK(n)\n  COGSTOP(n)\n"
              },
              {
                "pattern": "Wait for startup",
                "code": "cog := COGINIT(NEWCOG, @code, 0)\nREPEAT UNTIL COGCHK(cog)\n"
              },
              {
                "pattern": "Restart on failure",
                "code": "IF NOT COGCHK(driver_cog)\n  driver_cog := restart_driver()\n"
              }
            ],
            "see_also": [
              "language/spin2/methods/cogid.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/coginit.yaml"
            ]
          },
          "LOOKDOWN": {
            "method": "LOOKDOWN",
            "type": "method",
            "description": "Find 1-based index of value in list\n",
            "category": "Lookup Operations",
            "syntax": "index := LOOKDOWN(Value : Match1, Match2, ..., MatchN)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "1-based index of match, or 0 if not found"
            },
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWN(30 : 10, 20, 30, 40, 50)\n' Returns 3 (30 is 3rd item)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Character classification\ntype := LOOKDOWN(char : \"A\"..\"Z\", \"a\"..\"z\", \"0\"..\"9\")\n' Returns 1 for uppercase, 2 for lowercase, 3 for digit\n",
                "description": "Classify character type"
              },
              {
                "code": "' Command parsing\ncmd := LOOKDOWN(value : $01, $02, $04, $08, $10)\ncase cmd\n  1: handle_read()\n  2: handle_write()\n  3: handle_status()\n",
                "description": "Map value to command index"
              }
            ],
            "notes": [
              "Returns 1-based index (1 = first match)",
              "Returns 0 if value not found",
              "Supports ranges with .. operator",
              "Searches left to right, returns first match",
              "Inverse operation of LOOKUP",
              "Useful for classification and mapping"
            ],
            "related": [
              "LOOKDOWNZ",
              "LOOKUP",
              "LOOKUPZ"
            ],
            "see_also": [
              "Value searching",
              "Classification",
              "Reverse lookup"
            ]
          },
          "LONGMOVE": {
            "method": "LONGMOVE",
            "category": "memory_operations",
            "type": "method",
            "description": "Copy a specified number of longs (32-bit values) from source to destination in hub RAM.\nHandles overlapping regions correctly with automatic direction detection.\nMore efficient than BYTEMOVE for long-aligned data.\n",
            "syntax": "LONGMOVE(Destination, Source, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to copy (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "timing": {
              "aligned": "~8 + (count * 4) clock cycles",
              "misaligned": "Additional overhead for alignment",
              "optimization": "Uses 32-bit transfers when possible"
            },
            "examples": [
              {
                "code": "VAR\n  LONG data[100]\n  LONG backup[100]\n  \nPUB save_data()\n  LONGMOVE(@backup, @data, 100)\n",
                "description": "Backup array of longs"
              },
              {
                "code": "' Copy cog parameters\nDAT\n  params    LONG  0[8]\n  \nPUB setup_cog_params(src_params)\n  LONGMOVE(@params, src_params, 8)\n  COGINIT(NEWCOG, @cog_code, @params)\n",
                "description": "Copy parameter block for cog"
              },
              {
                "code": "' Shift array elements\nVAR\n  LONG array[50]\n  \nPUB remove_first()\n  result := array[0]\n  LONGMOVE(@array[0], @array[1], 49)\n  array[49] := 0\n",
                "description": "Remove first element, shift rest"
              },
              {
                "code": "' Copy structure\nVAR\n  LONG config[10]\n  LONG default_config[10]\n  \nPUB reset_config()\n  LONGMOVE(@config, @default_config, 10)\n",
                "description": "Reset configuration to defaults"
              },
              {
                "code": "' Stack manipulation\nVAR\n  LONG stack[64]\n  LONG stack_backup[64]\n  \nPUB save_stack_state()\n  LONGMOVE(@stack_backup, @stack, 64)\n",
                "description": "Save stack for debugging"
              }
            ],
            "common_uses": [
              "Array copying",
              "Parameter block transfer",
              "Structure copying",
              "Stack operations",
              "Buffer management",
              "Data structure initialization"
            ],
            "performance_benefits": {
              "vs_bytemove": "' BYTEMOVE for 100 longs (400 bytes)\nBYTEMOVE(@dest, @source, 400)  ' ~808 cycles\n\n' LONGMOVE for 100 longs\nLONGMOVE(@dest, @source, 100)  ' ~408 cycles\n' Nearly 2x faster for aligned data\n"
            },
            "alignment_impact": {
              "aligned": "Fastest - direct 32-bit transfers",
              "misaligned": "Works but requires byte-by-byte for edges",
              "recommendation": "Always align long data on 4-byte boundaries"
            },
            "related_methods": [
              "BYTEMOVE - Copy bytes",
              "WORDMOVE - Copy words",
              "LONGFILL - Fill with long value",
              "LONGCOMP - Compare longs",
              "LONGSWAP - Swap long regions"
            ],
            "notes": [
              "Count is in longs, not bytes",
              "Safe for overlapping regions",
              "Direction chosen automatically",
              "Alignment affects performance only",
              "Works with any hub RAM location"
            ],
            "conversion_note": "Bytes to longs: divide by 4\n100 bytes = 25 longs\nBYTEMOVE(@dest, @src, 100) equals\nLONGMOVE(@dest, @src, 25)\n",
            "warnings": [
              "Count is LONGS not BYTES",
              "Ensure destination has enough space",
              "Misalignment degrades performance",
              "Cannot copy to/from cog or LUT RAM directly"
            ],
            "see_also": [
              "language/spin2/methods/bytemove.yaml",
              "language/spin2/methods/wordmove.yaml",
              "language/spin2/methods/longfill.yaml"
            ]
          },
          "WORDSWAP": {
            "method": "WORDSWAP",
            "type": "method",
            "description": "Swap word values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "WORDSWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing word to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing word to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two word values\nWORDSWAP(@value1, @value2)\n",
                "description": "Exchange word values between variables"
              },
              {
                "code": "' Reverse word order in array\nrepeat i from 0 to size/2-1\n  WORDSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using word swapping"
              },
              {
                "code": "' Swap words for endian conversion\nWORDSWAP(@data[0], @data[1])\n",
                "description": "Swap words for byte order conversion"
              }
            ],
            "notes": [
              "Atomically exchanges the 16-bit word values",
              "Both addresses must be word-aligned (even addresses)",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange",
              "Each word is 2 bytes"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "BYTESWAP",
              "LONGSWAP",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation",
              "Endian conversion"
            ]
          },
          "LSTRING": {
            "method": "LSTRING",
            "type": "method",
            "description": "Create length-prefixed string constant\n",
            "category": "String Operations",
            "syntax": "address := LSTRING(StringLiteral)",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of length-prefixed string"
            },
            "examples": [
              {
                "code": "' Create length-prefixed string\nlstr := LSTRING(\"Hello, World!\")\n' First byte contains 13 (length)\n",
                "description": "Create length-prefixed string"
              },
              {
                "code": "' Read length-prefixed string\nlen := BYTE[lstr_addr]\nrepeat i from 1 to len\n  char := BYTE[lstr_addr][i]\n",
                "description": "Process length-prefixed string"
              },
              {
                "code": "' Send length-prefixed string\naddr := LSTRING(\"Command\")\nsend_bytes(addr, BYTE[addr] + 1)  ' Length + data\n",
                "description": "Send with length byte"
              }
            ],
            "notes": [
              "First byte contains string length",
              "String data follows length byte",
              "No null terminator added",
              "Maximum length is 255 characters",
              "Useful for binary protocols",
              "More efficient than null-terminated for known-length strings",
              "Stored in DAT section"
            ],
            "timing": {
              "description": "Immediate - compile time",
              "cycles": "2-9 clock cycles to load address"
            },
            "related": [
              "STRING",
              "BYTE",
              "STRSIZE"
            ],
            "see_also": [
              "Length-prefixed strings",
              "Binary protocols",
              "String formats"
            ]
          },
          "WRPIN": {
            "method": "WRPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the mode configuration register of one or more smart pins.\nSets up the smart pin operating mode, input sources, and output options.\nThis is the primary method for configuring smart pin functionality.\n",
            "syntax": "WRPIN(PinField, Mode)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "32-bit mode configuration value:\n- Bits 31-24: Filter/output options\n- Bits 23-16: Input selector B\n- Bits 15-8: Input selector A\n- Bits 7-6: Low level control\n- Bits 5-0: Smart pin mode (0-63)\n"
              }
            ],
            "returns": "none",
            "mode_register_format": {
              "bits_31_24": "Filter and output options:\n- Bit 31: Enable digital filter\n- Bit 30-28: Filter length\n- Bit 27-26: Output drive options\n",
              "bits_23_16": "Input B selector:\n- Relative pin selection (-3 to +3)\n- Special input sources\n",
              "bits_15_8": "Input A selector:\n- Relative pin selection (-3 to +3)\n- Special input sources\n",
              "bits_5_0": "Smart pin mode (0-63):\n- 00000: OFF (normal I/O)\n- 00001-11111: Various smart modes\n"
            },
            "examples": [
              {
                "code": "' Configure pin for UART TX (async serial)\nmode := %0000_0000_000_0000000000000_01_00111\nWRPIN(30, mode)\n",
                "description": "Setup UART transmit mode"
              },
              {
                "code": "' Configure for PWM output\nmode := %0000_0000_000_0000000000000_01_01001\nWRPIN(56, mode)\n",
                "description": "Setup PWM mode"
              },
              {
                "code": "' Configure quadrature encoder\nmode := %0000_0001_000_0000000000000_00_01011\nWRPIN(0, mode)\n",
                "description": "Setup quadrature decoder"
              },
              {
                "code": "' Configure ADC mode\nmode := %0000_0000_000_0000000000000_11_10011\nWRPIN(pin, mode)\n",
                "description": "Setup ADC conversion mode"
              },
              {
                "code": "' Reset to normal I/O\nWRPIN(pin, 0)\n",
                "description": "Disable smart pin mode"
              }
            ],
            "common_smart_modes": {
              "P_NORMAL": "%00000 - Normal I/O",
              "P_REPOSITORY": "%00001 - Long repository",
              "P_DAC_NOISE": "%00010 - DAC noise",
              "P_DAC_DITHER": "%00011 - DAC with dither",
              "P_PULSE": "%00100 - Pulse/cycle output",
              "P_TRANSITION": "%00101 - Transition output",
              "P_NCO_FREQ": "%00110 - NCO frequency",
              "P_NCO_DUTY": "%00111 - NCO duty",
              "P_PWM_TRIANGLE": "%01000 - PWM triangle",
              "P_PWM_SAWTOOTH": "%01001 - PWM sawtooth",
              "P_ASYNC_TX": "%00111 - Async serial transmit",
              "P_ASYNC_RX": "%01000 - Async serial receive",
              "P_QUADRATURE": "%01011 - Quadrature decode"
            },
            "smart_pin_workflow": {
              "1_configure": "WRPIN(pin, mode) - Set mode",
              "2_set_x": "WXPIN(pin, x_value) - Set timing/config",
              "3_set_y": "WYPIN(pin, y_value) - Set data/count",
              "4_enable": "DIRH(pin) - Enable smart pin",
              "5_operate": "Use RDPIN/RQPIN to read results"
            },
            "common_uses": [
              "UART serial communication",
              "PWM generation",
              "Frequency synthesis",
              "Quadrature encoder reading",
              "ADC/DAC operations",
              "Pulse measurement",
              "Protocol generation"
            ],
            "related_methods": [
              "WXPIN - Set X parameter",
              "WYPIN - Set Y parameter",
              "RDPIN - Read and acknowledge pin",
              "RQPIN - Read without acknowledge",
              "AKPIN - Acknowledge smart pin",
              "PINSTART - Complete pin setup",
              "PINCLEAR - Clear smart pin mode"
            ],
            "notes": [
              "Pin direction must be set after WRPIN",
              "Mode change takes effect immediately",
              "Mode 0 returns pin to normal I/O",
              "Some modes require X and Y configuration",
              "Smart pins operate independently of cog"
            ],
            "mode_persistence": [
              "Mode remains until changed or cog stopped",
              "Survives DIR changes",
              "Not affected by OUT changes",
              "Cleared by PINCLEAR or mode 0"
            ],
            "warnings": [
              "Configure mode before setting DIR",
              "Some modes conflict with normal I/O",
              "Mode bits must be valid for hardware",
              "Incorrect mode can damage external circuits"
            ],
            "see_also": [
              "language/spin2/methods/wxpin.yaml",
              "language/spin2/methods/wypin.yaml",
              "language/spin2/methods/pinstart.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "REGEXEC": {
            "method": "REGEXEC",
            "type": "method",
            "description": "Load and execute PASM2 code from hub RAM\n",
            "category": "Miscellaneous",
            "syntax": "result := REGEXEC(HubAddress)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in result1 register"
            },
            "examples": [
              {
                "code": "' Execute PASM from hub\nresult := REGEXEC(@hub_pasm_code)\n\nDAT\nhub_pasm_code\n  ' PASM code here\n  mov result1, #123\n  ret\n",
                "description": "Execute hub-based PASM code"
              },
              {
                "code": "' Dynamic code execution\nbuild_pasm_code(@buffer)  ' Generate code\nresult := REGEXEC(@buffer)  ' Execute it\n",
                "description": "Execute dynamically generated code"
              },
              {
                "code": "' Large PASM routine\nresult := REGEXEC(@big_routine)\n\nDAT\nbig_routine\n  ' Can be > 512 longs\n  ' Loaded and executed in chunks\n",
                "description": "Execute large PASM routine"
              }
            ],
            "notes": [
              "Loads PASM from hub to cog then executes",
              "Can execute code larger than cog RAM",
              "Preserves Spin2 interpreter",
              "Result in result1 register",
              "PASM must end with RET",
              "Parameters via PTRA/PTRB",
              "More flexible than CALL"
            ],
            "timing": {
              "description": "Load time + execution time",
              "cycles": "Variable based on code size"
            },
            "related": [
              "CALL",
              "REGLOAD",
              "SETREGS"
            ],
            "see_also": [
              "Dynamic code execution",
              "PASM2 programming",
              "Hub execution"
            ]
          },
          "LOOKUP": {
            "method": "LOOKUP",
            "type": "method",
            "description": "Look up value in table using 1-based indexing",
            "category": "Lookup Operations",
            "syntax": "result := LOOKUP(Index : Value1, Value2, ..., ValueN)",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "1-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUP(3 : 10, 20, 30, 40, 50)\n' Returns 30 (3rd item)\n",
                "description": "Basic indexed lookup"
              },
              {
                "code": "' Menu selection\naddress := LOOKUP(choice : @option1, @option2, @option3)\n",
                "description": "Select address by menu choice"
              },
              {
                "code": "' Use ranges\nchar := LOOKUP(index : \"A\"..\"Z\", \"0\"..\"9\")\n",
                "description": "Lookup with character ranges"
              }
            ],
            "notes": [
              "Index is 1-based (1 = first item)",
              "Returns 0 if index < 1 or > count",
              "Supports ranges with .. operator",
              "Values evaluated at compile time if possible",
              "Efficient for small lookup tables"
            ],
            "related": [
              "LOOKUPZ",
              "LOOKDOWN",
              "LOOKDOWNZ"
            ],
            "see_also": [
              "Table lookups",
              "Indexed access",
              "Value selection"
            ]
          },
          "PINCLEAR": {
            "method": "PINCLEAR",
            "type": "method",
            "description": "Clear smart pin configuration and disable pin\n",
            "category": "Smart Pin Operations",
            "syntax": "PINCLEAR(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Clear single smart pin\nPINCLEAR(16)\n",
                "description": "Reset pin 16 to default state"
              },
              {
                "code": "' Clear range of smart pins\nPINCLEAR(8 ADDPINS 7)  ' Clear pins 8-15\n",
                "description": "Clear multiple contiguous pins"
              },
              {
                "code": "' Reset smart pin before reconfiguration\nPINCLEAR(adc_pin)\nPINSTART(adc_pin, P_ADC, 0, 0)\n",
                "description": "Clear before setting new mode"
              }
            ],
            "notes": [
              "Sets DIR bit to 0 (disables pin output)",
              "Sets WRPIN mode register to 0 (disables smart pin mode)",
              "Resets pin to simple input state",
              "Clears all smart pin configuration",
              "Safe way to stop smart pin operation",
              "Should be called before reconfiguring a smart pin"
            ],
            "operations": [
              "DIR[pin] := 0 (disable output)",
              "WRPIN(pin, 0) (clear mode)"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "4-18 clock cycles"
            },
            "related": [
              "PINSTART",
              "WRPIN",
              "PINFLOAT"
            ],
            "see_also": [
              "Smart pin modes",
              "Pin initialization",
              "Pin state management"
            ]
          },
          "LOCKTRY": {
            "method": "LOCKTRY",
            "type": "method",
            "description": "Attempt to capture a lock without blocking\n",
            "category": "Lock Operations",
            "syntax": "result := LOCKTRY(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to try capturing (0..15)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if lock captured, FALSE (0) if already taken"
            },
            "examples": [
              {
                "code": "' Try to get lock\nif LOCKTRY(lock_id)\n  ' Got the lock, access resource\n  access_shared_resource()\n  LOCKREL(lock_id)\n",
                "description": "Non-blocking lock attempt"
              },
              {
                "code": "' Wait for lock with timeout\ntimeout := GETCT() + clkfreq  ' 1 second\nrepeat until LOCKTRY(lock_id) or POLLCT(timeout)\nif not LOCKTRY(lock_id)\n  ' Timeout - couldn't get lock\n  abort\n",
                "description": "Lock with timeout"
              },
              {
                "code": "' Blocking lock acquisition\nrepeat until LOCKTRY(lock_id)\n' Critical section\nLOCKREL(lock_id)\n",
                "description": "Wait until lock available"
              }
            ],
            "notes": [
              "Non-blocking operation",
              "Returns immediately with success/failure",
              "If successful, calling cog owns the lock",
              "Must call LOCKREL to release when done",
              "Can be used in polling loop for blocking behavior",
              "Lock must be allocated with LOCKNEW first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKREL",
              "LOCKNEW",
              "LOCKRET",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Mutual exclusion",
              "Critical sections"
            ]
          },
          "GETRND": {
            "method": "GETRND",
            "type": "method",
            "description": "Get random number from hardware generator",
            "category": "Miscellaneous",
            "syntax": "random := GETRND()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "32-bit hardware random number"
            },
            "examples": [
              {
                "code": "' Get random number\nvalue := GETRND()\n",
                "description": "Get 32-bit random value"
              },
              {
                "code": "' Random number in range 0-99\ndice := GETRND() +// 100\n",
                "description": "Random number with modulo"
              },
              {
                "code": "' Random delay\nWAITMS(GETRND() +// 1000)  ' 0-999ms random delay\n",
                "description": "Random timing"
              },
              {
                "code": "' Seed other generators\nseed := GETRND()\ninit_prng(seed)\n",
                "description": "Seed software PRNG"
              }
            ],
            "notes": [
              "Uses P2's hardware random number generator",
              "True random based on thermal noise",
              "Full 32-bit range",
              "No seeding required",
              "Each cog has independent access",
              "Use +// operator for scaled ranges"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "POLLCT",
              "GETCT"
            ],
            "see_also": [
              "Random number generation",
              "Hardware RNG",
              "Cryptographic operations"
            ]
          },
          "LOOKUPZ": {
            "method": "LOOKUPZ",
            "type": "method",
            "description": "Look up value in table using 0-based indexing",
            "category": "Lookup Operations",
            "syntax": "result := LOOKUPZ(Index : Value0, Value1, ..., ValueN)",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "0-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUPZ(2 : 10, 20, 30, 40, 50)\n' Returns 30 (index 2 = 3rd item)\n",
                "description": "Basic zero-indexed lookup"
              },
              {
                "code": "' Array-style access\nbaud := LOOKUPZ(setting : 9600, 19200, 38400, 57600, 115200)\n",
                "description": "Select baud rate by setting"
              },
              {
                "code": "' Pin mapping table\npin := LOOKUPZ(channel : 16, 17, 18, 19, 24, 25, 26, 27)\n",
                "description": "Map channel to pin number"
              },
              {
                "code": "' Use with ranges\nascii := LOOKUPZ(code : \"0\"..\"9\", \"A\"..\"F\")\n",
                "description": "Hex digit lookup table"
              }
            ],
            "notes": [
              "Index is 0-based (0 = first item)",
              "Returns 0 if index < 0 or >= count",
              "Supports ranges with .. operator",
              "More common than LOOKUP for array-like access",
              "Values evaluated at compile time if possible",
              "Efficient for small lookup tables"
            ],
            "related": [
              "LOOKUP",
              "LOOKDOWN",
              "LOOKDOWNZ"
            ],
            "see_also": [
              "Table lookups",
              "Zero-based indexing",
              "Array simulation"
            ]
          },
          "POLXY": {
            "method": "POLXY",
            "type": "method",
            "description": "Convert polar coordinates to Cartesian using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "X, Y := POLXY(Rho, Theta)",
            "parameters": [
              {
                "name": "Rho",
                "type": "long",
                "description": "Radius/magnitude (32-bit unsigned)"
              },
              {
                "name": "Theta",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns X and Y Cartesian coordinates"
            },
            "examples": [
              {
                "code": "' Convert polar to Cartesian\nx, y := POLXY(100, $4000_0000)  ' r=100, \u03b8=90\u00b0\n' Result: x \u2248 0, y \u2248 100\n",
                "description": "Basic polar to Cartesian conversion"
              },
              {
                "code": "' Draw circle using polar coordinates\nradius := 50\nrepeat angle from 0 to $FFFF_FFFF step $0400_0000\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n",
                "description": "Draw circle using polar coordinates"
              },
              {
                "code": "' Create spiral pattern\nangle := 0\nrepeat radius from 10 to 100\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n  angle += $0800_0000  ' Increment angle\n",
                "description": "Generate spiral pattern"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Full 32-bit precision maintained",
              "Rho (radius) is unsigned magnitude",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "XYPOL",
              "ROTXY",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Polar coordinates",
              "Coordinate conversion"
            ]
          },
          "BYTEFILL": {
            "method": "BYTEFILL",
            "category": "memory_operations",
            "type": "method",
            "description": "Fill a specified region of hub RAM with a byte value.\nEfficiently sets multiple consecutive bytes to the same value.\nCommonly used for clearing buffers, initializing arrays, and drawing operations.\n",
            "syntax": "BYTEFILL(Destination, Value, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nStarting address for the fill operation.\nCan be any valid hub address (0-524287).\n"
              },
              {
                "name": "Value",
                "type": "byte",
                "description": "Byte value to fill with (0-255).\nHigher bits are ignored if provided.\nCommon values: 0 (clear), 32 (space), 255 ($FF).\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to fill.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "small_fill": "~8 + count clock cycles",
              "large_fill": "Optimized for larger regions",
              "performance": "Faster than loop for count > 4"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[256]\n  \nPUB clear_buffer()\n  BYTEFILL(@buffer, 0, 256)\n",
                "description": "Clear buffer to zeros"
              },
              {
                "code": "VAR\n  BYTE screen[80 * 25]\n  \nPUB clear_screen()\n  BYTEFILL(@screen, \" \", 80 * 25)\n",
                "description": "Clear text screen with spaces"
              },
              {
                "code": "VAR\n  BYTE line[100]\n  \nPUB draw_horizontal_line(char)\n  BYTEFILL(@line, char, 100)\n",
                "description": "Create line of characters"
              },
              {
                "code": "' Initialize lookup table\nVAR\n  BYTE lookup[256]\n  \nPUB init_table()\n  BYTEFILL(@lookup, $FF, 256)  ' All entries invalid\n  ' Then set specific valid entries\n  lookup[10] := 1\n  lookup[20] := 2\n",
                "description": "Initialize lookup table"
              },
              {
                "code": "' Create test pattern\nVAR\n  BYTE pattern[1000]\n  \nPUB create_pattern()\n  BYTEFILL(@pattern[0], $AA, 500)\n  BYTEFILL(@pattern[500], $55, 500)\n",
                "description": "Create alternating pattern"
              }
            ],
            "common_uses": [
              "Buffer initialization",
              "Memory clearing",
              "Screen/display clearing",
              "Array initialization",
              "Pattern generation",
              "Padding operations"
            ],
            "typical_values": {
              "0": "Clear/zero memory",
              "32": "ASCII space for text",
              "255": "All bits set ($FF)",
              "$AA": "Alternating bits (10101010)",
              "$55": "Alternating bits (01010101)"
            },
            "related_methods": [
              "WORDFILL - Fill with word value",
              "LONGFILL - Fill with long value",
              "BYTEMOVE - Copy bytes",
              "BYTECOMP - Compare bytes"
            ],
            "performance_comparison": {
              "manual_loop": "' Slower for large counts\nREPEAT i FROM 0 TO count-1\n  BYTE[dest][i] := value\n  \n",
              "bytefill": "' Optimized implementation\nBYTEFILL(dest, value, count)\n' 3-10x faster for count > 10\n"
            },
            "notes": [
              "Only uses lower 8 bits of value",
              "Count of 0 is safe (no operation)",
              "No bounds checking on addresses",
              "Cannot fill cog or LUT RAM",
              "Sequential fill only"
            ],
            "best_practices": [
              "Use for initialization, not computation",
              "Clear sensitive data after use",
              "Initialize buffers before first use",
              "Use appropriate fill value for data type"
            ],
            "warnings": [
              "Ensure destination has enough space",
              "Address validation is programmer's responsibility",
              "Overwrites existing data without backup"
            ],
            "see_also": [
              "language/spin2/methods/wordfill.yaml",
              "language/spin2/methods/longfill.yaml",
              "language/spin2/methods/bytemove.yaml"
            ]
          },
          "PINLOW": {
            "method": "PINLOW",
            "aliases": [
              "PINL"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) low (output mode, logic 0).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) low (OUT=0).\nThis is equivalent to the PASM2 DIRL instruction.\n",
            "syntax": "PINLOW(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive low. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINLOW(56)",
                "description": "Drive pin 56 low (turn off LED)"
              },
              {
                "code": "PINLOW(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 low simultaneously"
              },
              {
                "code": "PINLOW(49..40)",
                "description": "Drive pins 40 through 49 low (wraps if needed)"
              },
              {
                "code": "VAR\n  LONG led_pin\nPUB main()\n  led_pin := 56\n  PINLOW(led_pin)\n",
                "description": "Use a variable for the pin number"
              }
            ],
            "underlying_pasm": {
              "instruction": "DIRL",
              "description": "Internally uses DIRL instruction which sets DIR=1 and OUT=0"
            },
            "common_uses": [
              "Turn off LEDs",
              "Pull signals to ground",
              "Assert active-low control signals",
              "Create logic 0 for communication"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINTOGGLE - Toggle pin state",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "Pin will remain low until explicitly changed",
              "Multiple pins can be controlled simultaneously",
              "Useful for Charlieplexing one side of LED matrix"
            ],
            "see_also": [
              "language/pasm2/dirl.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pintoggle.yaml"
            ]
          },
          "MULDIV64": {
            "method": "MULDIV64",
            "type": "method",
            "description": "Multiply then divide with 64-bit intermediate result\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := MULDIV64(Multiplier, Multiplicand, Divisor)",
            "parameters": [
              {
                "name": "Multiplier",
                "type": "long",
                "description": "First value to multiply (32-bit signed)"
              },
              {
                "name": "Multiplicand",
                "type": "long",
                "description": "Second value to multiply (32-bit signed)"
              },
              {
                "name": "Divisor",
                "type": "long",
                "description": "Value to divide by (32-bit signed, non-zero)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Result of (Multiplier \u00d7 Multiplicand) \u00f7 Divisor"
            },
            "examples": [
              {
                "code": "' Scale value without overflow\nscaled := MULDIV64(value, 1000, 1024)  ' value*1000/1024\n",
                "description": "Scale value precisely"
              },
              {
                "code": "' Calculate percentage\npercent := MULDIV64(part, 100, total)\n",
                "description": "Calculate percentage without overflow"
              },
              {
                "code": "' Frequency calculation\nfreq := MULDIV64(clkfreq, numerator, denominator)\n",
                "description": "Calculate precise frequency"
              },
              {
                "code": "' Fixed-point math\nresult := MULDIV64(a, b, $1_0000)  ' Multiply with 16.16 fixed point\n",
                "description": "Fixed-point multiplication"
              }
            ],
            "notes": [
              "Prevents overflow in intermediate calculation",
              "Uses 64-bit intermediate result",
              "All parameters are 32-bit signed",
              "Division by zero returns 0",
              "Useful for scaling and ratio calculations",
              "More precise than (a*b)/c for large values"
            ],
            "timing": {
              "description": "Multi-cycle operation",
              "cycles": "~50-60 clock cycles"
            },
            "related": [
              "QLOG",
              "QEXP"
            ],
            "see_also": [
              "Extended precision math",
              "Scaling operations",
              "Fixed-point arithmetic"
            ]
          },
          "POLLCT": {
            "method": "POLLCT",
            "type": "method",
            "description": "Check if system counter has passed specified tick value\n",
            "category": "Timing Operations",
            "syntax": "result := POLLCT(Tick)",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if tick has passed, FALSE (0) if not yet"
            },
            "examples": [
              {
                "code": "' Non-blocking timeout check\ntimeout := GETCT() + clkfreq  ' 1 second timeout\nrepeat\n  ' Do work...\n  if POLLCT(timeout)\n    ' Timeout occurred\n    quit\n",
                "description": "Implement non-blocking timeout"
              },
              {
                "code": "' Check if delay has elapsed\nstart_time := GETCT()\nend_time := start_time + clkfreq/10\nrepeat while not POLLCT(end_time)\n  ' Do other work while waiting\n",
                "description": "Non-blocking delay with work"
              },
              {
                "code": "' Multiple timer management\nrepeat\n  if POLLCT(timer1)\n    handle_timer1()\n    timer1 += period1\n  if POLLCT(timer2)\n    handle_timer2()\n    timer2 += period2\n",
                "description": "Manage multiple software timers"
              }
            ],
            "notes": [
              "Non-blocking alternative to WAITCT",
              "Returns immediately with TRUE/FALSE result",
              "Handles counter wraparound correctly",
              "Useful for implementing timeouts",
              "Can check multiple timers in same loop",
              "TRUE means current counter >= target (accounting for wrap)"
            ],
            "timing": {
              "description": "Immediate return",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "WAITCT",
              "GETCT",
              "POLLATN"
            ],
            "see_also": [
              "System counter",
              "Non-blocking timing",
              "Timeout handling"
            ]
          },
          "STRCOPY": {
            "method": "STRCOPY",
            "type": "method",
            "description": "Copy null-terminated string with length limit\n",
            "category": "String Operations",
            "syntax": "STRCOPY(DestAddress, SourceAddress, MaxCount)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Destination buffer address"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Source string address (null-terminated)"
              },
              {
                "name": "MaxCount",
                "type": "integer",
                "description": "Maximum characters to copy (including null)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Copy string with buffer limit\nSTRCOPY(@buffer, @source, 80)  ' Max 79 chars + null\n",
                "description": "Safe string copy with limit"
              },
              {
                "code": "' Copy user input\nSTRCOPY(@name, @input, 32)  ' Limit name to 31 chars\n",
                "description": "Copy with length protection"
              },
              {
                "code": "' Build compound string\nSTRCOPY(@message, STRING(\"Error: \"), 100)\n' Then append more...\n",
                "description": "Start building message"
              }
            ],
            "notes": [
              "Always null-terminates destination",
              "Stops at source null or MaxCount-1 characters",
              "MaxCount includes space for null terminator",
              "Prevents buffer overflow",
              "If MaxCount is 0, nothing is copied",
              "Destination buffer must be at least MaxCount bytes"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (2 per character) clock cycles"
            },
            "related": [
              "STRCOMP",
              "STRSIZE",
              "BYTEMOVE",
              "STRING"
            ],
            "see_also": [
              "String operations",
              "Buffer management",
              "Safe string handling"
            ]
          },
          "LOCKNEW": {
            "method": "LOCKNEW",
            "type": "method",
            "description": "Allocate a new hardware lock for inter-cog synchronization\n",
            "category": "Lock Operations",
            "syntax": "lock_id := LOCKNEW()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Lock ID (0..15) if successful, negative if no locks available"
            },
            "examples": [
              {
                "code": "' Allocate a new lock\nlock := LOCKNEW()\nif lock < 0\n  ' No locks available\n  abort\n",
                "description": "Allocate lock with error checking"
              },
              {
                "code": "' Initialize shared resource lock\nVAR\n  long buffer_lock\n\nPUB init()\n  buffer_lock := LOCKNEW()\n",
                "description": "Create lock for shared buffer"
              },
              {
                "code": "' Multiple locks for different resources\nspi_lock := LOCKNEW()\nuart_lock := LOCKNEW()\ni2c_lock := LOCKNEW()\n",
                "description": "Allocate multiple resource locks"
              }
            ],
            "notes": [
              "P2 has 16 hardware locks (0-15)",
              "Returns next available lock ID",
              "Returns negative value if all locks in use",
              "Lock is marked as allocated but not captured",
              "Must call LOCKRET when done to free lock",
              "Locks are shared across all cogs"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKRET",
              "LOCKTRY",
              "LOCKREL",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Inter-cog synchronization",
              "Resource sharing"
            ]
          },
          "QCOS": {
            "method": "QCOS",
            "type": "method",
            "description": "Calculate cosine of angle using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "cosine := QCOS(Angle, Length)",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Cosine value scaled by Length"
            },
            "examples": [
              {
                "code": "' Calculate cosine of 60 degrees\ncosine := QCOS($2AAA_AAAA, 1000)  ' 60\u00b0 with scale 1000\n' Result: cosine \u2248 500\n",
                "description": "Basic cosine calculation"
              },
              {
                "code": "' Generate cosine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QCOS(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate cosine wave plot"
              },
              {
                "code": "' Horizontal position for circular motion\nx_pos := center_x + QCOS(angle, radius)\n",
                "description": "Calculate X position on circle"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0",
              "Result = Length \u00d7 cos(Angle)",
              "Full 32-bit precision",
              "38-clock cycle operation",
              "Handles all quadrants correctly"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QSIN",
              "ROTXY",
              "POLXY"
            ],
            "see_also": [
              "CORDIC operations",
              "Trigonometric functions",
              "Waveform generation"
            ]
          }
        }
      },
      "registers": {
        "count": 25,
        "elements": {
          "IRET3": {
            "register": "IRET3",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 return vector\n",
            "examples": [
              "IRET3 := saved_address"
            ],
            "address": "497",
            "access": "read_write"
          },
          "DIRB": {
            "register": "DIRB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register B (pins 32-63)\n",
            "examples": [
              "DIRB := $FF000000  // Set pins 56-63 as outputs"
            ],
            "address": "507",
            "access": "read_write"
          },
          "PR1": {
            "register": "PR1",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 1\n",
            "examples": [
              "PR1 := counter",
              "temp := PR1"
            ],
            "address": "497",
            "access": "read_write"
          },
          "OUTB": {
            "register": "OUTB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register B (pins 32-63)\n",
            "examples": [
              "OUTB := high_pin_states"
            ],
            "address": "509",
            "access": "read_write"
          },
          "PR0": {
            "register": "PR0",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 0\n",
            "examples": [
              "PR0 := value",
              "result := PR0"
            ],
            "address": "496",
            "access": "read_write"
          },
          "PTRA": {
            "register": "PTRA",
            "type": "register",
            "category": "Special Function",
            "description": "Pointer A register\n",
            "examples": [
              "PTRA := @buffer",
              "RDLONG value, PTRA++"
            ],
            "address": "504",
            "access": "read_write"
          },
          "TASKHLT": {
            "register": "TASKHLT",
            "type": "register",
            "category": "Task Management",
            "description": "Task halt register (v47+)\n",
            "examples": [
              "TASKHLT := task_flags"
            ],
            "address": "512",
            "access": "read_write"
          },
          "IRET2": {
            "register": "IRET2",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 return vector\n",
            "examples": [
              "IRET2 := return_point"
            ],
            "address": "499",
            "access": "read_write"
          },
          "PR7": {
            "register": "PR7",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 7\n",
            "examples": [
              "PR7 := working_value"
            ],
            "address": "503",
            "access": "read_write"
          },
          "PA": {
            "register": "PA",
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter A / call target\n",
            "examples": [
              "PA := @subroutine",
              "CALL PA"
            ],
            "address": "502",
            "access": "read_write"
          },
          "IJMP1": {
            "register": "IJMP1",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 jump vector\n",
            "examples": [
              "IJMP1 := @interrupt1_handler"
            ],
            "address": "500",
            "access": "read_write"
          },
          "PR6": {
            "register": "PR6",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 6\n",
            "examples": [
              "PR6 := state_machine"
            ],
            "address": "502",
            "access": "read_write"
          },
          "INB": {
            "register": "INB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register B (pins 32-63)\n",
            "examples": [
              "sensor_data := INB"
            ],
            "address": "511",
            "access": "read"
          },
          "IJMP3": {
            "register": "IJMP3",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 jump vector\n",
            "examples": [
              "IJMP3 := @interrupt3_handler"
            ],
            "address": "496",
            "access": "read_write"
          },
          "PR5": {
            "register": "PR5",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 5\n",
            "examples": [
              "PR5 := loop_count"
            ],
            "address": "501",
            "access": "read_write"
          },
          "INA": {
            "register": "INA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register A (pins 0-31)\n",
            "examples": [
              "button_state := INA[button_pin]"
            ],
            "address": "510",
            "access": "read"
          },
          "PR4": {
            "register": "PR4",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 4\n",
            "examples": [
              "PR4 := data_length"
            ],
            "address": "500",
            "access": "read_write"
          },
          "PB": {
            "register": "PB",
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter B / call target\n",
            "examples": [
              "PB := @function",
              "CALL PB"
            ],
            "address": "503",
            "access": "read_write"
          },
          "IJMP2": {
            "register": "IJMP2",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 jump vector\n",
            "examples": [
              "IJMP2 := @interrupt2_handler"
            ],
            "address": "498",
            "access": "read_write"
          },
          "IRET1": {
            "register": "IRET1",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 return vector\n",
            "examples": [
              "IRET1 := stored_pc"
            ],
            "address": "501",
            "access": "read_write"
          },
          "OUTA": {
            "register": "OUTA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register A (pins 0-31)\n",
            "examples": [
              "OUTA := led_pattern",
              "!OUTA[led_pin]"
            ],
            "address": "508",
            "access": "read_write"
          },
          "PR3": {
            "register": "PR3",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 3\n",
            "examples": [
              "PR3 := status_flags"
            ],
            "address": "499",
            "access": "read_write"
          },
          "PTRB": {
            "register": "PTRB",
            "type": "register",
            "category": "Special Function",
            "description": "Pointer B register\n",
            "examples": [
              "PTRB := @array",
              "WRLONG data, PTRB++"
            ],
            "address": "505",
            "access": "read_write"
          },
          "DIRA": {
            "register": "DIRA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register A (pins 0-31)\n",
            "examples": [
              "DIRA := %11111111  // Set pins 0-7 as outputs"
            ],
            "address": "506",
            "access": "read_write"
          },
          "PR2": {
            "register": "PR2",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 2\n",
            "examples": [
              "PR2 := buffer_ptr"
            ],
            "address": "498",
            "access": "read_write"
          }
        }
      },
      "assembly_directives": {
        "count": 8,
        "elements": {
          "ALIGNL": {
            "directive": "ALIGNL",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Align to long boundary (4 bytes)\n",
            "syntax": "['ALIGNL']",
            "examples": [
              "ALIGNL  // Align to next long boundary"
            ]
          },
          "FIT": {
            "directive": "FIT",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Ensure code fits in specified limit\n",
            "syntax": "['FIT limit']",
            "examples": [
              "FIT $1F0  // Must fit in COG space"
            ]
          },
          "ORGH": {
            "directive": "ORGH",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address for hub RAM\n",
            "syntax": "['ORGH address']",
            "examples": [
              "ORGH $400  // Start at hub address $400"
            ]
          },
          "DITTO": {
            "directive": "DITTO",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Repeat last instruction (v50+)\n",
            "syntax": "['DITTO']",
            "examples": [
              "DITTO  // Repeat previous instruction"
            ]
          },
          "ALIGNW": {
            "directive": "ALIGNW",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Align to word boundary (2 bytes)\n",
            "syntax": "['ALIGNW']",
            "examples": [
              "ALIGNW  // Align to next word boundary"
            ]
          },
          "ORGF": {
            "directive": "ORGF",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address with forced alignment\n",
            "syntax": "['ORGF address']",
            "examples": [
              "ORGF $100  // Align to address $100"
            ]
          },
          "RES": {
            "directive": "RES",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Reserve space (advance origin)\n",
            "syntax": "['RES count']",
            "examples": [
              "RES 16  // Reserve 16 locations"
            ]
          },
          "ORG": {
            "directive": "ORG",
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address for COG RAM\n",
            "syntax": "['ORG address']",
            "examples": [
              "ORG 0  // Start at COG address 0"
            ]
          }
        }
      },
      "debug_commands": {
        "count": 23,
        "elements": {
          "SDEC_BYTE": {
            "command": "SDEC_BYTE",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal byte format\n",
            "syntax": "['SDEC_BYTE(value)']",
            "examples": [
              "DEBUG(SDEC_BYTE(offset))"
            ]
          },
          "UDEC_LONG": {
            "command": "UDEC_LONG",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal long format\n",
            "syntax": "['UDEC_LONG(value)']",
            "examples": [
              "DEBUG(UDEC_LONG(timestamp))"
            ]
          },
          "UDEC_WORD": {
            "command": "UDEC_WORD",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal word format\n",
            "syntax": "['UDEC_WORD(value)']",
            "examples": [
              "DEBUG(UDEC_WORD(address))"
            ]
          },
          "UBIN": {
            "command": "UBIN",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary format\n",
            "syntax": "['UBIN(value)']",
            "examples": [
              "DEBUG(UBIN(mask))"
            ]
          },
          "PC_KEY": {
            "command": "PC_KEY",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC keyboard input\n",
            "syntax": "['PC_KEY']",
            "examples": [
              "DEBUG(PC_KEY)"
            ]
          },
          "BOOL": {
            "command": "BOOL",
            "type": "debug_command",
            "category": "Boolean Format",
            "description": "Boolean format (v44+)\n",
            "syntax": "['BOOL(value)']",
            "examples": [
              "DEBUG(BOOL(flag))"
            ]
          },
          "SDEC_WORD": {
            "command": "SDEC_WORD",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal word format\n",
            "syntax": "['SDEC_WORD(value)']",
            "examples": [
              "DEBUG(SDEC_WORD(delta))"
            ]
          },
          "UDEC_BYTE": {
            "command": "UDEC_BYTE",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal byte format\n",
            "syntax": "['UDEC_BYTE(value)']",
            "examples": [
              "DEBUG(UDEC_BYTE(status))"
            ]
          },
          "DLY": {
            "command": "DLY",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug delay command\n",
            "syntax": "['DLY(milliseconds)']",
            "examples": [
              "DEBUG(DLY(100))"
            ]
          },
          "SDEC": {
            "command": "SDEC",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal format\n",
            "syntax": "['SDEC(value)']",
            "examples": [
              "DEBUG(SDEC(temperature))"
            ]
          },
          "SDEC_LONG": {
            "command": "SDEC_LONG",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal long format\n",
            "syntax": "['SDEC_LONG(value)']",
            "examples": [
              "DEBUG(SDEC_LONG(position))"
            ]
          },
          "UHEX": {
            "command": "UHEX",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal format\n",
            "syntax": "['UHEX(value)']",
            "examples": [
              "DEBUG(UHEX(address))"
            ]
          },
          "PC_MOUSE": {
            "command": "PC_MOUSE",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC mouse input\n",
            "syntax": "['PC_MOUSE']",
            "examples": [
              "DEBUG(PC_MOUSE)"
            ]
          },
          "DEBUG": {
            "command": "DEBUG",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug output statement\n",
            "syntax": "['DEBUG (expressions)']",
            "examples": [
              "DEBUG(\"Value:\", value)"
            ]
          },
          "UDEC": {
            "command": "UDEC",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal format\n",
            "syntax": "['UDEC(value)']",
            "examples": [
              "DEBUG(UDEC(counter))"
            ]
          },
          "LSTR": {
            "command": "LSTR",
            "type": "debug_command",
            "category": "String Format",
            "description": "Length-prefixed string\n",
            "syntax": "['LSTR(string_ptr)']",
            "examples": [
              "DEBUG(LSTR(@buffer))"
            ]
          },
          "UBIN_BYTE": {
            "command": "UBIN_BYTE",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary byte format\n",
            "syntax": "['UBIN_BYTE(value)']",
            "examples": [
              "DEBUG(UBIN_BYTE(pattern))"
            ]
          },
          "ZSTR": {
            "command": "ZSTR",
            "type": "debug_command",
            "category": "String Format",
            "description": "Zero-terminated string\n",
            "syntax": "['ZSTR(string_ptr)']",
            "examples": [
              "DEBUG(ZSTR(@message))"
            ]
          },
          "UHEX_BYTE": {
            "command": "UHEX_BYTE",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal byte format\n",
            "syntax": "['UHEX_BYTE(value)']",
            "examples": [
              "DEBUG(UHEX_BYTE(flags))"
            ]
          },
          "UBIN_WORD": {
            "command": "UBIN_WORD",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary word format\n",
            "syntax": "['UBIN_WORD(value)']",
            "examples": [
              "DEBUG(UBIN_WORD(config))"
            ]
          },
          "UBIN_LONG": {
            "command": "UBIN_LONG",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary long format\n",
            "syntax": "['UBIN_LONG(value)']",
            "examples": [
              "DEBUG(UBIN_LONG(bitfield))"
            ]
          },
          "UHEX_LONG": {
            "command": "UHEX_LONG",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal long format\n",
            "syntax": "['UHEX_LONG(value)']",
            "examples": [
              "DEBUG(UHEX_LONG(register))"
            ]
          },
          "UHEX_WORD": {
            "command": "UHEX_WORD",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal word format\n",
            "syntax": "['UHEX_WORD(value)']",
            "examples": [
              "DEBUG(UHEX_WORD(port))"
            ]
          }
        }
      },
      "special_symbols": {
        "count": 12,
        "elements": {
          ".": {
            "symbol": ".",
            "type": "special_symbol",
            "category": "Special",
            "description": "Decimal point or object method access\n",
            "examples": [
              "float_val := 3.14",
              "obj.method()"
            ]
          },
          "`": {
            "symbol": "`",
            "type": "special_symbol",
            "category": "Special",
            "description": "Tick operator for special formatting\n",
            "examples": [
              "`expression"
            ]
          },
          "@@": {
            "symbol": "@@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Absolute address operator - get absolute hub address\n",
            "examples": [
              "hub_addr := @@variable"
            ]
          },
          "..": {
            "symbol": "..",
            "type": "special_symbol",
            "category": "Special",
            "description": "Range operator for CASE statements\n",
            "examples": [
              "CASE value\n  1..10: low_range()\n  11..20: high_range()"
            ]
          },
          "^@": {
            "symbol": "^@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Object address operator - address within object\n",
            "examples": [
              "obj_addr := ^@method"
            ]
          },
          "~": {
            "symbol": "~",
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-clear operator - use value then clear\n",
            "examples": [
              "value := ~flag  // use flag then clear it"
            ]
          },
          "@": {
            "symbol": "@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Address-of operator - get memory address\n",
            "examples": [
              "ptr := @variable",
              "COGINIT(0, @assembly_code, @params)"
            ]
          },
          "%": {
            "symbol": "%",
            "type": "special_symbol",
            "category": "Special",
            "description": "Binary number prefix\n",
            "examples": [
              "mask := %11110000",
              "pattern := %1010_1010"
            ]
          },
          "_": {
            "symbol": "_",
            "type": "special_symbol",
            "category": "Special",
            "description": "Digit separator in numeric literals\n",
            "examples": [
              "freq := 80_000_000",
              "mask := %1111_0000_1111_0000"
            ]
          },
          "$$": {
            "symbol": "$$",
            "type": "special_symbol",
            "category": "Special",
            "description": "Current assembly address\n",
            "examples": [
              "distance := target - $$"
            ]
          },
          "~~": {
            "symbol": "~~",
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-set operator - use value then set to -1\n",
            "examples": [
              "value := ~~flag  // use flag then set to -1"
            ]
          },
          "$": {
            "symbol": "$",
            "type": "special_symbol",
            "category": "Special",
            "description": "Hexadecimal number prefix\n",
            "examples": [
              "value := $FF",
              "address := $1000"
            ]
          }
        }
      },
      "system_variables": {
        "count": 3,
        "elements": {
          "CLKFREQ": {
            "variable": "CLKFREQ",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "System clock frequency in Hz\n",
            "access": "read_write",
            "examples": [
              "CLKFREQ := 80_000_000  // 80MHz"
            ]
          },
          "VARBASE": {
            "variable": "VARBASE",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "Base address of VAR section\n",
            "access": "read",
            "examples": [
              "var_start := VARBASE"
            ]
          },
          "CLKMODE": {
            "variable": "CLKMODE",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "System clock mode configuration\n",
            "access": "read_write",
            "examples": [
              "CLKMODE := %0_0000_01_101_111_1_1  // 80MHz"
            ]
          }
        }
      }
    },
    "statistics": {
      "total_elements": 268,
      "by_category": {
        "keywords": 36,
        "operators": 74,
        "methods": 87,
        "registers": 25,
        "assembly_directives": 8,
        "debug_commands": 23,
        "special_symbols": 12,
        "system_variables": 3
      }
    }
  }
}