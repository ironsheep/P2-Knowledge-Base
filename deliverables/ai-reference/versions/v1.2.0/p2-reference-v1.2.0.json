{
  "meta": {
    "version": "1.2.0",
    "release_date": "2025-09-14",
    "completeness": 0.85,
    "stable": false,
    "breaking_changes_expected": true,
    "sources": {
      "primary": "P2 Documentation v35 - Rev B/C Silicon by Chip Gracey",
      "instruction_set": "P2 Instructions v35 Spreadsheet",
      "contributors": [
        "Chip Gracey (cgracey@parallax.com)",
        "Parallax Inc."
      ],
      "spin2": "PNUT-TS Compiler v1.51.5 Language Specification"
    },
    "last_updated": "2025-09-14T01:14:07.932919"
  },
  "architecture": {
    "cogs": {
      "count": 8,
      "type": "symmetric",
      "memory_per_cog": "512 longs (2KB) COG RAM",
      "registers_per_cog": "$000-$1FF",
      "execution": "2-clock instructions typical"
    },
    "hub": {
      "memory_size": "512KB",
      "access_method": "Egg Beater - 8-way interleaved",
      "slice_rotation": "Every clock cycle",
      "long_access": "Random: 9-16 clocks, Sequential: 2 clocks"
    },
    "smart_pins": {
      "count": 64,
      "modes": 32,
      "status": "partial_documentation",
      "note": "Complete documentation pending from Jon Titus"
    },
    "cordic": {
      "pipeline_stages": 54,
      "operations": [
        "rotate",
        "vector",
        "multiply",
        "divide",
        "sqrt",
        "log",
        "exp"
      ],
      "precision": "32-bit"
    },
    "clock": {
      "internal_rc": "~24MHz",
      "pll_range": "3.125MHz to 500MHz",
      "xi_input": "DC to 200MHz",
      "max_sysclock": "180MHz typical"
    }
  },
  "instructions": {
    "total_count": 491,
    "categories": {
      "math_logic": {
        "count": 73,
        "complete": [
          "ADD",
          "SUB",
          "AND",
          "OR",
          "XOR",
          "NOT",
          "MUL",
          "DIV"
        ],
        "partial": [
          "MULS",
          "DIVS"
        ],
        "examples": true
      },
      "memory": {
        "count": 45,
        "complete": [
          "MOV",
          "RDLONG",
          "WRLONG",
          "RDBYTE",
          "WRBYTE"
        ],
        "partial": [
          "RDFAST",
          "WRFAST"
        ],
        "hub_timing_documented": true
      },
      "flow_control": {
        "count": 38,
        "complete": [
          "JMP",
          "CALL",
          "RET",
          "DJNZ",
          "IJNZ"
        ],
        "partial": [
          "CALLD",
          "RETD"
        ],
        "conditional_execution": true
      },
      "pin_control": {
        "count": 35,
        "complete": [
          "DRVL",
          "DRVH",
          "DRVNOT",
          "TESTP"
        ],
        "partial": [
          "WRPIN",
          "WXPIN",
          "WYPIN"
        ],
        "smart_pin_integration": "partial"
      },
      "cordic": {
        "count": 8,
        "complete": [
          "QROTATE",
          "QVECTOR"
        ],
        "partial": [
          "QMUL",
          "QDIV",
          "QSQRT"
        ],
        "timing": "55-58 clocks typical"
      },
      "interrupts": {
        "count": 15,
        "levels": 3,
        "complete": [
          "SETINT1",
          "SETINT2",
          "SETINT3"
        ],
        "partial": [
          "TRGINT1",
          "NIXINT1"
        ]
      },
      "special": {
        "count": 42,
        "complete": [
          "NOP",
          "HUBSET",
          "COGINIT"
        ],
        "partial": [
          "DEBUG",
          "STREAMER"
        ],
        "missing": [
          "USB"
        ]
      }
    }
  },
  "condition_codes": {
    "supported": true,
    "flags": [
      "C",
      "Z"
    ],
    "prefixes": {
      "_RET_": "Execute if returning",
      "IF_": "Execute conditionally",
      "IF_C": "Execute if Carry set",
      "IF_NC": "Execute if Carry clear",
      "IF_Z": "Execute if Zero set",
      "IF_NZ": "Execute if Zero clear"
    }
  },
  "memory_model": {
    "cog_ram": {
      "size": "512 longs",
      "addressing": "$000-$1FF",
      "special_registers": "$1F0-$1FF"
    },
    "lut_ram": {
      "size": "512 longs",
      "addressing": "$200-$3FF",
      "shared_access": true
    },
    "hub_ram": {
      "size": "512KB",
      "addressing": "$00000-$7FFFF",
      "byte_addressable": true
    }
  },
  "gaps": {
    "boot_process": {
      "status": "missing",
      "workaround": "Use serial boot for development",
      "needed_from": "Chip Gracey"
    },
    "usb_support": {
      "status": "missing",
      "workaround": "Use serial communication",
      "needed_from": "Parallax"
    },
    "smart_pins_complete": {
      "status": "partial",
      "available_modes": 10,
      "total_modes": 32,
      "workaround": "Use documented modes only",
      "pending_from": "Jon Titus documentation"
    },
    "bytecode_interpreter": {
      "status": "missing",
      "workaround": "Use PASM2 or external compiler",
      "needed_from": "Chip Gracey"
    },
    "streamer_fifo": {
      "status": "partial",
      "workaround": "Use basic RDFAST/WRFAST",
      "needed_from": "Documentation team"
    }
  },
  "discovery": {
    "has_architecture": true,
    "has_instruction_set": true,
    "has_memory_model": true,
    "has_pin_control": true,
    "has_cordic": true,
    "has_interrupts": true,
    "has_boot_process": false,
    "has_usb": false,
    "has_complete_timing": false,
    "has_all_smart_pins": false,
    "has_bytecode": false
  },
  "code_generation_ready": {
    "basic_assembly": true,
    "hub_memory_access": true,
    "pin_control": true,
    "cog_launching": true,
    "cordic_math": true,
    "smart_pins_basic": true,
    "interrupts": false,
    "usb": false,
    "boot_configuration": false
  },
  "spin2": {
    "version": "1.51.5",
    "source": "PNUT-TS Compiler Language Specification",
    "extraction_date": "2025-01-13",
    "categories": {
      "keywords": {
        "count": 36,
        "description": "SPIN2 language keywords",
        "elements": {
          "LOOKDOWNZ": {
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns zero-based index of matching value in list\n",
            "syntax": "LOOKDOWNZ(value : list)",
            "examples": [
              "index := LOOKDOWNZ(color : RED, GREEN, BLUE)"
            ]
          },
          "FROM": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Starting value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "STEP": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Increment value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end STEP increment\n  statements\n",
            "examples": [
              "REPEAT i FROM 0 TO 100 STEP 5\n  process(i)"
            ]
          },
          "RETURN": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Return from method with optional value\n",
            "syntax": "RETURN [value]",
            "examples": [
              "RETURN",
              "RETURN result"
            ]
          },
          "ELSEIFNOT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch with negated condition\n",
            "syntax": "ELSEIFNOT condition\n  statements\n",
            "examples": [
              "ELSEIFNOT flag\n  result := \"false case\""
            ]
          },
          "IF": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution based on expression\n",
            "syntax": "IF condition\n  statements\n",
            "examples": [
              "IF temperature > 80\n  turn_on_fan()"
            ]
          },
          "IFNOT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution with negated condition\n",
            "syntax": "IFNOT condition\n  statements\n",
            "examples": [
              "IFNOT sensor_active\n  error_handler()"
            ]
          },
          "ELSEIF": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch in IF statement\n",
            "syntax": "ELSEIF condition\n  statements\n",
            "examples": [
              "ELSEIF x > 10\n  result := \"high\""
            ]
          },
          "OBJ": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Object section - declares object instances\n",
            "syntax": "OBJ\n  name : \"filename\"\n",
            "examples": [
              "OBJ\n  serial : \"FullDuplexSerial\""
            ]
          },
          "CON": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Constants section - defines named constant values\n",
            "syntax": "CON\n  identifier = expression\n",
            "examples": [
              "CON\n  LED_PIN = 56\n  BAUD_RATE = 115200"
            ]
          },
          "OTHER": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in CASE statement\n",
            "syntax": "CASE expression\n  value1: statements\n  OTHER: statements\n",
            "examples": [
              "CASE status\n  0: handle_success()\n  OTHER: handle_error()"
            ]
          },
          "NEXT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Continue to next iteration of loop\n",
            "syntax": "NEXT",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  IF i == 5\n    NEXT\n  process(i)"
            ]
          },
          "FILE": {
            "type": "keyword",
            "category": "Special",
            "description": "Compiler directive for file inclusion\n",
            "syntax": "FILE filename",
            "examples": [
              "FILE \"config.spin2\""
            ]
          },
          "QUIT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Exit loop immediately\n",
            "syntax": "QUIT",
            "examples": [
              "REPEAT\n  IF error_condition\n    QUIT\n  process_data()"
            ]
          },
          "BYTE": {
            "type": "keyword",
            "category": "Data Types",
            "description": "8-bit unsigned integer type (0-255)\n",
            "syntax": "BYTE variable[count]",
            "examples": [
              "BYTE flag",
              "BYTE buffer[128]"
            ]
          },
          "ABORT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Abort method execution with optional error value\n",
            "syntax": "ABORT [expression]",
            "examples": [
              "ABORT",
              "ABORT error_code"
            ]
          },
          "REPEAT": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop construct with various forms\n",
            "syntax": "REPEAT [count]\nREPEAT variable FROM start TO end [STEP increment]\nREPEAT WHILE condition\nREPEAT UNTIL condition\n",
            "examples": [
              "REPEAT 10",
              "REPEAT i FROM 1 TO 100 STEP 2",
              "REPEAT WHILE sensor_active"
            ]
          },
          "CASE_FAST": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Optimized case statement for sequential values\n",
            "syntax": "CASE_FAST expression\n  value: statements\n",
            "examples": [
              "CASE_FAST status\n  0: handle_ok()\n  1: handle_error()"
            ]
          },
          "TO": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Ending value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "DAT": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Data section - contains data and inline assembly\n",
            "syntax": "DAT\n  label type value\n",
            "examples": [
              "DAT\n  message BYTE \"Hello World\", 0"
            ]
          },
          "VAR": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Variables section - declares instance variables\n",
            "syntax": "VAR\n  type variable[count]\n",
            "examples": [
              "VAR\n  LONG counter\n  BYTE buffer[256]"
            ]
          },
          "STRING": {
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Convert expression to string representation\n",
            "syntax": "STRING(expression)",
            "examples": [
              "text := STRING(number)"
            ]
          },
          "WORD": {
            "type": "keyword",
            "category": "Data Types",
            "description": "16-bit unsigned integer type (0-65535)\n",
            "syntax": "WORD variable[count]",
            "examples": [
              "WORD address",
              "WORD lookup_table[128]"
            ]
          },
          "BYTEFIT": {
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a byte constant\n",
            "syntax": [],
            "examples": [
              "CON\n  SMALL_VALUE = BYTEFIT(200)"
            ]
          },
          "LONG": {
            "type": "keyword",
            "category": "Data Types",
            "description": "32-bit signed integer type\n",
            "syntax": "LONG variable[count]",
            "examples": [
              "LONG counter",
              "LONG data_buffer[256]"
            ]
          },
          "LOOKDOWN": {
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns index of matching value in list\n",
            "syntax": "LOOKDOWN(value : list)",
            "examples": [
              "index := LOOKDOWN(day : \"Mon\", \"Tue\", \"Wed\")"
            ]
          },
          "UNTIL": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue until condition becomes true\n",
            "syntax": "REPEAT UNTIL condition\n  statements\n",
            "examples": [
              "REPEAT UNTIL sensor_triggered\n  check_sensor()"
            ]
          },
          "WITH": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Object context specifier for method calls\n",
            "syntax": "WITH object",
            "examples": [
              "WITH serial\n  str(\"Hello World\")"
            ]
          },
          "CASE": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Multi-way branch based on expression value\n",
            "syntax": "CASE expression\n  value1: statements\n  value2: statements\n",
            "examples": [
              "CASE day\n  1: month_name := \"January\"\n  2: month_name := \"February\""
            ]
          },
          "LOOKUP": {
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given index\n",
            "syntax": "LOOKUP(index : list)",
            "examples": [
              "day_name := LOOKUP(day : \"Sun\", \"Mon\", \"Tue\")"
            ]
          },
          "PRI": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Private method declaration - accessible only within object\n",
            "syntax": "PRI method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PRI calculate_sum(a, b) : result\n  result := a + b"
            ]
          },
          "LOOKUPZ": {
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given zero-based index\n",
            "syntax": "LOOKUPZ(index : list)",
            "examples": [
              "color := LOOKUPZ(index : RED, GREEN, BLUE)"
            ]
          },
          "WORDFIT": {
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a word constant\n",
            "syntax": [],
            "examples": [
              "CON\n  MID_VALUE = WORDFIT(32000)"
            ]
          },
          "WHILE": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue while condition remains true\n",
            "syntax": "REPEAT WHILE condition\n  statements\n",
            "examples": [
              "REPEAT WHILE data_available\n  process_data()"
            ]
          },
          "PUB": {
            "type": "keyword",
            "category": "Block Structure",
            "description": "Public method declaration - accessible from other objects\n",
            "syntax": "PUB method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PUB start(pin) : success\n  configure_pin(pin)\n  success := TRUE"
            ]
          },
          "ELSE": {
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in IF statement\n",
            "syntax": "ELSE\n  statements\n",
            "examples": [
              "ELSE\n  result := 0"
            ]
          }
        }
      },
      "operators": {
        "count": 74,
        "description": "SPIN2 operators",
        "precedence_levels": 16,
        "elements": {
          "^^": {
            "type": "operator",
            "category": "Bitwise",
            "description": "Logical XOR operator\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF state1 ^^ state2\n  toggle()"
            ]
          },
          "?": {
            "type": "operator",
            "category": "Ternary",
            "description": "Conditional selection\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "FRAC": {
            "type": "operator",
            "category": "Math",
            "description": "Calculate fraction\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "frac := dividend FRAC divisor"
            ]
          },
          ":": {
            "type": "operator",
            "category": "Ternary",
            "description": "Conditional selection\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "!&&": {
            "type": "operator",
            "category": "Logical AND",
            "description": "Boolean AND/NAND\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "+<": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ROR": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "-.": {
            "type": "operator",
            "category": "Subtract",
            "description": "Integer/float subtraction\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ">=": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "/.": {
            "type": "operator",
            "category": "Divide",
            "description": "Divide/float/modulo/unsigned\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "SCA": {
            "type": "operator",
            "category": "Unary",
            "description": "Scale value (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "scaled := value SCA factor"
            ]
          },
          "+.": {
            "type": "operator",
            "category": "Add",
            "description": "Integer/float addition\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "SIGNX": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "NOT": {
            "type": "operator",
            "category": "Unary",
            "description": "Logical NOT (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF NOT ready\n  wait()"
            ]
          },
          "+>=": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "&&": {
            "type": "operator",
            "category": "Logical AND",
            "description": "Boolean AND/NAND\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ">": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "+<=>": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "??": {
            "type": "operator",
            "category": "Var-modify",
            "description": "Pre/post increment/decrement/random\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ADDBITS": {
            "type": "operator",
            "category": "Pin",
            "description": "Add bit count to pin number\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "pin_range := start_pin ADDBITS bit_count"
            ]
          },
          "BMASK": {
            "type": "operator",
            "category": "Unary",
            "description": "Create bit mask from bit count (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "mask := BMASK(8)  // Returns $FF"
            ]
          },
          "FABS": {
            "type": "operator",
            "category": "Math",
            "description": "Floating point absolute value\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "distance := FABS(float_difference)"
            ]
          },
          "XOR": {
            "type": "operator",
            "category": "Unary",
            "description": "Logical XOR (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF state1 XOR state2\n  toggle()"
            ]
          },
          "ABS": {
            "type": "operator",
            "category": "\\",
            "description": "` `^^` `ENCOD` `DECOD` `ONES` `SQRT` `QLOG` `QEXP`\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "SCAS": {
            "type": "operator",
            "category": "Unary",
            "description": "Scale value signed (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "scaled := value SCAS factor"
            ]
          },
          "<#": {
            "type": "operator",
            "category": "Limit",
            "description": "Max/min limiting\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "<=": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ">=.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point greater than or equal comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF temp >=. threshold\n  activate()"
            ]
          },
          "REV": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "QLOG": {
            "type": "operator",
            "category": "Unary",
            "description": "Quick logarithm (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "log_val := QLOG(value)"
            ]
          },
          "<>>": {
            "type": "operator",
            "category": "Equality",
            "description": "Equal/not equal (logical/bitwise)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "+<=": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ":=": {
            "type": "operator",
            "category": "Assignment",
            "description": "Assignment operator\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "variable := value",
              "result := calculate(x, y)"
            ]
          },
          "SAR": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "--": {
            "type": "operator",
            "category": "Var-modify",
            "description": "Pre/post increment/decrement/random\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ROL": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "#>": {
            "type": "operator",
            "category": "Limit",
            "description": "Max/min limiting\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "||": {
            "type": "operator",
            "category": "Bitwise",
            "description": "Logical OR operator\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF error || timeout\n  abort()"
            ]
          },
          "++": {
            "type": "operator",
            "category": "Var-modify",
            "description": "Pre/post increment/decrement/random\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "AND": {
            "type": "operator",
            "category": "Unary",
            "description": "Logical AND (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF ready AND enabled\n  start()"
            ]
          },
          "===": {
            "type": "operator",
            "category": "Equality",
            "description": "Equal/not equal (logical/bitwise)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "-": {
            "type": "operator",
            "category": "Subtract",
            "description": "Integer/float subtraction\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "...": {
            "type": "operator",
            "category": "Special",
            "description": "Line continuation operator - allows a single logical line to span multiple physical lines in SPIN2\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [
              "statement ... continuation",
              "expression part1 + part2 + ...",
              "          part3 + part4"
            ],
            "examples": [
              "result := value1 + value2 + ...\n          value3 + value4\n",
              "IF condition1 AND condition2 AND ...\n   condition3 AND condition4\n  ' Execute if all conditions true\n",
              "REPEAT count FROM 1 TO 100 STEP ...\n                  increment_value\n"
            ]
          },
          "<<": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "+>": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "QEXP": {
            "type": "operator",
            "category": "Unary",
            "description": "Quick exponential (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "exp_val := QEXP(value)"
            ]
          },
          "+//": {
            "type": "operator",
            "category": "arithmetic_operators",
            "description": "Add with unsigned modulo (circular arithmetic)",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": {
              "format": "result := value +// modulus",
              "parameters": {
                "value": "The value to operate on",
                "modulus": "The wrap-around point (result will be 0 to modulus-1)"
              },
              "returns": "Value modulo modulus"
            },
            "examples": {
              "circular_buffer_increment": {
                "description": "Increment buffer index with wrap-around",
                "code": "VAR\n  LONG head, tail\n  BYTE buffer[32]\n\nPUB addByte(data)\n  ' Calculate next tail position\n  nextTail := (tail + 1) +// 32\n  \n  ' Check if buffer full\n  if nextTail == head\n    return FALSE  ' Buffer full\n    \n  ' Add data and update tail\n  buffer[tail] := data\n  tail := nextTail\n  return TRUE\n",
                "source": "P2-OctoSerial pattern"
              },
              "modulo_arithmetic": {
                "description": "Various modulo operations",
                "code": "' Simple wrap-around\nindex := (index + 1) +// BUFFER_SIZE\n\n' Increment by N with wrap\nposition := (position + step) +// MAX_POSITION\n\n' Calculate distance in circular buffer\ndistance := (head - tail) +// BUFFER_SIZE\n"
              },
              "queue_management": {
                "description": "Circular queue push operation",
                "code": "PRI rxCheckInternal(portHandle) : nChar\n  nChar := NO_CHAR\n  if rxTailIdx[portHandle] <> rxHeadIdx[portHandle]\n    ' Increment with modulo\n    rxHeadIdx[portHandle] := (rxHeadIdx[portHandle] + 1) +// BUF_SIZE\n    ' Read from new head position\n    nChar := BYTE[pRxBuf[portHandle]][rxHeadIdx[portHandle]]\n",
                "source": "P2-OctoSerial"
              }
            }
          },
          "/": {
            "type": "operator",
            "category": "Divide",
            "description": "Divide/float/modulo/unsigned\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "<=.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point less than or equal comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF count <=. limit\n  continue()"
            ]
          },
          "OR": {
            "type": "operator",
            "category": "Unary",
            "description": "Logical OR (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF error OR timeout\n  abort()"
            ]
          },
          "<=>": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "*.": {
            "type": "operator",
            "category": "Multiply",
            "description": "Integer/float multiply\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ZEROX": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "+": {
            "type": "operator",
            "category": "Add",
            "description": "Integer/float addition\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ENCOD": {
            "type": "operator",
            "category": "Unary",
            "description": "Encode highest bit position (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "bit_pos := ENCOD(mask)"
            ]
          },
          "==": {
            "type": "operator",
            "category": "Equality",
            "description": "Equal/not equal (logical/bitwise)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "<": {
            "type": "operator",
            "category": "Comparison",
            "description": "Signed/unsigned compare\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ":=:": {
            "type": "operator",
            "category": "Assignment",
            "description": "Swap operator\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "a :=: b  // swap values of a and b"
            ]
          },
          "SQRT": {
            "type": "operator",
            "category": "Math",
            "description": "Integer square root\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "side := SQRT(area)"
            ]
          },
          "+/": {
            "type": "operator",
            "category": "Divide",
            "description": "Divide/float/modulo/unsigned\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "? :": {
            "type": "operator",
            "category": "Assignment",
            "description": "Ternary conditional operator\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "result := condition ? true_value : false_value"
            ]
          },
          "//": {
            "type": "operator",
            "category": "Divide",
            "description": "Divide/float/modulo/unsigned\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          ">.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point greater than comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF speed >. max_speed\n  slow_down()"
            ]
          },
          "<>.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point inequality comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF result <>. 0.0\n  handle_error()"
            ]
          },
          "<.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point less than comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF x <. y\n  smaller := x"
            ]
          },
          "DECOD": {
            "type": "operator",
            "category": "Unary",
            "description": "Decode bit position to mask (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "mask := DECOD(5)  // Returns $20"
            ]
          },
          "FSQRT": {
            "type": "operator",
            "category": "Math",
            "description": "Floating point square root\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "side := FSQRT(float_area)"
            ]
          },
          "<>": {
            "type": "operator",
            "category": "Equality",
            "description": "Equal/not equal (logical/bitwise)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ONES": {
            "type": "operator",
            "category": "Unary",
            "description": "Count number of 1 bits (also PASM2 instruction)\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "count := ONES(%10110101)  // Returns 5"
            ]
          },
          "*": {
            "type": "operator",
            "category": "Multiply",
            "description": "Integer/float multiply\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "ADDPINS": {
            "type": "operator",
            "category": "Pin",
            "description": "Add pin count to pin number\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "pin_range := start_pin ADDPINS pin_count"
            ]
          },
          ">>": {
            "type": "operator",
            "category": "Shift/Rotate",
            "description": "Bit manipulation\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": []
          },
          "==.": {
            "type": "operator",
            "category": "Float Compare",
            "description": "Floating point equality comparison\n",
            "precedence": 0,
            "associativity": "left-to-right",
            "operands": 2,
            "syntax": [],
            "examples": [
              "IF value ==. target\n  found()"
            ]
          }
        }
      },
      "methods": {
        "count": 87,
        "description": "Built-in SPIN2 methods",
        "elements": {
          "GETCRC": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Calculate CRC using hardware CRC engine\n",
            "parameters": [
              {
                "name": "DataAddress",
                "type": "address",
                "description": "Address of data to calculate CRC for"
              },
              {
                "name": "Polynomial",
                "type": "long",
                "description": "CRC polynomial to use"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to process"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Calculated CRC value"
            },
            "syntax": "crc := GETCRC(DataAddress, Polynomial, Count)",
            "examples": [
              {
                "code": "' Calculate CRC-32\ncrc32 := GETCRC(@data, $EDB88320, size)\n",
                "description": "Calculate standard CRC-32"
              },
              {
                "code": "' Calculate CRC-16\ncrc16 := GETCRC(@buffer, $8005, length) & $FFFF\n",
                "description": "Calculate CRC-16"
              },
              {
                "code": "' Verify data integrity\ncalculated := GETCRC(@packet, polynomial, packet_size)\nif calculated == expected_crc\n  ' Data is valid\n",
                "description": "Verify data with CRC"
              }
            ],
            "compiler_implementation": {}
          },
          "LONGFILL": {
            "type": "method",
            "category": "memory_operations",
            "description": "Fill a specified region of hub RAM with a 32-bit long value.\nEfficiently sets multiple consecutive longs to the same value.\nCommonly used for clearing arrays, initializing data structures, and setting patterns.\n",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for correct operation.\nStarting address for the fill operation.\n"
              },
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit value to fill with.\nCan be any long value.\nCommon values: 0 (clear), -1 ($FFFFFFFF), pointers, patterns.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to fill (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "syntax": "LONGFILL(Destination, Value, Count)",
            "examples": [
              {
                "code": "VAR\n  LONG buffer[256]\n  \nPUB clear_buffer()\n  LONGFILL(@buffer, 0, 256)\n",
                "description": "Clear array of longs"
              },
              {
                "code": "VAR\n  LONG stack[64]\n  \nPUB init_stack()\n  LONGFILL(@stack, $DEAD_BEEF, 64)\n  ' Helps identify stack overflow\n",
                "description": "Initialize stack with marker pattern"
              },
              {
                "code": "VAR\n  LONG pointers[100]\n  \nPUB init_pointers()\n  LONGFILL(@pointers, @default_handler, 100)\n",
                "description": "Initialize function pointer table"
              },
              {
                "code": "' Initialize mailbox system\nDAT\n  mailboxes LONG 0[8]\n  \nPUB clear_mailboxes()\n  LONGFILL(@mailboxes, -1, 8)  ' -1 = empty\n",
                "description": "Initialize inter-cog mailboxes"
              },
              {
                "code": "' Create test pattern\nVAR\n  LONG pattern[1000]\n  \nPUB create_patterns()\n  LONGFILL(@pattern[0], $12345678, 500)\n  LONGFILL(@pattern[500], $87654321, 500)\n",
                "description": "Create diagnostic patterns"
              }
            ],
            "compiler_implementation": {}
          },
          "LOOKDOWNZ": {
            "type": "method",
            "category": "Lookup Operations",
            "description": "Find 0-based index of value in list\n",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "0-based index of match, or -1 if not found"
            },
            "syntax": "index := LOOKDOWNZ(Value : Match0, Match1, ..., MatchN)",
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWNZ(30 : 10, 20, 30, 40, 50)\n' Returns 2 (30 is at index 2)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Menu option mapping\nselection := LOOKDOWNZ(key : \"Q\", \"S\", \"L\", \"H\")\ncase selection\n  0: quit_program()\n  1: save_file()\n  2: load_file()\n  3: show_help()\n",
                "description": "Map key to action"
              },
              {
                "code": "' Validate input range\nif LOOKDOWNZ(value : 0..9, 16..25, 32..47) >= 0\n  ' Value is in valid range\n  process_value(value)\n",
                "description": "Check if value in valid ranges"
              }
            ],
            "compiler_implementation": {}
          },
          "GETCT": {
            "type": "method",
            "category": "timing",
            "description": "Get the current 32-bit system counter value.\nThe system counter increments once per clock cycle continuously from boot.\nWraps around from $FFFF_FFFF to $0000_0000 approximately every 21 seconds at 200MHz.\nEssential for precise timing measurements and delays.\n",
            "parameters": "none",
            "returns": {
              "name": "Count",
              "type": "long",
              "description": "Current 32-bit system counter value.\nIncrements at system clock frequency.\nWraps from $FFFF_FFFF to $0000_0000.\n"
            },
            "syntax": "GETCT() : Count",
            "examples": [
              {
                "code": "start := GETCT()\n' ... do something ...\nelapsed := GETCT() - start\n' elapsed now contains clock cycles\n",
                "description": "Measure execution time"
              },
              {
                "code": "' Convert cycles to microseconds\nstart := GETCT()\nprocess_data()\nelapsed_us := (GETCT() - start) / (CLKFREQ / 1_000_000)\n",
                "description": "Time measurement in microseconds"
              },
              {
                "code": "' Wait for exact 1 second\ntarget := GETCT() + CLKFREQ\nWAITCT(target)\n",
                "description": "Precise 1-second delay"
              },
              {
                "code": "' Create 10Hz precise loop\nnext_time := GETCT()\nREPEAT\n  next_time += CLKFREQ / 10\n  WAITCT(next_time)\n  do_10hz_task()\n",
                "description": "Precise periodic execution"
              },
              {
                "code": "' Timeout pattern\ntimeout := GETCT() + (CLKFREQ / 1000) * 100  ' 100ms timeout\nREPEAT WHILE (GETCT() - timeout) < 0\n  IF PINREAD(0)\n    ' Got response\n    QUIT\n' Timed out\n",
                "description": "Implement timeout"
              }
            ],
            "compiler_implementation": {}
          },
          "NAN": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Check if floating-point value is Not-a-Number\n",
            "parameters": [
              {
                "name": "FloatValue",
                "type": "float",
                "description": "Floating-point value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if NaN, FALSE (0) otherwise"
            },
            "syntax": "result := NAN(FloatValue)",
            "examples": [
              {
                "code": "' Check for NaN\nif NAN(result)\n  ' Handle invalid result\n  result := 0.0\n",
                "description": "Check and handle NaN"
              },
              {
                "code": "' Validate calculation\nvalue := sqrt(-1.0)  ' Creates NaN\nif NAN(value)\n  debug(\"Invalid operation\")\n",
                "description": "Detect invalid math operation"
              },
              {
                "code": "' Filter NaN from data\nrepeat i from 0 to count-1\n  if not NAN(data[i])\n    process(data[i])\n",
                "description": "Skip NaN values in processing"
              }
            ],
            "compiler_implementation": {}
          },
          "SETREGS": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Copy hub RAM to cog registers\n",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM source address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "SETREGS(HubAddress, CogAddress, Count)",
            "examples": [
              {
                "code": "' Load PASM code into cog\nSETREGS(@pasm_code, $100, 50)  ' Load 50 longs\n",
                "description": "Load PASM code to cog RAM"
              },
              {
                "code": "' Restore saved registers\nVAR\n  LONG saved_regs[16]\n\nSETREGS(@saved_regs, $1F0, 16)  ' Restore $1F0-$1FF\n",
                "description": "Restore cog register state"
              },
              {
                "code": "' Initialize PASM variables\nVAR\n  LONG init_data[10]\n\nrepeat i from 0 to 9\n  init_data[i] := i * 100\nSETREGS(@init_data, $100, 10)\n",
                "description": "Set PASM variables in cog"
              }
            ],
            "compiler_implementation": {}
          },
          "COGINIT": {
            "type": "method",
            "category": "cog_management",
            "description": "Start PASM2 code in a specified or available cog.\nLoads PASM2 code from hub RAM into cog RAM and begins execution.\nReturns the cog number that was started, or -1 if no cog was available.\nThis is the primary method for launching parallel processing cores.\n",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- COGEXEC_NEW or NEWCOG (-1): Start any available cog\n- Bit 5 set: Execute from hub RAM (HUBEXEC mode)\n"
              },
              {
                "name": "PASMaddr",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute.\nUse @ operator to get address of code label.\nMust be long-aligned for cog execution.\n"
              },
              {
                "name": "PTRAvalue",
                "type": "long",
                "description": "Initial value for PTRA register in new cog.\nTypically used to pass parameter block address.\nCan be any 32-bit value.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using COGEXEC_NEW)\n"
            },
            "syntax": "COGINIT(CogNum, PASMaddr, PTRAvalue) : CogID",
            "examples": [
              {
                "code": "DAT\n  ORG 0\nblink_code\n  DIRH  #56\n.loop\n  OUTNOT #56\n  WAITX ##25_000_000\n  JMP   #.loop\n  \nPUB start_blinker()\n  cog := COGINIT(COGEXEC_NEW, @blink_code, 0)\n  IF cog == -1\n    ' Failed to start\n",
                "description": "Start PASM blinker in any available cog"
              },
              {
                "code": "VAR\n  LONG params[4]\n  \nPUB start_driver()\n  params[0] := @buffer\n  params[1] := buffer_size\n  params[2] := pin_number\n  params[3] := 0  ' command\n  \n  COGINIT(COGEXEC_NEW, @driver_code, @params)\n",
                "description": "Start driver with parameter block"
              },
              {
                "code": "' Stop and restart cog 1 with new code\nCOGINIT(1, @new_code, @config)\n",
                "description": "Start specific cog (stops if running)"
              },
              {
                "code": "' Start hub execution mode\nCOGINIT(COGEXEC_NEW_PAIR | HUBEXEC, @hub_code, @data)\n",
                "description": "Start code in hub execution mode"
              }
            ],
            "compiler_implementation": {}
          },
          "COGSPIN": {
            "type": "method",
            "category": "cog_management",
            "description": "Start a Spin2 method in a specified or available cog.\nLoads the Spin2 interpreter into the cog and begins executing the specified method.\nReturns the cog number that was started, or -1 if no cog was available.\nEssential for parallel Spin2 execution.\n",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- NEWCOG or -1: Start any available cog\n"
              },
              {
                "name": "Method({Parameters})",
                "type": "method_call",
                "description": "Spin2 method to execute with optional parameters.\nMethod name followed by parameters in parentheses.\nCan be in current object or another object.\n"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Hub address of stack space for the new cog.\nUse @stack_array to get address.\nMinimum 32 longs recommended, more for complex code.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using NEWCOG)\n"
            },
            "syntax": "COGSPIN(CogNum, Method({Parameters}), StackAddress) : CogID",
            "examples": [
              {
                "code": "VAR\n  LONG stack[64]\n  LONG cog_id\n  \nPUB main()\n  cog_id := COGSPIN(NEWCOG, worker(), @stack)\n  IF cog_id == -1\n    ' Failed to start\n    \nPRI worker()\n  REPEAT\n    ' Do work in parallel\n    PINTOGGLE(56)\n    WAITMS(500)\n",
                "description": "Start worker method in new cog"
              },
              {
                "code": "VAR\n  LONG stack1[64], stack2[64]\n  LONG sensor_data\n  \nPUB start_sensors()\n  COGSPIN(NEWCOG, read_sensor(0, @sensor_data), @stack1)\n  COGSPIN(NEWCOG, read_sensor(1, @sensor_data), @stack2)\n  \nPRI read_sensor(pin, ptr)\n  REPEAT\n    LONG[ptr][pin] := read_adc(pin)\n    WAITMS(10)\n",
                "description": "Multiple sensor readers with parameters"
              },
              {
                "code": "OBJ\n  serial : \"serial_driver\"\n  \nVAR\n  LONG serial_stack[128]\n  \nPUB init()\n  ' Start serial driver in separate cog\n  COGSPIN(NEWCOG, serial.rx_handler(), @serial_stack)\n",
                "description": "Start object method in new cog"
              },
              {
                "code": "VAR\n  LONG cog_stacks[4][64]\n  \nPUB parallel_process()\n  REPEAT i FROM 0 TO 3\n    COGSPIN(NEWCOG, process_chunk(i), @cog_stacks[i])\n",
                "description": "Launch multiple parallel processors"
              },
              {
                "code": "' Multi-COG Flash FS stress test pattern\nCON\n  NUM_TESTER_COGS = 7\n  STACK_SIZE_LONGS = 64\n  \nDAT\n  ' Per-COG stacks in DAT for persistence\n  stacks  LONG  0[NUM_TESTER_COGS * STACK_SIZE_LONGS]\n  results BYTE  0[8]  ' One per COG\n  lock    LONG  -1    ' Shared resource lock\n  \nPUB stress_test() | idx\n  ' Initialize lock for file system access\n  lock := LOCKNEW()\n  \n  ' Launch test COGs with indexed stacks\n  REPEAT idx FROM 0 TO NUM_TESTER_COGS-1\n    COGSPIN(NEWCOG, fs_tester(idx), @stacks[idx * STACK_SIZE_LONGS])\n  \n  ' Monitor results\n  REPEAT\n    show_results()\n    WAITMS(1000)\n    \nPRI fs_tester(cog_index) | handle\n  ' Each COG performs random file operations\n  REPEAT\n    ' Random delay to create contention\n    WAITMS(GETRND() & $FF)\n    \n    ' Acquire lock for file system access\n    REPEAT WHILE NOT LOCKTRY(lock)\n    \n    ' Perform file operation\n    handle := open(\"test.dat\", \"r\")\n    IF handle >= 0\n      ' Read/write operations\n      results[cog_index]++\n      close(handle)\n    \n    ' Release lock\n    LOCKREL(lock)\n",
                "description": "Multi-COG flash filesystem stress test",
                "source": "P2-FLASH-FS"
              }
            ],
            "compiler_implementation": {}
          },
          "CLKSET": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Safely set new clock mode and frequency\n",
            "parameters": [
              {
                "name": "Mode",
                "type": "long",
                "description": "Clock mode configuration bits"
              },
              {
                "name": "Frequency",
                "type": "long",
                "description": "New clock frequency in Hz"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "CLKSET(Mode, Frequency)",
            "examples": [
              {
                "code": "' Set to 200MHz with PLL\nCLKSET(clkmode_pll, 200_000_000)\n",
                "description": "Set high-speed PLL mode"
              },
              {
                "code": "' Drop to RCFAST for low power\nCLKSET(clkmode_rcfast, 20_000_000)\n",
                "description": "Switch to internal RC oscillator"
              },
              {
                "code": "' Dynamic frequency scaling\nif battery_low\n  CLKSET(clkmode_pll, 80_000_000)  ' Reduce to 80MHz\nelse\n  CLKSET(clkmode_pll, 180_000_000)  ' Normal 180MHz\n",
                "description": "Adjust clock for power management"
              }
            ],
            "compiler_implementation": {}
          },
          "PINHIGH": {
            "type": "method",
            "category": "pin_control",
            "description": "Drive specified pin(s) high (output mode, logic 1).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) high (OUT=1).\nThis is equivalent to the PASM2 DIRH instruction.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive high. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "syntax": "PINHIGH(PinField)",
            "examples": [
              {
                "code": "PINHIGH(56)",
                "description": "Drive pin 56 high (typically an LED pin)"
              },
              {
                "code": "PINHIGH(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 high simultaneously"
              },
              {
                "code": "PINHIGH(15..8)",
                "description": "Drive pins 8 through 15 high (note: reverse range)"
              },
              {
                "code": "CON\n  LED = 56\nPUB main()\n  PINHIGH(LED)\n",
                "description": "Use a constant for the pin number"
              }
            ],
            "compiler_implementation": {}
          },
          "WAITATN": {
            "type": "method",
            "category": "COG Management",
            "description": "Wait for attention signal from another cog\n",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "WAITATN()",
            "examples": [
              {
                "code": "' Wait for signal from another cog\nWAITATN()  ' Block until ATN received\n' Process the signal\n",
                "description": "Simple cog synchronization"
              },
              {
                "code": "' Worker cog waiting for commands\nrepeat\n  WAITATN()  ' Wait for command signal\n  command := shared_variable\n  process_command(command)\n",
                "description": "Command-driven worker cog"
              },
              {
                "code": "' Multi-stage synchronization\n' Stage 1\ndo_work_stage1()\nsignal_complete()  ' Tell master\nWAITATN()         ' Wait for next stage\n' Stage 2\ndo_work_stage2()\n",
                "description": "Multi-stage cog coordination"
              }
            ],
            "compiler_implementation": {}
          },
          "COGATN": {
            "type": "method",
            "category": "cog_management",
            "description": "Strobe the attention signal to one or more cogs.\nSets attention flags that can be polled or waited on by target cogs.\nProvides fast inter-cog signaling without using hub RAM.\nEssential for event notification and synchronization.\n",
            "parameters": [
              {
                "name": "CogMask",
                "type": "long",
                "description": "16-bit mask specifying which cogs to signal:\n- Bits 0-7: Target cog selection (1 = signal that cog)\n- Bits 8-15: Must be zero\n- Can signal multiple cogs simultaneously\n- Use (1 << cog_num) to signal specific cog\n"
              }
            ],
            "returns": "none",
            "syntax": "COGATN(CogMask)",
            "examples": [
              {
                "code": "' Signal cog 3\nCOGATN(1 << 3)\n",
                "description": "Signal single cog"
              },
              {
                "code": "' Signal cogs 0, 2, and 4\nCOGATN(%00010101)\n",
                "description": "Signal multiple cogs"
              },
              {
                "code": "' Broadcast to all other cogs\nCOGATN($FF ^ (1 << COGID()))\n",
                "description": "Signal all cogs except self"
              },
              {
                "code": "VAR\n  LONG worker_cogs\n  \nPUB signal_workers()\n  ' Signal all registered workers\n  COGATN(worker_cogs)\n  \nPUB register_worker()\n  worker_cogs |= (1 << COGID())\n",
                "description": "Dynamic cog group signaling"
              },
              {
                "code": "' Producer-consumer pattern\nPUB producer()\n  REPEAT\n    produce_data()\n    COGATN(1 << consumer_cog)  ' Data ready\n    \nPUB consumer()\n  REPEAT\n    WAITATN()  ' Wait for signal\n    process_data()\n",
                "description": "Producer-consumer synchronization"
              }
            ],
            "compiler_implementation": {}
          },
          "COGSTOP": {
            "type": "method",
            "category": "cog_management",
            "description": "Stop a specified cog immediately.\nThe cog stops executing and becomes available for reuse.\nAll pins controlled by the cog are released to float state.\nNo effect if the cog is already stopped.\n",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to stop:\n- 0-7: Stop specific cog\n- Can use COGID() to stop current cog\n- Invalid numbers have no effect\n"
              }
            ],
            "returns": "none",
            "syntax": "COGSTOP(CogNum)",
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB stop_driver()\n  IF driver_cog => 0\n    COGSTOP(driver_cog)\n    driver_cog := -1\n",
                "description": "Stop a driver cog and mark as stopped"
              },
              {
                "code": "' Emergency stop all other cogs\nREPEAT cog FROM 0 TO 7\n  IF cog <> COGID()\n    COGSTOP(cog)\n",
                "description": "Stop all cogs except current"
              },
              {
                "code": "' Self-termination\nCOGSTOP(COGID())\n' Code never reaches here\n",
                "description": "Stop current cog (suicide)"
              },
              {
                "code": "PUB restart_cog(n, code_addr, param)\n  COGSTOP(n)  ' Ensure stopped first\n  RETURN COGINIT(n, code_addr, param)\n",
                "description": "Restart a specific cog with new code"
              }
            ],
            "compiler_implementation": {}
          },
          "BYTEMOVE": {
            "type": "method",
            "category": "memory_operations",
            "description": "Copy a specified number of bytes from source to destination in hub RAM.\nHandles overlapping regions correctly (safe for moving data within same buffer).\nAutomatically determines forward or reverse copy direction to prevent data corruption.\n",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to copy.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "syntax": "BYTEMOVE(Destination, Source, Count)",
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[100]\n  BYTE backup[100]\n  \nPUB save_buffer()\n  BYTEMOVE(@backup, @buffer, 100)\n",
                "description": "Create backup copy of buffer"
              },
              {
                "code": "' Shift array elements right by 1\nVAR\n  BYTE array[50]\n  \nPUB insert_at_beginning(value)\n  BYTEMOVE(@array[1], @array[0], 49)\n  array[0] := value\n",
                "description": "Insert element at array beginning"
              },
              {
                "code": "' Copy string with length check\nPUB safe_strcopy(dest, source, max_len)\n  len := STRSIZE(source) <# (max_len - 1)\n  BYTEMOVE(dest, source, len)\n  BYTE[dest][len] := 0  ' Null terminate\n",
                "description": "Safe string copy with size limit"
              },
              {
                "code": "' Scroll buffer up one line (80 chars)\nVAR\n  BYTE screen[25][80]\n  \nPUB scroll_up()\n  BYTEMOVE(@screen[0], @screen[1], 24 * 80)\n  BYTEFILL(@screen[24], \" \", 80)\n",
                "description": "Scroll text display"
              },
              {
                "code": "' Extract substring\nPUB substring(dest, source, start, length)\n  BYTEMOVE(dest, source + start, length)\n  BYTE[dest][length] := 0\n",
                "description": "Extract portion of string"
              }
            ],
            "compiler_implementation": {}
          },
          "WAITMS": {
            "type": "method",
            "category": "timing",
            "description": "Delay execution for a specified number of milliseconds.\nProvides a simple timing delay that automatically accounts for the system clock frequency.\nMore convenient than WAITCT for simple delays as it handles the math internally.\n",
            "parameters": [
              {
                "name": "Milliseconds",
                "type": "long",
                "description": "Number of milliseconds to delay (1-4,294,967 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "syntax": "WAITMS(Milliseconds)",
            "examples": [
              {
                "code": "WAITMS(1000)",
                "description": "Delay for 1 second"
              },
              {
                "code": "REPEAT\n  PINHIGH(56)\n  WAITMS(500)\n  PINLOW(56)\n  WAITMS(500)\n",
                "description": "Blink LED at 1Hz"
              },
              {
                "code": "VAR\n  LONG delay_time\nPUB variable_delay()\n  delay_time := 100\n  REPEAT 10\n    PINTOGGLE(56)\n    WAITMS(delay_time)\n    delay_time += 50\n",
                "description": "Variable delay that increases each iteration"
              },
              {
                "code": "' Debounce a button\nIF PINREAD(0)\n  WAITMS(50)  ' Debounce delay\n  IF PINREAD(0)\n    ' Button really pressed\n",
                "description": "Button debouncing"
              }
            ],
            "compiler_implementation": {}
          },
          "COGID": {
            "type": "method",
            "category": "cog_management",
            "description": "Get the ID number of the currently executing cog.\nReturns a value from 0 to 7 identifying which cog is running this code.\nEssential for cog self-identification and coordination.\n",
            "parameters": "none",
            "returns": {
              "name": "CogNum",
              "type": "long",
              "description": "Current cog's ID number (0-7).\nAlways returns valid cog number.\n"
            },
            "syntax": "COGID() : CogNum",
            "examples": [
              {
                "code": "VAR\n  BYTE cog_status[8]\n  \nPUB mark_ready()\n  cog_status[COGID()] := 1\n",
                "description": "Mark current cog as ready in status array"
              },
              {
                "code": "PUB self_stop()\n  ' Clean up resources\n  release_pins()\n  ' Stop myself\n  COGSTOP(COGID())\n",
                "description": "Cog self-termination"
              },
              {
                "code": "DAT\n  cog_mailbox LONG 0[8]\n  \nPUB get_my_mailbox() : address\n  address := @cog_mailbox[COGID()]\n",
                "description": "Get mailbox for current cog"
              },
              {
                "code": "PUB debug_print()\n  SEND(\"Cog \", COGID(), \" reporting\", 13)\n",
                "description": "Identify cog in debug output"
              },
              {
                "code": "PUB stop_all_except_me()\n  REPEAT n FROM 0 TO 7\n    IF n <> COGID()\n      COGSTOP(n)\n",
                "description": "Stop all other cogs"
              }
            ],
            "compiler_implementation": {}
          },
          "PINFLOAT": {
            "type": "method",
            "category": "pin_control",
            "description": "Float specified pin(s) to high-impedance state (input mode).\nClears the direction bit(s) to input (DIR=0), releasing the pin from being driven.\nThe pin becomes an input and can be read or driven by external circuitry.\nThis is equivalent to the PASM2 FLTL instruction.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to float. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "syntax": "PINFLOAT(PinField)",
            "examples": [
              {
                "code": "PINFLOAT(0)",
                "description": "Float pin 0 to high-impedance"
              },
              {
                "code": "PINFLOAT(0 ADDPINS 7)",
                "description": "Float pins 0 through 7 (release bus)"
              },
              {
                "code": "' Charlieplexing example\nPINFLOAT(0 ADDPINS 7)  ' Float all pins first\nPINHIGH(3)             ' Drive one pin high\nPINLOW(0)              ' Drive another low\n' Others remain floating\n",
                "description": "Prepare pins for Charlieplexing LED matrix"
              },
              {
                "code": "' I2C bus release\nPINFLOAT(28 ADDPINS 1)  ' Release SDA and SCL (pins 28, 29)\n",
                "description": "Release I2C bus pins"
              }
            ],
            "compiler_implementation": {}
          },
          "PINSTART": {
            "type": "method",
            "category": "Smart Pin Operations",
            "description": "Configure and start smart pin with mode and parameters.\nSupports pin groups via ADDPINS operator for parallel operations.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression.\nUse ADDPINS to specify multiple consecutive pins:\n- Single pin: 16\n- Pin range: 16 ADDPINS 3 (pins 16-19)\n- Pin group: BASE_PIN ADDPINS (COUNT-1)\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "Smart pin mode configuration (P_* constants)"
              },
              {
                "name": "Xval",
                "type": "long",
                "description": "X parameter for smart pin mode"
              },
              {
                "name": "Yval",
                "type": "long",
                "description": "Y parameter for smart pin mode"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "PINSTART(PinField, Mode, Xval, Yval)",
            "examples": [
              {
                "code": "' Start ADC on pin 16\nPINSTART(16, P_ADC | P_ADC_1X, 0, 0)\n",
                "description": "Configure pin as ADC input"
              },
              {
                "code": "' Start PWM on pin 8\nPINSTART(8, P_PWM_TRIANGLE, 1000, 500)\n",
                "description": "Configure PWM with period=1000, duty=500"
              },
              {
                "code": "' Start serial TX on pin 62\nPINSTART(62, P_ASYNC_TX | P_OE, clkfreq/115200, 0)\n",
                "description": "Configure asynchronous serial transmit"
              },
              {
                "code": "' Start quadrature encoder on pins 32-33\nPINSTART(32 ADDPINS 1, P_QUADRATURE_A, 0, 0)\n",
                "description": "Configure quadrature encoder input"
              },
              {
                "code": "' HUB75 RGB pin groups for LED panel\nCON\n  RGB_BASE = 16        ' Base pin for RGB data\n  RGB_COUNT = 6        ' 6 pins for RGB (2 per color)\n  CLK_PIN = 22\n  LAT_PIN = 23\n  OE_PIN = 24\n  \nPUB setup_hub75()\n  ' Configure 6 RGB data pins as outputs\n  PINSTART(RGB_BASE ADDPINS (RGB_COUNT-1), P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Configure control pins\n  PINSTART(CLK_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(LAT_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(OE_PIN, P_HIGH_FAST | P_OE, 0, 0)\n",
                "description": "Configure HUB75 LED panel pin groups",
                "source": "hub75_driver"
              },
              {
                "code": "' Multi-pin ADC configuration for sensor array\nCON\n  SENSOR_BASE = 8\n  SENSOR_COUNT = 8      ' 8 sensors\n  \nPUB setup_sensors() | i\n  ' Configure 8 consecutive ADC pins\n  REPEAT i FROM 0 TO SENSOR_COUNT-1\n    PINSTART(SENSOR_BASE + i, P_ADC | P_ADC_1X, 0, 0)\n    \n  ' Or using ADDPINS for group config (same mode)\n  PINSTART(SENSOR_BASE ADDPINS (SENSOR_COUNT-1), P_HIGH_1K5, 0, 0)\n",
                "description": "Configure sensor array pins",
                "source": "sensor_array"
              },
              {
                "code": "' Flash FS SPI pin configuration\nCON\n  SPI_CLK = 56\n  SPI_MOSI = 57\n  SPI_MISO = 58\n  SPI_CS = 59\n  \nPUB setup_spi()\n  ' Configure SPI pins as group\n  PINSTART(SPI_CLK ADDPINS 3, P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Then set specific modes\n  PINSTART(SPI_CLK, P_TRANSITION_OUTPUT, 1, 0)\n  PINSTART(SPI_MOSI, P_SYNC_TX | P_OE, SPI_CLK<<24 | 8, 0)\n  PINSTART(SPI_MISO, P_SYNC_RX, SPI_CLK<<24 | 8, 0)\n",
                "description": "Configure SPI pins for flash filesystem",
                "source": "P2-FLASH-FS"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKNEXT": {
            "type": "method",
            "category": "Task Operations",
            "description": "Yield control to next task in round-robin schedule\n",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKNEXT()",
            "examples": [
              {
                "code": "' Cooperative yield\nrepeat\n  do_work_chunk()\n  TASKNEXT()  ' Let other tasks run\n",
                "description": "Yield after work chunk"
              },
              {
                "code": "' Polling with yield\nrepeat\n  if data_ready\n    process_data()\n  TASKNEXT()  ' Don't hog CPU\n",
                "description": "Polling with cooperation"
              },
              {
                "code": "' Long computation with yields\nrepeat i from 0 to 1000\n  calculate_step(i)\n  if i // 10 == 0\n    TASKNEXT()  ' Yield every 10 iterations\n",
                "description": "Periodic yielding in long loop"
              }
            ],
            "compiler_implementation": {}
          },
          "STRSIZE": {
            "type": "method",
            "category": "String Operations",
            "description": "Get length of null-terminated string\n",
            "parameters": [
              {
                "name": "StringAddress",
                "type": "address",
                "description": "Address of null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Number of characters (not including null terminator)"
            },
            "syntax": "length := STRSIZE(StringAddress)",
            "examples": [
              {
                "code": "' Get string length\nlen := STRSIZE(@message)\ndebug(\"Message length: \", udec(len))\n",
                "description": "Get string length"
              },
              {
                "code": "' Check if string fits in buffer\nif STRSIZE(@input) < buffer_size\n  STRCOPY(@buffer, @input, buffer_size)\n",
                "description": "Validate before copying"
              },
              {
                "code": "' Calculate total message size\ntotal := STRSIZE(@part1) + STRSIZE(@part2) + 1\n",
                "description": "Calculate combined length"
              }
            ],
            "compiler_implementation": {}
          },
          "QSIN": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Calculate sine of angle using hardware CORDIC\n",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Sine value scaled by Length"
            },
            "syntax": "sine := QSIN(Angle, Length)",
            "examples": [
              {
                "code": "' Calculate sine of 30 degrees\nsine := QSIN($1555_5555, 1000)  ' 30\u00b0 with scale 1000\n' Result: sine \u2248 500\n",
                "description": "Basic sine calculation"
              },
              {
                "code": "' Generate sine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QSIN(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate sine wave plot"
              },
              {
                "code": "' Vertical position for circular motion\ny_pos := center_y + QSIN(angle, radius)\n",
                "description": "Calculate Y position on circle"
              }
            ],
            "compiler_implementation": {}
          },
          "REGLOAD": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Load PASM2 code from hub to cog registers\n",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "REGLOAD(HubAddress)",
            "examples": [
              {
                "code": "' Load PASM code\nREGLOAD(@pasm_routines)\n' Code now in cog, ready to CALL\n",
                "description": "Load PASM for later execution"
              },
              {
                "code": "' Update PASM code\nmodify_pasm(@buffer)  ' Modify code\nREGLOAD(@buffer)      ' Reload it\nresult := CALL($100)  ' Execute at cog address\n",
                "description": "Dynamic code modification"
              },
              {
                "code": "' Load different routines\nif mode == 1\n  REGLOAD(@fast_routines)\nelse\n  REGLOAD(@accurate_routines)\n",
                "description": "Conditional code loading"
              }
            ],
            "compiler_implementation": {}
          },
          "LONGSWAP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Swap long values between two memory locations\n",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing long to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing long to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "LONGSWAP(Address1, Address2)",
            "examples": [
              {
                "code": "' Swap two long values\nLONGSWAP(@value1, @value2)\n",
                "description": "Exchange long values between variables"
              },
              {
                "code": "' Reverse long order in array\nrepeat i from 0 to size/2-1\n  LONGSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using long swapping"
              },
              {
                "code": "' Swap register values\nLONGSWAP(@reg_a, @reg_b)\n",
                "description": "Exchange 32-bit register values"
              }
            ],
            "compiler_implementation": {}
          },
          "WORDMOVE": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Copy words from one memory location to another\n",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM destination starting address for word copy"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Hub RAM source starting address for word copy"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words (16-bit values) to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "WORDMOVE(DestAddress, SourceAddress, Count)",
            "examples": [
              {
                "code": "' Copy 100 words from source to destination\nWORDMOVE(@dest_array, @source_array, 100)\n",
                "description": "Copy 100 words between arrays"
              },
              {
                "code": "' Shift array elements up by one word\nWORDMOVE(@array[1], @array[0], 99)\n",
                "description": "Shift array elements with overlap handling"
              }
            ],
            "compiler_implementation": {}
          },
          "LOCKREL": {
            "type": "method",
            "category": "Lock Operations",
            "description": "Release a captured lock\n",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to release (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "LOCKREL(LockID)",
            "examples": [
              {
                "code": "' Basic lock usage pattern\nrepeat until LOCKTRY(lock_id)\n' Critical section - exclusive access\nmodify_shared_data()\nLOCKREL(lock_id)  ' Release for other cogs\n",
                "description": "Standard lock/unlock pattern"
              },
              {
                "code": "' Ensure lock release on error\nif LOCKTRY(lock_id)\n  result := process_data()\n  LOCKREL(lock_id)\n  if result < 0\n    abort\n",
                "description": "Release lock before error abort"
              },
              {
                "code": "' Multiple lock management\nLOCKREL(resource_a_lock)\nLOCKREL(resource_b_lock)\n",
                "description": "Release multiple locks"
              }
            ],
            "compiler_implementation": {}
          },
          "PINTOGGLE": {
            "type": "method",
            "category": "pin_control",
            "description": "Drive and toggle specified pin(s).\nFirst sets the direction bit(s) to output (DIR=1), then inverts the current output state (OUT^=1).\nIf pin was high, it becomes low. If pin was low, it becomes high.\nThis is equivalent to the PASM2 DRVNOT instruction.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to toggle. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "syntax": "PINTOGGLE(PinField)",
            "examples": [
              {
                "code": "PINTOGGLE(56)",
                "description": "Toggle pin 56 (LED will change state)"
              },
              {
                "code": "REPEAT\n  PINTOGGLE(56)\n  WAITMS(500)\n",
                "description": "Blink an LED at 1Hz"
              },
              {
                "code": "PINTOGGLE(0 ADDPINS 7)",
                "description": "Toggle pins 0 through 7 simultaneously"
              },
              {
                "code": "VAR\n  LONG status_pins\nPUB flash_status()\n  status_pins := 8 ADDPINS 3  ' Pins 8, 9, 10, 11\n  REPEAT 5\n    PINTOGGLE(status_pins)\n    WAITMS(100)\n",
                "description": "Flash multiple status LEDs"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKHALT": {
            "type": "method",
            "category": "Task Operations",
            "description": "Pause/halt a running task temporarily\n",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to halt (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKHALT(TaskID)",
            "examples": [
              {
                "code": "' Pause a task\nTASKHALT(3)  ' Pause task 3\n' Do critical work...\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Pause and resume task"
              },
              {
                "code": "' Pause all tasks for critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKHALT(task_id)\n' Critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKRESUME(task_id)\n",
                "description": "Pause all tasks temporarily"
              },
              {
                "code": "' Conditional task pause\nif buffer_full\n  TASKHALT(producer_task)\n",
                "description": "Pause producer when buffer full"
              }
            ],
            "compiler_implementation": {}
          },
          "LONGCOMP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Compare blocks of longs in memory\n",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all longs match, FALSE (0) if any longs differ"
            },
            "syntax": "result := LONGCOMP(Address1, Address2, Count)",
            "examples": [
              {
                "code": "' Compare two long arrays\nif LONGCOMP(@results1, @results2, 256)\n  ' Arrays match (256 longs)\n",
                "description": "Compare long arrays"
              },
              {
                "code": "' Verify calculation results\nif LONGCOMP(@computed, @expected, 32)\n  ' All 32 computed values match expected\n",
                "description": "Verify 32-bit calculation results"
              },
              {
                "code": "' Check for signature pattern\nif LONGCOMP(@header, @valid_signature, 4)\n  ' Found valid 4-long signature\n",
                "description": "Validate header signature"
              }
            ],
            "compiler_implementation": {}
          },
          "RDPIN": {
            "type": "method",
            "category": "Smart Pin Operations",
            "description": "Read smart pin result and clear IN flag (acknowledge)\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "syntax": "result := RDPIN(PinField)",
            "examples": [
              {
                "code": "' Read ADC result from pin 16\nadc_value := RDPIN(16)\n",
                "description": "Read ADC conversion result"
              },
              {
                "code": "' Read pulse width measurement\nwidth := RDPIN(8) & $7FFF_FFFF  ' Mask off C flag\n",
                "description": "Read pulse width, remove C flag"
              },
              {
                "code": "' Check C flag while reading\nvalue := RDPIN(pin)\nif value < 0  ' C flag was set (bit 31)\n  ' Handle C flag condition\n",
                "description": "Read value and check C flag state"
              }
            ],
            "compiler_implementation": {}
          },
          "ROTXY": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Rotate X,Y coordinates by specified angle using CORDIC\n",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Angle",
                "type": "long",
                "description": "Rotation angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns rotated X2 and Y2 coordinates"
            },
            "syntax": "X2, Y2 := ROTXY(X, Y, Angle)",
            "examples": [
              {
                "code": "' Rotate point 45 degrees\nx2, y2 := ROTXY(100, 0, $2000_0000)  ' 45\u00b0 = $20000000\n' Result: x2 \u2248 71, y2 \u2248 71\n",
                "description": "Rotate point by 45 degrees"
              },
              {
                "code": "' Animate rotating point\nangle := 0\nrepeat\n  x2, y2 := ROTXY(radius, 0, angle)\n  plot(center_x + x2, center_y + y2)\n  angle += $0100_0000  ' Increment angle\n",
                "description": "Animate point rotating around origin"
              },
              {
                "code": "' Rotate sprite vertices\nrepeat i from 0 to num_vertices-1\n  vx[i], vy[i] := ROTXY(vx[i], vy[i], rotation)\n",
                "description": "Rotate all vertices of a shape"
              }
            ],
            "compiler_implementation": {}
          },
          "SEND": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Send data bytes using configured output method\n",
            "parameters": [
              {
                "name": "DataItems",
                "type": "variable",
                "description": "One or more data items to send (bytes, strings, arrays)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "SEND(DataItems...)",
            "examples": [
              {
                "code": "' Send single byte\nSEND($41)  ' Send 'A'\n",
                "description": "Send single byte"
              },
              {
                "code": "' Send string\nSEND(STRING(\"Hello, World!\"))\n",
                "description": "Send string constant"
              },
              {
                "code": "' Send multiple items\nSEND($0D, $0A, STRING(\"Ready\"), $0D, $0A)\n",
                "description": "Send mixed data types"
              },
              {
                "code": "' Send array data\nSEND(BYTE[@buffer, 10])  ' Send 10 bytes from buffer\n",
                "description": "Send array contents"
              }
            ],
            "compiler_implementation": {}
          },
          "CALL": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Call inline PASM2 code from Spin2\n",
            "parameters": [
              {
                "name": "PASMAddress",
                "type": "address",
                "description": "Address of PASM2 code to execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in PASM result register"
            },
            "syntax": "result := CALL(PASMAddress)",
            "examples": [
              {
                "code": "' Call inline PASM routine\nresult := CALL(@pasm_code)\n\nDAT\npasm_code\n  mov result1, #42\n  ret\n",
                "description": "Call simple PASM routine"
              },
              {
                "code": "' Pass parameters via PTRA/PTRB\nPTRA := @input_data\nPTRB := @output_buffer\nCALL(@process_data)\n",
                "description": "Call PASM with parameters"
              },
              {
                "code": "' Fast calculation in PASM\nvalue := CALL(@fast_multiply)\n\nDAT\nfast_multiply\n  mov pa, ptra\n  mov pb, ptrb\n  mul pa, pb\n  mov result1, pa\n  ret\n",
                "description": "PASM for fast math"
              }
            ],
            "compiler_implementation": {}
          },
          "RQPIN": {
            "type": "method",
            "category": "Smart Pin Operations",
            "description": "Read smart pin result without clearing IN flag\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "syntax": "result := RQPIN(PinField)",
            "examples": [
              {
                "code": "' Peek at smart pin value without acknowledging\ncurrent_count := RQPIN(24)\n",
                "description": "Read current value without affecting measurement"
              },
              {
                "code": "' Monitor ADC without clearing ready flag\nif PINREAD(16)  ' Check if new data ready\n  preview := RQPIN(16)  ' Preview value\n  if preview > threshold\n    actual := RDPIN(16)  ' Now acknowledge\n",
                "description": "Preview value before deciding to acknowledge"
              },
              {
                "code": "' Check multiple pins without acknowledging\nrepeat pin from 8 to 15\n  values[pin] := RQPIN(pin)\n",
                "description": "Read multiple smart pins without clearing flags"
              }
            ],
            "compiler_implementation": {}
          },
          "WAITUS": {
            "type": "method",
            "category": "timing",
            "description": "Delay execution for a specified number of microseconds.\nProvides microsecond-resolution timing delay that automatically accounts for system clock frequency.\nMore precise than WAITMS for short delays.\n",
            "parameters": [
              {
                "name": "Microseconds",
                "type": "long",
                "description": "Number of microseconds to delay (1-4,294,967,295 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "syntax": "WAITUS(Microseconds)",
            "examples": [
              {
                "code": "WAITUS(10)",
                "description": "Delay for 10 microseconds"
              },
              {
                "code": "' Generate 50% duty cycle square wave\nREPEAT\n  PINHIGH(0)\n  WAITUS(10)\n  PINLOW(0)\n  WAITUS(10)\n",
                "description": "50kHz square wave (20\u00b5s period)"
              },
              {
                "code": "' Pulse width generation\nPUB pulse(pin, width_us)\n  PINHIGH(pin)\n  WAITUS(width_us)\n  PINLOW(pin)\n",
                "description": "Generate precise pulse width"
              },
              {
                "code": "' Bit-banged serial timing\nPUB send_bit(value)\n  PINWRITE(TX_PIN, value)\n  WAITUS(104)  ' 9600 baud bit time\n",
                "description": "Serial bit timing at 9600 baud"
              },
              {
                "code": "' I2C clock stretching\nPINHIGH(SCL)\nWAITUS(5)  ' Setup time\ndata := PINREAD(SDA)\nWAITUS(5)  ' Hold time\nPINLOW(SCL)\n",
                "description": "I2C timing compliance"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKWAIT": {
            "type": "method",
            "category": "Task Operations",
            "description": "Wait for specific condition with task yielding\n",
            "parameters": [
              {
                "name": "Condition",
                "type": "expression",
                "description": "Boolean condition to wait for"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKWAIT(Condition)",
            "examples": [
              {
                "code": "' Wait for flag\nTASKWAIT(ready_flag == TRUE)\n' Flag is now true\n",
                "description": "Wait for flag to be set"
              },
              {
                "code": "' Wait for buffer space\nTASKWAIT(buffer_count < MAX_SIZE)\n' Can now add to buffer\n",
                "description": "Wait for buffer availability"
              },
              {
                "code": "' Wait for multiple conditions\nTASKWAIT(data_ready AND not busy_flag)\n' Both conditions met\n",
                "description": "Wait for complex condition"
              }
            ],
            "compiler_implementation": {}
          },
          "QLOG": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Calculate natural logarithm using hardware CORDIC\n",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Input value (unsigned 32-bit)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Natural logarithm in 5.27 fixed-point format"
            },
            "syntax": "result := QLOG(Value)",
            "examples": [
              {
                "code": "' Calculate natural log\nln_value := QLOG($1000_0000)  ' ln(0.0625)\n' Result in 5.27 fixed-point format\n",
                "description": "Basic logarithm calculation"
              },
              {
                "code": "' Calculate log base 10\nlog10_value := QLOG(value) * 39457 >> 17  ' Convert ln to log10\n",
                "description": "Convert natural log to log base 10"
              },
              {
                "code": "' Audio decibel calculation\ndb := QLOG(amplitude) * 1717 >> 12  ' 20*log10(amplitude)\n",
                "description": "Calculate decibels from amplitude"
              }
            ],
            "compiler_implementation": {}
          },
          "STRCOMP": {
            "type": "method",
            "category": "String Operations",
            "description": "Compare two null-terminated strings\n",
            "parameters": [
              {
                "name": "StringAddress1",
                "type": "address",
                "description": "Address of first null-terminated string"
              },
              {
                "name": "StringAddress2",
                "type": "address",
                "description": "Address of second null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if strings match, FALSE (0) if different"
            },
            "syntax": "result := STRCOMP(StringAddress1, StringAddress2)",
            "examples": [
              {
                "code": "' Compare two strings\nif STRCOMP(@input, STRING(\"hello\"))\n  ' Strings match\n",
                "description": "Basic string comparison"
              },
              {
                "code": "' Command parsing\nif STRCOMP(@command, STRING(\"QUIT\"))\n  quit_program()\nelseif STRCOMP(@command, STRING(\"HELP\"))\n  show_help()\n",
                "description": "Parse command strings"
              },
              {
                "code": "' Password check\nif STRCOMP(@entered_pass, @stored_pass)\n  ' Grant access\n  access_granted := TRUE\n",
                "description": "Validate password"
              }
            ],
            "compiler_implementation": {}
          },
          "HUBSET": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Execute HUBSET instruction for low-level hub configuration\n",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit configuration value for hub"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "HUBSET(Value)",
            "examples": [
              {
                "code": "' Enable debug output\nHUBSET($F0)  ' Enable debug pins\n",
                "description": "Configure debug pins"
              },
              {
                "code": "' Set clock mode bits\nHUBSET(clkmode_bits)\n",
                "description": "Direct clock configuration"
              },
              {
                "code": "' Reset specific hub feature\nHUBSET(config & !$100)  ' Clear bit 8\n",
                "description": "Modify hub configuration"
              }
            ],
            "compiler_implementation": {}
          },
          "SIZEOF": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Get size of structure or data type in bytes\n",
            "parameters": [
              {
                "name": "Structure",
                "type": "structure_name",
                "description": "Name of structure defined in CON section"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Size in bytes of the structure"
            },
            "syntax": "size := SIZEOF(Structure)",
            "examples": [
              {
                "code": "CON\n  ' Define structure\n  POINT = LONG[2]  ' X, Y coordinates\n\nPUB main()\n  size := SIZEOF(POINT)  ' Returns 8 (2 longs * 4 bytes)\n",
                "description": "Get structure size"
              },
              {
                "code": "CON\n  ' Complex structure\n  HEADER = LONG + WORD[4] + BYTE[16]\n\nVAR\n  BYTE buffer[SIZEOF(HEADER)]\n",
                "description": "Allocate buffer for structure"
              },
              {
                "code": "CON\n  ' Nested structures\n  VECTOR3 = LONG[3]\n  MATRIX3 = VECTOR3[3]\n\nPUB get_size()\n  return SIZEOF(MATRIX3)  ' Returns 36 (9 longs * 4)\n",
                "description": "Size of nested structure"
              }
            ],
            "compiler_implementation": {}
          },
          "LOCKRET": {
            "type": "method",
            "category": "Lock Operations",
            "description": "Return allocated lock to available pool\n",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to return (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "LOCKRET(LockID)",
            "examples": [
              {
                "code": "' Return lock when done\nLOCKRET(lock_id)\n",
                "description": "Free a lock"
              },
              {
                "code": "' Cleanup in stop method\nPUB stop()\n  if lock_id >= 0\n    LOCKRET(lock_id)\n    lock_id := -1\n",
                "description": "Clean shutdown with lock release"
              },
              {
                "code": "' Return multiple locks\nrepeat i from 0 to num_locks-1\n  LOCKRET(locks[i])\n",
                "description": "Free multiple locks"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKID": {
            "type": "method",
            "category": "Task Operations",
            "description": "Get the current task's ID\n",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Current task ID (0-31)"
            },
            "syntax": "id := TASKID()",
            "examples": [
              {
                "code": "' Get current task ID\nmy_id := TASKID()\ndebug(\"Running as task \", udec(my_id))\n",
                "description": "Display current task ID"
              },
              {
                "code": "' Task-specific behavior\ncase TASKID()\n  0: main_task_work()\n  1: worker1_work()\n  2: worker2_work()\n",
                "description": "Task-specific execution"
              },
              {
                "code": "' Store task ID for later\nVAR\n  LONG task_ids[32]\n\ntask_ids[TASKID()] := GETCT()  ' Store start time\n",
                "description": "Track task timing"
              }
            ],
            "compiler_implementation": {}
          },
          "LOCKCHK": {
            "type": "method",
            "category": "Lock Operations",
            "description": "Check lock state and ownership without affecting it\n",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to check (0..15)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Lock state: bit 31 = captured flag, bits 3:0 = owner cog ID"
            },
            "syntax": "state := LOCKCHK(LockID)",
            "examples": [
              {
                "code": "' Check if lock is free\nstate := LOCKCHK(lock_id)\nif state < 0  ' Bit 31 set\n  ' Lock is captured\n  owner := state & $F  ' Get owner cog\n",
                "description": "Check lock availability"
              },
              {
                "code": "' Verify we own the lock\nstate := LOCKCHK(lock_id)\nif (state & $F) == COGID()\n  ' We own this lock\n",
                "description": "Verify lock ownership"
              },
              {
                "code": "' Debug lock status\nstate := LOCKCHK(lock_id)\nif state < 0\n  debug(\"Lock captured by cog \", udec(state & $F))\nelse\n  debug(\"Lock is free\")\n",
                "description": "Display lock status"
              }
            ],
            "compiler_implementation": {}
          },
          "GETREGS": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Copy cog registers to hub RAM\n",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM destination address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "GETREGS(HubAddress, CogAddress, Count)",
            "examples": [
              {
                "code": "' Save cog registers\nVAR\n  LONG saved_regs[16]\n\nGETREGS(@saved_regs, $1F0, 16)  ' Save $1F0-$1FF\n",
                "description": "Save cog register state"
              },
              {
                "code": "' Debug cog registers\nVAR\n  LONG cog_dump[512]\n\nGETREGS(@cog_dump, 0, 512)  ' Dump entire cog\n",
                "description": "Complete cog memory dump"
              },
              {
                "code": "' Read PASM variables\nVAR\n  LONG pasm_vars[10]\n\nGETREGS(@pasm_vars, $100, 10)  ' Get PASM data\n",
                "description": "Read PASM variables from cog"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKCHK": {
            "type": "method",
            "category": "Task Operations",
            "description": "Check if a task is running\n",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to check (0-31)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if task is running, FALSE (0) if not"
            },
            "syntax": "result := TASKCHK(TaskID)",
            "examples": [
              {
                "code": "' Check if task is running\nif TASKCHK(5)\n  ' Task 5 is active\n",
                "description": "Check single task status"
              },
              {
                "code": "' Count active tasks\ncount := 0\nrepeat task_id from 0 to 31\n  if TASKCHK(task_id)\n    count++\n",
                "description": "Count running tasks"
              },
              {
                "code": "' Wait for task to finish\nrepeat while TASKCHK(worker_task)\n  TASKNEXT()  ' Yield while waiting\n",
                "description": "Wait for task completion"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKSTOP": {
            "type": "method",
            "category": "Task Operations",
            "description": "Stop and terminate a running task\n",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to stop (0-31) or THISTASK (-1) for current"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKSTOP(TaskID)",
            "examples": [
              {
                "code": "' Stop specific task\nTASKSTOP(2)  ' Stop task ID 2\n",
                "description": "Stop task by ID"
              },
              {
                "code": "' Task stops itself\nPUB background_task()\n  repeat\n    if shutdown_flag\n      TASKSTOP(THISTASK)  ' Stop self\n",
                "description": "Task self-termination"
              },
              {
                "code": "' Stop all tasks except main\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKSTOP(task_id)\n",
                "description": "Stop all secondary tasks"
              }
            ],
            "compiler_implementation": {}
          },
          "WORDFILL": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Fill memory with a repeated word value\n",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM starting address to begin filling"
              },
              {
                "name": "Value",
                "type": "word",
                "description": "16-bit word value to fill with"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to fill"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "WORDFILL(DestAddress, Value, Count)",
            "examples": [
              {
                "code": "' Clear a word array to zero\nWORDFILL(@buffer, 0, 256)\n",
                "description": "Clear 256 words to zero"
              },
              {
                "code": "' Initialize array with pattern\nWORDFILL(@data, $FFFF, 100)\n",
                "description": "Fill 100 words with $FFFF"
              },
              {
                "code": "' Set default values\nWORDFILL(@settings, $1234, 50)\n",
                "description": "Initialize settings array with default value"
              }
            ],
            "compiler_implementation": {}
          },
          "POLLATN": {
            "type": "method",
            "category": "COG Management",
            "description": "Check for attention signal without blocking\n",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if ATN signal received, FALSE (0) if not"
            },
            "syntax": "result := POLLATN()",
            "examples": [
              {
                "code": "' Non-blocking check for signal\nif POLLATN()\n  ' ATN signal received\n  process_signal()\n",
                "description": "Check for signal without blocking"
              },
              {
                "code": "' Main loop with signal handling\nrepeat\n  do_main_work()\n  if POLLATN()\n    handle_interrupt()\n",
                "description": "Interruptible main loop"
              },
              {
                "code": "' Timeout waiting for ATN\ntimeout := GETCT() + clkfreq\nrepeat\n  if POLLATN()\n    ' Got signal\n    quit\n  if POLLCT(timeout)\n    ' Timeout - no signal\n    return FALSE\n",
                "description": "ATN wait with timeout"
              }
            ],
            "compiler_implementation": {}
          },
          "XYPOL": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Convert Cartesian coordinates to polar using CORDIC\n",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate (32-bit signed)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns Rho (radius) and Theta (angle)"
            },
            "syntax": "Rho, Theta := XYPOL(X, Y)",
            "examples": [
              {
                "code": "' Convert Cartesian to polar\nrho, theta := XYPOL(100, 100)  \n' Result: rho \u2248 141, theta \u2248 $2000_0000 (45\u00b0)\n",
                "description": "Basic Cartesian to polar conversion"
              },
              {
                "code": "' Calculate distance and angle to target\ndx := target_x - current_x\ndy := target_y - current_y\ndistance, angle := XYPOL(dx, dy)\n",
                "description": "Find distance and direction to target"
              },
              {
                "code": "' Convert joystick X,Y to magnitude and direction\nmagnitude, direction := XYPOL(joy_x - 128, joy_y - 128)\nif magnitude > threshold\n  move_player(direction, magnitude)\n",
                "description": "Process joystick input"
              }
            ],
            "compiler_implementation": {}
          },
          "BYTE": {
            "type": "method",
            "category": "Data Creation",
            "description": "Declare byte data or access byte-sized memory\n",
            "parameters": [],
            "returns": "",
            "syntax": "Declaration: BYTE [Count]\nAccess: BYTE[BaseAddress][Index]\nInline: BYTE(Value1, Value2, ...)\n",
            "examples": [
              {
                "code": "DAT\n  my_bytes  BYTE  $FF, $00, $55, $AA\n",
                "description": "Declare byte data in DAT section"
              },
              {
                "code": "VAR\n  buffer  BYTE[256]  ' 256-byte array\n",
                "description": "Declare byte array in VAR section"
              },
              {
                "code": "' Write byte to hub memory\nBYTE[$1000] := $42\n\n' Read byte from hub memory  \nvalue := BYTE[$1000]\n",
                "description": "Direct hub memory byte access"
              },
              {
                "code": "' Send byte sequence\nsend(BYTE($48, $65, $6C, $6C, $6F))  ' \"Hello\"\n",
                "description": "Inline byte data creation"
              }
            ],
            "compiler_implementation": {}
          },
          "WXPIN": {
            "type": "method",
            "category": "smart_pin_operations",
            "description": "Write the X parameter register of one or more smart pins.\nThe X register typically controls timing, frequency, or configuration parameters.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "XValue",
                "type": "long",
                "description": "32-bit value for X register.\nInterpretation depends on smart pin mode:\n- Timing periods for serial modes\n- Frequency values for NCO modes\n- Configuration bits for special modes\n"
              }
            ],
            "returns": "none",
            "syntax": "WXPIN(PinField, XValue)",
            "examples": [
              {
                "code": "' Set UART baud rate to 115200\nbaud := 115200\nx_val := CLKFREQ / baud - 1\nWXPIN(30, x_val)\n",
                "description": "Configure UART baud rate"
              },
              {
                "code": "' Set PWM period to 1000 clocks\nWXPIN(56, 999)  ' 1000 - 1\n",
                "description": "Set PWM period"
              },
              {
                "code": "' Configure 1MHz NCO frequency\nfreq := 1_000_000\nx_val := freq * ($8000_0000 / (CLKFREQ / 2))\nWXPIN(pin, x_val)\n",
                "description": "Set NCO frequency"
              },
              {
                "code": "' Set measurement window to 1 second\nWXPIN(pin, CLKFREQ)\n",
                "description": "Configure measurement period"
              },
              {
                "code": "' Configure 16-bit SPI transfer\nWXPIN(spi_pin, %1_00111)  ' 16 bits, MSB first\n",
                "description": "SPI configuration"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKRESUME": {
            "type": "method",
            "category": "Task Operations",
            "description": "Resume a halted task\n",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to resume (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKRESUME(TaskID)",
            "examples": [
              {
                "code": "' Resume paused task\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Resume single task"
              },
              {
                "code": "' Synchronized resume\nTASKHALT(worker1)\nTASKHALT(worker2)\nprepare_data()\nTASKRESUME(worker1)\nTASKRESUME(worker2)\n",
                "description": "Synchronized task resumption"
              },
              {
                "code": "' Conditional resume\nif not buffer_full\n  TASKRESUME(producer_task)\n",
                "description": "Resume producer when buffer has space"
              }
            ],
            "compiler_implementation": {}
          },
          "PINWRITE": {
            "type": "method",
            "category": "pin_control",
            "description": "Drive specified pin(s) with data pattern.\nSets the direction bit(s) to output (DIR=1) and writes the data pattern to the pins (OUT=data).\nWhen multiple pins are specified, the data is written to them in parallel.\nLower bits of data correspond to lower-numbered pins in the field.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Data",
                "type": "long",
                "description": "Data to write to the pins:\n- For single pin: 0 = low, non-zero = high\n- For multiple pins: Each bit maps to a pin\n- Bit 0 of data \u2192 lowest pin in field\n- Bit n of data \u2192 nth pin in field\n"
              }
            ],
            "returns": "none",
            "syntax": "PINWRITE(PinField, Data)",
            "examples": [
              {
                "code": "PINWRITE(56, 1)",
                "description": "Write high to pin 56"
              },
              {
                "code": "PINWRITE(56, 0)",
                "description": "Write low to pin 56"
              },
              {
                "code": "PINWRITE(0 ADDPINS 7, %10101010)",
                "description": "Write alternating pattern to pins 0-7"
              },
              {
                "code": "PINWRITE(7..0, $FF)",
                "description": "Write all high to pins 0-7 (reversed range)"
              },
              {
                "code": "VAR\n  BYTE pattern\nPUB animate()\n  pattern := %00000001\n  REPEAT 8\n    PINWRITE(0 ADDPINS 7, pattern)\n    pattern <<= 1\n    WAITMS(100)\n",
                "description": "Animate a moving bit pattern"
              },
              {
                "code": "' Write 4-bit value to pins 12-15\nvalue := 9  ' Binary 1001\nPINWRITE(12 ADDPINS 3, value)\n' Pin 12 = 1, Pin 13 = 0, Pin 14 = 0, Pin 15 = 1\n",
                "description": "Write multi-bit value to pin group"
              }
            ],
            "compiler_implementation": {}
          },
          "GETMS": {
            "type": "method",
            "category": "Timing Operations",
            "description": "Get milliseconds elapsed since system boot\n",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Milliseconds since boot (32-bit value)"
            },
            "syntax": "ms := GETMS()",
            "examples": [
              {
                "code": "' Measure elapsed time\nstart_ms := GETMS()\n' Do some work...\nelapsed := GETMS() - start_ms\ndebug(\"Elapsed: \", udec(elapsed), \" ms\")\n",
                "description": "Measure operation duration"
              },
              {
                "code": "' Simple timeout\ntimeout_ms := GETMS() + 5000  ' 5 second timeout\nrepeat while GETMS() < timeout_ms\n  if check_condition()\n    quit\n",
                "description": "Implement millisecond timeout"
              },
              {
                "code": "' Display uptime\nms := GETMS()\nseconds := ms / 1000\nminutes := seconds / 60\nhours := minutes / 60\ndebug(\"Uptime: \", udec(hours), \":\", udec(minutes//60), \":\", udec(seconds//60))\n",
                "description": "Calculate and display system uptime"
              }
            ],
            "compiler_implementation": {}
          },
          "GETSEC": {
            "type": "method",
            "category": "Timing Operations",
            "description": "Get seconds elapsed since system boot\n",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Seconds since boot (32-bit value)"
            },
            "syntax": "seconds := GETSEC()",
            "examples": [
              {
                "code": "' Display uptime in seconds\ndebug(\"System uptime: \", udec(GETSEC()), \" seconds\")\n",
                "description": "Show system uptime"
              },
              {
                "code": "' Long-running timer\nstart_sec := GETSEC()\n' ... much later ...\nelapsed_sec := GETSEC() - start_sec\ndebug(\"Process ran for \", udec(elapsed_sec), \" seconds\")\n",
                "description": "Measure long durations"
              },
              {
                "code": "' Periodic task every 10 seconds\nnext_run := GETSEC() + 10\nrepeat\n  if GETSEC() >= next_run\n    do_periodic_task()\n    next_run += 10\n",
                "description": "Schedule periodic tasks"
              }
            ],
            "compiler_implementation": {}
          },
          "BYTECOMP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Complement bytes within a long value",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all bytes match, FALSE (0) if any bytes differ"
            },
            "syntax": "result := BYTECOMP(Address1, Address2, Count)",
            "examples": [
              {
                "code": "' Compare two strings\nif BYTECOMP(@string1, @string2, 10)\n  ' First 10 bytes match\n",
                "description": "Compare fixed-length byte sequences"
              },
              {
                "code": "' Verify buffer contents\nif BYTECOMP(@buffer, @expected, 256)\n  ' Buffer matches expected data\n",
                "description": "Verify buffer against expected values"
              },
              {
                "code": "' Check for pattern\nif BYTECOMP(@data[offset], @pattern, 4)\n  ' Found 4-byte pattern at offset\n",
                "description": "Search for byte pattern in data"
              }
            ],
            "compiler_implementation": {}
          },
          "WYPIN": {
            "type": "method",
            "category": "smart_pin_operations",
            "description": "Write the Y parameter register of one or more smart pins.\nThe Y register typically holds data to transmit, duty cycle values, or count values.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "YValue",
                "type": "long",
                "description": "32-bit value for Y register.\nInterpretation depends on smart pin mode:\n- Data byte/word/long for serial modes\n- Duty cycle for PWM modes\n- Count value for pulse modes\n"
              }
            ],
            "returns": "none",
            "syntax": "WYPIN(PinField, YValue)",
            "examples": [
              {
                "code": "' Send byte via UART\nWYPIN(30, \"A\")  ' Send character 'A'\n",
                "description": "UART transmit character"
              },
              {
                "code": "' Set 50% PWM duty cycle\nperiod := 1000\nWXPIN(56, period - 1)\nWYPIN(56, period / 2)  ' 50% duty\n",
                "description": "Set PWM duty cycle"
              },
              {
                "code": "' Output 10 pulses\nWYPIN(pin, 10)\n",
                "description": "Generate pulse burst"
              },
              {
                "code": "' Set DAC to mid-level\nWYPIN(dac_pin, $8000)  ' 16-bit mid-scale\n",
                "description": "Set DAC output level"
              },
              {
                "code": "' Send 32-bit SPI data\nWYPIN(spi_pin, data_long)\n",
                "description": "SPI data transmission"
              }
            ],
            "compiler_implementation": {}
          },
          "AKPIN": {
            "type": "method",
            "category": "Smart Pin Operations",
            "description": "Acknowledge smart pin by clearing its IN flag\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "AKPIN(PinField)",
            "examples": [
              {
                "code": "' Acknowledge smart pin after processing\nvalue := RQPIN(16)  ' Read without acknowledge\nprocess(value)      ' Process the value\nAKPIN(16)          ' Now acknowledge\n",
                "description": "Separate read and acknowledge operations"
              },
              {
                "code": "' Clear multiple smart pin flags\nrepeat pin from 0 to 7\n  AKPIN(pin)\n",
                "description": "Acknowledge multiple smart pins"
              },
              {
                "code": "' Reset smart pin for next measurement\nif error_condition\n  AKPIN(sensor_pin)  ' Clear flag to restart\n",
                "description": "Clear flag to reset measurement"
              }
            ],
            "compiler_implementation": {}
          },
          "WAITCT": {
            "type": "method",
            "category": "Timing Operations",
            "description": "Wait until system counter reaches specified tick value\n",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "WAITCT(Tick)",
            "examples": [
              {
                "code": "' Wait for specific time\ntarget := GETCT() + clkfreq/10  ' 100ms from now\nWAITCT(target)\n",
                "description": "Wait for precise timing point"
              },
              {
                "code": "' Create periodic loop\nnext_time := GETCT()\nrepeat\n  next_time += clkfreq/1000  ' 1ms period\n  WAITCT(next_time)\n  ' Do periodic task\n",
                "description": "Precise periodic timing"
              },
              {
                "code": "' Synchronize multiple cogs\nsync_time := GETCT() + clkfreq\nWAITCT(sync_time)  ' All cogs wait for same time\n",
                "description": "Multi-cog synchronization"
              }
            ],
            "compiler_implementation": {}
          },
          "QEXP": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Calculate exponential (e^x) using hardware CORDIC\n",
            "parameters": [
              {
                "name": "Exponent",
                "type": "long",
                "description": "Exponent value in 5.27 fixed-point format"
              }
            ],
            "returns": {
              "type": "long",
              "description": "e^x result (unsigned 32-bit)"
            },
            "syntax": "result := QEXP(Exponent)",
            "examples": [
              {
                "code": "' Calculate e^1\nresult := QEXP($0800_0000)  ' e^1 in 5.27 format\n' Result \u2248 2.71828...\n",
                "description": "Basic exponential calculation"
              },
              {
                "code": "' Calculate power of 10\npower10 := QEXP(x * 22713 >> 13)  ' 10^x using e^(x*ln(10))\n",
                "description": "Calculate powers of 10"
              },
              {
                "code": "' Exponential growth/decay\nvalue := initial * QEXP(rate * time >> 10) >> 22\n",
                "description": "Model exponential growth"
              }
            ],
            "compiler_implementation": {}
          },
          "STRING": {
            "type": "method",
            "category": "String Operations",
            "description": "Create string constant and return its address\n",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of null-terminated string"
            },
            "syntax": "address := STRING(StringLiteral)",
            "examples": [
              {
                "code": "' Get address of string constant\nmsg_addr := STRING(\"Hello, World!\")\n",
                "description": "Create string constant"
              },
              {
                "code": "' Pass string to method\nsend_message(STRING(\"Error: File not found\"))\n",
                "description": "Pass string directly to method"
              },
              {
                "code": "' Use in comparison\nif STRCOMP(@input, STRING(\"YES\"))\n  proceed()\n",
                "description": "Compare with string constant"
              },
              {
                "code": "' Build menu options\noption1 := STRING(\"1. Start\")\noption2 := STRING(\"2. Settings\")\noption3 := STRING(\"3. Quit\")\n",
                "description": "Create menu strings"
              }
            ],
            "compiler_implementation": {}
          },
          "PINREAD": {
            "type": "method",
            "category": "pin_control",
            "description": "Read the current state of specified pin(s).\nReads the input register (IN) for the specified pins regardless of their direction.\nReturns the pin states as a value where each bit represents a pin's state.\nFor single pin: returns 0 or 1. For multiple pins: returns multi-bit value.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to read. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": {
              "name": "PinStates",
              "type": "long",
              "description": "Current state of the pin(s):\n- Single pin: 0 (low) or 1 (high)\n- Multiple pins: Each bit represents a pin\n- Bit 0 = lowest numbered pin in field\n- Bit n = nth pin in field\n"
            },
            "syntax": "PINREAD(PinField) : PinStates",
            "examples": [
              {
                "code": "IF PINREAD(0)\n  ' Pin 0 is high\nELSE\n  ' Pin 0 is low\n",
                "description": "Read single pin as boolean"
              },
              {
                "code": "buttons := PINREAD(0 ADDPINS 7)",
                "description": "Read 8 buttons into a byte"
              },
              {
                "code": "' Read 4-bit DIP switch\nsetting := PINREAD(12 ADDPINS 3)\n' Returns 0-15 based on switch positions\n",
                "description": "Read multi-bit value from pins"
              },
              {
                "code": "' Wait for button press (active high)\nREPEAT UNTIL PINREAD(8)\n' Button is now pressed\n",
                "description": "Poll for pin state change"
              },
              {
                "code": "' Read and decode 3-bit address\naddress := PINREAD(5..3)\nCASE address\n  0: handle_device_0()\n  1: handle_device_1()\n  2..7: handle_others()\n",
                "description": "Read and decode pin pattern"
              }
            ],
            "compiler_implementation": {}
          },
          "BYTESWAP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Swap byte values between two memory locations\n",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing byte to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing byte to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "BYTESWAP(Address1, Address2)",
            "examples": [
              {
                "code": "' Swap two byte values\nBYTESWAP(@value1, @value2)\n",
                "description": "Exchange byte values between variables"
              },
              {
                "code": "' Reverse byte order in array\nrepeat i from 0 to size/2-1\n  BYTESWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using byte swapping"
              },
              {
                "code": "' Swap bytes at specific hub addresses\nBYTESWAP($1000, $2000)\n",
                "description": "Exchange bytes at hub memory locations"
              }
            ],
            "compiler_implementation": {}
          },
          "RECV": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Receive data byte using configured input method\n",
            "parameters": [],
            "returns": {
              "type": "byte",
              "description": "Received byte value (0-255)"
            },
            "syntax": "byte := RECV()",
            "examples": [
              {
                "code": "' Receive single byte\nchar := RECV()\n",
                "description": "Receive one byte"
              },
              {
                "code": "' Build string from input\nrepeat i from 0 to 79\n  buffer[i] := RECV()\n  if buffer[i] == 13  ' Enter key\n    buffer[i] := 0\n    quit\n",
                "description": "Receive string until Enter"
              },
              {
                "code": "' Echo received data\nrepeat\n  byte_in := RECV()\n  SEND(byte_in)\n",
                "description": "Echo loop"
              },
              {
                "code": "' Wait for specific character\nrepeat until RECV() == \"!\"\n' Got start character\n",
                "description": "Wait for start marker"
              }
            ],
            "compiler_implementation": {}
          },
          "WORD": {
            "type": "method",
            "category": "Data Creation",
            "description": "Declare word data or access word-sized memory\n",
            "parameters": [],
            "returns": "",
            "syntax": "Declaration: WORD [Count]\nAccess: WORD[BaseAddress][Index]\nInline: WORD(Value1, Value2, ...)\n",
            "examples": [
              {
                "code": "DAT\n  my_words  WORD  $1234, $5678, $ABCD\n",
                "description": "Declare word data in DAT section"
              },
              {
                "code": "VAR\n  samples  WORD[1024]  ' 1024-word array\n",
                "description": "Declare word array in VAR section"
              },
              {
                "code": "' Write word to hub memory\nWORD[$2000] := $1234\n\n' Read word from hub memory  \nvalue := WORD[$2000]\n",
                "description": "Direct hub memory word access"
              },
              {
                "code": "' Process word sequence\nprocess(WORD($1000, $2000, $3000))\n",
                "description": "Inline word data creation"
              }
            ],
            "compiler_implementation": {}
          },
          "TASKSPIN": {
            "type": "method",
            "category": "Task Operations",
            "description": "Start a new Spin2 task within the current cog\n",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID (0-31) or NEWTASK (-1) for next available"
              },
              {
                "name": "Method",
                "type": "method",
                "description": "Spin2 method to run as task with optional parameters"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Address of stack space for the task"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "TASKSPIN(TaskID, Method({Parameters}), StackAddress)",
            "examples": [
              {
                "code": "' Start a new task\nVAR\n  LONG task_stack[64]\n\nTASKSPIN(NEWTASK, background_process(), @task_stack)\n",
                "description": "Start background task"
              },
              {
                "code": "' Start specific task ID\nTASKSPIN(2, sensor_monitor(16, 1000), @sensor_stack)\n",
                "description": "Start task with ID 2"
              },
              {
                "code": "' Multiple tasks\nTASKSPIN(NEWTASK, task1(), @stack1)\nTASKSPIN(NEWTASK, task2(), @stack2)\nTASKSPIN(NEWTASK, task3(), @stack3)\n",
                "description": "Start multiple tasks"
              }
            ],
            "compiler_implementation": {}
          },
          "LONG": {
            "type": "method",
            "category": "Data Creation",
            "description": "Declare long data or access long-sized memory\n",
            "parameters": [],
            "returns": "",
            "syntax": "Declaration: LONG [Count]\nAccess: LONG[BaseAddress][Index]\nInline: LONG(Value1, Value2, ...)\n",
            "examples": [
              {
                "code": "DAT\n  my_longs  LONG  $12345678, $DEADBEEF, 1_000_000\n",
                "description": "Declare long data in DAT section"
              },
              {
                "code": "VAR\n  results  LONG[512]  ' 512-long array\n",
                "description": "Declare long array in VAR section"
              },
              {
                "code": "' Write long to hub memory\nLONG[$4000] := $12345678\n\n' Read long from hub memory  \nvalue := LONG[$4000]\n",
                "description": "Direct hub memory long access"
              },
              {
                "code": "' Pass long sequence to method\ncalculate(LONG(100_000, 200_000, 300_000))\n",
                "description": "Inline long data creation"
              }
            ],
            "compiler_implementation": {}
          },
          "WORDCOMP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Complement words within a long value",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all words match, FALSE (0) if any words differ"
            },
            "syntax": "result := WORDCOMP(Address1, Address2, Count)",
            "examples": [
              {
                "code": "' Compare two word arrays\nif WORDCOMP(@array1, @array2, 100)\n  ' Arrays match (100 words)\n",
                "description": "Compare word arrays"
              },
              {
                "code": "' Verify sensor data\nif WORDCOMP(@readings, @expected, 64)\n  ' All 64 sensor readings match expected\n",
                "description": "Verify 16-bit sensor data"
              },
              {
                "code": "' Check for word pattern\nif WORDCOMP(@data[i], @signature, 4)\n  ' Found 4-word signature at position i\n",
                "description": "Search for word pattern in data"
              }
            ],
            "compiler_implementation": {}
          },
          "COGCHK": {
            "type": "method",
            "category": "cog_management",
            "description": "Check if a specified cog is currently running.\nReturns -1 if the cog is running, or 0 if it's stopped.\nNon-invasive check that doesn't affect the cog's operation.\n",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to check (0-7).\nValues outside 0-7 return 0.\n"
              }
            ],
            "returns": {
              "name": "Running",
              "type": "long",
              "description": "- -1 (TRUE): Cog is running\n- 0 (FALSE): Cog is stopped or invalid number\n"
            },
            "syntax": "COGCHK(CogNum) : Running",
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB ensure_driver_running()\n  IF NOT COGCHK(driver_cog)\n    driver_cog := COGINIT(NEWCOG, @driver, 0)\n",
                "description": "Restart driver if not running"
              },
              {
                "code": "PUB wait_for_cog_stop(n)\n  REPEAT WHILE COGCHK(n)\n    WAITMS(10)\n",
                "description": "Wait for cog to stop"
              },
              {
                "code": "PUB count_running_cogs() : count\n  count := 0\n  REPEAT n FROM 0 TO 7\n    IF COGCHK(n)\n      count++\n",
                "description": "Count how many cogs are running"
              },
              {
                "code": "PUB find_free_cog() : cog_num\n  REPEAT cog_num FROM 0 TO 7\n    IF NOT COGCHK(cog_num)\n      RETURN\n  RETURN -1  ' All cogs busy\n",
                "description": "Find first available cog"
              },
              {
                "code": "PUB monitor_cog_health()\n  REPEAT\n    IF NOT COGCHK(critical_cog)\n      ' Critical cog crashed!\n      handle_error()\n      restart_critical_cog()\n    WAITMS(100)\n",
                "description": "Monitor critical cog health"
              }
            ],
            "compiler_implementation": {}
          },
          "LOOKDOWN": {
            "type": "method",
            "category": "Lookup Operations",
            "description": "Find 1-based index of value in list\n",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "1-based index of match, or 0 if not found"
            },
            "syntax": "index := LOOKDOWN(Value : Match1, Match2, ..., MatchN)",
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWN(30 : 10, 20, 30, 40, 50)\n' Returns 3 (30 is 3rd item)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Character classification\ntype := LOOKDOWN(char : \"A\"..\"Z\", \"a\"..\"z\", \"0\"..\"9\")\n' Returns 1 for uppercase, 2 for lowercase, 3 for digit\n",
                "description": "Classify character type"
              },
              {
                "code": "' Command parsing\ncmd := LOOKDOWN(value : $01, $02, $04, $08, $10)\ncase cmd\n  1: handle_read()\n  2: handle_write()\n  3: handle_status()\n",
                "description": "Map value to command index"
              }
            ],
            "compiler_implementation": {}
          },
          "LONGMOVE": {
            "type": "method",
            "category": "memory_operations",
            "description": "Copy a specified number of longs (32-bit values) from source to destination in hub RAM.\nHandles overlapping regions correctly with automatic direction detection.\nMore efficient than BYTEMOVE for long-aligned data.\n",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to copy (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "syntax": "LONGMOVE(Destination, Source, Count)",
            "examples": [
              {
                "code": "VAR\n  LONG data[100]\n  LONG backup[100]\n  \nPUB save_data()\n  LONGMOVE(@backup, @data, 100)\n",
                "description": "Backup array of longs"
              },
              {
                "code": "' Copy cog parameters\nDAT\n  params    LONG  0[8]\n  \nPUB setup_cog_params(src_params)\n  LONGMOVE(@params, src_params, 8)\n  COGINIT(NEWCOG, @cog_code, @params)\n",
                "description": "Copy parameter block for cog"
              },
              {
                "code": "' Shift array elements\nVAR\n  LONG array[50]\n  \nPUB remove_first()\n  result := array[0]\n  LONGMOVE(@array[0], @array[1], 49)\n  array[49] := 0\n",
                "description": "Remove first element, shift rest"
              },
              {
                "code": "' Copy structure\nVAR\n  LONG config[10]\n  LONG default_config[10]\n  \nPUB reset_config()\n  LONGMOVE(@config, @default_config, 10)\n",
                "description": "Reset configuration to defaults"
              },
              {
                "code": "' Stack manipulation\nVAR\n  LONG stack[64]\n  LONG stack_backup[64]\n  \nPUB save_stack_state()\n  LONGMOVE(@stack_backup, @stack, 64)\n",
                "description": "Save stack for debugging"
              }
            ],
            "compiler_implementation": {}
          },
          "WORDSWAP": {
            "type": "method",
            "category": "Memory Operations",
            "description": "Swap word values between two memory locations\n",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing word to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing word to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "WORDSWAP(Address1, Address2)",
            "examples": [
              {
                "code": "' Swap two word values\nWORDSWAP(@value1, @value2)\n",
                "description": "Exchange word values between variables"
              },
              {
                "code": "' Reverse word order in array\nrepeat i from 0 to size/2-1\n  WORDSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using word swapping"
              },
              {
                "code": "' Swap words for endian conversion\nWORDSWAP(@data[0], @data[1])\n",
                "description": "Swap words for byte order conversion"
              }
            ],
            "compiler_implementation": {}
          },
          "LSTRING": {
            "type": "method",
            "category": "String Operations",
            "description": "Create length-prefixed string constant\n",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of length-prefixed string"
            },
            "syntax": "address := LSTRING(StringLiteral)",
            "examples": [
              {
                "code": "' Create length-prefixed string\nlstr := LSTRING(\"Hello, World!\")\n' First byte contains 13 (length)\n",
                "description": "Create length-prefixed string"
              },
              {
                "code": "' Read length-prefixed string\nlen := BYTE[lstr_addr]\nrepeat i from 1 to len\n  char := BYTE[lstr_addr][i]\n",
                "description": "Process length-prefixed string"
              },
              {
                "code": "' Send length-prefixed string\naddr := LSTRING(\"Command\")\nsend_bytes(addr, BYTE[addr] + 1)  ' Length + data\n",
                "description": "Send with length byte"
              }
            ],
            "compiler_implementation": {}
          },
          "WRPIN": {
            "type": "method",
            "category": "smart_pin_operations",
            "description": "Write the mode configuration register of one or more smart pins.\nSets up the smart pin operating mode, input sources, and output options.\nThis is the primary method for configuring smart pin functionality.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "32-bit mode configuration value:\n- Bits 31-24: Filter/output options\n- Bits 23-16: Input selector B\n- Bits 15-8: Input selector A\n- Bits 7-6: Low level control\n- Bits 5-0: Smart pin mode (0-63)\n"
              }
            ],
            "returns": "none",
            "syntax": "WRPIN(PinField, Mode)",
            "examples": [
              {
                "code": "' Configure pin for UART TX (async serial)\nmode := %0000_0000_000_0000000000000_01_00111\nWRPIN(30, mode)\n",
                "description": "Setup UART transmit mode"
              },
              {
                "code": "' Configure for PWM output\nmode := %0000_0000_000_0000000000000_01_01001\nWRPIN(56, mode)\n",
                "description": "Setup PWM mode"
              },
              {
                "code": "' Configure quadrature encoder\nmode := %0000_0001_000_0000000000000_00_01011\nWRPIN(0, mode)\n",
                "description": "Setup quadrature decoder"
              },
              {
                "code": "' Configure ADC mode\nmode := %0000_0000_000_0000000000000_11_10011\nWRPIN(pin, mode)\n",
                "description": "Setup ADC conversion mode"
              },
              {
                "code": "' Reset to normal I/O\nWRPIN(pin, 0)\n",
                "description": "Disable smart pin mode"
              }
            ],
            "compiler_implementation": {}
          },
          "REGEXEC": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Load and execute PASM2 code from hub RAM\n",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in result1 register"
            },
            "syntax": "result := REGEXEC(HubAddress)",
            "examples": [
              {
                "code": "' Execute PASM from hub\nresult := REGEXEC(@hub_pasm_code)\n\nDAT\nhub_pasm_code\n  ' PASM code here\n  mov result1, #123\n  ret\n",
                "description": "Execute hub-based PASM code"
              },
              {
                "code": "' Dynamic code execution\nbuild_pasm_code(@buffer)  ' Generate code\nresult := REGEXEC(@buffer)  ' Execute it\n",
                "description": "Execute dynamically generated code"
              },
              {
                "code": "' Large PASM routine\nresult := REGEXEC(@big_routine)\n\nDAT\nbig_routine\n  ' Can be > 512 longs\n  ' Loaded and executed in chunks\n",
                "description": "Execute large PASM routine"
              }
            ],
            "compiler_implementation": {}
          },
          "LOOKUP": {
            "type": "method",
            "category": "Lookup Operations",
            "description": "Look up value in table using 1-based indexing",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "1-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "syntax": "result := LOOKUP(Index : Value1, Value2, ..., ValueN)",
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUP(3 : 10, 20, 30, 40, 50)\n' Returns 30 (3rd item)\n",
                "description": "Basic indexed lookup"
              },
              {
                "code": "' Menu selection\naddress := LOOKUP(choice : @option1, @option2, @option3)\n",
                "description": "Select address by menu choice"
              },
              {
                "code": "' Use ranges\nchar := LOOKUP(index : \"A\"..\"Z\", \"0\"..\"9\")\n",
                "description": "Lookup with character ranges"
              }
            ],
            "compiler_implementation": {}
          },
          "PINCLEAR": {
            "type": "method",
            "category": "Smart Pin Operations",
            "description": "Clear smart pin configuration and disable pin\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "PINCLEAR(PinField)",
            "examples": [
              {
                "code": "' Clear single smart pin\nPINCLEAR(16)\n",
                "description": "Reset pin 16 to default state"
              },
              {
                "code": "' Clear range of smart pins\nPINCLEAR(8 ADDPINS 7)  ' Clear pins 8-15\n",
                "description": "Clear multiple contiguous pins"
              },
              {
                "code": "' Reset smart pin before reconfiguration\nPINCLEAR(adc_pin)\nPINSTART(adc_pin, P_ADC, 0, 0)\n",
                "description": "Clear before setting new mode"
              }
            ],
            "compiler_implementation": {}
          },
          "LOCKTRY": {
            "type": "method",
            "category": "Lock Operations",
            "description": "Attempt to capture a lock without blocking\n",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to try capturing (0..15)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if lock captured, FALSE (0) if already taken"
            },
            "syntax": "result := LOCKTRY(LockID)",
            "examples": [
              {
                "code": "' Try to get lock\nif LOCKTRY(lock_id)\n  ' Got the lock, access resource\n  access_shared_resource()\n  LOCKREL(lock_id)\n",
                "description": "Non-blocking lock attempt"
              },
              {
                "code": "' Wait for lock with timeout\ntimeout := GETCT() + clkfreq  ' 1 second\nrepeat until LOCKTRY(lock_id) or POLLCT(timeout)\nif not LOCKTRY(lock_id)\n  ' Timeout - couldn't get lock\n  abort\n",
                "description": "Lock with timeout"
              },
              {
                "code": "' Blocking lock acquisition\nrepeat until LOCKTRY(lock_id)\n' Critical section\nLOCKREL(lock_id)\n",
                "description": "Wait until lock available"
              }
            ],
            "compiler_implementation": {}
          },
          "GETRND": {
            "type": "method",
            "category": "Miscellaneous",
            "description": "Get random number from hardware generator",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "32-bit hardware random number"
            },
            "syntax": "random := GETRND()",
            "examples": [
              {
                "code": "' Get random number\nvalue := GETRND()\n",
                "description": "Get 32-bit random value"
              },
              {
                "code": "' Random number in range 0-99\ndice := GETRND() +// 100\n",
                "description": "Random number with modulo"
              },
              {
                "code": "' Random delay\nWAITMS(GETRND() +// 1000)  ' 0-999ms random delay\n",
                "description": "Random timing"
              },
              {
                "code": "' Seed other generators\nseed := GETRND()\ninit_prng(seed)\n",
                "description": "Seed software PRNG"
              }
            ],
            "compiler_implementation": {}
          },
          "LOOKUPZ": {
            "type": "method",
            "category": "Lookup Operations",
            "description": "Look up value in table using 0-based indexing",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "0-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "syntax": "result := LOOKUPZ(Index : Value0, Value1, ..., ValueN)",
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUPZ(2 : 10, 20, 30, 40, 50)\n' Returns 30 (index 2 = 3rd item)\n",
                "description": "Basic zero-indexed lookup"
              },
              {
                "code": "' Array-style access\nbaud := LOOKUPZ(setting : 9600, 19200, 38400, 57600, 115200)\n",
                "description": "Select baud rate by setting"
              },
              {
                "code": "' Pin mapping table\npin := LOOKUPZ(channel : 16, 17, 18, 19, 24, 25, 26, 27)\n",
                "description": "Map channel to pin number"
              },
              {
                "code": "' Use with ranges\nascii := LOOKUPZ(code : \"0\"..\"9\", \"A\"..\"F\")\n",
                "description": "Hex digit lookup table"
              }
            ],
            "compiler_implementation": {}
          },
          "POLXY": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Convert polar coordinates to Cartesian using CORDIC\n",
            "parameters": [
              {
                "name": "Rho",
                "type": "long",
                "description": "Radius/magnitude (32-bit unsigned)"
              },
              {
                "name": "Theta",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns X and Y Cartesian coordinates"
            },
            "syntax": "X, Y := POLXY(Rho, Theta)",
            "examples": [
              {
                "code": "' Convert polar to Cartesian\nx, y := POLXY(100, $4000_0000)  ' r=100, \u03b8=90\u00b0\n' Result: x \u2248 0, y \u2248 100\n",
                "description": "Basic polar to Cartesian conversion"
              },
              {
                "code": "' Draw circle using polar coordinates\nradius := 50\nrepeat angle from 0 to $FFFF_FFFF step $0400_0000\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n",
                "description": "Draw circle using polar coordinates"
              },
              {
                "code": "' Create spiral pattern\nangle := 0\nrepeat radius from 10 to 100\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n  angle += $0800_0000  ' Increment angle\n",
                "description": "Generate spiral pattern"
              }
            ],
            "compiler_implementation": {}
          },
          "BYTEFILL": {
            "type": "method",
            "category": "memory_operations",
            "description": "Fill a specified region of hub RAM with a byte value.\nEfficiently sets multiple consecutive bytes to the same value.\nCommonly used for clearing buffers, initializing arrays, and drawing operations.\n",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nStarting address for the fill operation.\nCan be any valid hub address (0-524287).\n"
              },
              {
                "name": "Value",
                "type": "byte",
                "description": "Byte value to fill with (0-255).\nHigher bits are ignored if provided.\nCommon values: 0 (clear), 32 (space), 255 ($FF).\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to fill.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "syntax": "BYTEFILL(Destination, Value, Count)",
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[256]\n  \nPUB clear_buffer()\n  BYTEFILL(@buffer, 0, 256)\n",
                "description": "Clear buffer to zeros"
              },
              {
                "code": "VAR\n  BYTE screen[80 * 25]\n  \nPUB clear_screen()\n  BYTEFILL(@screen, \" \", 80 * 25)\n",
                "description": "Clear text screen with spaces"
              },
              {
                "code": "VAR\n  BYTE line[100]\n  \nPUB draw_horizontal_line(char)\n  BYTEFILL(@line, char, 100)\n",
                "description": "Create line of characters"
              },
              {
                "code": "' Initialize lookup table\nVAR\n  BYTE lookup[256]\n  \nPUB init_table()\n  BYTEFILL(@lookup, $FF, 256)  ' All entries invalid\n  ' Then set specific valid entries\n  lookup[10] := 1\n  lookup[20] := 2\n",
                "description": "Initialize lookup table"
              },
              {
                "code": "' Create test pattern\nVAR\n  BYTE pattern[1000]\n  \nPUB create_pattern()\n  BYTEFILL(@pattern[0], $AA, 500)\n  BYTEFILL(@pattern[500], $55, 500)\n",
                "description": "Create alternating pattern"
              }
            ],
            "compiler_implementation": {}
          },
          "PINLOW": {
            "type": "method",
            "category": "pin_control",
            "description": "Drive specified pin(s) low (output mode, logic 0).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) low (OUT=0).\nThis is equivalent to the PASM2 DIRL instruction.\n",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive low. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "syntax": "PINLOW(PinField)",
            "examples": [
              {
                "code": "PINLOW(56)",
                "description": "Drive pin 56 low (turn off LED)"
              },
              {
                "code": "PINLOW(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 low simultaneously"
              },
              {
                "code": "PINLOW(49..40)",
                "description": "Drive pins 40 through 49 low (wraps if needed)"
              },
              {
                "code": "VAR\n  LONG led_pin\nPUB main()\n  led_pin := 56\n  PINLOW(led_pin)\n",
                "description": "Use a variable for the pin number"
              }
            ],
            "compiler_implementation": {}
          },
          "MULDIV64": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Multiply then divide with 64-bit intermediate result\n",
            "parameters": [
              {
                "name": "Multiplier",
                "type": "long",
                "description": "First value to multiply (32-bit signed)"
              },
              {
                "name": "Multiplicand",
                "type": "long",
                "description": "Second value to multiply (32-bit signed)"
              },
              {
                "name": "Divisor",
                "type": "long",
                "description": "Value to divide by (32-bit signed, non-zero)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Result of (Multiplier \u00d7 Multiplicand) \u00f7 Divisor"
            },
            "syntax": "result := MULDIV64(Multiplier, Multiplicand, Divisor)",
            "examples": [
              {
                "code": "' Scale value without overflow\nscaled := MULDIV64(value, 1000, 1024)  ' value*1000/1024\n",
                "description": "Scale value precisely"
              },
              {
                "code": "' Calculate percentage\npercent := MULDIV64(part, 100, total)\n",
                "description": "Calculate percentage without overflow"
              },
              {
                "code": "' Frequency calculation\nfreq := MULDIV64(clkfreq, numerator, denominator)\n",
                "description": "Calculate precise frequency"
              },
              {
                "code": "' Fixed-point math\nresult := MULDIV64(a, b, $1_0000)  ' Multiply with 16.16 fixed point\n",
                "description": "Fixed-point multiplication"
              }
            ],
            "compiler_implementation": {}
          },
          "POLLCT": {
            "type": "method",
            "category": "Timing Operations",
            "description": "Check if system counter has passed specified tick value\n",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if tick has passed, FALSE (0) if not yet"
            },
            "syntax": "result := POLLCT(Tick)",
            "examples": [
              {
                "code": "' Non-blocking timeout check\ntimeout := GETCT() + clkfreq  ' 1 second timeout\nrepeat\n  ' Do work...\n  if POLLCT(timeout)\n    ' Timeout occurred\n    quit\n",
                "description": "Implement non-blocking timeout"
              },
              {
                "code": "' Check if delay has elapsed\nstart_time := GETCT()\nend_time := start_time + clkfreq/10\nrepeat while not POLLCT(end_time)\n  ' Do other work while waiting\n",
                "description": "Non-blocking delay with work"
              },
              {
                "code": "' Multiple timer management\nrepeat\n  if POLLCT(timer1)\n    handle_timer1()\n    timer1 += period1\n  if POLLCT(timer2)\n    handle_timer2()\n    timer2 += period2\n",
                "description": "Manage multiple software timers"
              }
            ],
            "compiler_implementation": {}
          },
          "STRCOPY": {
            "type": "method",
            "category": "String Operations",
            "description": "Copy null-terminated string with length limit\n",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Destination buffer address"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Source string address (null-terminated)"
              },
              {
                "name": "MaxCount",
                "type": "integer",
                "description": "Maximum characters to copy (including null)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "syntax": "STRCOPY(DestAddress, SourceAddress, MaxCount)",
            "examples": [
              {
                "code": "' Copy string with buffer limit\nSTRCOPY(@buffer, @source, 80)  ' Max 79 chars + null\n",
                "description": "Safe string copy with limit"
              },
              {
                "code": "' Copy user input\nSTRCOPY(@name, @input, 32)  ' Limit name to 31 chars\n",
                "description": "Copy with length protection"
              },
              {
                "code": "' Build compound string\nSTRCOPY(@message, STRING(\"Error: \"), 100)\n' Then append more...\n",
                "description": "Start building message"
              }
            ],
            "compiler_implementation": {}
          },
          "LOCKNEW": {
            "type": "method",
            "category": "Lock Operations",
            "description": "Allocate a new hardware lock for inter-cog synchronization\n",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Lock ID (0..15) if successful, negative if no locks available"
            },
            "syntax": "lock_id := LOCKNEW()",
            "examples": [
              {
                "code": "' Allocate a new lock\nlock := LOCKNEW()\nif lock < 0\n  ' No locks available\n  abort\n",
                "description": "Allocate lock with error checking"
              },
              {
                "code": "' Initialize shared resource lock\nVAR\n  long buffer_lock\n\nPUB init()\n  buffer_lock := LOCKNEW()\n",
                "description": "Create lock for shared buffer"
              },
              {
                "code": "' Multiple locks for different resources\nspi_lock := LOCKNEW()\nuart_lock := LOCKNEW()\ni2c_lock := LOCKNEW()\n",
                "description": "Allocate multiple resource locks"
              }
            ],
            "compiler_implementation": {}
          },
          "QCOS": {
            "type": "method",
            "category": "Math/CORDIC Operations",
            "description": "Calculate cosine of angle using hardware CORDIC\n",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Cosine value scaled by Length"
            },
            "syntax": "cosine := QCOS(Angle, Length)",
            "examples": [
              {
                "code": "' Calculate cosine of 60 degrees\ncosine := QCOS($2AAA_AAAA, 1000)  ' 60\u00b0 with scale 1000\n' Result: cosine \u2248 500\n",
                "description": "Basic cosine calculation"
              },
              {
                "code": "' Generate cosine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QCOS(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate cosine wave plot"
              },
              {
                "code": "' Horizontal position for circular motion\nx_pos := center_x + QCOS(angle, radius)\n",
                "description": "Calculate X position on circle"
              }
            ],
            "compiler_implementation": {}
          }
        }
      },
      "registers": {
        "count": 25,
        "description": "SPIN2 special registers",
        "elements": {
          "IRET3": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 return vector\n",
            "address": "497",
            "access": "read_write",
            "cog_specific": true
          },
          "DIRB": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register B (pins 32-63)\n",
            "address": "507",
            "access": "read_write",
            "cog_specific": true
          },
          "PR1": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 1\n",
            "address": "497",
            "access": "read_write",
            "cog_specific": true
          },
          "OUTB": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register B (pins 32-63)\n",
            "address": "509",
            "access": "read_write",
            "cog_specific": true
          },
          "PR0": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 0\n",
            "address": "496",
            "access": "read_write",
            "cog_specific": true
          },
          "PTRA": {
            "type": "register",
            "category": "Special Function",
            "description": "Pointer A register\n",
            "address": "504",
            "access": "read_write",
            "cog_specific": true
          },
          "TASKHLT": {
            "type": "register",
            "category": "Task Management",
            "description": "Task halt register (v47+)\n",
            "address": "512",
            "access": "read_write",
            "cog_specific": true
          },
          "IRET2": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 return vector\n",
            "address": "499",
            "access": "read_write",
            "cog_specific": true
          },
          "PR7": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 7\n",
            "address": "503",
            "access": "read_write",
            "cog_specific": true
          },
          "PA": {
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter A / call target\n",
            "address": "502",
            "access": "read_write",
            "cog_specific": true
          },
          "IJMP1": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 jump vector\n",
            "address": "500",
            "access": "read_write",
            "cog_specific": true
          },
          "PR6": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 6\n",
            "address": "502",
            "access": "read_write",
            "cog_specific": true
          },
          "INB": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register B (pins 32-63)\n",
            "address": "511",
            "access": "read",
            "cog_specific": true
          },
          "IJMP3": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 jump vector\n",
            "address": "496",
            "access": "read_write",
            "cog_specific": true
          },
          "PR5": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 5\n",
            "address": "501",
            "access": "read_write",
            "cog_specific": true
          },
          "INA": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register A (pins 0-31)\n",
            "address": "510",
            "access": "read",
            "cog_specific": true
          },
          "PR4": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 4\n",
            "address": "500",
            "access": "read_write",
            "cog_specific": true
          },
          "PB": {
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter B / call target\n",
            "address": "503",
            "access": "read_write",
            "cog_specific": true
          },
          "IJMP2": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 jump vector\n",
            "address": "498",
            "access": "read_write",
            "cog_specific": true
          },
          "IRET1": {
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 return vector\n",
            "address": "501",
            "access": "read_write",
            "cog_specific": true
          },
          "OUTA": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register A (pins 0-31)\n",
            "address": "508",
            "access": "read_write",
            "cog_specific": true
          },
          "PR3": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 3\n",
            "address": "499",
            "access": "read_write",
            "cog_specific": true
          },
          "PTRB": {
            "type": "register",
            "category": "Special Function",
            "description": "Pointer B register\n",
            "address": "505",
            "access": "read_write",
            "cog_specific": true
          },
          "DIRA": {
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register A (pins 0-31)\n",
            "address": "506",
            "access": "read_write",
            "cog_specific": true
          },
          "PR2": {
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 2\n",
            "address": "498",
            "access": "read_write",
            "cog_specific": true
          }
        }
      },
      "assembly_directives": {
        "count": 8,
        "description": "Inline PASM2 assembly directives",
        "elements": {
          "ALIGNL": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Align to long boundary (4 bytes)\n",
            "syntax": "['ALIGNL']",
            "examples": [
              "ALIGNL  // Align to next long boundary"
            ]
          },
          "FIT": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Ensure code fits in specified limit\n",
            "syntax": "['FIT limit']",
            "examples": [
              "FIT $1F0  // Must fit in COG space"
            ]
          },
          "ORGH": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address for hub RAM\n",
            "syntax": "['ORGH address']",
            "examples": [
              "ORGH $400  // Start at hub address $400"
            ]
          },
          "DITTO": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Repeat last instruction (v50+)\n",
            "syntax": "['DITTO']",
            "examples": [
              "DITTO  // Repeat previous instruction"
            ]
          },
          "ALIGNW": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Align to word boundary (2 bytes)\n",
            "syntax": "['ALIGNW']",
            "examples": [
              "ALIGNW  // Align to next word boundary"
            ]
          },
          "ORGF": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address with forced alignment\n",
            "syntax": "['ORGF address']",
            "examples": [
              "ORGF $100  // Align to address $100"
            ]
          },
          "RES": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Reserve space (advance origin)\n",
            "syntax": "['RES count']",
            "examples": [
              "RES 16  // Reserve 16 locations"
            ]
          },
          "ORG": {
            "type": "assembly_directive",
            "category": "Assembly",
            "description": "Set origin address for COG RAM\n",
            "syntax": "['ORG address']",
            "examples": [
              "ORG 0  // Start at COG address 0"
            ]
          }
        }
      },
      "debug_commands": {
        "count": 23,
        "description": "DEBUG statement commands",
        "elements": {
          "SDEC_BYTE": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal byte format\n",
            "syntax": "['SDEC_BYTE(value)']",
            "examples": [
              "DEBUG(SDEC_BYTE(offset))"
            ]
          },
          "UDEC_LONG": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal long format\n",
            "syntax": "['UDEC_LONG(value)']",
            "examples": [
              "DEBUG(UDEC_LONG(timestamp))"
            ]
          },
          "UDEC_WORD": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal word format\n",
            "syntax": "['UDEC_WORD(value)']",
            "examples": [
              "DEBUG(UDEC_WORD(address))"
            ]
          },
          "UBIN": {
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary format\n",
            "syntax": "['UBIN(value)']",
            "examples": [
              "DEBUG(UBIN(mask))"
            ]
          },
          "PC_KEY": {
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC keyboard input\n",
            "syntax": "['PC_KEY']",
            "examples": [
              "DEBUG(PC_KEY)"
            ]
          },
          "BOOL": {
            "type": "debug_command",
            "category": "Boolean Format",
            "description": "Boolean format (v44+)\n",
            "syntax": "['BOOL(value)']",
            "examples": [
              "DEBUG(BOOL(flag))"
            ]
          },
          "SDEC_WORD": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal word format\n",
            "syntax": "['SDEC_WORD(value)']",
            "examples": [
              "DEBUG(SDEC_WORD(delta))"
            ]
          },
          "UDEC_BYTE": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal byte format\n",
            "syntax": "['UDEC_BYTE(value)']",
            "examples": [
              "DEBUG(UDEC_BYTE(status))"
            ]
          },
          "DLY": {
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug delay command\n",
            "syntax": "['DLY(milliseconds)']",
            "examples": [
              "DEBUG(DLY(100))"
            ]
          },
          "SDEC": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal format\n",
            "syntax": "['SDEC(value)']",
            "examples": [
              "DEBUG(SDEC(temperature))"
            ]
          },
          "SDEC_LONG": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal long format\n",
            "syntax": "['SDEC_LONG(value)']",
            "examples": [
              "DEBUG(SDEC_LONG(position))"
            ]
          },
          "UHEX": {
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal format\n",
            "syntax": "['UHEX(value)']",
            "examples": [
              "DEBUG(UHEX(address))"
            ]
          },
          "PC_MOUSE": {
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC mouse input\n",
            "syntax": "['PC_MOUSE']",
            "examples": [
              "DEBUG(PC_MOUSE)"
            ]
          },
          "DEBUG": {
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug output statement\n",
            "syntax": "['DEBUG (expressions)']",
            "examples": [
              "DEBUG(\"Value:\", value)"
            ]
          },
          "UDEC": {
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal format\n",
            "syntax": "['UDEC(value)']",
            "examples": [
              "DEBUG(UDEC(counter))"
            ]
          },
          "LSTR": {
            "type": "debug_command",
            "category": "String Format",
            "description": "Length-prefixed string\n",
            "syntax": "['LSTR(string_ptr)']",
            "examples": [
              "DEBUG(LSTR(@buffer))"
            ]
          },
          "UBIN_BYTE": {
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary byte format\n",
            "syntax": "['UBIN_BYTE(value)']",
            "examples": [
              "DEBUG(UBIN_BYTE(pattern))"
            ]
          },
          "ZSTR": {
            "type": "debug_command",
            "category": "String Format",
            "description": "Zero-terminated string\n",
            "syntax": "['ZSTR(string_ptr)']",
            "examples": [
              "DEBUG(ZSTR(@message))"
            ]
          },
          "UHEX_BYTE": {
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal byte format\n",
            "syntax": "['UHEX_BYTE(value)']",
            "examples": [
              "DEBUG(UHEX_BYTE(flags))"
            ]
          },
          "UBIN_WORD": {
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary word format\n",
            "syntax": "['UBIN_WORD(value)']",
            "examples": [
              "DEBUG(UBIN_WORD(config))"
            ]
          },
          "UBIN_LONG": {
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary long format\n",
            "syntax": "['UBIN_LONG(value)']",
            "examples": [
              "DEBUG(UBIN_LONG(bitfield))"
            ]
          },
          "UHEX_LONG": {
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal long format\n",
            "syntax": "['UHEX_LONG(value)']",
            "examples": [
              "DEBUG(UHEX_LONG(register))"
            ]
          },
          "UHEX_WORD": {
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal word format\n",
            "syntax": "['UHEX_WORD(value)']",
            "examples": [
              "DEBUG(UHEX_WORD(port))"
            ]
          }
        }
      },
      "special_symbols": {
        "count": 12,
        "description": "Special symbols and markers",
        "elements": {
          ".": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Decimal point or object method access\n",
            "usage": [],
            "examples": [
              "float_val := 3.14",
              "obj.method()"
            ]
          },
          "`": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Tick operator for special formatting\n",
            "usage": [],
            "examples": [
              "`expression"
            ]
          },
          "@@": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Absolute address operator - get absolute hub address\n",
            "usage": [],
            "examples": [
              "hub_addr := @@variable"
            ]
          },
          "..": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Range operator for CASE statements\n",
            "usage": [],
            "examples": [
              "CASE value\n  1..10: low_range()\n  11..20: high_range()"
            ]
          },
          "^@": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Object address operator - address within object\n",
            "usage": [],
            "examples": [
              "obj_addr := ^@method"
            ]
          },
          "~": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-clear operator - use value then clear\n",
            "usage": [],
            "examples": [
              "value := ~flag  // use flag then clear it"
            ]
          },
          "@": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Address-of operator - get memory address\n",
            "usage": [],
            "examples": [
              "ptr := @variable",
              "COGINIT(0, @assembly_code, @params)"
            ]
          },
          "%": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Binary number prefix\n",
            "usage": [],
            "examples": [
              "mask := %11110000",
              "pattern := %1010_1010"
            ]
          },
          "_": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Digit separator in numeric literals\n",
            "usage": [],
            "examples": [
              "freq := 80_000_000",
              "mask := %1111_0000_1111_0000"
            ]
          },
          "$$": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Current assembly address\n",
            "usage": [],
            "examples": [
              "distance := target - $$"
            ]
          },
          "~~": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-set operator - use value then set to -1\n",
            "usage": [],
            "examples": [
              "value := ~~flag  // use flag then set to -1"
            ]
          },
          "$": {
            "type": "special_symbol",
            "category": "Special",
            "description": "Hexadecimal number prefix\n",
            "usage": [],
            "examples": [
              "value := $FF",
              "address := $1000"
            ]
          }
        }
      },
      "system_variables": {
        "count": 3,
        "description": "Built-in system variables",
        "elements": {
          "CLKFREQ": {
            "type": "system_variable",
            "category": "",
            "description": "System clock frequency in Hz\n",
            "value_type": "",
            "compile_time": false
          },
          "VARBASE": {
            "type": "system_variable",
            "category": "",
            "description": "Base address of VAR section\n",
            "value_type": "",
            "compile_time": false
          },
          "CLKMODE": {
            "type": "system_variable",
            "category": "",
            "description": "System clock mode configuration\n",
            "value_type": "",
            "compile_time": false
          }
        }
      }
    },
    "statistics": {
      "total_elements": 268,
      "by_category": {
        "keywords": 36,
        "operators": 74,
        "methods": 87,
        "registers": 25,
        "assembly_directives": 8,
        "debug_commands": 23,
        "special_symbols": 12,
        "system_variables": 3
      }
    }
  },
  "code_generation_guidance": {
    "spin2": {
      "indentation": "2 spaces per level",
      "naming_conventions": {
        "constants": "UPPER_SNAKE_CASE",
        "variables": "camelCase or snake_case",
        "methods": "camelCase",
        "objects": "PascalCase"
      },
      "comment_style": {
        "single_line": "' comment",
        "block": "{{ block comment }}",
        "documentation": "'' documentation comment"
      },
      "best_practices": [
        "Use CON section for constants",
        "Use VAR section for variables",
        "Use OBJ section for object declarations",
        "Place PUB methods before PRI methods",
        "Use meaningful method and variable names"
      ]
    },
    "pasm2": {
      "instruction_format": "label instruction operands 'comment",
      "indentation": "Use tabs for alignment",
      "naming_conventions": {
        "labels": "snake_case with : suffix",
        "constants": "UPPER_SNAKE_CASE"
      }
    }
  }
}