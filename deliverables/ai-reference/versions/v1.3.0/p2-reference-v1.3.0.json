{
  "meta": {
    "version": "1.3.0",
    "release_date": "2025-09-20",
    "completeness": 0.95,
    "stable": false,
    "breaking_changes_expected": true,
    "sources": {
      "primary": "P2 Documentation v35 - Rev B/C Silicon by Chip Gracey",
      "instruction_set": "P2 Instructions v35 Spreadsheet",
      "contributors": [
        "Chip Gracey (cgracey@parallax.com)",
        "Parallax Inc."
      ],
      "pasm2": "engineering/knowledge-base/P2/language/pasm2/",
      "spin2": "engineering/knowledge-base/P2/language/spin2/ (PNUT-TS v1.51.5)"
    },
    "last_updated": "2025-09-20T11:50:14.608029"
  },
  "architecture": {
    "cogs": {
      "count": 8,
      "type": "symmetric",
      "memory_per_cog": "512 longs (2KB) COG RAM",
      "registers_per_cog": "$000-$1FF",
      "execution": "2-clock instructions typical"
    },
    "hub": {
      "memory_size": "512KB",
      "access_method": "Egg Beater - 8-way interleaved",
      "slice_rotation": "Every clock cycle",
      "long_access": "Random: 9-16 clocks, Sequential: 2 clocks"
    },
    "smart_pins": {
      "count": 64,
      "modes": 32,
      "status": "partial_documentation",
      "note": "Complete documentation pending from Jon Titus"
    },
    "cordic": {
      "pipeline_stages": 54,
      "operations": [
        "rotate",
        "vector",
        "multiply",
        "divide",
        "sqrt",
        "log",
        "exp"
      ],
      "precision": "32-bit"
    },
    "clock": {
      "internal_rc": "~24MHz",
      "pll_range": "3.125MHz to 500MHz",
      "xi_input": "DC to 200MHz",
      "max_sysclock": "180MHz typical"
    }
  },
  "instructions": {
    "total_count": 358,
    "source": "engineering/knowledge-base/P2/language/pasm2/",
    "extraction_date": "2025-09-20T11:50:14.608029",
    "categories": {
      "Math and Logic": {
        "count": 20,
        "description": "Math and Logic",
        "instructions": {
          "CRCBIT": {
            "mnemonic": "CRCBIT",
            "syntax": "CRCBIT  D,{#}S",
            "encoding": "EEEE 1001110 10I DDDDDDDDD SSSSSSSSS",
            "description": "Iterate CRC value in D using C and polynomial in S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "SUMZ": {
            "mnemonic": "SUMZ",
            "syntax": "SUMZ    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}   Sum +/-S into D by Z. If Z = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D +/- S)"
              },
              "Z": {
                "formula": "1 then D = D - S, else D = D + S"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SUMC": {
            "mnemonic": "SUMC",
            "syntax": "SUMC    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}   Sum +/-S into D by C. If C = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 then D = D - S, else D = D + S"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RGBEXP": {
            "mnemonic": "RGBEXP",
            "syntax": "RGBEXP  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100111",
            "description": "Expand 5:6:5 RGB value in D[15:0] into 8:8:8 value in D[31:8].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WRC": {
            "mnemonic": "WRC",
            "syntax": "WRC     D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101100",
            "description": "Write 0 or 1 to D, according to C. D = {31'b0, C).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MERGEW": {
            "mnemonic": "MERGEW",
            "syntax": "MERGEW  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100011",
            "description": "Merge bits of words in D. D = {D[31], D[15], D[30], D[14], ...D[17], D[1], D[16], D[0]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WRZ": {
            "mnemonic": "WRZ",
            "syntax": "WRZ     D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101110",
            "description": "Write 0 or 1 to D, according to Z. D = {31'b0, Z).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MERGEB": {
            "mnemonic": "MERGEB",
            "syntax": "MERGEB  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100001",
            "description": "Merge bits of bytes in D. D = {D[31], D[23], D[15], D[7], ...D[24], D[16], D[8], D[0]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MOVBYTS": {
            "mnemonic": "MOVBYTS",
            "syntax": "MOVBYTS D,{#}S",
            "encoding": "EEEE 1001111 11I DDDDDDDDD SSSSSSSSS",
            "description": "Move bytes within D, per S. D = {D.BYTE[S[7:6]], D.BYTE[S[5:4]], D.BYTE[S[3:2]], D.BYTE[S[1:0]]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MUXC": {
            "mnemonic": "MUXC",
            "syntax": "MUXC    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}   Mux C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ C}}). C = parity of result. *",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MUXNC": {
            "mnemonic": "MUXNC",
            "syntax": "MUXNC   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}   Mux C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ C}}). C = parity of result. *",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identifies the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "TESTB": {
            "mnemonic": "TESTB",
            "syntax": "TESTB   D,{#}S         WC/WZ",
            "encoding": "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "WC/WZ   Test bit S[4:0] of D, write to C/Z. C/Z = D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR D[S[4:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 2
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_testb",
                "pattern": "D,S/#",
                "description": "Test bit with logic function: Destination register, bit position",
                "valueType": 2
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SEUSSR": {
            "mnemonic": "SEUSSR",
            "syntax": "SEUSSR  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100101",
            "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Reverse pattern.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "RGBSQZ": {
            "mnemonic": "RGBSQZ",
            "syntax": "RGBSQZ  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100110",
            "description": "Squeeze 8:8:8 RGB value in D[31:8] into 5:6:5 value in D[15:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "LOC": {
            "mnemonic": "LOC",
            "syntax": "LOC     PA/PB/PTRA/PTRB,#{\\}A",
            "encoding": "EEEE 11101WW RAA AAAAAAAAA AAAAAAAAA",
            "description": "R = 1, address = PC + A, else address = A.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 22
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_loc",
                "pattern": "D,#S{\\}",
                "description": "Load address: destination register, immediate address (optional \\ for absolute)",
                "valueType": 22
              }
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          },
          "XORO32": {
            "mnemonic": "XORO32",
            "syntax": "XORO32  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101000",
            "description": "Iterate D with xoroshiro32+ PRNG algorithm and put PRNG result into next instruction's S.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SEUSSF": {
            "mnemonic": "SEUSSF",
            "syntax": "SEUSSF  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100100",
            "description": "Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Forward pattern.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "SPLITW": {
            "mnemonic": "SPLITW",
            "syntax": "SPLITW  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100010",
            "description": "Split odd/even bits of D into words. D = {D[31], D[29], D[27], D[25], ...D[6], D[4], D[2], D[0]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SPLITB": {
            "mnemonic": "SPLITB",
            "syntax": "SPLITB  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001100000",
            "description": "Split every 4th bit of D into bytes. D = {D[31], D[27], D[23], D[19], ...D[12], D[8], D[4], D[0]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "CRCNIB": {
            "mnemonic": "CRCNIB",
            "syntax": "CRCNIB  D,{#}S",
            "encoding": "EEEE 1001110 11I DDDDDDDDD SSSSSSSSS",
            "description": "Q = Q << 4.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "original",
            "documentation_level": "minimal"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETNIB instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETNIB instruction.",
        "instructions": {
          "ALTSN": {
            "mnemonic": "ALTSN",
            "syntax": "ALTSN Dest, {#}Src",
            "encoding": "EEEE 1001010 10I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTSN should be followed by SETNIB\u2014 it modifies the SETNIB instruction's Dest and Num values, enabling code Result: The next instruction's pipelined Dest and Num values are altered to be (Src + Dest[11:3]) & $1FF, or just Dest[11:3] for syntax 2, and Dest[2:0], respectively.\n\nALTSN should be followed by SETNIB\u2014 it modi\ufb01es the SETNIB instruction's Dest and Num values, enabling code\n\nto iterate through multiple nibbles of data across a range of Reg RAM. SETNIB's Dest value is changed to (Src +\n\nDest[11:3]) & $1FF (for syntax 1), or to Dest[11:3] (for syntax 2), and its Num value is changed to Dest[2:0].\n\nDest[11:3] corresponds to the target long register's 9-bit address and Dest[2:0] is the nibble ID within it; values of\n\n0\u20137 identify individual nibbles, by position, in least-signi\ufb01cant nibble order. Iteratively executing ALTSN followed\n\nby SETNIB, and each time incrementing ALTSN's 12-bit Dest value by one, effectively writes a stream of nibble\n\nvalues to Reg RAM as if it were all made of nibble-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of nibbles begins. ALTSN adds the long index\n\n(Dest[11:3]) to the base (Src[8:0]) to locate the register holding the target nibble. The nibble ID (Dest[2:0])\n\nidenti\ufb01es the nibble's position within that long register.\n\n\u25cf   At the end of ALTSN execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 12-bit\n\nindex (Dest) for a future ALTSN+SETNIB iteration.\n\nIn syntax 2, Dest serves as the full nibble address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its nibble index instead of the long's relative index (to add to a base) and nibble index.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 12-bit value is the index, or the full nibble address, for the SETNIB instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[11:3]) for SETNIB) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution).",
              "The base is the Reg RAM address where the series of nibbles begins. ALTSN adds the long index (Dest[11:3]) to the base (Src[8:0]) to locate the register holding the target nibble. The nibble ID (Dest[2:0]) identi\ufb01es the nibble's position within that long register.",
              "At the end of ALTSN execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 12-bit index (Dest) for a future ALTSN+SETNIB iteration.",
              "The instruction following ALTSN is shielded from interrupt",
              "ALTSN alters the next instruction regardless of its kind\u2014 the intention is for it to be a SETNIB",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Set template D \ufb01eld for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template D \ufb01eld for ALTI.",
        "instructions": {
          "SETD": {
            "mnemonic": "SETD",
            "syntax": "SETD Dest, {#}Src",
            "encoding": "EEEE 1001101 10I DDDDDDDDD SSSSSSSSS                        D                    \u2014                \u2014                     2",
            "description": "SETD copies Src[8:0] to the D field of the template, Dest, to be used with an ALTI instruction. Bits outside the D Result: The D field [17:9] of template Dest is set to Src[8:0].\n\nSETD copies Src[8:0] to the D \ufb01eld of the template, Dest, to be used with an ALTI instruction. Bits outside the D\n\n\ufb01eld remain unaffected. The D \ufb01eld (or Dest \ufb01eld) holds the address of a register (or sometimes a literal value) for\n\nthe instruction to use as it's destination value, and usually as its result destination, during its execution.\n\nThe ALTI template is a 32-bit value with the following format:\n\nBits             31:28 (4 bits)          27:19 (9 bits)              18            17:9 (9 bits)          8:0 (9 bits)\n\nField Description       Condition Field         Result Field       Indirect \"I\" Field     Dest \"D\" Field       Source \"S\" Field\n\nSETD can also be used in self-modifying Reg RAM code. Unlike with ALTx instructions, when used this way, \ufb01eld\n\nvalue modi\ufb01cation occurs in the program code itself (not the instruction pipeline); code is altered, values persist.\n\nDue to the instruction pipeline nature, after modifying a code register, it is necessary to elapse at least two\n\ninstructions before executing the modi\ufb01ed register.\n\nSETD         inst, op                        'set \"inst\" register[17:9] to op[8:0]\n\nNOP                                          '\ufb01rst spacer instruction, could be anything\n\nNOP                                          'second spacer instruction, could be anything\n\ninst      MOV          x, y                            'operate on x using y; x may become any register per SETD",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction.",
              "Src is a register or 9-bit literal whose value (Src[8:0]) is copied to the D \ufb01eld of Dest."
            ],
            "related": [
              "SETS",
              "SETR",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-NCO-rollover event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-NCO-rollover event \ufb02ag.",
        "instructions": {
          "POLLXRO": {
            "mnemonic": "POLLXRO",
            "syntax": "POLLXRO {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001100 000100100                            \u2014      XRO Event          XRO Event                2",
            "description": "POLLXRO copies the state of the streamer NCO rollover event flag into C and/or Z and then clears the flag (unless Result: Streamer-NCO-rollover event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLXRO copies the state of the streamer NCO rollover event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless\n\nit's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the streamer-NCO-\n\nrollover event \ufb02ag prior to clearing it.\n\nThe streamer-NCO-rollover event \ufb02ag is set whenever the streamer's numerically-controlled oscillator (NCO) rolls\n\nover. The streamer-NCO-rollover event \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXRO,\n\nWAITXRO, JXRO, or JNXRO instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXRO",
              "JXRO",
              "JNXRO"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to low/high according to Z or !Z.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) output level to low/high according to Z or !Z.",
        "instructions": {
          "OUTZ": {
            "mnemonic": "OUTZ",
            "syntax": "OUTZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001100",
            "description": "OUTZ or OUTNZ alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "OUTNZ": {
            "mnemonic": "OUTNZ",
            "syntax": "OUTNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001101",
            "description": "OUTZ or OUTNZ alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and to an output level of random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and to an output level of random low/high.",
        "instructions": {
          "FLTRND": {
            "mnemonic": "FLTRND",
            "syntax": "FLTRND {#}Dest {WCZ}",
            "encoding": [
              "EEEE 1101011 CZL DDDDDDDDD 001010110 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
              "EEEE 1101011 CZL DDDDDDDDD 001010100 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit"
            ],
            "description": "FLTRND sets the I/O pin(s) designated by Dest to the input direction and with output level(s) set randomly low and Result: The I/O pins described by Dest are set to the input direction and each output level is set randomly low or high; the rest are left as-is. Z = OUT bit.\n\nFLTRND sets the I/O pin(s) designated by Dest to the input direction and with output level(s) set randomly low and\n\nhigh, based on bit(s) from the Xoroshiro128** PRNG. All other pins are left unchanged. This instruction can\n\naffect one or more of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nFLTRND achieves the same effect as two instructions\u2014 DIRL followed by OUTRND.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the FLTRND instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for FLTRND's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nFLTZ / FLTNZ\n\nFloat Z or not Z\n\nI/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to Z.\n\nFLTZ       {#}Dest {WCZ}\n\nFLTNZ {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the input direction and to an output level of low/high according\n\nto Z or !Z; the rest are left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\ninput direction and output levels of low or high.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR            FX     DEST          SRC            Write             C Flag             Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001010100 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\nEEEE 1101011 CZL DDDDDDDDD 001010101 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a FLTZ or FLTNZ.\n\nFLTZ or FLTNZ sets the I/O pin(s) designated by Dest to the input direction and to a low/high output level\n\naccording to the state, or inverse state, of the Z \ufb02ag; i.e. alters the pin's direction and output registers. All other\n\npins are left unchanged. Each of these instructions, FLTZ and FLTNZ, can affect one or more of the bits within\n\nthe DIRA or DIRB and OUTA or OUTB registers.\n\nFLTZ or FLTNZ achieves the same effect as two instructions\u2014 DIRL followed by OUTZ or OUTNZ.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the FLTZ / FLTNZ instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for FLTZ / FLTNZ's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to the input direction and with output level(s) set randomly to low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if CORDIC-read-but-empty event flag set or clear.": {
        "count": 2,
        "description": "Event Branch Instruction - Jump if CORDIC-read-but-empty event flag set or clear.",
        "instructions": {
          "JNQMT": {
            "mnemonic": "JNQMT",
            "syntax": "JNQMT   {#}S",
            "encoding": "EEEE 1011110 01I 000011111 SSSSSSSSS",
            "description": "JQMT or JNQMT checks the cog's CORDIC results event flag and jumps to the address described by Src if the flag Result: If CORDIC-read-but-empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "JQMT": {
            "mnemonic": "JQMT",
            "syntax": "JQMT    {#}S",
            "encoding": "EEEE 1011110 01I 000001111 SSSSSSSSS",
            "description": "JQMT or JNQMT checks the cog's CORDIC results event flag and jumps to the address described by Src if the flag Result: If CORDIC-read-but-empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry and zero \ufb02ags left into value (2-bit rotate left).": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry and zero \ufb02ags left into value (2-bit rotate left).",
        "instructions": {
          "RCZL": {
            "mnemonic": "RCZL",
            "syntax": "RCZL Dest {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101011                           D         D[31]           D[30]                  2",
            "description": "RCZL shifts Dest's binary value left by two places and sets Dest[1] to C and Dest[0] to Z. Result: The bits of Dest are shifted left by two places and C and Z are inserted as new LSBs.\n\nRCZL shifts Dest's binary value left by two places and sets Dest[1] to C and Dest[0] to Z.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the original Dest[31] state.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z is \ufb02ag is updated to the original Dest[30] state.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "D[31] D[30] 2"
            },
            "parameters": [
              "Dest is the register containing the value to rotate the carry and zero \ufb02ags left into.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values.",
        "instructions": {
          "CMP": {
            "mnemonic": "CMP",
            "syntax": "CMP Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010000 CZI DDDDDDDDD SSSSSSSSS                  \u2014          Unsigned (D < S)      D=S                    2",
            "description": "CMP compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMP compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C\n\nand Z \ufb02ags accordingly.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest is less than Src.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest equals Src.\n\nTo compare unsigned, multi-long values, use CMP followed by CMPX as described in Comparing Two Multi-Long\n\nValues.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - S)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual               \u25aa   Page 59",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "CMPR",
              "CMPX",
              "CMPS",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "CMP D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 64,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1600
              },
              "category": "Arithmetic",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one signed value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one signed value from another.",
        "instructions": {
          "SUBS": {
            "mnemonic": "SUBS",
            "syntax": "SUBS Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001110 CZI DDDDDDDDD SSSSSSSSS                     D           sign of (D - S)       Result = 0               2",
            "description": "SUBS subtracts the signed Src from the signed Dest and stores the result into the Dest register. If Src is a 9-bit Result: Difference of signed Dest and signed Src is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.\n\nSUBS subtracts the signed Src from the signed Dest and stores the result into the Dest register. If Src is a 9-bit\n\nliteral, its value is interpreted as positive (0-511; it is not sign-extended) \u2014 use ##Value (or insert a prior AUGS\n\ninstruction) for a 32-bit signed value; negative or positive.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the subtraction results in a signed under\ufb02ow (signed\n\nborrow), or is cleared (0) if no under\ufb02ow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest - Src is zero, or is cleared (0) if it is\n\nnon-zero.\n\nTo subtract signed, multi-long values, use SUB (not SUBS) followed possibly by SUBX, and \ufb01nally SUBSX as\n\ndescribed in Subtracting Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SUB",
              "SUBX",
              "SUBSX",
              "ADDS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to !Z.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to !Z.",
        "instructions": {
          "NEGNZ": {
            "mnemonic": "NEGNZ",
            "syntax": "NEGNZ Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110111 CZI DDDDDDDDD SSSSSSSSS                    D            Sign of result       Result = 0               2",
              "EEEE 0110111 CZ0 DDDDDDDDD DDDDDDDDD                    D            Sign of result       Result = 0               2"
            ],
            "description": "NEGNZ negates Src (syntax 1) or Dest (syntax 2) if !Z = 1 and stores the result in the Dest register. If !Z = 0, the Src Result: The Src or Dest value, possibly negated according to !Z, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.\n\nNEGNZ negates Src (syntax 1) or Dest (syntax 2) if !Z = 1 and stores the result in the Dest register. If !Z = 0, the Src\n\nor Dest value is left as-is (not negated) and is stored into Dest. If the negation is performed, it \ufb02ips the value's\n\nsign; ex: 193 becomes -193, or -3,062 becomes 3,062.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to !C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if !C=0) or negated value (if !C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "NEGZ",
              "NEGC",
              "NEGNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Miscellaneous": {
        "count": 5,
        "description": "Miscellaneous",
        "instructions": {
          "SETQ": {
            "mnemonic": "SETQ",
            "syntax": "SETQ    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000101000",
            "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set block transfer. Also used before MUXQ/COGINIT/QDIV/QFRAC/QROTATE/WAITxxx.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "GETCT": {
            "mnemonic": "GETCT",
            "syntax": "GETCT   D               {WC}",
            "encoding": "EEEE 1101011 C00 DDDDDDDDD 000011010",
            "description": "T=0 on reset, CT++ on every clock.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "same"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETQ2": {
            "mnemonic": "SETQ2",
            "syntax": "SETQ2   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000101001",
            "description": "Set Q to D. Use before RDLONG/WRLONG/WMLONG to set LUT block transfer.\n\nSETQ2 enables block transfers to/from LUT RAM instead of COG RAM:\n- SETQ2 + RDLONG: Block read from HUB to LUT\n- SETQ2 + WRLONG: Block write from LUT to HUB\n- Fast bulk data movement for lookup tables\n- Essential for waveform tables and large datasets\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "WAITX": {
            "mnemonic": "WAITX",
            "syntax": "WAITX   {#}D     {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 000011111",
            "description": "Wait for D+1 clock cycles. Stalls the cog for precise timing delays.\nZ = 0 after completion.\n\nCritical for bit-banging protocols, PWM generation, and timing-sensitive\noperations where precise delays are required.\n",
            "timing": {
              "cycles": "2 + D",
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": 0
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "GETRND": {
            "mnemonic": "GETRND",
            "syntax": "GETRND\u00a0 D\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0 {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000011011",
            "description": "Get RND into C/Z. C = RND[31], Z = RND[30], unique per cog.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "RND[31], Z = RND[30], unique per cog"
              },
              "Z": {
                "formula": "RND[30], unique per cog"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 25
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_de",
                "pattern": "D | {WC/WZ/WCZ}",
                "description": "Destination register or effect flags only (GETRND)",
                "valueType": 25
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Interrupt Instruction - Trigger breakpoint in speci\ufb01ed cog.": {
        "count": 1,
        "description": "Interrupt Instruction - Trigger breakpoint in speci\ufb01ed cog.",
        "instructions": {
          "COGBRK": {
            "mnemonic": "COGBRK",
            "syntax": "COGBRK {#}Dest",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110101                   \u2014                 \u2014                  \u2014                   2",
            "description": "COGBRK triggers an asynchronous breakpoint in a designated cog. The COGBRK instruction must be executed Result: If in the Debug ISR, trigger an asynchronous breakpoint in cog identified by Dest.\n\nCOGBRK triggers an asynchronous breakpoint in a designated cog. The COGBRK instruction must be executed\n\nfrom within a Debug ISR (interrupt service routine) and the designated cog must already have its asynchronous\n\nbreakpoint interrupt enabled. Dest[2:0] indicates the ID of the desired cog.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal whose value (lower 3-bits) indicates which cog to trigger."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values plus carry \ufb02ag.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values plus carry \ufb02ag.",
        "instructions": {
          "CMPX": {
            "mnemonic": "CMPX",
            "syntax": "CMPX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010001 CZI DDDDDDDDD SSSSSSSSS                  \u2014        Unsigned (D < S+C) Z AND (D = S+C)              2",
            "description": "CMPX compares the unsigned values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMPX compares the unsigned values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally\n\nsetting the C and Z \ufb02ags accordingly. The CMPX instruction is used to perform unsigned multi-long comparisons,\n\nsuch as 64-bit comparisons.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest is less than Src plus C, or is cleared (0) otherwise.\n\nUse WC or WCZ on preceding CMP and CMPX instructions for proper \ufb01nal C \ufb02ag.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and Dest equals Src + C, or it is\n\ncleared (0) otherwise. Use WZ or WCZ on preceding CMP and CMPX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo compare multi-long values, use CMP followed by one or more CMPX instructions as described in Comparing\n\nTwo Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (D == S + C)"
              }
            },
            "parameters": [
              "Dest is a register containing the value to compare with that of Src plus C.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to !C.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to !C.",
        "instructions": {
          "NEGNC": {
            "mnemonic": "NEGNC",
            "syntax": "NEGNC Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110101 CZI DDDDDDDDD SSSSSSSSS                    D            Sign of result       Result = 0               2",
              "EEEE 0110101 CZ0 DDDDDDDDD DDDDDDDDD                    D            Sign of result       Result = 0               2"
            ],
            "description": "NEGNC negates Src (syntax 1) or Dest (syntax 2) if !C = 1 and stores the result in the Dest register. If !C = 0, the Src Result: The Src or Dest value, possibly negated according to !C, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.\n\nNEGNC negates Src (syntax 1) or Dest (syntax 2) if !C = 1 and stores the result in the Dest register. If !C = 0, the Src\n\nor Dest value is left as-is (not negated) and is stored into Dest. If the negation is performed, it \ufb02ips the value's\n\nsign; ex: 21 becomes -21, or -1,374 becomes 1,374.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to !C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if !C=0) or negated value (if !C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "NEGC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETBYTE instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETBYTE instruction.",
        "instructions": {
          "ALTSB": {
            "mnemonic": "ALTSB",
            "syntax": "ALTSB Dest, {#}Src",
            "encoding": "EEEE 1001011 00I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTSB should be followed by SETBYTE\u2014 it modifies the SETBYTE instruction's Dest and Num values, enabling.\n\nALTSB should be followed by SETBYTE\u2014 it modi\ufb01es the SETBYTE instruction's Dest and Num values, enabling\n\ncode to iterate through multiple bytes of data across a range of Reg RAM. SETBYTE's Dest value is changed to\n\n(Src + Dest[10:2]) & $1FF (for syntax 1), or to Dest[10:2] (for syntax 2), and its Num value is changed to Dest[1:0].\n\nDest[10:2] corresponds to the target long register's 9-bit address and Dest[1:0] is the byte ID within it; values of\n\n0\u20133 identify individual bytes, by position, in least-signi\ufb01cant byte order. Iteratively executing ALTSB followed by\n\nSETBYTE, and each time incrementing ALTSB's 11-bit Dest value by one, effectively writes a stream of byte values\n\nto Reg RAM as if it were all made of byte-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of bytes begins. ALTSB adds the long index\n\n(Dest[10:2]) to the base (Src[8:0]) to locate the register holding the target byte. The byte ID (Dest[1:0])\n\nidenti\ufb01es the byte's position within that long register.\n\n\u25cf   At the end of ALTSB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 11-bit\n\nindex (Dest) for a future ALTSB+SETBYTE iteration.\n\nIn syntax 2, Dest serves as the full byte address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its byte index instead of the long's relative index (to add to a base) and byte index.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 11-bit value is the index, or the full byte address, for the SETBYTE instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[10:2]) for SETBYTE) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution).",
              "The base is the Reg RAM address where the series of bytes begins. ALTSB adds the long index (Dest[10:2]) to the base (Src[8:0]) to locate the register holding the target byte. The byte ID (Dest[1:0]) identi\ufb01es the byte's position within that long register.",
              "At the end of ALTSB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 11-bit index (Dest) for a future ALTSB+SETBYTE iteration.",
              "The instruction following ALTSB is shielded from interrupt",
              "ALTSB alters the next instruction regardless of its kind\u2014 the intention is for it to be a SETBYTE",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if zero or not zero.": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if zero or not zero.",
        "instructions": {
          "TJNZ": {
            "mnemonic": "TJNZ",
            "syntax": "TJNZ    D,{#}S",
            "encoding": "EEEE 1011100 11I DDDDDDDDD SSSSSSSSS",
            "description": "Dest is tested and if it's zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register whose value is tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two signed values plus carry \ufb02ag.": {
        "count": 1,
        "description": "Math Instruction - Compare two signed values plus carry \ufb02ag.",
        "instructions": {
          "CMPSX": {
            "mnemonic": "CMPSX",
            "syntax": "CMPSX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010011 CZI DDDDDDDDD SSSSSSSSS                 \u2014         Signed (D < S+C) Z AND (D = (S+C))             2",
            "description": "CMPSX compares the signed values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMPSX compares the signed values of Dest and Src plus C (by subtracting Src + C from Dest) and optionally\n\nsetting the C and Z \ufb02ags accordingly. The CMPSX instruction is used to perform signed multi-long comparisons,\n\nsuch as 64-bit comparisons.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest is less than Src + C (as multi-long values). Use WC\n\nor WCZ on preceding CMP and CMPX instructions for proper \ufb01nal C \ufb02ag.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and the result of Dest - (Src + C) is\n\nzero, or it is cleared (0) if non-zero. Use WZ or WCZ on preceding SUB and SUBX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo compare signed, multi-long values, use CMP (not CMPS) followed possibly by CMPX, and \ufb01nally CMPSX as\n\ndescribed in Comparing Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - (S + C))"
              },
              "Z": {
                "formula": "Z AND (D == S + C)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub RAM - Read": {
        "count": 5,
        "description": "Hub RAM - Read",
        "instructions": {
          "RDBYTE": {
            "mnemonic": "RDBYTE",
            "syntax": "RDBYTE  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}     Read zero-extended byte from hub address {#}S/PTRx into D. C = MSB of byte. *",
            "timing": {
              "cycles": 9,
              "type": "variable",
              "range": "9...16 / 9...26"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of byte"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 15
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RDWORD": {
            "mnemonic": "RDWORD",
            "syntax": "RDWORD  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}     Read zero-extended word from hub address {#}S/PTRx into D. C = MSB of word. *                                          9...16 1 / 9...26",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of word"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 15
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RDLONG": {
            "mnemonic": "RDLONG",
            "syntax": "RDLONG  D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}                                                                                                                            9...16 1 / 9...26",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "RDLONG D,S/#/PTRA/PTRB",
              "encoding": {
                "bits": 32,
                "opcode": 352,
                "effects": 3,
                "operandFormat": 15,
                "rawValue": 32608
              },
              "category": "Memory and I/O",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "POPB": {
            "mnemonic": "POPB",
            "syntax": "POPB    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 111011111",
            "description": "Read long from hub address --PTRB into D.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long",
                "description": "Set to bit 31 of the popped value"
              },
              "Z": {
                "formula": "Result = 0",
                "description": "Set if popped value is zero"
              }
            },
            "parameters": [
              "D is the destination register to receive the popped value",
              "PTRB is automatically decremented before the read"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 32
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pushpop",
                "pattern": "D/# | D",
                "description": "Push immediate/register or Pop to register (PUSHA/PUSHB/POPA/POPB)",
                "valueType": 32
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "POPA": {
            "mnemonic": "POPA",
            "syntax": "POPA    D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1011000 CZ1 DDDDDDDDD 101011111",
            "description": "Read long from hub address --PTRA into D.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long",
                "description": "Set to bit 31 of the popped value"
              },
              "Z": {
                "formula": "Result = 0",
                "description": "Set if popped value is zero"
              }
            },
            "parameters": [
              "D is the destination register to receive the popped value",
              "PTRA is automatically decremented before the read"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 32
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pushpop",
                "pattern": "D/# | D",
                "description": "Push immediate/register or Pop to register (PUSHA/PUSHB/POPA/POPB)",
                "valueType": 32
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Interrupts": {
        "count": 10,
        "description": "Interrupts",
        "instructions": {
          "GETBRK": {
            "mnemonic": "GETBRK",
            "syntax": "GETBRK  D          WC/WZ/WCZ",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000110101",
            "description": "Get breakpoint/cog status into D according to WC/WZ/WCZ.\n\nFlag modes determine what information is retrieved:\n- WCZ: D = 32-bit ISR call address\n- WC: D = 8-bit COG ID in D[7:0]\n- WZ: D = 8-bit breakpoint code in D[7:0]\n- No flags: D = 16-bit skip pattern in D[15:0]\n\nEssential for debug infrastructure and multi-COG coordination.\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 29
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_getbrk",
                "pattern": "D/# WC/WZ/WCZ",
                "description": "Get break address: destination/immediate, REQUIRES effect flags",
                "valueType": 29
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "TRGINT1": {
            "mnemonic": "TRGINT1",
            "syntax": "TRGINT1",
            "encoding": "EEEE 1101011 000 000100010 000100100",
            "description": "Trigger INT1, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETINT3": {
            "mnemonic": "SETINT3",
            "syntax": "SETINT3 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100111",
            "description": "Set INT3 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "NIXINT1": {
            "mnemonic": "NIXINT1",
            "syntax": "NIXINT1",
            "encoding": "EEEE 1101011 000 000100101 000100100",
            "description": "Cancel INT1.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETINT2": {
            "mnemonic": "SETINT2",
            "syntax": "SETINT2 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100110",
            "description": "Set INT2 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "NIXINT3": {
            "mnemonic": "NIXINT3",
            "syntax": "NIXINT3",
            "encoding": "EEEE 1101011 000 000100111 000100100",
            "description": "Cancel INT3.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETINT1": {
            "mnemonic": "SETINT1",
            "syntax": "SETINT1 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100101",
            "description": "Set INT1 source to D[3:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "NIXINT2": {
            "mnemonic": "NIXINT2",
            "syntax": "NIXINT2",
            "encoding": "EEEE 1101011 000 000100110 000100100",
            "description": "Cancel INT2.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "TRGINT2": {
            "mnemonic": "TRGINT2",
            "syntax": "TRGINT2",
            "encoding": "EEEE 1101011 000 000100011 000100100",
            "description": "Trigger INT2, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "TRGINT3": {
            "mnemonic": "TRGINT3",
            "syntax": "TRGINT3",
            "encoding": "EEEE 1101011 000 000100100 000100100",
            "description": "Trigger INT3, regardless of STALLI mode.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Bitwise NOT a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise NOT a value.",
        "instructions": {
          "NOT": {
            "mnemonic": "NOT",
            "syntax": "NOT Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110001 CZI DDDDDDDDD SSSSSSSSS                   D               !S[31]           Result = 0                2",
              "EEEE 0110001 CZ0 DDDDDDDDD DDDDDDDDD                   D               !D[31]           Result = 0                2"
            ],
            "description": "{WC/WZ/WCZ}   Get !D into D. D = !D. C = !D[31]. *\n\nNOT performs a bitwise NOT (inverting all bits) of the value in Src (or in Dest) and stores the result into Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag value is replaced by the inverse of either S[31] (syntax 1) or D[31]\n\n(syntax 2).\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of !Src (syntax 1) or !Dest (syntax 2) equals\n\nzero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "!D[31] Result =",
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register containing the value to bitwise NOT (syntax 2) or to be replaced by the bitwise NOT of Src (syntax 1).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value will be bitwise NOTed and stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Color Space Converter": {
        "count": 5,
        "description": "Color Space Converter",
        "instructions": {
          "SETCY": {
            "mnemonic": "SETCY",
            "syntax": "SETCY   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111000",
            "description": "Set the colorspace converter \\\"CY\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETCFRQ": {
            "mnemonic": "SETCFRQ",
            "syntax": "SETCFRQ {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111011",
            "description": "Set the colorspace converter \\\"CFRQ\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETCQ": {
            "mnemonic": "SETCQ",
            "syntax": "SETCQ   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111010",
            "description": "Set the colorspace converter \\\"CQ\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETCI": {
            "mnemonic": "SETCI",
            "syntax": "SETCI   {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111001",
            "description": "Set the colorspace converter \\\"CI\\\" parameter to D[31:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETCMOD": {
            "mnemonic": "SETCMOD",
            "syntax": "SETCMOD {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111100",
            "description": "Set the colorspace converter \\\"CMOD\\\" parameter to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Hub FIFO - Read": {
        "count": 5,
        "description": "Hub FIFO - Read",
        "instructions": {
          "RFVAR": {
            "mnemonic": "RFVAR",
            "syntax": "RFVAR   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010011",
            "description": "{WC/WZ/WCZ}   Used after RDFAST. Read zero-extended 1..4-byte value from FIFO into D. C = 0. *                                       2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": 0
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RFVARS": {
            "mnemonic": "RFVARS",
            "syntax": "RFVARS  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010100",
            "description": "{WC/WZ/WCZ}   Used after RDFAST. Read sign-extended 1..4-byte value from FIFO into D. C = MSB of value. *                            2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of value"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RFWORD": {
            "mnemonic": "RFWORD",
            "syntax": "RFWORD  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010001",
            "description": "{WC/WZ/WCZ}   Used after RDFAST. Read zero-extended word from FIFO into D. C = MSB of word. *                                        2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of word"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RFLONG": {
            "mnemonic": "RFLONG",
            "syntax": "RFLONG  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010010",
            "description": "{WC/WZ/WCZ}   Used after RDFAST. Read long from FIFO into D. C = MSB of long. *                                                      2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of long"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RFBYTE": {
            "mnemonic": "RFBYTE",
            "syntax": "RFBYTE  D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000010000",
            "description": "{WC/WZ/WCZ}   Used after RDFAST. Read zero-extended byte from FIFO into D. C = MSB of byte. *                                        2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of byte"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Events - Branch": {
        "count": 24,
        "description": "Events - Branch",
        "instructions": {
          "JINT": {
            "mnemonic": "JINT",
            "syntax": "JINT    {#}S",
            "encoding": "EEEE 1011110 01I 000000000 SSSSSSSSS",
            "description": "Jump to S** if INT event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JSE3": {
            "mnemonic": "JSE3",
            "syntax": "JSE3    {#}S",
            "encoding": "EEEE 1011110 01I 000000110 SSSSSSSSS",
            "description": "Jump to S** if SE3 event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNXRO": {
            "mnemonic": "JNXRO",
            "syntax": "JNXRO   {#}S",
            "encoding": "EEEE 1011110 01I 000011100 SSSSSSSSS",
            "description": "Jump to S** if XRO event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JSE2": {
            "mnemonic": "JSE2",
            "syntax": "JSE2    {#}S",
            "encoding": "EEEE 1011110 01I 000000101 SSSSSSSSS",
            "description": "Jump to S** if SE2 event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNSE4": {
            "mnemonic": "JNSE4",
            "syntax": "JNSE4   {#}S",
            "encoding": "EEEE 1011110 01I 000010111 SSSSSSSSS",
            "description": "Jump to S** if SE4 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JPAT": {
            "mnemonic": "JPAT",
            "syntax": "JPAT    {#}S",
            "encoding": "EEEE 1011110 01I 000001000 SSSSSSSSS",
            "description": "Jump to S** if PAT event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JNCT1": {
            "mnemonic": "JNCT1",
            "syntax": "JNCT1   {#}S",
            "encoding": "EEEE 1011110 01I 000010001 SSSSSSSSS",
            "description": "Jump to S** if CT1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNINT": {
            "mnemonic": "JNINT",
            "syntax": "JNINT   {#}S",
            "encoding": "EEEE 1011110 01I 000010000 SSSSSSSSS",
            "description": "Jump to S** if INT event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JNSE3": {
            "mnemonic": "JNSE3",
            "syntax": "JNSE3   {#}S",
            "encoding": "EEEE 1011110 01I 000010110 SSSSSSSSS",
            "description": "Jump to S** if SE3 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JXRO": {
            "mnemonic": "JXRO",
            "syntax": "JXRO    {#}S",
            "encoding": "EEEE 1011110 01I 000001100 SSSSSSSSS",
            "description": "Jump to S** if XRO event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JNPAT": {
            "mnemonic": "JNPAT",
            "syntax": "JNPAT   {#}S",
            "encoding": "EEEE 1011110 01I 000011000 SSSSSSSSS",
            "description": "Jump to S** if PAT event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JCT1": {
            "mnemonic": "JCT1",
            "syntax": "JCT1    {#}S",
            "encoding": "EEEE 1011110 01I 000000001 SSSSSSSSS",
            "description": "Jump to S** if CT1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JSE4": {
            "mnemonic": "JSE4",
            "syntax": "JSE4    {#}S",
            "encoding": "EEEE 1011110 01I 000000111 SSSSSSSSS",
            "description": "Jump to S** if SE4 event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNSE2": {
            "mnemonic": "JNSE2",
            "syntax": "JNSE2   {#}S",
            "encoding": "EEEE 1011110 01I 000010101 SSSSSSSSS",
            "description": "Jump to S** if SE2 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNSE1": {
            "mnemonic": "JNSE1",
            "syntax": "JNSE1   {#}S",
            "encoding": "EEEE 1011110 01I 000010100 SSSSSSSSS",
            "description": "Jump to S** if SE1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNATN": {
            "mnemonic": "JNATN",
            "syntax": "JNATN   {#}S",
            "encoding": "EEEE 1011110 01I 000011110 SSSSSSSSS",
            "description": "Jump to S** if ATN event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JCT2": {
            "mnemonic": "JCT2",
            "syntax": "JCT2    {#}S",
            "encoding": "EEEE 1011110 01I 000000010 SSSSSSSSS",
            "description": "Jump to S** if CT2 event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JCT3": {
            "mnemonic": "JCT3",
            "syntax": "JCT3    {#}S",
            "encoding": "EEEE 1011110 01I 000000011 SSSSSSSSS",
            "description": "Jump to S** if CT3 event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JXFI": {
            "mnemonic": "JXFI",
            "syntax": "JXFI    {#}S",
            "encoding": "EEEE 1011110 01I 000001011 SSSSSSSSS",
            "description": "Jump to S** if XFI event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JATN": {
            "mnemonic": "JATN",
            "syntax": "JATN    {#}S",
            "encoding": "EEEE 1011110 01I 000001110 SSSSSSSSS",
            "description": "Jump to S** if ATN event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "JNCT2": {
            "mnemonic": "JNCT2",
            "syntax": "JNCT2   {#}S",
            "encoding": "EEEE 1011110 01I 000010010 SSSSSSSSS",
            "description": "Jump to S** if CT2 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JSE1": {
            "mnemonic": "JSE1",
            "syntax": "JSE1    {#}S",
            "encoding": "EEEE 1011110 01I 000000100 SSSSSSSSS",
            "description": "Jump to S** if SE1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNCT3": {
            "mnemonic": "JNCT3",
            "syntax": "JNCT3   {#}S",
            "encoding": "EEEE 1011110 01I 000010011 SSSSSSSSS",
            "description": "Jump to S** if CT3 event \ufb02ag is clear.                                                                       2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "JNXFI": {
            "mnemonic": "JNXFI",
            "syntax": "JNXFI   {#}S",
            "encoding": "EEEE 1011110 01I 000011011 SSSSSSSSS",
            "description": "Jump to S** if XFI event \ufb02ag is set.                                                                         2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Branch D - Call+Skip": {
        "count": 1,
        "description": "Branch D - Call+Skip",
        "instructions": {
          "EXECF": {
            "mnemonic": "EXECF",
            "syntax": "EXECF\u00a0\u00a0 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110011",
            "description": "Jump to D[9:0] in cog/LUT and set SKIPF pattern to D[31:10]. PC = {10'b0, D[9:0]}.\n",
            "timing": {
              "cycles": "4/4",
              "type": "fixed"
            },
            "flags_affected": {
              "C": "{10'b0, D[9:0]}"
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear CORDIC-read-but-empty event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear CORDIC-read-but-empty event \ufb02ag.",
        "instructions": {
          "POLLQMT": {
            "mnemonic": "POLLQMT",
            "syntax": "POLLQMT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001111 000100100                 \u2014            QMT Event         QMT Event                 2",
            "description": "POLLQMT copies the state of the CORDIC-read-but-empty event flag into C and/or Z and then clears the flag Result: CORDIC-read-but-empty event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLQMT copies the state of the CORDIC-read-but-empty event \ufb02ag into C and/or Z and then clears the \ufb02ag\n\n(unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the CORDIC-read-but-\n\nempty event \ufb02ag prior to clearing it.\n\nThe CORDIC-read-but-empty event \ufb02ag is set whenever GETQX / GETQY executes without any CORDIC results\n\navailable or in progress. The pin-pattern-detected event \ufb02ag is cleared upon cog start or execution of POLLQMT,\n\nWAITQMT, JQMT, or JNQMT instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "JQMT",
              "JNQMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to low/high according to C or !C.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) output level to low/high according to C or !C.",
        "instructions": {
          "OUTC": {
            "mnemonic": "OUTC",
            "syntax": "OUTC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001010",
            "description": "OUTC or OUTNC alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "OUTNC": {
            "mnemonic": "OUTNC",
            "syntax": "OUTNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001011",
            "description": "OUTC or OUTNC alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of Result: The I/O pin output level bit(s), described by Dest, are set to low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context in PA/PB/PTRA/PTRB/D.": {
        "count": 1,
        "description": "Flow Control Instruction - Call a subroutine; store return context in PA/PB/PTRA/PTRB/D.",
        "instructions": {
          "CALLD": {
            "mnemonic": "CALLD",
            "syntax": "CALLD Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 11100WW RAA AAAAAAAAA AAAAAAAAA             Pxxx1 and PC            \u2014                   \u2014               4 / 13\u201320",
              "EEEE 1011001 CZI DDDDDDDDD SSSSSSSSS              D1 and PC             S[31]               S[30]            4 / 13\u201320",
              "EEEE 1011010 0LI DDDDDDDDD SSSSSSSSS                1"
            ],
            "description": "CALLD records the current state of the C and Z flags and the address of the next instruction (PC + 1 if Cog/LUT Result: Write current C and Z flags and address of the next instruction into either PA, PB, PTRA, PTRB, or Dest, set PC to new relative or absolute address (in Addr or Src), and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.\n\nCALLD records the current state of the C and Z \ufb02ags and the address of the next instruction (PC + 1 if Cog/LUT\n\nexecution; PC + 4 if Hub execution) by writing them to the PA, PB, PTRA, PTRB, or Dest register, potentially updates\n\nthe C and Z \ufb02ags with new given states, and jumps to the given address or offset. The routine at the new address\n\nshould eventually execute another CALLD instruction to return to the recorded address (the instruction following\n\nthe original CALLD) optionally restore the C and Z \ufb02ag state as it was prior, and optionally prep for another CALLD.\n\nThis instruction is typically used for the P2 DEBUG function.\n\nIn syntax 1, #Addr and #\\Addr encodes the instruction with relative and absolute addressing, respectively. The\n\nrelative form (the default) is vital for creating relocatable code. In either case, use symbolic references for Addr\n\nand the assembler will encode it properly. Examples: CALLD PA, #SendBit or CALLD PB, #\\DebugStatus\n\nIn syntax 2, the format of the value at Src is CZxxxxxx_xxxxAAAA_AAAAAAAA_AAAAAAAA. C is the new C \ufb02ag\n\nstate, Z is the new Z \ufb02ag state, A is the new 20-bit address to jump to, and x are don't-care bits. If Src is a 9-bit\n\nliteral (immediate), it will be sign-extended to 20 bits and used as a relative offset; giving a range of -256 to +255\n\ninstructions, relative to the instruction following the CALLD. When relative, PC is adjusted by signed(Src) if\n\nCog/LUT execution, or by signed(Src*4) if Hub execution.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to match S[31], after its original state is recorded.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is updated to match S[30], after its original state is recorded.\n\nCALLPA / CALLPB\n\nCall parameter A or B\n\nFlow Control Instruction - Call a subroutine; store return context on the stack and copy D into PA or PB.\n\nCALLPA {#}Dest, {#}Src\n\nCALLPB {#}Dest, {#}Src\n\nResult: Push current C and Z \ufb02ags and address of the next instruction onto the hardware stack, copy D to PA or\n\nPB, and set PC to new relative or absolute address.\n\n\u25cf   Dest is a register, 9-bit literal, or 32-bit augmented literal whose value is copied to PA or PB.\n\n\u25cf   Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST          SRC             Write            C Flag              Z Flag             Clocks\n\nEEEE 1011010 0LI DDDDDDDDD SSSSSSSSS                1\n\nK , PA and PC           \u2014                   \u2014               4 / 13\u201320\n\nEEEE 1011010 1LI DDDDDDDDD SSSSSSSSS K , PB and PC  1\n\n\u2014                   \u2014               4 / 13\u201320\n\n1\n\nThe current C, Z, and effective next PC values are pushed onto the stack (K) prior to updating PC with Src.\n\nCALLPA and CALLPB records the current state of the C and Z \ufb02ags and the address of the next instruction (PC + 1\n\nif Cog/LUT execution; PC + 4 if Hub execution) by pushing to the stack (K), copies Dest to PA or PB, and jumps to\n\nthe given address or offset in Src. The routine at the new address should eventually execute a RET instruction, or\n\nan instruction with a _RET_ condition, to return to the recorded address (the instruction following the CALLPA or\n\nCALLPB) and optionally restore the C and Z \ufb02ag state as it was prior.\n\nThe Src can be absolute or relative; use #Addr for calling a range of -256 to +255 instructions, relative to the\n\ninstruction following the CALLPA or CALLPA. When relative, PC is adjusted by signed(Src) if Cog/LUT execution,\n\nor by signed(Src*4) if Hub execution.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "S[31] S[30] 4"
            },
            "parameters": [
              "PA|PB|PTRA|PTRB is the special register to store the current C and Z \ufb02ags and next address into.",
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register to write the current C and Z \ufb02ags and the address of the next instruction into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to and optional new C and Z states. Use # for relative addressing; omit # for absolute addressing.",
              "WC, WZ, or WCZ are optional effects to update the \ufb02ags from Src's upper bit states.",
              "Dest is a register, 9-bit literal, or 32-bit augmented literal whose value is copied to PA or PB.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 20
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_calld",
                "pattern": "D,#S/{@}S | D,S/#",
                "description": "Call with return register: destination, address/relative/immediate",
                "valueType": 20
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Start an available cog, or restart a cog by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Start an available cog, or restart a cog by ID.",
        "instructions": {
          "COGINIT": {
            "mnemonic": "COGINIT",
            "syntax": "COGINIT {#}Dest, {#}Src {WC}",
            "encoding": "EEEE 1100111 CLI DDDDDDDDD SSSSSSSSS D if reg and WC              No cog available           \u2014           2\u20139, +2 if result",
            "description": "COGINIT starts a new (unused) cog, a new pair of cogs (that may share LUT memory), or a specific cog by ID, to Result: Target cog is started, according to Dest, to execute code from Src. The code pointer (Src) is written to the target Cog's PTRB, and optionally a data pointer or user value is written to its PTRA (if previous SETQ is provided).\n\nCOGINIT starts a new (unused) cog, a new pair of cogs (that may share LUT memory), or a speci\ufb01c cog by ID, to\n\nload code from Hub RAM to be executed within Reg/LUT RAM or to be executed right from Hub RAM.\n\nIf the WC effect is speci\ufb01ed, the C \ufb02ag is set (1) if the instruction failed to launch a cog, or is cleared (0) if it was\n\nsuccessful. Also with the WC effect, if Dest is a register, it is overwritten with $F (on failure) or with the ID of the\n\nnewly launched cog \u2014or the lowest of the pair of cogs\u2014 (on success).\n\nThe format of Dest is %E_N_xVVV.\n\nE: 0 = load from Hub RAM (Src) into target cog's Reg RAM ($000\u2013$1F7) and begin execution at its Reg\n\nRAM ($000); 1 = no load, just execute from target cog's existing Reg/LUT RAM, or from Hub RAM.\n\nN: 0 = target cog ID is V; 1 = start a free cog or cog pair according to V.\n\nV: when N = 0, V is a speci\ufb01c cog ID (0\u20137; %000\u2013%111); when N = 1, V is 0 (%000) to start a free cog or 1\n\n(%001) to start a free odd/even pair of cogs for LUT RAM sharing. Use the WC effect to get the results in\n\nDest and C.\n\nThe lower 20 bits of Src is the address of the start of code; the address in Hub RAM (or Reg/LUT RAM) where the\n\nexecutable code image begins. The entire 32-bit Src value will be written into the target cog's PTRB register.\n\nIf COGINIT is preceded by SETQ, the SETQ value will be written into the target cog's PTRA register. This is\n\nintended as a convenient means of pointing the target cog's program to some runtime data structure or passing it\n\na 32-bit parameter. If no SETQ is used, the target cog's PTRA register will be cleared to zero.\n\nRelated instructions are COGID and COGSTOP.\n\nExecution Modes\n\nCode can be loaded into Cog RAM (Reg RAM and optionally LUT RAM) and executed, or code can be executed\n\nfrom Hub RAM without pre-loading into Cog RAM. For PASM2 programs, the former achieves the fastest\n\nexecution speed and natural isolation from other cogs while the latter achieves a larger effective code space\n\nbeyond the \u22481,000 instruction limit inside Cog RAM. It is common to run PASM2 code from Reg RAM.\n\nTo execute code from Reg RAM, it must \ufb01rst be loaded from Hub RAM (i.e. a Dest value where E = 0 achieves both\n\nload and execute in a single COGINIT instruction).\n\nTo execute code from LUT RAM, it must \ufb01rst be manually copied or streamed into LUT RAM by code executing in\n\nReg RAM (or by the neighboring cog in an even/odd pair that are sharing LUT RAM).\n\nTo execute code from Hub RAM, the Dest's E bit must be 1 and the Src must be an address beyond $3FF. Note\n\nthat with a single COGINIT instruction, code could start out loaded into Reg RAM (E = 0), execute from there, and\n\ncan branch to $400 or beyond (Hub execution), or it can even copy or stream code into LUT RAM, execute in\n\nReg+LUT RAM, and then branch to $400 or beyond (Hub execution).\n\nAdditionally, it's possible to load and execute code in another cog's Reg RAM (one COGINIT instruction) and\n\nrestart that cog thereafter (another COGINIT instruction) to execute starting at any place in its existing Reg RAM\n\nor LUT RAM (from the previous load) by using a Dest value with E = 1 and a Src value of less than $400. This\n\nworks whether or not the cog is terminated \ufb01rst, since its Cog RAM is retained during its terminated (dormant)\n\nstate. For example, one possibility is a Reg/LUT RAM-resident program consisting of a number of small\n\nindependent routines which are each exclusively started at-will by another cog\u2014 apparent cog launch and parallel\n\nprocessing with no \"loading\" overhead latency.\n\nCOGINIT Constants\n\nA number of constants are prede\ufb01ned for use in forming desired Dest values for COGINIT instructions.\n\nCOGINIT Constants\n\nSymbol (for Dest)     Dest Value      Notes\n\nThe target cog loads its own Reg RAM registers $000\u2013$1F7 from the Hub RAM\n\nCOGEXEC           %0_0_0000       starting at Src address, then begins execution at register address $000. Target\n\ncog ID must be specified; i.e. COGEXEC+5 will launch Cog 5 in this fashion.\n\nSame as above except an available (non-running) cog is chosen automatically;\n\ndo not specify an ID. Use WC effect and a register for Dest (register's value set\n\nCOGEXEC_NEW         %0_1_0000\n\nto COGEXEC_NEW) to get pass/fail (0/1) result in C flag and ID of employed\n\ncog in Dest register.\n\nSame as above except an available (non-running) even/odd pair of cogs is\n\nCOGEXEC_NEW_PAIR       %0_1_0001       chosen automatically\u2014 useful for LUT RAM sharing. Dest receives the lowest\n\nID of the pair if successful (when the WC effect is used).\n\nNo loading; the target cog begins execution at Reg/LUT/Hub RAM address Src.\n\nTarget cog ID must be specified; i.e. HUBEXEC+2 will launch Cog 2 in this\n\nHUBEXEC           %1_0_0000\n\nfashion. NOTE: Though named HUBEXEC, this constant can also be used to\n\nexecute pre-existing code in Reg RAM or LUT RAM as well as Hub RAM.\n\nSame as above except an available (non-running) cog is chosen automatically;\n\ndo not specify an ID. Use WC effect and a register for Dest (register's value set\n\nHUBEXEC_NEW         %1_1_0000\n\nto HUBEXEC_NEW) to get pass/fail (0/1) result in C flag and ID of employed\n\ncog in Dest register.\n\nSame as above except an available (non-running) even/odd pair of cogs is\n\nHUBEXEC_NEW_PAIR       %1_1_0001       chosen automatically\u2014 useful for LUT RAM sharing. Dest receives the lowest\n\nID of the pair if successful (when the WC effect is used).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal describing the type of launch and possibly the ID of the desired cog to launch. If Dest is a register and WC is given, Dest is also where the ID of the launched cog will be written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (lower 20 bits) is the target RAM address (for code) and the new cog's PTRB value. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual           \u25aa   Page 64",
              "WC is an optional effect to update the C \ufb02ag with the success (0) or fail (1) status and triggers Dest to be overwritten with new cog's ID."
            ],
            "related": [
              "COGID",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Streamer": {
        "count": 6,
        "description": "Streamer",
        "instructions": {
          "XSTOP": {
            "mnemonic": "XSTOP",
            "syntax": "XSTOP",
            "encoding": "EEEE 1100101 011 000000000 000000000",
            "description": "Stop streamer immediately.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "XINIT": {
            "mnemonic": "XINIT",
            "syntax": "XINIT   {#}D,{#}S",
            "encoding": "EEEE 1100101 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Issue streamer command immediately, zeroing phase.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "enhanced_from_code_study",
            "documentation_level": "comprehensive"
          },
          "XCONT": {
            "mnemonic": "XCONT",
            "syntax": "XCONT   {#}D,{#}S",
            "encoding": "EEEE 1100110 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Bu er new streamer command to be issued on \ufb01nal NCO rollover of current command, continuing phase.                           2+",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "XZERO": {
            "mnemonic": "XZERO",
            "syntax": "XZERO   {#}D,{#}S",
            "encoding": "EEEE 1100101 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Bu er new streamer command to be issued on \ufb01nal NCO rollover of current command, zeroing phase.                             2+",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "GETXACC": {
            "mnemonic": "GETXACC",
            "syntax": "GETXACC D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 000011110",
            "description": "Get the streamer's Goertzel X accumulator into D and the Y accumulator into the next instruction's S, clear accumulators.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "SETXFRQ": {
            "mnemonic": "SETXFRQ",
            "syntax": "SETXFRQ {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000011101",
            "description": "Set streamer NCO frequency to D.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Compare two unsigned values, get MSB of difference.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values, get MSB of difference.",
        "instructions": {
          "CMPM": {
            "mnemonic": "CMPM",
            "syntax": "CMPM Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010101 CZI DDDDDDDDD SSSSSSSSS                  \u2014             Result[31]         D=S                    2",
            "description": "CMPM compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMPM compares the unsigned values of Dest and Src (by subtracting Src from Dest) and optionally setting the C\n\nand Z \ufb02ags accordingly.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the MSB of (Dest - Src).\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest equals Src.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result[31] D=S 2"
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent SETWORD instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent SETWORD instruction.",
        "instructions": {
          "ALTSW": {
            "mnemonic": "ALTSW",
            "syntax": "ALTSW Dest, {#}Src",
            "encoding": [
              "EEEE 1001011 10I DDDDDDDDD SSSSSSSSS                     D 1",
              "EEEE 0101000 CZI DDDDDDDDD SSSSSSSSS                  D          Parity of Result     Result = 0              2",
              "EEEE 0101001 CZI DDDDDDDDD SSSSSSSSS                  D          Parity of Result     Result = 0              2"
            ],
            "description": "ALTSW should be followed by SETWORD\u2014 it modifies the SETWORD instruction's Dest and Num values, enabling Result: The next instruction's pipelined Dest and Num fields are altered to be (Src + Dest[9:1]) & $1FF, or just Dest[9:1] for syntax 2, and Dest[0], respectively.\n\nALTSW should be followed by SETWORD\u2014 it modi\ufb01es the SETWORD instruction's Dest and Num values, enabling\n\ncode to iterate through multiple words of data across a range of Reg RAM. SETWORD's Dest value is changed to\n\n(Src + Dest[9:1]) & $1FF (for syntax 1), or to Dest[9:1] (for syntax 2), and its Num value is changed to Dest[0].\n\nDest[9:1] corresponds to the target long register's 9-bit address and Dest[0] is the word ID within it; values of 0\u20131\n\nidentify individual words, by position, in least-signi\ufb01cant word order. Iteratively executing ALTSW followed by\n\nSETWORD, and each time incrementing ALTSW's 10-bit Dest value by one, effectively writes a stream of word\n\nvalues to Reg RAM as if it were all made of word-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of words begins. ALTSW adds the long index\n\n(Dest[9:1]) to the base (Src[8:0]) to locate the register holding the target word. The word ID (Dest[0])\n\nidenti\ufb01es the word's position within that long register.\n\n\u25cf   At the end of ALTSW execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 10-bit\n\nindex (Dest) for a future ALTSW+SETWORD iteration.\n\nIn syntax 2, Dest serves as the full word address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its word index instead of the long's relative index (to add to a base) and word index.\n\nAND or ANDN performs a bitwise AND of the value in Src (or !Src) into that of Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result contains an odd number of high (1) bits, or is\n\ncleared (0) if it contains an even number of high bits.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest AND Src (or Dest AND !Src) equals zero, or is\n\ncleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register whose 10-bit value is the index, or the full word address, for the SETWORD instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[9:1]) for SETWORD) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution).",
              "The base is the Reg RAM address where the series of words begins. ALTSW adds the long index (Dest[9:1]) to the base (Src[8:0]) to locate the register holding the target word. The word ID (Dest[0]) identi\ufb01es the word's position within that long register.",
              "At the end of ALTSW execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 10-bit index (Dest) for a future ALTSW+SETWORD iteration.",
              "The instruction following ALTSW is shielded from interrupt",
              "ALTSW alters the next instruction regardless of its kind\u2014 the intention is for it to be a SETWORD",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction",
              "Dest is the register containing the value to bitwise AND with Src (or with !Src) and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (or inverse value) will be bitwise ANDed into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Smart Pins": {
        "count": 8,
        "description": "Smart Pins",
        "instructions": {
          "SETDACS": {
            "mnemonic": "SETDACS",
            "syntax": "SETDACS {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000011100",
            "description": "DAC3 = D[31:24], DAC2 = D[23:16], DAC1 = D[15:8], DAC0 = D[7:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RDPIN": {
            "mnemonic": "RDPIN",
            "syntax": "RDPIN   D,{#}S          {WC}",
            "encoding": "EEEE 1010100 C1I DDDDDDDDD SSSSSSSSS",
            "description": "{WC}   Read smart pin S[5:0] result \"Z\" into D, acknowledge smart pin. C = modal result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "modal result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RQPIN": {
            "mnemonic": "RQPIN",
            "syntax": "RQPIN   D,{#}S          {WC}",
            "encoding": "EEEE 1010100 C0I DDDDDDDDD SSSSSSSSS",
            "description": "C = modal result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "modal result"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WXPIN": {
            "mnemonic": "WXPIN",
            "syntax": "WXPIN   {#}D,{#}S",
            "encoding": "EEEE 1100000 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set \\\"X\\\" of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ overrides S[10:6].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "WYPIN": {
            "mnemonic": "WYPIN",
            "syntax": "WYPIN   {#}D,{#}S",
            "encoding": "EEEE 1100001 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Set \"Y\" register of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins.\nWraps within A/B pins. Prior SETQ overrides S[10:6].\n\nThe Y register serves multiple purposes:\n- For PWM modes: Sets the base period\n- For SPI/serial: Controls data to transmit\n- For counter modes: Sets count value\n- For ADC modes: Initiates conversions\n- Writing Y also acknowledges pin completion\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "SETSCP": {
            "mnemonic": "SETSCP",
            "syntax": "SETSCP  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 001110000",
            "description": "Set four-channel oscilloscope enable to D[6] and set input pin base to D[5:2].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WRPIN": {
            "mnemonic": "WRPIN",
            "syntax": "WRPIN   {#}D,{#}S",
            "encoding": "EEEE 1100000 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Set mode of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. \nWraps within A/B pins. Prior SETQ overrides S[10:6].\n\n**CRITICAL REQUIREMENT**: Smart pins MUST be reset (DIR=0) before configuring with WRPIN.\nThis ensures the smart pin is in a known state and prevents configuration conflicts.\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "GETSCP": {
            "mnemonic": "GETSCP",
            "syntax": "GETSCP  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001110001",
            "description": "Get four-channel oscilloscope samples into D. D = {ch3[7:0],ch2[7:0],ch1[7:0],ch0[7:0]}.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Create unsigned 16-bit scale value for next instruction's S value.": {
        "count": 1,
        "description": "Math Instruction - Create unsigned 16-bit scale value for next instruction's S value.",
        "instructions": {
          "SCA": {
            "mnemonic": "SCA",
            "syntax": "SCA Dest, {#}Src {WZ}",
            "encoding": "EEEE 1010001 0ZI DDDDDDDDD SSSSSSSSS                    \u2014                 \u2014             Product = 0               2",
            "description": "SCA multiplies the lower 16-bits of each of Dest and Src together, right shifts the 32-bit product by 16 (to scale Result: The upper 16 bits of the unsigned product from the 16-bit Dest and Src multiplication is substituted as the next instruction's Src value and optionally the Z flag is updated to the zero status.\n\nSCA multiplies the lower 16-bits of each of Dest and Src together, right shifts the 32-bit product by 16 (to scale\n\ndown the result), and substitutes this value as the next instruction's Src value.\n\nIf the WZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the product (before scaling down) is zero, or is cleared (0) if\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the 16-bit value to multiply with Src.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose value is multiplied with Dest.",
              "WZ is an optional effect to update the Z \ufb02ag."
            ],
            "related": [
              "SCAS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a word left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a word left into a value.",
        "instructions": {
          "ROLWORD": {
            "mnemonic": "ROLWORD",
            "syntax": "ROLWORD Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1001010 0NI DDDDDDDDD SSSSSSSSS                           D           \u2014                 \u2014                    2",
              "EEEE 1001010 000 DDDDDDDDD 000000000                           D           \u2014                 \u2014                    2"
            ],
            "description": "ROLWORD reads the word identified by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW Result: Word Num (0\u20131) of Src, or a word from a source described by prior ALTGW instruction, is rotated left into Dest.\n\nROLWORD reads the word identi\ufb01ed by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW\n\ninstruction, and rotates it left into Dest.\n\nROLWORD achieves the same effect as two instructions\u2014 a 16-bit SHL followed by SETWORD into word 0.\n\nNum (0\u20131) identi\ufb01es a value's individual words, by position, in least-signi\ufb01cant word order.\n\nSyntax 2 is intended for use after an ALTGW instruction; i.e. in a loop to iteratively read a series of word values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the word into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target word to read.",
              "Num is a 1-bit literal identifying the nibble ID (0\u20131) of Src to read."
            ],
            "related": [
              "ALTGW",
              "ROLNIB",
              "ROLBYTE",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 11
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds1get",
                "pattern": "D{,S/#,#0..1}",
                "description": "Get word: destination, optional source and word index 0-1",
                "valueType": 11
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Bitwise OR a value with another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise OR a value with another.",
        "instructions": {
          "OR": {
            "mnemonic": "OR",
            "syntax": "OR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0101010 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0                2",
            "description": "OR performs a bitwise OR of the value in Src into that of Dest. Result: Dest OR Src is stored in Dest and flags are optionally updated with parity and zero status.\n\nOR performs a bitwise OR of the value in Src into that of Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result contains an odd number of high (1) bits, or is\n\ncleared (0) if it contains an even number of high bits.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest OR Src result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register containing the value to bitwise OR with Src and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be bitwise ORed into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Test": {
        "count": 3,
        "description": "Branch S - Test",
        "instructions": {
          "TJF": {
            "mnemonic": "TJF",
            "syntax": "TJF     D,{#}S",
            "encoding": "EEEE 1011101 00I DDDDDDDDD SSSSSSSSS",
            "description": "Test D and jump to S** if D is full (D = $FFFF_FFFF).                                                                    2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "TJS": {
            "mnemonic": "TJS",
            "syntax": "TJS     D,{#}S",
            "encoding": "EEEE 1011101 10I DDDDDDDDD SSSSSSSSS",
            "description": "Test D and jump to S** if D is signed (D[31] = 1).                                                                   2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "TJZ": {
            "mnemonic": "TJZ",
            "syntax": "TJZ     D,{#}S",
            "encoding": "EEEE 1011100 10I DDDDDDDDD SSSSSSSSS",
            "description": "Test D and jump to S** if D is zero.                                                                                 2 or 4 / 2 or",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Get bit position of top-most 1 of Src or Dest into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get bit position of top-most 1 of Src or Dest into Dest.",
        "instructions": {
          "ENCOD": {
            "mnemonic": "ENCOD",
            "syntax": "ENCOD Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0111100 CZI DDDDDDDDD SSSSSSSSS                    D               S != 0            Result = 0              2",
              "EEEE 0111100 CZ0 DDDDDDDDD DDDDDDDDD                    D           Original D != 0       Result = 0              2"
            ],
            "description": "ENCOD stores the bit position value (0\u201431) of the top-most high bit (1) of Src, or Dest, into Dest. If the value to Result: The bit position value of the top-most high bit (1) in Src, or Dest, is stored in Dest.\n\nENCOD stores the bit position value (0\u201431) of the top-most high bit (1) of Src, or Dest, into Dest. If the value to\n\nencode (Src, or original Dest (in syntax 2)) may be %0, the resulting Dest will be 0\u2014 use the WC or WCZ effect and\n\ncheck the resulting C \ufb02ag to distinguish between the cases of input Src/Dest = %1 verses input Src/Dest = %0.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Src (or original Dest in syntax 2) was not zero, or is\n\ncleared (0) if it was zero.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result equals zero, or is cleared (0) if not zero.\n\n\u25cf     A long of %00000000_00000000_00000000_00000001 encodes to 0.\n\n\u25cf     A long of %00000000_00000000_00000000_00100000 encodes to 5.\n\n\u25cf     A long of %00000000_00000000_10000001_01000000 encodes to 15.\n\n\u25cf     A long of %00000000_00000000_00000000_00000000 encodes to 0 with optional C cleared to 0.\n\nENCOD is the complement of DECOD.\n\nEffects ( WC, WZ, WCZ, ANDC, etc. )\n\nNearly half of PASM2 instructions feature optional effects to modify the C and/or Z \ufb02ags. An Effect is placed at\n\nthe end of such instructions.\n\n{Label} {Condition} Instruction Operands {Effect}\n\nWhen included (where allowed) the \ufb02ag or \ufb02ags are updated by the instruction execution; when omitted, the \ufb02ags\n\nremain as-is. Only zero or one Effect is allowed per instruction.\n\nEffects\n\nEffect        Description\n\nANDC          AND tested bit/pin into current C; used on TESTxx instructions\n\nANDZ          AND tested bit/pin into current Z; used on TESTxx instructions\n\nORC           OR tested bit/pin into current C; used on TESTxx instructions\n\nORZ           OR tested bit/pin into current Z; used on TESTxx instructions\n\nXORC          XOR tested bit/pin into current C; used on TESTxx instructions\n\nXORZ          XOR tested bit/pin into current Z; used on TESTxx instructions\n\nWC           Write C \ufb02ag; used on many instructions\n\nWCZ           Write both C and Z \ufb02ags; used on many instructions\n\nWZ           Write Z \ufb02ag; used on many instructions\n\nFor example:\n\nAND     config, #%1000        WZ               'con\ufb01g[3] low? z=1\n\nTESTP #4                      ANDZ             'pin 4 high? z=1\n\nif_z                 JMP     #MoreCode                              'jump if con\ufb01g[3] low and pin 4 high\n\nThis code jumps to the label MoreCode only if con\ufb01g bit 3 is low (0) and I/O pin 4 is high. This \ufb01rst instruction\n\nbitwise AND's %1000 into con\ufb01g and sets the Z \ufb02ag if that result is zero. The second instruction tests I/O pin 4\n\nand bitwise AND's its high/low state into the Z \ufb02ag. The third instruction, which speci\ufb01es an if_z condition,\n\nexecutes only if the z \ufb02ag is high by then, jumping to MoreCode; otherwise it behaves like a nop instruction. Using\n\nan Effect on instructions, along with a Condition on later instructions, enables code to be much more powerful\n\nthan what is possible with typical assembly languages. See IF_x (Conditions) for more information. NOTE: In this\n\nexample, the \ufb01rst instruction modi\ufb01es con\ufb01g\u2014 to do non-destructive bit tests, use a testb instead of and\n\ninstruction.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register in which to store the encoded bit position value and optionally begins by containing the 32-bit value it is encoding (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is to be encoded into a bit position.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "A long of %00000000_00000000_00000000_00000001 encodes to 0.",
              "A long of %00000000_00000000_00000000_00100000 encodes to 5.",
              "A long of %00000000_00000000_10000001_01000000 encodes to 15.",
              "A long of %00000000_00000000_00000000_00000000 encodes to 0 with optional C cleared to 0."
            ],
            "related": [
              "DECOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context on the stack and copy D into PA or PB.": {
        "count": 2,
        "description": "Flow Control Instruction - Call a subroutine; store return context on the stack and copy D into PA or PB.",
        "instructions": {
          "CALLPB": {
            "mnemonic": "CALLPB",
            "syntax": "CALLPB  {#}D,{#}S",
            "encoding": "EEEE 1011010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "CALLPA and CALLPB records the current state of the C and Z flags and the address of the next instruction (PC + 1 Result: Push current C and Z flags and address of the next instruction onto the hardware stack, copy D to PA or PB, and set PC to new relative or absolute address.",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register, 9-bit literal, or 32-bit augmented literal whose value is copied to PA or PB.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 14
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_lsj",
                "pattern": "D/#,S/@",
                "description": "Jump/call with immediate destination and relative source: destination/immediate, relative address",
                "valueType": 14
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "CALLPA": {
            "mnemonic": "CALLPA",
            "syntax": "CALLPA  {#}D,{#}S",
            "encoding": "EEEE 1011010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "CALLPA and CALLPB records the current state of the C and Z flags and the address of the next instruction (PC + 1 Result: Push current C and Z flags and address of the next instruction onto the hardware stack, copy D to PA or PB, and set PC to new relative or absolute address.",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register, 9-bit literal, or 32-bit augmented literal whose value is copied to PA or PB.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal that contains the relative or absolute address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 14
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_lsj",
                "pattern": "D/#,S/@",
                "description": "Jump/call with immediate destination and relative source: destination/immediate, relative address",
                "valueType": 14
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate bits right.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate bits right.",
        "instructions": {
          "ROR": {
            "mnemonic": "ROR",
            "syntax": "ROR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000000 CZI DDDDDDDDD SSSSSSSSS                           D      Last bit out   1",
            "description": "ROR rotates Dest's binary value right by Src places (0\u201331 bits). All LSBs rotated out are moved into the new Result: The bits of Dest are rotated right by Src bits; any departing LSBs are moved into MSBs.\n\nROR rotates Dest's binary value right by Src places (0\u201331 bits). All LSBs rotated out are moved into the new\n\nMSBs.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit rotated out (effectively C =\n\nresult bit \"31\") if Src is 1\u201331, or to Dest[0] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero. Since no bits are lost by this operation, the result will only be zero if Dest started at zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate right by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Adjust signed value by other Z-negated or !Z-negated value.": {
        "count": 1,
        "description": "Math Instruction - Adjust signed value by other Z-negated or !Z-negated value.",
        "instructions": {
          "SUMNZ": {
            "mnemonic": "SUMNZ",
            "syntax": "SUMNZ   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUMZ or SUMNZ adjusts the signed Dest value by Src or -Src (depending on Z or !Z) and stores the result into the Result: The sum of signed Dest and either Src or -Src (according to Z) is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D +/- S)"
              },
              "Z": {
                "formula": "0 then D = D - S, else D = D + S"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0 or !Z=0) or negated value (if Z=1 or !Z=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUMC",
              "SUMNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear counter event 1/2/3 \ufb02ag.": {
        "count": 3,
        "description": "Event Monitor Instruction - Retrieve and clear counter event 1/2/3 \ufb02ag.",
        "instructions": {
          "POLLCT1": {
            "mnemonic": "POLLCT1",
            "syntax": "POLLCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000001 000100100                  \u2014            CT1 Event           CT1 Event                 2",
              "EEEE 1101011 CZ0 000000010 000100100                  \u2014            CT2 Event           CT2 Event                 2",
              "EEEE 1101011 CZ0 000000011 000100100                  \u2014            CT3 Event           CT3 Event                 2"
            ],
            "description": "Get CT1 event flag into C/Z, then clear it.\n\nPOLLCT1, POLLCT2, or POLLCT3 copies the state of the count 1, 2, or 3 event \ufb02ag into C and/or Z and then clears\n\nthe \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\ncounter event \ufb02ag prior to clearing it.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "POLLCT2": {
            "mnemonic": "POLLCT2",
            "syntax": "POLLCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000001 000100100                  \u2014            CT1 Event           CT1 Event                 2",
              "EEEE 1101011 CZ0 000000010 000100100                  \u2014            CT2 Event           CT2 Event                 2",
              "EEEE 1101011 CZ0 000000011 000100100                  \u2014            CT3 Event           CT3 Event                 2"
            ],
            "description": "Get CT2 event flag into C/Z, then clear it.\n\nPOLLCT1, POLLCT2, or POLLCT3 copies the state of the count 1, 2, or 3 event \ufb02ag into C and/or Z and then clears\n\nthe \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\ncounter event \ufb02ag prior to clearing it.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "POLLCT3": {
            "mnemonic": "POLLCT3",
            "syntax": "POLLCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000001 000100100                  \u2014            CT1 Event           CT1 Event                 2",
              "EEEE 1101011 CZ0 000000010 000100100                  \u2014            CT2 Event           CT2 Event                 2",
              "EEEE 1101011 CZ0 000000011 000100100                  \u2014            CT3 Event           CT3 Event                 2"
            ],
            "description": "Get CT3 event flag into C/Z, then clear it.\n\nPOLLCT1, POLLCT2, or POLLCT3 copies the state of the count 1, 2, or 3 event \ufb02ag into C and/or Z and then clears\n\nthe \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\ncounter event \ufb02ag prior to clearing it.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear attention \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear attention \ufb02ag.",
        "instructions": {
          "WAITATN": {
            "mnemonic": "WAITATN",
            "syntax": "WAITATN {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011110 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITATN waits for an attention event to occur (unless the event flag is already set), then clears the event flag Result: Wait for attention event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITATN waits for an attention event to occur (unless the event \ufb02ag is already set), then clears the event \ufb02ag\n\n(unless it's being set again by the event sensor) and resumes execution at the next instruction. Optionally,\n\nWAITATN can time-out if the attention event doesn't occur soon enough; setting C and/or Z \ufb02ags and then\n\nresuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITATN.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe attention event \ufb02ag is set whenever another cog issues an attention request for this cog. The attention event\n\n\ufb02ag is cleared upon cog start, or execution of POLLATN, WAITATN, JATN, or JNATN instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "COGATN",
              "POLLATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Handling Instruction - Get the attention of one or more other cogs.": {
        "count": 1,
        "description": "Event Handling Instruction - Get the attention of one or more other cogs.",
        "instructions": {
          "COGATN": {
            "mnemonic": "COGATN",
            "syntax": "COGATN {#}Dest",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111111                  \u2014                 \u2014                  \u2014                   2",
            "description": "COGATN strobes the attention signal for one or more cogs. Dest bit positions 7:0 represent cogs 7 through 0; high Result: The attention signal of one or more cogs is strobed.\n\nCOGATN strobes the attention signal for one or more cogs. Dest bit positions 7:0 represent cogs 7 through 0; high\n\n(1) bits indicate the cog(s) to signal. The receiving cog(s) then latch the signal, setting an internal \ufb02ag, and can\n\nuse any of the attention monitor instructions (JATN, JNATN, POLLATN, WAITATN) or interrupts to respond and\n\nclear the \ufb02ag.\n\nCOGATN         #00100010                    'Get attention of cogs 1 and 5\n\nIn the intended use case, the cog receiving an attention request knows which other cog is strobing it and how to\n\nrespond. In cases where multiple cogs may request the attention of a single cog, some messaging structure may\n\nneed to be implemented in Hub RAM to differentiate requests.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal whose value (lower 8-bit pattern) indicates which cogs to signal."
            ],
            "related": [
              "POLLATN",
              "WAITATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Stop a cog by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Stop a cog by ID.",
        "instructions": {
          "COGSTOP": {
            "mnemonic": "COGSTOP",
            "syntax": "COGSTOP {#}Dest",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000011                        \u2014                 \u2014                \u2014                    2\u20139",
            "description": "COGSTOP terminates the cog identified by Dest[2:0]. In this dormant state, the cog ceases to execute code and Result: Cog indicated by Dest is terminated (stopped).\n\nCOGSTOP terminates the cog identi\ufb01ed by Dest[2:0]. In this dormant state, the cog ceases to execute code and\n\npower consumption is greatly reduced.\n\nConditions ( IF_x )\n\nEvery PASM2 instruction has an optional \u201ccondition\u201d that dynamically executes or excludes the instruction based\n\non \ufb02ag settings at runtime. A condition, if provided, is placed in front of the instruction it controls.\n\n{Label} {Condition} Instruction Operands {Effect}\n\nConditions are optional; omitting the condition means \"always execute\" the instruction (the default behavior). The\n\nCondition \ufb01eld on an instruction line can contain one of \ufb01fty condition symbols (including blank; the default). The\n\nfull set of condition symbols resolves down to 16 unique condition patterns (4-bits) that are stored in the\n\ninstruction's opcode (the COND \ufb01eld) during assembly.\n\nThis Condition feature, along with the instructions\u2019 optional Effect feature, makes Propeller 2 Assembly very\n\npowerful. For example, the C and Z \ufb02ags can be affected at will and later instructions can be conditionally\n\nexecuted based on those results, making for easy behavioral changes through a single non-branching code path.\n\nWhen an instruction\u2019s condition evaluates to FALSE, the instruction effectively does nothing\u2014 still elapsing 2 clock\n\ncycles, but not affecting any \ufb02ags or registers. This makes the timing of multi-decision code deterministic.\n\nConditions\n\nCondition1        Encoding2 Instruction Executes...\n\nIF_E             %1010        if comparison/subtraction was equal (Z = 1)\n\nIF_NE            %0101        if comparison/subtraction was not equal (Z = 0)\n\nIF_A             %0001        if comparison/subtraction was above (C = 0 and Z = 0)\n\nIF_AE            %0011        if comparison/subtraction was above or equal (C = 0)\n\nIF_B             %1100        if comparison/subtraction was below (C = 1)\n\nIF_BE            %1110     if comparison/subtraction was below or equal (C = 1 or Z = 1)\n\nIF_GT            %0001     if comparison/subtraction was greater than (C = 0 and Z = 0)\n\nIF_GE            %0011     if comparison/subtraction was greater than or equal (C = 0)\n\nIF_LT           %1100     if comparison/subtraction was less than (C = 1)\n\nIF_LE            %1110     if comparison/subtraction was less than or equal (C = 1 or Z = 1)\n\nIF_C            %1100     if C set (C = 1)\n\nIF_NC            %0011     if C clear (C = 0)\n\nIF_Z            %1010     if Z set (Z = 1)\n\nIF_NZ            %0101     if Z clear (Z = 0)\n\nIF_C_EQ_Z          %1001     if C equal to Z (C = 0 and Z = 0 --or-- C = 1 and Z = 1)\n\nIF_C_NE_Z          %0110     if C not equal to Z (C = 0 and Z = 1 --or-- C = 1 and Z = 0)\n\nIF_C_AND_Z         %1000     if C set and Z set (C = 1 and Z = 1)\n\nIF_C_AND_NZ         %0100     if C set and Z clear (C = 1 and Z = 0)\n\nIF_NC_AND_Z         %0010     if C clear and Z set (C = 0 and Z = 1)\n\nIF_NC_AND_NZ        %0001     if C clear and Z clear (C = 0 and Z = 0)\n\nIF_C_OR_Z          %1110     if C set or Z set (C = 1 or Z = 1)\n\nIF_C_OR_NZ         %1101     if C set or Z clear (C = 1 or Z = 0)\n\nIF_NC_OR_Z         %1011     if C clear or Z set (C = 0 or Z = 1)\n\nIF_NC_OR_NZ         %0111     if C clear or Z clear (C = 1 or Z = 0)\n\nIF_Z_EQ_C          %1001     if Z equal to C (Z = 0 and C = 0 --or-- Z = 1 and C = 1)\n\nIF_Z_NE_C          %0110     if Z not equal to C (Z = 0 and C = 1 --or-- Z = 1 and C = 0)\n\nIF_Z_AND_C         %1000     if Z set and C set (Z = 1 and C = 1)\n\nIF_Z_AND_NC         %0010     if Z set and C clear (Z = 1 and C = 0)\n\nIF_NZ_AND_C         %0100     if Z clear and C set (Z = 0 and C = 1)\n\nIF_NZ_AND_NC        %0001     if Z clear and C clear (Z = 0 and C = 0)\n\nIF_Z_OR_C          %1110     if Z set or C set (Z = 1 or C = 1)\n\nIF_Z_OR_NC         %1011     if Z set or C clear (Z = 1 or C = 0)\n\nIF_NZ_OR_C         %1101     if Z clear or C set (Z = 0 or C = 1)\n\nIF_NZ_OR_NC         %0111     if Z clear or C clear (Z = 0 or C = 0)\n\nIF_00           %0001     if C clear and Z clear (C = 0 and Z = 0)\n\nIF_01           %0010     if C clear and Z set (C = 0 and Z = 1)\n\nIF_10           %0100     if C set and Z clear (C = 1 and Z = 0)\n\nIF_11           %1000     if C set and Z set (C = 1 and Z = 1)\n\nIF_X0            %0101     if Z clear (Z = 0)\n\nIF_X1            %1010     if Z set (Z = 1)\n\nIF_0X            %0011     if C clear (C = 0)\n\nIF_1X            %1100     if C set (C = 1)\n\nIF_NOT_00          %1110     if C clear and Z clear (C = 0 and Z = 0)\n\nIF_NOT_01          %1101     if C set or Z clear (C = 1 or Z = 0)\n\nIF_NOT_10          %1011     if C clear or Z set (C = 0 or Z = 1)\n\nIF_NOT_11          %0111     if C clear or Z clear (C = 0 or Z = 0)\n\nIF_DIFF          %0110     if C not equal to Z (C = 0 and Z = 1 --or-- C = 1 and Z = 0)\n\nIF_SAME           %1001     if C equal to Z (C = 0 and Z = 0 --or-- C = 1 and Z = 1)\n\n_RET_            %0000     always; execute instruction then return if no branch; no context restore\n\n%1111     always; this is the default, no condition expressed\n\n1\n\nThe Condition symbol must be entered in place of the {Condition} item (ahead of the Instruction) on an instruction line.\n\n2\n\nThe Encoding value is emitted into the COND \ufb01eld (the EEEE bits) in the compiled instruction opcode.\n\nNote that for every Condition that acts upon the state of C and/or Z \ufb02ags, there's also a Modi\ufb01er (for use with\n\nMODxx instructions) capable of applying \ufb02ag state(s) based on similar logic. Additionally, the Condition symbols\n\nand descriptions are similar to, and the encoding exactly matches, that of the related Modi\ufb01ers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register or 9-bit literal indicating (in lowest 3 bits) which cog to stop."
            ],
            "related": [
              "COGINIT",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Skip": {
        "count": 1,
        "description": "Branch D - Skip",
        "instructions": {
          "SKIP": {
            "mnemonic": "SKIP",
            "syntax": "SKIP \u00a0\u00a0 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110001",
            "description": "Skip instructions per D. Subsequent instructions 0..31 get cancelled for each '1' bit in D[0]..D[31].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Force signed value to be greater than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force signed value to be greater than or equal to another.",
        "instructions": {
          "FGES": {
            "mnemonic": "FGES",
            "syntax": "FGES Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0011010 CZI DDDDDDDDD SSSSSSSSS                    D           limit enforced        Result = 0              2",
            "description": "FGES sets signed Dest to signed Src if Dest is less than Src. This is also known as a limit minimum function; Result: Signed Dest is set to signed Src if Dest was less than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.\n\nFGES sets signed Dest to signed Src if Dest is less than Src. This is also known as a limit minimum function;\n\npreventing Dest from sinking below Src.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was limited (Dest was less than Src and now Dest is\n\nequal to Src), or is cleared (0) if not limited.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the signed value to limit to a minimum of signed Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose signed value is the lower limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "FLES",
              "FGE",
              "FLE"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Zero-extend value beyond designated bit.": {
        "count": 1,
        "description": "Math Instruction - Zero-extend value beyond designated bit.",
        "instructions": {
          "ZEROX": {
            "mnemonic": "ZEROX",
            "syntax": "ZEROX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0111010 CZI DDDDDDDDD SSSSSSSSS                    D            MSB of result        Result = 0               2",
            "description": "ZEROX fills the bits of Dest, above the bit indicated by Src[4:0], with zeros; i.e. zero-extending the value. This is C = MSB of result.\n\nZEROX \ufb01lls the bits of Dest, above the bit indicated by Src[4:0], with zeros; i.e. zero-extending the value. This is\n\nhandy when converting encoded or received unsigned values from a small bit width to a large bit with; i.e. 32 bits.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set to the result's MSB value.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.\n\nPROPELLER 2 ASSEMBLY LANGUAGE (PASM2) IN BRIEF\n\nMath and Logic Instructions\n\nClocks\n\nInstruction                                                              Description\n\nReg, LUT, & Hub\n\nABS      D          {WC/WZ/WCZ}    Get absolute value of D into D. D = ABS(D). C = D[31]. *                                                                       2\n\nABS      D,{#}S     {WC/WZ/WCZ}    Get absolute value of S into D. D = ABS(S). C = S[31]. *                                                                       2\n\nADD      D,{#}S     {WC/WZ/WCZ}    Add S into D. D = D + S. C = carry of (D + S). *                                                                               2\n\nADDS     D,{#}S     {WC/WZ/WCZ}    Add S into D, signed. D = D + S. C = correct sign of (D + S). *                                                                2\n\nADDSX    D,{#}S     {WC/WZ/WCZ}    Add (S + C) into D, signed and extended. D = D + S + C. C = correct sign of (D + S + C). Z = Z AND (result == 0).              2\n\nADDX     D,{#}S     {WC/WZ/WCZ}    Add (S + C) into D, extended. D = D + S + C. C = carry of (D + S + C). Z = Z AND (result == 0).                                2\n\nAND      D,{#}S     {WC/WZ/WCZ}    AND S into D. D = D & S. C = parity of result. *                                                                               2\n\nANDN     D,{#}S     {WC/WZ/WCZ}    AND !S into D. D = D & !S. C = parity of result. *                                                                             2\n\nBITC     D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = C. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                 2\n\nBITH     D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = 1. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                 2\n\nBITL     D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = 0. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                 2\n\nBITNC    D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = !C. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                2\n\nBITNOT   D,{#}S            {WCZ}   Toggle bits D[S[9:5]+S[4:0]:S[4:0]]. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].              2\n\nBITNZ    D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = !Z. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                2\n\nBits D[S[9:5]+S[4:0]:S[4:0]] = RNDs. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original\n\nBITRND   D,{#}S            {WCZ}                                                                                                                                  2\n\nD[S[4:0]].\n\nBITZ     D,{#}S            {WCZ}   Bits D[S[9:5]+S[4:0]:S[4:0]] = Z. Other bits una ected. Prior SETQ overrides S[9:5]. C,Z = original D[S[4:0]].                 2\n\nBMASK    D                         Get LSB-justi\ufb01ed bit mask of size (D[4:0] + 1) into D. D = ($0000_0002 << D[4:0]) - 1.                                         2\n\nBMASK    D,{#}S                    Get LSB-justi\ufb01ed bit mask of size (S[4:0] + 1) into D. D = ($0000_0002 << S[4:0]) - 1.                                         2\n\nCMP      D,{#}S     {WC/WZ/WCZ}    Compare D to S. C = borrow of (D - S). Z = (D == S).                                                                           2\n\nCMPM     D,{#}S     {WC/WZ/WCZ}    Compare D to S, get MSB of di erence into C. C = MSB of (D - S). Z = (D == S).                                                 2\n\nCMPR     D,{#}S     {WC/WZ/WCZ}    Compare S to D (reverse). C = borrow of (S - D). Z = (D == S).                                                                 2\n\nCMPS     D,{#}S     {WC/WZ/WCZ}    Compare D to S, signed. C = correct sign of (D - S). Z = (D == S).                                                             2\n\nCMPSUB   D,{#}S     {WC/WZ/WCZ}    Compare and subtract S from D if D >= S. If D => S then D = D - S and C = 1, else D same and C = 0. *                          2\n\nCMPSX    D,{#}S     {WC/WZ/WCZ}    Compare D to (S + C), signed and extended. C = correct sign of (D - (S + C)). Z = Z AND (D == S + C).                          2\n\nCMPX     D,{#}S     {WC/WZ/WCZ}    Compare D to (S + C), extended. C = borrow of (D - (S + C)). Z = Z AND (D == S + C).                                           2\n\nCRCBIT   D,{#}S                    Iterate CRC value in D using C and polynomial in S. If (C XOR D[0]) then D = (D >> 1) XOR S, else D = (D >> 1).                2\n\nIterate CRC value in D using Q[31:28] and polynomial in S. Like CRCBIT x 4. Q = Q << 4. Use 'REP\n\nCRCNIB   D,{#}S                                                                                                                                                   2\n\n#n,#1'+SETQ+CRCNIB+CRCNIB+CRCNIB...\n\nDECMOD   D,{#}S     {WC/WZ/WCZ}    Decrement with modulus. If D = 0 then D = S and C = 1, else D = D - 1 and C = 0. *                                             2\n\nDECOD    D                         Decode D[4:0] into D. D = 1 << D[4:0].                                                                                         2\n\nDECOD    D,{#}S                    Decode S[4:0] into D. D = 1 << S[4:0].                                                                                         2\n\nENCOD    D          {WC/WZ/WCZ}    Get bit position of top-most '1' in D into D. D = position of top '1' in S (0..31). C = (S != 0). *                            2\n\nENCOD    D,{#}S     {WC/WZ/WCZ}    Get bit position of top-most '1' in S into D. D = position of top '1' in S (0..31). C = (S != 0). *                            2\n\nFGE      D,{#}S     {WC/WZ/WCZ}    Force D >= S. If D < S then D = S and C = 1, else D same and C = 0. *                                                          2\n\nFGES     D,{#}S     {WC/WZ/WCZ}    Force D >= S, signed. If D < S then D = S and C = 1, else D same and C = 0. *                                                  2\n\nFLE      D,{#}S     {WC/WZ/WCZ}    Force D <= S. If D > S then D = S and C = 1, else D same and C = 0. *                                                          2\n\nFLES     D,{#}S     {WC/WZ/WCZ}    Force D <= S, signed. If D > S then D = S and C = 1, else D same and C = 0. *                                                  2\n\nGETBYTE D                          Get byte established by prior ALTGB instruction into D.                                                                        2\n\nGETBYTE D,{#}S,#N                  Get byte N of S into D. D = {24'b0, S.BYTE[N]).                                                                                2\n\nGETNIB   D                         Get nibble established by prior ALTGN instruction into D.                                                                      2\n\nGETNIB   D,{#}S,#N               Get nibble N of S into D. D = {28'b0, S.NIBBLE[N]).                                                                                  2\n\nGETWORD D                        Get word established by prior ALTGW instruction into D.                                                                              2\n\nGETWORD D,{#}S,#N                Get word N of S into D. D = {16'b0, S.WORD[N]).                                                                                      2\n\nINCMOD   D,{#}S    {WC/WZ/WCZ}   Increment with modulus. If D = S then D = 0 and C = 1, else D = D + 1 and C = 0. *                                                   2\n\nGet {12'b0, address[19:0]} into PA/PB/PTRA/PTRB (per W). If R = 1, address = PC + A, else address = A. \"\\\"\n\nLOC      PA/PB/PTRA/PTRB,#{\\}A                                                                                                                                        2\n\nforces R = 0.\n\nMERGEB   D                       Merge bits of bytes in D. D = {D[31], D[23], D[15], D[7], ...D[24], D[16], D[8], D[0]}.                                              2\n\nMERGEW   D                       Merge bits of words in D. D = {D[31], D[15], D[30], D[14], ...D[17], D[1], D[16], D[0]}.                                             2\n\nMODC     c                {WC}   Modify C according to cccc. C = cccc[{C,Z}].                                                                                         2\n\nMODCZ    c,z       {WC/WZ/WCZ}   Modify C and Z according to cccc and zzzz. C = cccc[{C,Z}], Z = zzzz[{C,Z}].                                                         2\n\nMODZ     z                {WZ}   Modify Z according to zzzz. Z = zzzz[{C,Z}].                                                                                         2\n\nMOV      D,{#}S    {WC/WZ/WCZ}   Move S into D. D = S. C = S[31]. *                                                                                                   2\n\nMOVBYTS D,{#}S                   Move bytes within D, per S. D = {D.BYTE[S[7:6]], D.BYTE[S[5:4]], D.BYTE[S[3:2]], D.BYTE[S[1:0]]}.                                    2\n\nMUL      D,{#}S           {WZ}   D = unsigned (D[15:0] * S[15:0]). Z = (S == 0) | (D == 0).                                                                           2\n\nMULS     D,{#}S           {WZ}   D = signed (D[15:0] * S[15:0]). Z = (S == 0) | (D == 0).                                                                             2\n\nMUXC     D,{#}S    {WC/WZ/WCZ}   Mux C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ C}}). C = parity of result. *                                      2\n\nMUXNC    D,{#}S    {WC/WZ/WCZ}   Mux !C into each D bit that is '1' in S. D = (!S & D ) | (S & {32{!C}}). C = parity of result. *                                     2\n\nFor each non-zero nibble in S, copy that nibble into the corresponding D nibble, else leave that D nibble the\n\nMUXNIBS D,{#}S                                                                                                                                                        2\n\nsame.\n\nFor each non-zero bit pair in S, copy that bit pair into the corresponding D bits, else leave that D bit pair the\n\nMUXNITS D,{#}S                                                                                                                                                        2\n\nsame.\n\nMUXNZ    D,{#}S    {WC/WZ/WCZ}   Mux !Z into each D bit that is '1' in S. D = (!S & D ) | (S & {32{!Z}}). C = parity of result. *                                     2\n\nMUXQ     D,{#}S                  Used after SETQ. For each '1' bit in Q, copy the corresponding bit in S into D. D = (D & !Q) | (S & Q).                              2\n\nMUXZ     D,{#}S    {WC/WZ/WCZ}   Mux Z into each D bit that is '1' in S. D = (!S & D ) | (S & {32{ Z}}). C = parity of result. *                                      2\n\nNEG      D         {WC/WZ/WCZ}   Negate D. D = -D. C = MSB of result. *                                                                                               2\n\nNEG      D,{#}S    {WC/WZ/WCZ}   Negate S into D. D = -S. C = MSB of result. *                                                                                        2\n\nNEGC     D         {WC/WZ/WCZ}   Negate D by C. If C = 1 then D = -D, else D = D. C = MSB of result. *                                                                2\n\nNEGC     D,{#}S    {WC/WZ/WCZ}   Negate S by C into D. If C = 1 then D = -S, else D = S. C = MSB of result. *                                                         2\n\nNEGNC    D         {WC/WZ/WCZ}   Negate D by !C. If C = 0 then D = -D, else D = D. C = MSB of result. *                                                               2\n\nNEGNC    D,{#}S    {WC/WZ/WCZ}   Negate S by !C into D. If C = 0 then D = -S, else D = S. C = MSB of result. *                                                        2\n\nNEGNZ    D         {WC/WZ/WCZ}   Negate D by !Z. If Z = 0 then D = -D, else D = D. C = MSB of result. *                                                               2\n\nNEGNZ    D,{#}S    {WC/WZ/WCZ}   Negate S by !Z into D. If Z = 0 then D = -S, else D = S. C = MSB of result. *                                                        2\n\nNEGZ     D         {WC/WZ/WCZ}   Negate D by Z. If Z = 1 then D = -D, else D = D. C = MSB of result. *                                                                2\n\nNEGZ     D,{#}S    {WC/WZ/WCZ}   Negate S by Z into D. If Z = 1 then D = -S, else D = S. C = MSB of result. *                                                         2\n\nNOT      D         {WC/WZ/WCZ}   Get !D into D. D = !D. C = !D[31]. *                                                                                                 2\n\nNOT      D,{#}S    {WC/WZ/WCZ}   Get !S into D. D = !S. C = !S[31]. *                                                                                                 2\n\nONES     D         {WC/WZ/WCZ}   Get number of '1's in D into D. D = number of '1's in S (0..32). C = LSB of result. *                                                2\n\nONES     D,{#}S    {WC/WZ/WCZ}   Get number of '1's in S into D. D = number of '1's in S (0..32). C = LSB of result. *                                                2\n\nOR       D,{#}S    {WC/WZ/WCZ}   OR S into D. D = D | S. C = parity of result. *                                                                                      2\n\nRCL      D,{#}S    {WC/WZ/WCZ}   Rotate carry left. D = [63:32] of ({D[31:0], {32{C}}} << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *              2\n\nRCR      D,{#}S    {WC/WZ/WCZ}   Rotate carry right. D = [31:0] of ({{32{C}}, D[31:0]} >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0]. *               2\n\nRCZL     D         {WC/WZ/WCZ}   Rotate C,Z left through D. D = {D[29:0], C, Z}. C = D[31], Z = D[30].                                                                2\n\nRCZR     D         {WC/WZ/WCZ}   Rotate C,Z right through D. D = {C, Z, D[31:2]}. C = D[1], Z = D[0].                                                                 2\n\nREV      D                       Reverse D bits. D = D[0:31].                                                                                                         2\n\nExpand 5:6:5 RGB value in D[15:0] into 8:8:8 value in D[31:8]. D = {D[15:11,15:13], D[10:5,10:9], D[4:0,4:2],\n\nRGBEXP   D                                                                                                                                                            2\n\n8'b0}.\n\nRGBSQZ   D                        Squeeze 8:8:8 RGB value in D[31:8] into 5:6:5 value in D[15:0]. D = {15'b0, D[31:27], D[23:18], D[15:11]}.                          2\n\nROL      D,{#}S     {WC/WZ/WCZ}   Rotate left. D = [63:32] of ({D[31:0], D[31:0]} << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *                   2\n\nROLBYTE D                         Rotate-left byte established by prior ALTGB instruction into D.                                                                     2\n\nROLBYTE D,{#}S,#N                 Rotate-left byte N of S into D. D = {D[23:0], S.BYTE[N]).                                                                           2\n\nROLNIB   D                        Rotate-left nibble established by prior ALTGN instruction into D.                                                                   2\n\nROLNIB   D,{#}S,#N                Rotate-left nibble N of S into D. D = {D[27:0], S.NIBBLE[N]).                                                                       2\n\nROLWORD D                         Rotate-left word established by prior ALTGW instruction into D.                                                                     2\n\nROLWORD D,{#}S,#N                 Rotate-left word N of S into D. D = {D[15:0], S.WORD[N]).                                                                           2\n\nROR      D,{#}S     {WC/WZ/WCZ}   Rotate right. D = [31:0] of ({D[31:0], D[31:0]} >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0]. *                    2\n\nShift arithmetic left. D = [63:32] of ({D[31:0], {32{D[0]}}} << S[4:0]). C = last bit shifted out if S[4:0] > 0, else\n\nSAL      D,{#}S     {WC/WZ/WCZ}                                                                                                                                       2\n\nD[31]. *\n\nShift arithmetic right. D = [31:0] of ({{32{D[31]}}, D[31:0]} >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else\n\nSAR      D,{#}S     {WC/WZ/WCZ}                                                                                                                                       2\n\nD[0]. *\n\nSCA      D,{#}S            {WZ}   Next instruction's S value = unsigned (D[15:0] * S[15:0]) >> 16. *                                                                  2\n\nSCAS     D,{#}S            {WZ}   Next instruction's S value = signed (D[15:0] * S[15:0]) >> 14. In this scheme, $4000 = 1.0 and $C000 = -1.0. *                      2\n\nSETBYTE {#}S                      Set S[7:0] into byte established by prior ALTSB instruction.                                                                        2\n\nSETBYTE D,{#}S,#N                 Set S[7:0] into byte N in D, keeping rest of D same.                                                                                2\n\nSETD     D,{#}S                   Set D \ufb01eld of D to S[8:0]. D = {D[31:18], S[8:0], D[8:0]}.                                                                          2\n\nSETNIB   {#}S                     Set S[3:0] into nibble established by prior ALTSN instruction.                                                                      2\n\nSETNIB   D,{#}S,#N                Set S[3:0] into nibble N in D, keeping rest of D same.                                                                              2\n\nSETR     D,{#}S                   Set R \ufb01eld of D to S[8:0]. D = {D[31:28], S[8:0], D[18:0]}.                                                                         2\n\nSETS     D,{#}S                   Set S \ufb01eld of D to S[8:0]. D = {D[31:9], S[8:0]}.                                                                                   2\n\nSETWORD {#}S                      Set S[15:0] into word established by prior ALTSW instruction.                                                                       2\n\nSETWORD D,{#}S,#N                 Set S[15:0] into word N in D, keeping rest of D same.                                                                               2\n\nSEUSSF   D                        Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Forward pattern.                       2\n\nSEUSSR   D                        Relocate and periodically invert bits within D. Returns to original value on 32nd iteration. Reverse pattern.                       2\n\nSHL      D,{#}S     {WC/WZ/WCZ}   Shift left. D = [63:32] of ({D[31:0], 32'b0} << S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[31]. *                      2\n\nSHR      D,{#}S     {WC/WZ/WCZ}   Shift right. D = [31:0] of ({32'b0, D[31:0]} >> S[4:0]). C = last bit shifted out if S[4:0] > 0, else D[0]. *                       2\n\nSIGNX    D,{#}S     {WC/WZ/WCZ}   Sign-extend D from bit S[4:0]. C = MSB of result. *                                                                                 2\n\nSPLITB   D                        Split every 4th bit of D into bytes. D = {D[31], D[27], D[23], D[19], ...D[12], D[8], D[4], D[0]}.                                  2\n\nSPLITW   D                        Split odd/even bits of D into words. D = {D[31], D[29], D[27], D[25], ...D[6], D[4], D[2], D[0]}.                                   2\n\nSUB      D,{#}S     {WC/WZ/WCZ}   Subtract S from D. D = D - S. C = borrow of (D - S). *                                                                              2\n\nSUBR     D,{#}S     {WC/WZ/WCZ}   Subtract D from S (reverse). D = S - D. C = borrow of (S - D). *                                                                    2\n\nSUBS     D,{#}S     {WC/WZ/WCZ}   Subtract S from D, signed. D = D - S. C = correct sign of (D - S). *                                                                2\n\nSubtract (S + C) from D, signed and extended. D = D - (S + C). C = correct sign of (D - (S + C)). Z = Z AND (result\n\nSUBSX    D,{#}S     {WC/WZ/WCZ}                                                                                                                                       2\n\n== 0).\n\nSUBX     D,{#}S     {WC/WZ/WCZ}   Subtract (S + C) from D, extended. D = D - (S + C). C = borrow of (D - (S + C)). Z = Z AND (result == 0).                           2\n\nSUMC     D,{#}S     {WC/WZ/WCZ}   Sum +/-S into D by C. If C = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *                                     2\n\nSUMNC    D,{#}S     {WC/WZ/WCZ}   Sum +/-S into D by !C. If C = 0 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *                                    2\n\nSUMNZ    D,{#}S     {WC/WZ/WCZ}   Sum +/-S into D by !Z. If Z = 0 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *                                    2\n\nSUMZ     D,{#}S     {WC/WZ/WCZ}   Sum +/-S into D by Z. If Z = 1 then D = D - S, else D = D + S. C = correct sign of (D +/- S). *                                     2\n\nTEST     D          {WC/WZ/WCZ}   Test D. C = parity of D. Z = (D == 0).                                                                                              2\n\nTEST     D,{#}S     {WC/WZ/WCZ}   Test D with S. C = parity of (D & S). Z = ((D & S) == 0).                                                                           2\n\nTESTB    D,{#}S           WC/WZ   Test bit S[4:0] of D, write to C/Z. C/Z = D[S[4:0]].                                                                                2\n\nTESTB    D,{#}S         ORC/ORZ   Test bit S[4:0] of D, OR into C/Z. C/Z = C/Z OR D[S[4:0]].                                                                          2\n\nTESTB    D,{#}S       ANDC/ANDZ   Test bit S[4:0] of D, AND into C/Z. C/Z = C/Z AND D[S[4:0]].                                                                        2\n\nTESTB    D,{#}S       XORC/XORZ         Test bit S[4:0] of D, XOR into C/Z. C/Z = C/Z XOR D[S[4:0]].                                                                 2\n\nTESTBN   D,{#}S             WC/WZ       Test bit S[4:0] of !D, write to C/Z. C/Z = !D[S[4:0]].                                                                       2\n\nTESTBN   D,{#}S            ORC/ORZ      Test bit S[4:0] of !D, OR into C/Z. C/Z = C/Z OR !D[S[4:0]].                                                                 2\n\nTESTBN   D,{#}S       ANDC/ANDZ         Test bit S[4:0] of !D, AND into C/Z. C/Z = C/Z AND !D[S[4:0]].                                                               2\n\nTESTBN   D,{#}S       XORC/XORZ         Test bit S[4:0] of !D, XOR into C/Z. C/Z = C/Z XOR !D[S[4:0]].                                                               2\n\nTESTN    D,{#}S      {WC/WZ/WCZ} Test D with !S. C = parity of (D & !S). Z = ((D & !S) == 0).                                                                        2\n\nWRC      D                              Write 0 or 1 to D, according to C. D = {31'b0, C).                                                                           2\n\nWRNC     D                              Write 0 or 1 to D, according to !C. D = {31'b0, !C).                                                                         2\n\nWRNZ     D                              Write 0 or 1 to D, according to !Z. D = {31'b0, !Z).                                                                         2\n\nWRZ      D                              Write 0 or 1 to D, according to Z. D = {31'b0, Z).                                                                           2\n\nXOR      D,{#}S     {WC/WZ/WCZ}         XOR S into D. D = D ^ S. C = parity of result. *                                                                             2\n\nXORO32   D                              Iterate D with xoroshiro32+ PRNG algorithm and put PRNG result into next instruction's S.                                    2\n\nZEROX    D,{#}S     {WC/WZ/WCZ}         Zero-extend D above bit S[4:0]. C = MSB of result. *                                                                         2\n\nPin & Smart Pin Instructions\n\nClocks\n\nInstruction                                                                   Description\n\nCog, LUT & Hub\n\nPin\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = C. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRC     {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = 1. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRH     {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = 0. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRL     {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = !C. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRNC    {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nToggle DIR bits of pins D[10:6]+D[5:0]..D[5:0]. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRNOT   {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = !Z. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRNZ    {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z =\n\nDIRRND   {#}D               {WCZ}                                                                                                                                    2\n\nDIR bit.\n\nDIR bits of pins D[10:6]+D[5:0]..D[5:0] = Z. Wraps within DIRA/DIRB. Prior SETQ overrides D[10:6]. C,Z = DIR\n\nDIRZ     {#}D               {WCZ}                                                                                                                                    2\n\nbit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = C. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVC     {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVH     {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVL     {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVNC    {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nToggle OUT bits of pins D[10:6]+D[5:0]..D[5:0]. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVNOT   {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVNZ    {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVRND   {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z. DIR bits = 1. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nDRVZ     {#}D               {WCZ}                                                                                                                                    2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = C. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTC     {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTH     {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTL     {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTNC    {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nToggle OUT bits of pins D[10:6]+D[5:0]..D[5:0]. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTNOT   {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTNZ    {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTRND   {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z. DIR bits = 0. Wraps within OUTA/OUTB. Prior SETQ overrides\n\nFLTZ     {#}D             {WCZ}                                                                                                                              2\n\nD[10:6]. C,Z = OUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = C. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTC     {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 1. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTH     {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = 0. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTL     {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !C. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTNC    {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nToggle OUT bits of pins D[10:6]+D[5:0]..D[5:0]. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z =\n\nOUTNOT   {#}D             {WCZ}                                                                                                                              2\n\nOUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = !Z. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTNZ    {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = RNDs. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z =\n\nOUTRND   {#}D             {WCZ}                                                                                                                              2\n\nOUT bit.\n\nOUT bits of pins D[10:6]+D[5:0]..D[5:0] = Z. Wraps within OUTA/OUTB. Prior SETQ overrides D[10:6]. C,Z = OUT\n\nOUTZ     {#}D             {WCZ}                                                                                                                              2\n\nbit.\n\nTESTP    {#}D             WC/WZ   Test IN bit of pin D[5:0], write to C/Z. C/Z = IN[D[5:0]].                                                                 2\n\nTESTP    {#}D           ORC/ORZ   Test IN bit of pin D[5:0], OR into C/Z. C/Z = C/Z OR IN[D[5:0]].                                                           2\n\nTESTP    {#}D         ANDC/ANDZ   Test IN bit of pin D[5:0], AND into C/Z. C/Z = C/Z AND IN[D[5:0]].                                                         2\n\nTESTP    {#}D         XORC/XORZ   Test IN bit of pin D[5:0], XOR into C/Z. C/Z = C/Z XOR IN[D[5:0]].                                                         2\n\nTESTPN   {#}D             WC/WZ   Test !IN bit of pin D[5:0], write to C/Z. C/Z = !IN[D[5:0]].                                                               2\n\nTESTPN   {#}D           ORC/ORZ   Test !IN bit of pin D[5:0], OR into C/Z. C/Z = C/Z OR !IN[D[5:0]].                                                         2\n\nTESTPN   {#}D         ANDC/ANDZ   Test !IN bit of pin D[5:0], AND into C/Z. C/Z = C/Z AND !IN[D[5:0]].                                                       2\n\nTESTPN   {#}D         XORC/XORZ   Test !IN bit of pin D[5:0], XOR into C/Z. C/Z = C/Z XOR !IN[D[5:0]].                                                       2\n\nSmart Pin\n\nAKPIN    {#}S                     Acknowledge smart pins S[10:6]+S[5:0]..S[5:0]. Wraps within A/B pins. Prior SETQ overrides S[10:6].                        2\n\nGETSCP   D                        Get four-channel oscilloscope samples into D. D = {ch3[7:0],ch2[7:0],ch1[7:0],ch0[7:0]}.                                   2\n\nRDPIN    D,{#}S            {WC}   Read smart pin S[5:0] result \"Z\" into D, acknowledge smart pin. C = modal result.                                          2\n\nRead smart pin S[5:0] result \"Z\" into D, don't acknowledge smart pin (\"Q\" in RQPIN means \"quiet\"). C = modal\n\nRQPIN    D,{#}S            {WC}                                                                                                                              2\n\nresult.\n\nSETDACS {#}D                      DAC3 = D[31:24], DAC2 = D[23:16], DAC1 = D[15:8], DAC0 = D[7:0].                                                           2\n\nSETSCP   {#}D                     Set four-channel oscilloscope enable to D[6] and set input pin base to D[5:2].                                             2\n\nSet mode of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ\n\nWRPIN    {#}D,{#}S                                                                                                                                           2\n\noverrides S[10:6].\n\nSet \"X\" of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ\n\nWXPIN    {#}D,{#}S                                                                                                                                                   2\n\noverrides S[10:6].\n\nSet \"Y\" of smart pins S[10:6]+S[5:0]..S[5:0] to D, acknowledge smart pins. Wraps within A/B pins. Prior SETQ\n\nWYPIN    {#}D,{#}S                                                                                                                                                   2\n\noverrides S[10:6].\n\nBranch Instructions\n\nClocks\n\nInstruction                                                           Description\n\nCog & LUT / Hub\n\nCALL     #{\\}A                    Call to A by pushing {C, Z, 10'b0, PC[19:0]} onto stack. If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.                4 / 13...20\n\nCALL     D          {WC/WZ/WCZ}   Call to D by pushing {C, Z, 10'b0, PC[19:0]} onto stack. C = D[31], Z = D[30], PC = D[19:0].                                  4 / 13...20\n\nCall to A by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRA++. If R = 1 then PC += A, else PC = A. \"\\\" forces R\n\nCALLA    #{\\}A                                                                                                                                              5...12 1 / 14...32 1\n\n= 0.\n\nCALLA    D          {WC/WZ/WCZ}   Call to D by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRA++. C = D[31], Z = D[30], PC = D[19:0].                   5...12 1 / 14...32 1\n\nCall to A by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRB++. If R = 1 then PC += A, else PC = A. \"\\\" forces R\n\nCALLB    #{\\}A                                                                                                                                              5...12 1 / 14...32 1\n\n= 0.\n\nCALLB    D          {WC/WZ/WCZ}   Call to D by writing {C, Z, 10'b0, PC[19:0]} to hub long at PTRB++. C = D[31], Z = D[30], PC = D[19:0].                   5...12 1 / 14...32 1\n\nCALLD    D,{#}S     {WC/WZ/WCZ}   Call to S** by writing {C, Z, 10'b0, PC[19:0]} to D. C = S[31], Z = S[30].                                                    4 / 13...20\n\nCall to A by writing {C, Z, 10'b0, PC[19:0]} to PA/PB/PTRA/PTRB (per W). If R = 1 then PC += A, else PC = A. \"\\\"\n\nCALLD    PA/PB/PTRA/PTRB,#{\\}A                                                                                                                                  4 / 13...20\n\nforces R = 0.\n\nCALLPA   {#}D,{#}S                Call to S** by pushing {C, Z, 10'b0, PC[19:0]} onto stack, copy D to PA.                                                      4 / 13...20\n\nCALLPB   {#}D,{#}S                Call to S** by pushing {C, Z, 10'b0, PC[19:0]} onto stack, copy D to PB.                                                      4 / 13...20\n\nDJF      D,{#}S                   Decrement D and jump to S** if result is $FFFF_FFFF.                                                                     2 or 4 / 2 or 13...20\n\nDJNF     D,{#}S                   Decrement D and jump to S** if result is not $FFFF_FFFF.                                                                 2 or 4 / 2 or 13...20\n\nDJNZ     D,{#}S                   Decrement D and jump to S** if result is not zero.                                                                       2 or 4 / 2 or 13...20\n\nDJZ      D,{#}S                   Decrement D and jump to S** if result is zero.                                                                           2 or 4 / 2 or 13...20\n\nEXECF    {#}D                     Jump to D[9:0] in cog/LUT and set SKIPF pattern to D[31:10]. PC = {10'b0, D[9:0]}.                                               4/4\n\nIJNZ     D,{#}S                   Increment D and jump to S** if result is not zero.                                                                       2 or 4 / 2 or 13...20\n\nIJZ      D,{#}S                   Increment D and jump to S** if result is zero.                                                                           2 or 4 / 2 or 13...20\n\nJMP      #{\\}A                    Jump to A. If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.                                                              4 / 13...20\n\nJMP      D          {WC/WZ/WCZ}   Jump to D. C = D[31], Z = D[30], PC = D[19:0].                                                                                4 / 13...20\n\nJMPREL   {#}D                     Jump ahead/back by D instructions. For cogex, PC += D[19:0]. For hubex, PC += D[17:0] << 2.                                   4 / 13...20\n\nREP      {#}D,{#}S                Execute next D[8:0] instructions S times. If S = 0, repeat instructions in\ufb01nitely. If D[8:0] = 0, nothing repeats.               2/2\n\nRESI0                             Resume from INT0. (CALLD $1FE,$1FF WCZ)                                                                                       4 / 13...20\n\nRESI1                             Resume from INT1. (CALLD $1F4,$1F5 WCZ)                                                                                       4 / 13...20\n\nRESI2                             Resume from INT2. (CALLD $1F2,$1F3 WCZ)                                                                                       4 / 13...20\n\nRESI3                             Resume from INT3. (CALLD $1F0,$1F1 WCZ)                                                                                       4 / 13...20\n\nRET                 {WC/WZ/WCZ}   Return by popping stack (K). C = K[31], Z = K[30], PC = K[19:0].                                                              4 / 13...20\n\nRETA                {WC/WZ/WCZ}   Return by reading hub long (L) at --PTRA. C = L[31], Z = L[30], PC = L[19:0].                                             11...18 1 / 20...40 1\n\nRETB                {WC/WZ/WCZ}   Return by reading hub long (L) at --PTRB. C = L[31], Z = L[30], PC = L[19:0].                                             11...18 1 / 20...40 1\n\nRETI0                             Return from INT0. (CALLD $1FF,$1FF WCZ)                                                                                       4 / 13...20\n\nRETI1                             Return from INT1. (CALLD $1FF,$1F5 WCZ)                                                                                       4 / 13...20\n\nRETI2                             Return from INT2. (CALLD $1FF,$1F3 WCZ)                                                                                       4 / 13...20\n\nRETI3                             Return from INT3. (CALLD $1FF,$1F1 WCZ)                                                                                       4 / 13...20\n\nSKIP     {#}D                     Skip instructions per D. Subsequent instructions 0..31 get cancelled for each '1' bit in D[0]..D[31].                            2/2\n\nSKIPF    {#}D                     Skip cog/LUT instructions fast per D. Like SKIP, but instead of cancelling instructions, the PC leaps over them.             2 / ILLEGAL\n\nTJF      D,{#}S                   Test D and jump to S** if D is full (D = $FFFF_FFFF).                                                                    2 or 4 / 2 or 13...20\n\nTJNF       D,{#}S                   Test D and jump to S** if D is not full (D != $FFFF_FFFF).                                                           2 or 4 / 2 or 13...20\n\nTJNS       D,{#}S                   Test D and jump to S** if D is not signed (D[31] = 0).                                                               2 or 4 / 2 or 13...20\n\nTJNZ       D,{#}S                   Test D and jump to S** if D is not zero.                                                                             2 or 4 / 2 or 13...20\n\nTJS        D,{#}S                   Test D and jump to S** if D is signed (D[31] = 1).                                                                   2 or 4 / 2 or 13...20\n\nTJV        D,{#}S                   Test D and jump to S** if D over\ufb02owed (D[31] != C, C = 'correct sign' from last addition/subtraction).               2 or 4 / 2 or 13...20\n\nTJZ        D,{#}S                   Test D and jump to S** if D is zero.                                                                                 2 or 4 / 2 or 13...20\n\n1\n\n+1 if crosses hub long\n\nHub Control, FIFO, & RAM Instructions\n\nClocks\n\nInstruction                                                          Description\n\nCog & LUT / Hub\n\nHub Control\n\nCOGID      {#}D              {WC}   If D is register and no WC, get cog ID (0 to 15) into D. If WC, check status of cog D[3:0], C = 1 if on.           2...9, +2 if result / same\n\nCOGINIT {#}D,{#}S            {WC}   Start cog selected by D. S[19:0] sets hub startup address and PTRB of cog. Prior SETQ sets PTRA of cog.            2...9, +2 if result / same\n\nCOGSTOP {#}D                        Stop cog D[3:0].                                                                                                         2...9 / same\n\nLOCKNEW D                    {WC}   Request a LOCK. D will be written with the LOCK number (0 to 15). C = 1 if no LOCK available.                           4...11 / same\n\nRelease LOCK D[3:0]. If D is a register and WC, get current/last cog id of LOCK owner into D and LOCK status\n\nLOCKREL {#}D                 {WC}                                                                                                                      2...9, +2 if result / same\n\ninto C.\n\nLOCKRET {#}D                        Return LOCK D[3:0] for reallocation.                                                                                     2...9 / same\n\nTry to get LOCK D[3:0]. C = 1 if got LOCK. LOCKREL releases LOCK. LOCK is also released if owner cog stops or\n\nLOCKTRY {#}D                 {WC}                                                                                                                      2...9, +2 if result / same\n\nrestarts.\n\nHUBSET     {#}D                     Set hub con\ufb01guration to D.                                                                                               2...9 / same\n\nHub FIFO\n\nGETPTR     D                        Get current FIFO hub pointer into D.                                                                                   2 / FIFO IN USE\n\nSet next block for when block wraps. D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start\n\nFBLOCK     {#}D,{#}S                                                                                                                                       2 / FIFO IN USE\n\naddress.\n\nBegin new fast hub read via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] =       2 or WRFAST \ufb01nish +\n\nRDFAST     {#}D,{#}S\n\nblock start address.                                                                                                10...17 / FIFO IN USE\n\nBegin new fast hub write via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] =     2 or WRFAST \ufb01nish + 3 /\n\nWRFAST     {#}D,{#}S\n\nblock start address.                                                                                                     FIFO IN USE\n\nRFBYTE     D          {WC/WZ/WCZ}   Used after RDFAST. Read zero-extended byte from FIFO into D. C = MSB of byte. *                                        2 / FIFO IN USE\n\nRFLONG     D          {WC/WZ/WCZ}   Used after RDFAST. Read long from FIFO into D. C = MSB of long. *                                                      2 / FIFO IN USE\n\nRFVAR      D          {WC/WZ/WCZ}   Used after RDFAST. Read zero-extended 1..4-byte value from FIFO into D. C = 0. *                                       2 / FIFO IN USE\n\nRFVARS     D          {WC/WZ/WCZ}   Used after RDFAST. Read sign-extended 1..4-byte value from FIFO into D. C = MSB of value. *                            2 / FIFO IN USE\n\nRFWORD     D          {WC/WZ/WCZ}   Used after RDFAST. Read zero-extended word from FIFO into D. C = MSB of word. *                                        2 / FIFO IN USE\n\nWFBYTE     {#}D                     Used after WRFAST. Write byte in D[7:0] into FIFO.                                                                     2 / FIFO IN USE\n\nWFLONG     {#}D                     Used after WRFAST. Write long in D[31:0] into FIFO.                                                                    2 / FIFO IN USE\n\nWFWORD     {#}D                     Used after WRFAST. Write word in D[15:0] into FIFO.                                                                    2 / FIFO IN USE\n\nHub RAM\n\nPOPA       D          {WC/WZ/WCZ}   Read long from hub address --PTRA into D. C = MSB of long. *                                                           9...16 1 / 9...26 1\n\nPOPB       D          {WC/WZ/WCZ}   Read long from hub address --PTRB into D. C = MSB of long. *                                                           9...16 1 / 9...26 1\n\nRDBYTE     D,{#}S/P {WC/WZ/WCZ}     Read zero-extended byte from hub address {#}S/PTRx into D. C = MSB of byte. *                                           9...16 / 9...26\n\nRead long from hub address {#}S/PTRx into D. C = MSB of long. * Prior SETQ/SETQ2 invokes cog/LUT block\n\nRDLONG     D,{#}S/P {WC/WZ/WCZ}                                                                                                                            9...16 1 / 9...26 1\n\ntransfer.\n\nRDWORD     D,{#}S/P {WC/WZ/WCZ}     Read zero-extended word from hub address {#}S/PTRx into D. C = MSB of word. *                                          9...16 1 / 9...26 1\n\nPUSHA      {#}D                     Write long in D[31:0] to hub address PTRA++.                                                                           3...10 1 / 3...20 1\n\nPUSHB      {#}D                     Write long in D[31:0] to hub address PTRB++.                                                                           3...10 1 / 3...20 1\n\nWrite only non-$00 bytes in D[31:0] to hub address {#}S/PTRx. Prior SETQ/SETQ2 invokes cog/LUT block\n\nWMLONG     D,{#}S/P                                                                                                                              3...10 1 / 3...20 1\n\ntransfer.\n\nWRBYTE     {#}D,{#}S/P             Write byte in D[7:0] to hub address {#}S/PTRx.                                                                  3...10 / 3...20\n\nWRLONG     {#}D,{#}S/P             Write long in D[31:0] to hub address {#}S/PTRx. Prior SETQ/SETQ2 invokes cog/LUT block transfer.              3...10 1 / 3...20 1\n\nWRWORD     {#}D,{#}S/P             Write word in D[15:0] to hub address {#}S/PTRx.                                                               3...10 1 / 3...20 1\n\n1\n\n+1 if crosses hub long\n\nEvent Instructions\n\nClocks\n\nInstruction                                                           Description\n\nCog & LUT / Hub\n\nADDCT1     D,{#}S                  Set CT1 event to trigger on CT = D + S. Adds S into D.                                                                2\n\nADDCT2     D,{#}S                  Set CT2 event to trigger on CT = D + S. Adds S into D.                                                                2\n\nADDCT3     D,{#}S                  Set CT3 event to trigger on CT = D + S. Adds S into D.                                                                2\n\nCOGATN     {#}D                    Strobe \"attention\" of all cogs whose corresponding bits are high in D[15:0].                                          2\n\nJATN       {#}S                    Jump to S** if ATN event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJCT1       {#}S                    Jump to S** if CT1 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJCT2       {#}S                    Jump to S** if CT2 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJCT3       {#}S                    Jump to S** if CT3 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJFBW       {#}S                    Jump to S** if FBW event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJINT       {#}S                    Jump to S** if INT event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJNATN      {#}S                    Jump to S** if ATN event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNCT1      {#}S                    Jump to S** if CT1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNCT2      {#}S                    Jump to S** if CT2 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNCT3      {#}S                    Jump to S** if CT3 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNFBW      {#}S                    Jump to S** if FBW event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNINT      {#}S                    Jump to S** if INT event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNPAT      {#}S                    Jump to S** if PAT event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNQMT      {#}S                    Jump to S** if QMT event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNSE1      {#}S                    Jump to S** if SE1 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNSE2      {#}S                    Jump to S** if SE2 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNSE3      {#}S                    Jump to S** if SE3 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNSE4      {#}S                    Jump to S** if SE4 event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNXFI      {#}S                    Jump to S** if XFI event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNXMT      {#}S                    Jump to S** if XMT event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNXRL      {#}S                    Jump to S** if XRL event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJNXRO      {#}S                    Jump to S** if XRO event \ufb02ag is clear.                                                                       2 or 4 / 2 or 13...20\n\nJPAT       {#}S                    Jump to S** if PAT event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJQMT       {#}S                    Jump to S** if QMT event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJSE1       {#}S                    Jump to S** if SE1 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJSE2       {#}S                    Jump to S** if SE2 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJSE3       {#}S                    Jump to S** if SE3 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJSE4       {#}S                    Jump to S** if SE4 event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJXFI       {#}S                    Jump to S** if XFI event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJXMT       {#}S                    Jump to S** if XMT event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJXRL       {#}S                    Jump to S** if XRL event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nJXRO       {#}S                    Jump to S** if XRO event \ufb02ag is set.                                                                         2 or 4 / 2 or 13...20\n\nPOLLATN              {WC/WZ/WCZ}   Get ATN event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLCT1              {WC/WZ/WCZ}   Get CT1 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLCT2              {WC/WZ/WCZ}   Get CT2 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLCT3              {WC/WZ/WCZ}   Get CT3 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLFBW              {WC/WZ/WCZ}   Get FBW event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLINT              {WC/WZ/WCZ}   Get INT event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLPAT              {WC/WZ/WCZ}   Get PAT event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLQMT              {WC/WZ/WCZ}   Get QMT event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLSE1              {WC/WZ/WCZ}   Get SE1 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLSE2              {WC/WZ/WCZ}   Get SE2 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLSE3              {WC/WZ/WCZ}   Get SE3 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLSE4              {WC/WZ/WCZ}   Get SE4 event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLXFI              {WC/WZ/WCZ}   Get XFI event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLXMT              {WC/WZ/WCZ}   Get XMT event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLXRL              {WC/WZ/WCZ}   Get XRL event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nPOLLXRO              {WC/WZ/WCZ}   Get XRO event \ufb02ag into C/Z, then clear it.                                                                                    2\n\nSETPAT    {#}D,{#}S                Set pin pattern for PAT event. C selects INA/INB, Z selects =/!=, D provides mask value, S provides match value.              2\n\nSETSE1    {#}D                     Set SE1 event con\ufb01guration to D[8:0].                                                                                         2\n\nSETSE2    {#}D                     Set SE2 event con\ufb01guration to D[8:0].                                                                                         2\n\nSETSE3    {#}D                     Set SE3 event con\ufb01guration to D[8:0].                                                                                         2\n\nSETSE4    {#}D                     Set SE4 event con\ufb01guration to D[8:0].                                                                                         2\n\nWAITATN              {WC/WZ/WCZ}   Wait for ATN event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT1              {WC/WZ/WCZ}   Wait for CT1 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT2              {WC/WZ/WCZ}   Wait for CT2 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT3              {WC/WZ/WCZ}   Wait for CT3 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITFBW              {WC/WZ/WCZ}   Wait for FBW event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITINT              {WC/WZ/WCZ}   Wait for INT event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITPAT              {WC/WZ/WCZ}   Wait for PAT event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE1              {WC/WZ/WCZ}   Wait for SE1 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE2              {WC/WZ/WCZ}   Wait for SE2 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE3              {WC/WZ/WCZ}   Wait for SE3 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE4              {WC/WZ/WCZ}   Wait for SE4 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITXFI              {WC/WZ/WCZ}   Wait for XFI event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITXMT              {WC/WZ/WCZ}   Wait for XMT event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITXRL              {WC/WZ/WCZ}   Wait for XRL event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITXRO              {WC/WZ/WCZ}   Wait for XRO event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nInterrupt Instructions\n\nClocks\n\nInstruction                                                            Description\n\nCog, LUT & Hub\n\nALLOWI                             Allow interrupts (default).                                                                                                   2\n\nIf in debug ISR, set next break condition to D. Else, set BRK code to D[7:0] and unconditionally trigger BRK\n\nBRK       {#}D                                                                                                                                                   2\n\ninterrupt, if enabled.\n\nIf in debug ISR, trigger asynchronous breakpoint in cog D[3:0]. Cog D[3:0] must have asynchronous breakpoint\n\nCOGBRK    {#}D                                                                                                                                                   2\n\nenabled.\n\nGETBRK    D            WC/WZ/WCZ   Get breakpoint/cog status into D according to WC/WZ/WCZ. See documentation for details.                                         2\n\nNIXINT1                            Cancel INT1.                                                                                                                    2\n\nNIXINT2                            Cancel INT2.                                                                                                                    2\n\nNIXINT3                            Cancel INT3.                                                                                                                    2\n\nSETINT1 {#}D                       Set INT1 source to D[3:0].                                                                                                      2\n\nSETINT2 {#}D                       Set INT2 source to D[3:0].                                                                                                      2\n\nSETINT3 {#}D                       Set INT3 source to D[3:0].                                                                                                      2\n\nSTALLI                             Stall Interrupts.                                                                                                               2\n\nTRGINT1                            Trigger INT1, regardless of STALLI mode.                                                                                        2\n\nTRGINT2                            Trigger INT2, regardless of STALLI mode.                                                                                        2\n\nTRGINT3                            Trigger INT3, regardless of STALLI mode.                                                                                        2\n\nRegister Indirection Instructions\n\nClocks\n\nInstruction                                                         Description\n\nCog & LUT / Hub\n\nALTB      D,{#}S                   Alter D \ufb01eld of next instruction to D[13:5].                                                                                    2\n\nALTB      D,{#}S                   Alter D \ufb01eld of next instruction to (D[13:5] + S) & $1FF. D += sign-extended S[17:9].                                           2\n\nALTD      D                        Alter D \ufb01eld of next instruction to D[8:0].                                                                                     2\n\nALTD      D,{#}S                   Alter D \ufb01eld of next instruction to (D + S) & $1FF. D += sign-extended S[17:9].                                                 2\n\nALTGB     D                        Alter subsequent GETBYTE/ROLBYTE instruction. Next S \ufb01eld = D[10:2], N \ufb01eld = D[1:0].                                           2\n\nAlter subsequent GETBYTE/ROLBYTE instruction. Next S \ufb01eld = (D[10:2] + S) & $1FF, N \ufb01eld = D[1:0]. D +=\n\nALTGB     D,{#}S                                                                                                                                                   2\n\nsign-extended S[17:9].\n\nALTGN     D                        Alter subsequent GETNIB/ROLNIB instruction. Next S \ufb01eld = D[11:3], N \ufb01eld = D[2:0].                                             2\n\nAlter subsequent GETNIB/ROLNIB instruction. Next S \ufb01eld = (D[11:3] + S) & $1FF, N \ufb01eld = D[2:0]. D +=\n\nALTGN     D,{#}S                                                                                                                                                   2\n\nsign-extended S[17:9].\n\nALTGW     D                        Alter subsequent GETWORD/ROLWORD instruction. Next S \ufb01eld = D[9:1], N \ufb01eld = D[0].                                              2\n\nAlter subsequent GETWORD/ROLWORD instruction. Next S \ufb01eld = ((D[9:1] + S) & $1FF), N \ufb01eld = D[0]. D +=\n\nALTGW     D,{#}S                                                                                                                                                   2\n\nsign-extended S[17:9].\n\nALTI      D                        Execute D in place of next instruction. D stays same.                                                                           2\n\nALTI      D,{#}S                   Substitute next instruction's I/R/D/S \ufb01elds with \ufb01elds from D, per S. Modify D per S.                                           2\n\nALTR      D                        Alter result register address (normally D \ufb01eld) of next instruction to D[8:0].                                                  2\n\nALTR      D,{#}S                   Alter result register address (normally D \ufb01eld) of next instruction to (D + S) & $1FF. D += sign-extended S[17:9].              2\n\nALTS      D                        Alter S \ufb01eld of next instruction to D[8:0].                                                                                     2\n\nALTS      D,{#}S                   Alter S \ufb01eld of next instruction to (D + S) & $1FF. D += sign-extended S[17:9].                                                 2\n\nALTSB     D                        Alter subsequent SETBYTE instruction. Next D \ufb01eld = D[10:2], N \ufb01eld = D[1:0].                                                   2\n\nAlter subsequent SETBYTE instruction. Next D \ufb01eld = (D[10:2] + S) & $1FF, N \ufb01eld = D[1:0]. D += sign-extended\n\nALTSB     D,{#}S                                                                                                                                                   2\n\nS[17:9].\n\nALTSN     D                        Alter subsequent SETNIB instruction. Next D \ufb01eld = D[11:3], N \ufb01eld = D[2:0].                                                    2\n\nAlter subsequent SETNIB instruction. Next D \ufb01eld = (D[11:3] + S) & $1FF, N \ufb01eld = D[2:0]. D += sign-extended\n\nALTSN     D,{#}S                                                                                                                                                   2\n\nS[17:9].\n\nALTSW     D                        Alter subsequent SETWORD instruction. Next D \ufb01eld = D[9:1], N \ufb01eld = D[0].                                                      2\n\nAlter subsequent SETWORD instruction. Next D \ufb01eld = (D[9:1] + S) & $1FF, N \ufb01eld = D[0]. D += sign-extended\n\nALTSW     D,{#}S                                                                                                                                                   2\n\nS[17:9].\n\nCORDIC Solver Instructions\n\nClocks\n\nInstruction                                                          Description\n\nCog, LUT & Hub\n\nGETQX       D           {WC/WZ/WCZ}   Retrieve CORDIC result X into D. Waits, in case result not ready. C = X[31]. 1                                           2...58\n\n1\n\nGETQY       D           {WC/WZ/WCZ}   Retrieve CORDIC result Y into D. Waits, in case result not ready. C = Y[31].                                             2...58\n\nQDIV        {#}D,{#}S                 Begin CORDIC unsigned division of {SETQ value or 32'b0, D} / S. GETQX/GETQY retrieves quotient/remainder.                2...9\n\nQEXP        {#}D                      Begin CORDIC logarithm-to-number conversion of D. GETQX retrieves number.                                                2...9\n\nQFRAC       {#}D,{#}S                 Begin CORDIC unsigned division of {D, SETQ value or 32'b0} / S. GETQX/GETQY retrieves quotient/remainder.                2...9\n\nBegin CORDIC number-to-logarithm conversion of D. GETQX retrieves log {5'whole_exponent,\n\nQLOG        {#}D                                                                                                                                               2...9\n\n27'fractional_exponent}.\n\nQMUL        {#}D,{#}S                 Begin CORDIC unsigned multiplication of D * S. GETQX/GETQY retrieves lower/upper product.                                2...9\n\nQROTATE {#}D,{#}S                     Begin CORDIC rotation of point (D, SETQ value or 32'b0) by angle S. GETQX/GETQY retrieves X/Y.                           2...9\n\nQSQRT       {#}D,{#}S                 Begin CORDIC square root of {S, D}. GETQX retrieves root.                                                                2...9\n\nQVECTOR {#}D,{#}S                     Begin CORDIC vectoring of point (D, S). GETQX/GETQY retrieves length/angle.                                              2...9\n\n1\n\nZ = (result == 0)\n\nColor Space Converter and Pixel Mixer Instructions\n\nClocks\n\nInstruction                                                          Description\n\nCog, LUT & Hub\n\nColor Space Converter\n\nSETCFRQ {#}D                          Set the colorspace converter \"CFRQ\" parameter to D[31:0].                                                                    2\n\nSETCI       {#}D                      Set the colorspace converter \"CI\" parameter to D[31:0].                                                                      2\n\nSETCMOD {#}D                          Set the colorspace converter \"CMOD\" parameter to D[8:0].                                                                     2\n\nSETCQ       {#}D                      Set the colorspace converter \"CQ\" parameter to D[31:0].                                                                      2\n\nSETCY       {#}D                      Set the colorspace converter \"CY\" parameter to D[31:0].                                                                      2\n\nPixel Mixer\n\nADDPIX      D,{#}S                    Add bytes of S into bytes of D, with $FF saturation.                                                                         7\n\nBLNPIX      D,{#}S                    Alpha-blend bytes of S into bytes of D, using SETPIV value.                                                                  7\n\nMIXPIX      D,{#}S                    Mix bytes of S into bytes of D, using SETPIX and SETPIV values.                                                              7\n\nMULPIX      D,{#}S                    Multiply bytes of S into bytes of D, where $FF = 1.0 and $00 = 0.0.                                                          7\n\nSETPIV      {#}D                      Set BLNPIX/MIXPIX blend factor to D[7:0].                                                                                    2\n\nSETPIX      {#}D                      Set MIXPIX mode to D[5:0].                                                                                                   2\n\nLookup Table, Streamer, and Misc Instructions\n\nClocks\n\nInstruction                                                          Description\n\nCog & LUT / Hub\n\nLookup Table\n\nRDLUT       D,{#}S/P {WC/WZ/WCZ}      Read data from LUT address {#}S/PTRx into D. C = MSB of data. *                                                              3\n\nIf D[0] = 1 then enable LUT sharing, where LUT writes within the adjacent odd/even companion cog are copied\n\nSETLUTS {#}D                                                                                                                                                       2\n\nto this cog's LUT.\n\nWRLUT       {#}D,{#}S/P               Write D to LUT address {#}S/PTRx.                                                                                            2\n\nStreamer\n\nGet the streamer's Goertzel X accumulator into D and the Y accumulator into the next instruction's S, clear\n\nGETXACC D                                                                                                                                                          2\n\naccumulators.\n\nSETXFRQ {#}D                          Set streamer NCO frequency to D.                                                                                             2\n\nXCONT       {#}D,{#}S                 Bu er new streamer command to be issued on \ufb01nal NCO rollover of current command, continuing phase.                           2+\n\nXINIT    {#}D,{#}S                 Issue streamer command immediately, zeroing phase.                                                                          2\n\nXSTOP                              Stop streamer immediately.                                                                                                  2\n\nXZERO    {#}D,{#}S                 Bu er new streamer command to be issued on \ufb01nal NCO rollover of current command, zeroing phase.                             2+\n\nMiscellaneous\n\nQueue #n to be used as upper 23 bits for next #D occurrence, so that the next 9-bit #D will be augmented to 32\n\nAUGD     #n                                                                                                                                                    2\n\nbits.\n\nQueue #n to be used as upper 23 bits for next #S occurrence, so that the next 9-bit #S will be augmented to 32\n\nAUGS     #n                                                                                                                                                    2\n\nbits.\n\nGet CT[31:0] or CT[63:32] if WC into D. GETCT WC + GETCT gets full CT. CT=0 on reset, CT++ on every clock. C =\n\nGETCT    D                 {WC}                                                                                                                                2\n\nsame.\n\nGETRND                WC/WZ/WCZ    Get RND into C/Z. C = RND[31], Z = RND[30], unique per cog.                                                                 2\n\nGet RND into D/C/Z. RND is the PRNG that updates on every clock. D = RND[31:0], C = RND[31], Z = RND[30],\n\nGETRND   D           {WC/WZ/WCZ}                                                                                                                               2\n\nunique per cog.\n\nNOP                                No operation.                                                                                                               2\n\nPOP      D          {WC/WZ/WCZ}    Pop stack (K). D = K. C = K[31]. *                                                                                          2\n\nPUSH     {#}D                      Push D onto stack.                                                                                                          2\n\nSet Q to D. Use before RDLONG/WRLONG/WMLONG to set block transfer. Also used before\n\nSETQ     {#}D                                                                                                                                                  2\n\nMUXQ/COGINIT/QDIV/QFRAC/QROTATE/WAITxxx.\n\nSETQ2    {#}D                      Set Q to D. Use before RDLONG/WRLONG/WMLONG to set LUT block transfer.                                                      2\n\nWAITX    {#}D       {WC/WZ/WCZ}    Wait 2 + D clocks if no WC/WZ/WCZ. If WC/WZ/WCZ, wait 2 + (D & RND) clocks. C/Z = 0.                                    2+D\n\nPROPELLER 2 RESERVED WORDS (SPIN2 + PASM2)\n\nPrede\ufb01ned symbols recognized by the compiler to have special meaning.\n\n_ (leading underscore)\n\n_C              _C_NE_Z             _E              _LT                   _NC_OR_NZ        _NZ_AND_C         _RET_              _Z_AND_NC           _Z_OR_NC\n\n_C_AND_NZ       _C_OR_NZ            _GE             _NC                   _NC_OR_Z         _NZ_AND_NC        _SET               _Z_EQ_C\n\n_C_AND_Z        _C_OR_Z             _GT             _NC_AND_NZ            _NE              _NZ_OR_C          _Z                 _Z_NE_C\n\n_C_EQ_Z         _CLR                _LE             _NC_AND_Z             _NZ              _NZ_OR_NC         _Z_AND_C           _Z_OR_C\n\nA-B\n\nABORT       ADDCT2         ADDSX          ALLOWI        ALTGN       ALTSB        ANDN          AUGS           BITMAP        BITZ         BOX           BYTES_1BIT\n\nABS         ADDCT3         ADDX           ALT           ALTGW       ALTSN        ANDZ          BACKCOLOR      BITNC         BLACK        BRK           BYTES_2BIT\n\nADD         ADDPINS        AKPIN          ALTB          ALTI        ALTSW        ARCHIVE       BITC           BITNOT        BLNPIX       BYTE          BYTES_4BIT\n\nADDBITS     ADDPIX         ALIGNL         ALTD          ALTR        AND          ASMCLK        BITH           BITNZ         BLUE         BYTEFILL\n\nADDCT1      ADDS           ALIGNW         ALTGB         ALTS        ANDC         AUGD          BITL           BITRND        BMASK        BYTEMOVE\n\nC-D\n\nCALL          CIRCLE         CMPSUB                   COGINIT         DEBUG_BAUD                    DEBUG_TOP                 DIRH        DJZ           DRVRND\n\nCALLA         CLEAR          CMPSX                    COGSPIN         DEBUG_COGS                    DEBUG_WIDTH               DIRL        DLY           DRVZ\n\nCALLB         CLKFREQ        CMPX                     COGSTOP         DEBUG_DELAY                   DEBUG_WINDOWS_OFF         DIRNC       DOT\n\nCALLD         CLKMODE        COGATN                   COLOR           DEBUG_DISPLAY_LEFT            DECMOD                    DIRNOT      DOTSIZE\n\nCALLPA        CLKSET         COGBRK                   CON             DEBUG_DISPLAY_TOP             DECOD                     DIRNZ       DRVC\n\nCALLPB        CLOSE          COGCHK                   CRCBIT          DEBUG_HEIGHT                  DEPTH                     DIRRND      DRVH\n\nCARTESIAN     CMP            COGEXEC                  CRCNIB          DEBUG_LEFT                    DEV                       DIRZ        DRVL\n\nCASE          CMPM           COGEXEC_NEW              CYAN            DEBUG_LOG_SIZE                DIRA                      DJF         DRVNC\n\nCASE_FAST     CMPR           COGEXEC_NEW_PAIR         DAT             DEBUG_PIN                     DIRB                      DJNF        DRVNOT\n\nCHANNEL       CMPS           COGID                    DEBUG           DEBUG_TIMESTAMP               DIRC                      DJNZ\n\nE-F\n\nELSE        EVENT_ATN      EVENT_INT      EVENT_SE3     EVENT_XRO         FDEC               FDEC_REG_ARRAY_        FIT         FLTH          FLTRND     FVAR\n\nELSEIF      EVENT_CT1      EVENT_PAT      EVENT_SE4     EXECF             FDEC_              FFT                    FLE         FLTL          FLTZ       FVARS\n\nELSEIFNOT   EVENT_CT2      EVENT_QMT      EVENT_XFI     FABS              FDEC_ARRAY         FGE                    FLES        FLTNC         FRAC\n\nENCOD       EVENT_CT3      EVENT_SE1      EVENT_XMT     FALSE             FDEC_ARRAY_        FGES                   FLOAT       FLTNOT        FROM\n\nEND         EVENT_FBW      EVENT_SE2      EVENT_XRL     FBLOCK            FDEC_REG_ARRAY     FILE                   FLTC        FLTNZ         FSQRT\n\nG-H\n\nGETBRK        GETMS          GETQX           GETRND             GETWORD          GREY          HSV16              HSV8          HUBEXEC                 HUBSET\n\nGETBYTE       GETNIB         GETQY           GETSCP             GETXACC          HIDEXY        HSV16W             HSV8W         HUBEXEC_NEW\n\nGETCT         GETPTR         GETREGS         GETSEC             GREEN            HOLDOFF       HSV16X             HSV8X         HUBEXEC_NEW_PAIR\n\nI-J\n\nIF          IF_10           IF_AE             IF_E                 IF_NOT_01          IF_Z_AND_C         INA               JINT          JNSE2          JSE4\n\nIF_00       IF_1000         IF_ALWAYS         IF_GE                IF_NOT_10          IF_Z_AND_NC        INB               JMP           JNSE3          JXFI\n\nIF_0000     IF_1001         IF_B              IF_GT                IF_NOT_11          IF_Z_EQ_C          INCMOD            JMPREL        JNSE4          JXMT\n\nIF_0001     IF_1010         IF_BE             IF_LE                IF_NZ              IF_Z_NE_C          INT_OFF           JNATN         JNXFI          JXRL\n\nIF_0010     IF_1011         IF_C              IF_LT                IF_NZ_AND_C        IF_Z_OR_C          IRET1             JNCT1         JNXMT          JXRO\n\nIF_0011     IF_11           IF_C_AND_NZ       IF_NC                IF_NZ_AND_NC       IF_Z_OR_NC         IRET2             JNCT2         JNXRL\n\nIF_01       IF_1100         IF_C_AND_Z        IF_NC_AND_NZ         IF_NZ_OR_C         IFNOT              IRET3             JNCT3         JNXRO\n\nIF_0100     IF_1101         IF_C_EQ_Z         IF_NC_AND_Z          IF_NZ_OR_NC        IJMP1              JATN              JNFBW         JPAT\n\nIF_0101     IF_1110         IF_C_NE_Z         IF_NC_OR_NZ          IF_SAME            IJMP2              JCT1              JNINT         JQMT\n\nIF_0110     IF_1111         IF_C_OR_NZ        IF_NC_OR_Z           IF_X0              IJMP3              JCT2              JNPAT         JSE1\n\nIF_0111     IF_1X           IF_C_OR_Z         IF_NE                IF_X1              IJNZ               JCT3              JNQMT         JSE2\n\nIF_0X       IF_A            IF_DIFF           IF_NOT_00            IF_Z               IJZ                JFBW              JNSE1         JSE3\n\nL-M\n\nLINE         LOCKREL       LONG            LONGS_2BIT      LOOKUP          LUMA8W       LUT8             MERGEW           MODZ           MULPIX         MUXNITS\n\nLINESIZE     LOCKRET       LONGFILL        LONGS_4BIT      LOOKUPZ         LUMA8X       LUTCOLORS        MIDI             MOV            MULS           MUXNZ\n\nLOC          LOCKTRY       LONGMOVE        LONGS_8BIT      LSTR            LUT1         MAG              MIXPIX           MOVBYTS        MUXC           MUXQ\n\nLOCKCHK      LOGIC         LONGS_16BIT     LOOKDOWN        LSTR_           LUT2         MAGENTA          MODC             MUL            MUXNC          MUXZ\n\nLOCKNEW      LOGSCALE      LONGS_1BIT      LOOKDOWNZ       LUMA8           LUT4         MERGEB           MODCZ            MULDIV64       MUXNIBS\n\nN-O\n\nNAN          NEGNZ          NEXT             NOP                ONES             ORC                ORIGIN          OUTB             OUTNC             OUTZ\n\nNEG          NEGX           NIXINT1          NOT                OPACITY          ORG                ORZ             OUTC             OUTNOT            OVAL\n\nNEGC         NEGZ           NIXINT2          OBJ                OR               ORGF               OTHER           OUTH             OUTNZ\n\nNEGNC        NEWCOG         NIXINT3          OBOX               ORANGE           ORGH               OUTA            OUTL             OUTRND\n\nP\n\nP_ADC              P_COUNT_RISES         P_HIGH_1K5          P_LOW_10UA    P_PASS_AB           P_STATE_TICKS     PI             POLLCT2   PR0\n\nP_ADC_100X         P_COUNTER_HIGHS       P_HIGH_1MA          P_LOW_150K    P_PERIODS_HIGHS     P_SYNC_IO         PINCLEAR       POLLCT3   PR1\n\nP_ADC_10X          P_COUNTER_PERIODS     P_HIGH_FAST         P_LOW_15K     P_PERIODS_TICKS     P_SYNC_RX         PINF           POLLFBW   PR2\n\nP_ADC_1X           P_COUNTER_TICKS       P_HIGH_FLOAT        P_LOW_1K5     P_PLUS1_A           P_SYNC_TX         PINFLOAT       POLLINT   PR3\n\nP_ADC_30X          P_DAC_124R_3V         P_HIGH_TICKS        P_LOW_1MA     P_PLUS1_B           P_TRANSITION      PINH           POLLPAT   PR4\n\nP_ADC_3X           P_DAC_600R_2V         P_INVERT_A          P_LOW_FAST    P_PLUS2_A           P_TRUE_A          PINHIGH        POLLQMT   PR5\n\nP_ADC_EXT          P_DAC_75R_2V          P_INVERT_B          P_LOW_FLOAT   P_PLUS2_B           P_TRUE_B          PINL           POLLSE1   PR6\n\nP_ADC_FLOAT        P_DAC_990R_3V         P_INVERT_IN         P_MINUS1_A    P_PLUS3_A           P_TRUE_IN         PINLOW         POLLSE2   PR7\n\nP_ADC_GIO          P_DAC_DITHER_PWM      P_INVERT_OUT        P_MINUS1_B    P_PLUS3_B           P_TRUE_OUT        PINR           POLLSE3   PRECISE\n\nP_ADC_SCOPE        P_DAC_DITHER_RND      P_INVERT_OUTPUT     P_MINUS2_A    P_PULSE             P_TRUE_OUTPUT     PINREAD        POLLSE4   PRECOMPILE\n\nP_ADC_VIO          P_DAC_NOISE           P_LEVEL_A           P_MINUS2_B    P_PWM_SAWTOOTH      P_TT_00           PINSTART       POLLXFI   PRI\n\nP_AND_AB           P_EVENTS_TICKS        P_LEVEL_A_FBN       P_MINUS3_A    P_PWM_SMPS          P_TT_01           PINT           POLLXMT   PTRA\n\nP_ASYNC_IO         P_FILT0_AB            P_LEVEL_B_FBN       P_MINUS3_B    P_PWM_TRIANGLE      P_TT_10           PINTOGGLE      POLLXRL   PTRB\n\nP_ASYNC_RX         P_FILT1_AB            P_LEVEL_B_FBP       P_NCO_DUTY    P_QUADRATURE        P_TT_11           PINW           POLLXRO   PUB\n\nP_ASYNC_TX         P_FILT2_AB            P_LOCAL_A           P_NCO_FREQ    P_REG_UP            P_USB_PAIR        PINWRITE       POLXY     PUSH\n\nP_BITDAC           P_FILT3_AB            P_LOCAL_B           P_NORMAL      P_REG_UP_DOWN       P_XOR_AB          PLOT           POP       PUSHA\n\nP_CHANNEL          P_HIGH_100UA          P_LOGIC_A           P_OE          P_REPOSITORY        PA                POLAR          POPA      PUSHB\n\nP_COMPARE_AB       P_HIGH_10UA           P_LOGIC_A_FB        P_OR_AB       P_SCHMITT_A         PB                POLLATN        POPB\n\nP_COMPARE_AB_FB    P_HIGH_150K           P_LOGIC_B_FB        P_OUTBIT_A    P_SCHMITT_A_FB      PC_KEY            POLLCT         POS\n\nP_COUNT_HIGHS      P_HIGH_15K            P_LOW_100UA         P_OUTBIT_B    P_SCHMITT_B_FB      PC_MOUSE          POLLCT1        POSX\n\nQ-R\n\nQCOS        QROTATE         RATE           RDFAST          RED         RES           RETA        RETURN         RFWORD         RGBI8W     ROLWORD\n\nQDIV        QSIN            RCL            RDLONG          REG         RESI0         RETB        REV            RGB16          RGBI8X     ROR\n\nQEXP        QSQRT           RCR            RDLUT           REGEXEC     RESI1         RETI0       RFBYTE         RGB24          RGBSQZ     ROTXY\n\nQFRAC       QUIT            RCZL           RDPIN           REGLOAD     RESI2         RETI1       RFLONG         RGB8           ROL        ROUND\n\nQLOG        QVECTOR         RCZR           RDWORD          REP         RESI3         RETI2       RFVAR          RGBEXP         ROLBYTE    RQPIN\n\nQMUL        RANGE           RDBYTE         RECV            REPEAT      RET           RETI3       RFVARS         RGBI8          ROLNIB\n\nS-T\n\nSAL                   SBIN_WORD_ARRAY_     SDEC_WORD             SETNIB           SHEX                    SIGNED             SUBR          TEXTSTYLE\n\nSAMPLES               SCA                  SDEC_WORD_            SETPAT           SHEX_                   SIGNX              SUBS          TITLE\n\nSAR                   SCAS                 SDEC_WORD_ARRAY       SETPIV           SHEX_BYTE               SIZE               SUBSX         TJF\n\nSAVE                  SCOPE                SDEC_WORD_ARRAY_      SETPIX           SHEX_BYTE_              SKIP               SUBX          TJNF\n\nSBIN                  SCOPE_XY             SEND                  SETQ             SHEX_BYTE_ARRAY         SKIPF              SUMC          TJNS\n\nSBIN_                 SCROLL               SET                   SETQ2            SHEX_BYTE_ARRAY_        SPACING            SUMNC         TJNZ\n\nSBIN_BYTE_            SDEC                 SETBYTE               SETR             SHEX_LONG               SPECTRO            SUMNZ         TJS\n\nSBIN_BYTE_ARRAY       SDEC_                SETCFRQ               SETREGS          SHEX_LONG_              SPLITB             SUMZ          TJV\n\nSBIN_BYTE_ARRAY_      SDEC_BYTE            SETCI                 SETS             SHEX_LONG_ARRAY         SPLITW             TERM          TJZ\n\nSBIN_LONG             SDEC_BYTE_           SETCMOD               SETSCP           SHEX_LONG_ARRAY_        SPRITE             TEST          TO\n\nSBIN_LONG_            SDEC_BYTE_ARRAY      SETCQ                 SETSE1           SHEX_REG_ARRAY          SPRITEDEF          TESTB         TRACE\n\nSBIN_LONG_ARRAY       SDEC_BYTE_ARRAY_     SETCY                 SETSE2           SHEX_REG_ARRAY_         SQRT               TESTBN        TRGINT1\n\nSBIN_LONG_ARRAY_      SDEC_LONG            SETD                  SETSE3           SHEX_WORD               STALLI             TESTN         TRGINT2\n\nSBIN_REG_ARRAY        SDEC_LONG_           SETDACS               SETSE4           SHEX_WORD_              STEP               TESTP         TRGINT3\n\nSBIN_REG_ARRAY_       SDEC_LONG_ARRAY      SETINT1               SETWORD          SHEX_WORD_ARRAY         STRCOMP            TESTPN        TRIGGER\n\nSBIN_WORD             SDEC_LONG_ARRAY_     SETINT2               SETXFRQ          SHEX_WORD_ARRAY_        STRING             TEXT          TRUE\n\nSBIN_WORD_            SDEC_REG_ARRAY       SETINT3               SEUSSF           SHL                     STRSIZE            TEXTANGLE     TRUNC\n\nSBIN_WORD_ARRAY       SDEC_REG_ARRAY_      SETLUTS               SEUSSR           SHR                     SUB                TEXTSIZE\n\nU, V, W\n\nUBIN                    UBIN_WORD_ARRAY_         UDEC_WORD_ARRAY            UHEX_WORD_               WAITPAT             WFWORD           WRLONG\n\nUBIN_                   UDEC                     UDEC_WORD_ARRAY_           UHEX_WORD_ARRAY          WAITSE1             WHILE            WRLUT\n\nUBIN_BYTE               UDEC_                    UHEX                       UHEX_WORD_ARRAY_         WAITSE2             WHITE            WRNC\n\nUBIN_BYTE_              UDEC_BYTE                UHEX_                      UNTIL                    WAITSE3             WINDOW           WRNZ\n\nUBIN_BYTE_ARRAY         UDEC_BYTE_               UHEX_BYTE                  UPDATE                   WAITSE4             WMLONG           WRPIN\n\nUBIN_BYTE_ARRAY_        UDEC_BYTE_ARRAY          UHEX_BYTE_                 VAR                      WAITUS              WORD             WRWORD\n\nUBIN_LONG               UDEC_BYTE_ARRAY_         UHEX_BYTE_ARRAY            VARBASE                  WAITX               WORDFILL         WRZ\n\nUBIN_LONG_              UDEC_LONG                UHEX_BYTE_ARRAY_           WAITATN                  WAITXFI             WORDMOVE         WXPIN\n\nUBIN_LONG_ARRAY         UDEC_LONG_               UHEX_LONG                  WAITCT                   WAITXMT             WORDS_1BIT       WYPIN\n\nUBIN_LONG_ARRAY_        UDEC_LONG_ARRAY          UHEX_LONG_                 WAITCT1                  WAITXRL             WORDS_2BIT       WZ\n\nUBIN_REG_ARRAY          UDEC_LONG_ARRAY_         UHEX_LONG_ARRAY            WAITCT2                  WAITXRO             WORDS_4BIT\n\nUBIN_REG_ARRAY_         UDEC_REG_ARRAY           UHEX_LONG_ARRAY_           WAITCT3                  WC                  WORDS_8BIT\n\nUBIN_WORD               UDEC_REG_ARRAY_          UHEX_REG_ARRAY             WAITFBW                  WCZ                 WRBYTE\n\nUBIN_WORD_              UDEC_WORD                UHEX_REG_ARRAY_            WAITINT                  WFBYTE              WRC\n\nUBIN_WORD_ARRAY         UDEC_WORD_               UHEX_WORD                  WAITMS                   WFLONG              WRFAST\n\nX, Y, Z\n\nX_16P_2DAC8_WFWORD             X_8P_4DAC2_WFBYTE           X_DACS_X_X_0N0            X_IMM_4X8_LUT              X_RFBYTE_LUMA8            XOR\n\nX_16P_4DAC4_WFWORD             X_ALT_OFF                   X_DACS_X_X_1_0            X_IMM_8X4_1DAC4            X_RFBYTE_RGB8             XORC\n\nX_1ADC8_0P_1DAC8_WFBYTE        X_ALT_ON                    X_DACS_X_X_X_0            X_IMM_8X4_2DAC2            X_RFBYTE_RGBI8            XORO32\n\nX_1ADC8_8P_2DAC8_WFWORD        X_DACS_0_0_0_0              X_DDS_GOERTZEL_SINC1      X_IMM_8X4_4DAC1            X_RFLONG_16X2_LUT         XORZ\n\nX_1P_1DAC1_WFBYTE              X_DACS_0_0_X_X              X_DDS_GOERTZEL_SINC2      X_IMM_8X4_LUT              X_RFLONG_32P_4DAC8        XSTOP\n\nX_2ADC8_0P_2DAC8_WFWORD        X_DACS_0_X_X_X              X_IMM_16X2_1DAC2          X_PINS_OFF                 X_RFLONG_32X1_LUT         XYPOL\n\nX_2ADC8_16P_4DAC8_WFLONG       X_DACS_0N0_0N0              X_IMM_16X2_2DAC1          X_PINS_ON                  X_RFLONG_4X8_LUT          XZERO\n\nX_2P_1DAC2_WFBYTE              X_DACS_0N0_X_X              X_IMM_16X2_LUT            X_RFBYTE_1P_1DAC1          X_RFLONG_8X4_LUT          YELLOW\n\nX_2P_2DAC1_WFBYTE              X_DACS_1_0_1_0              X_IMM_1X32_4DAC8          X_RFBYTE_2P_1DAC2          X_RFLONG_RGB24            ZEROX\n\nX_32P_4DAC8_WFLONG             X_DACS_1_0_X_X              X_IMM_2X16_2DAC8          X_RFBYTE_2P_2DAC1          X_RFWORD_16P_2DAC8        ZSTR\n\nX_4ADC8_0P_4DAC8_WFLONG        X_DACS_1N1_0N0              X_IMM_2X16_4DAC4          X_RFBYTE_4P_1DAC4          X_RFWORD_16P_4DAC4        ZSTR_\n\nX_4P_1DAC4_WFBYTE              X_DACS_3_2_1_0              X_IMM_32X1_1DAC1          X_RFBYTE_4P_2DAC2          X_RFWORD_RGB16\n\nX_4P_2DAC2_WFBYTE              X_DACS_OFF                  X_IMM_32X1_LUT            X_RFBYTE_4P_4DAC1          X_WRITE_OFF\n\nX_4P_4DAC1_WFBYTE              X_DACS_X_0_X_X              X_IMM_4X8_1DAC8           X_RFBYTE_8P_1DAC8          X_WRITE_ON\n\nX_8P_1DAC8_WFBYTE              X_DACS_X_X_0_0              X_IMM_4X8_2DAC4           X_RFBYTE_8P_2DAC4          XCONT\n\nX_8P_2DAC4_WFBYTE              X_DACS_X_X_0_X              X_IMM_4X8_4DAC2           X_RFBYTE_8P_4DAC2          XINIT\n\nCHANGE LOG\n\nDate       Notes\n\n11/11/2021    Live draft workspace published.\n\n11/02/2022    Official release.\n\nPARALLAX INCORPORATED\n\nParallax Inc.                  O\ufb03ce: +1 916-624-8333           sales@parallax.com         www.parallax.com/p2\n\n599 Menlo Drive, Suite 100     Toll Free US: 888-512-1024      support@parallax.com       forums.parallax.com\n\nRocklin, CA 95765\n\nUSA\n\nPurchase of the P2X8C4M64P does not include any license to emulate any other device nor to communicate\n\nvia any speci\ufb01c proprietary protocol; P2X8C4M64P connectivity objects and code examples provided or\n\nreferenced by Parallax, Inc. are NOT licensed and are provided for research and development purposes only;\n\nend users must seek permission to use licensed protocols for their applications and products from the protocol\n\nlicense holders.\n\nParallax, Inc. makes no warranty, representation or guarantee regarding the suitability of its products\n\nfor any particular purpose, nor does Parallax, Inc. assume any liability arising out of the application or\n\nuse of any product, and speci\ufb01cally disclaims any and all liability, including without limitation consequential\n\nor incidental damages even if Parallax, Inc. has been advised of the possibility of such damages.\n\nare trademarks of Parallax, Inc.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to zero-extend above bit Src[4:0] and is where the result is written.",
              "Src is a register or 9-bit literal whose value (lower 5 bits) identi\ufb01es the bit of Dest to zero-extend beyond.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SIGNX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force unsigned value to be greater than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force unsigned value to be greater than or equal to another.",
        "instructions": {
          "FGE": {
            "mnemonic": "FGE",
            "syntax": "FGE Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0011000 CZI DDDDDDDDD SSSSSSSSS                    D           limit enforced        Result = 0              2",
            "description": "FGE sets unsigned Dest to unsigned Src if Dest is less than Src. This is also known as a limit minimum function; Result: Unsigned Dest is set to unsigned Src if Dest was less than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.\n\nFGE sets unsigned Dest to unsigned Src if Dest is less than Src. This is also known as a limit minimum function;\n\npreventing Dest from sinking below Src.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was limited (Dest was less than Src and now Dest is\n\nequal to Src), or is cleared (0) if not limited.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the unsigned value to limit to a minimum of unsigned Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose unsigned value is the lower limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "FLE",
              "FGES",
              "FLES"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Shift bits left, extending the LSB.": {
        "count": 1,
        "description": "Bit Operation Instruction - Shift bits left, extending the LSB.",
        "instructions": {
          "SAL": {
            "mnemonic": "SAL",
            "syntax": "SAL Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000111 CZI DDDDDDDDD SSSSSSSSS                            D      Last bit out   1",
            "description": "SAL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to that of the original Dest[0]. Result: The bits of Dest are shifted left by Src bits, extending Dest[0] into new rightmost bits.\n\nSAL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to that of the original Dest[0].\n\nSAL is the complement of SAR for bit streams but not for math operations\u2014 use SHL instead for swift 32-bit\n\ninteger multiplication by a power-of-two.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out (effectively C =\n\nresult bit \"32\") if Src is 1\u201331, or to Dest[31] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to arithmetically left shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to arithmetically shift left.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Lookup Table": {
        "count": 3,
        "description": "Lookup Table",
        "instructions": {
          "WRLUT": {
            "mnemonic": "WRLUT",
            "syntax": "WRLUT   {#}D,{#}S/P",
            "encoding": "EEEE 1100001 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Write D to LUT address {#}S/PTRx.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 16
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_lsp",
                "pattern": "D/#,S/#/PTRA/PTRB",
                "description": "Memory operation: destination/immediate, source/immediate/pointer",
                "valueType": 16
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RDLUT": {
            "mnemonic": "RDLUT",
            "syntax": "RDLUT   D,{#}S/P {WC/WZ/WCZ}",
            "encoding": "EEEE 1010101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "{WC/WZ/WCZ}      Read data from LUT address {#}S/PTRx into D. C = MSB of data. *",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "MSB of data"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 15
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETLUTS": {
            "mnemonic": "SETLUTS",
            "syntax": "SETLUTS {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110111",
            "description": "If D[0] = 1 then enable LUT sharing, where LUT writes within the adjacent odd/even companion cog are copied to this cog's LUT.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input/output according to C or !C.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to input/output according to C or !C.",
        "instructions": {
          "DIRC": {
            "mnemonic": "DIRC",
            "syntax": "DIRC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000010",
            "description": "DIRC or DIRNC alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the C Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to C or !C; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DIRNC": {
            "mnemonic": "DIRNC",
            "syntax": "DIRNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000011",
            "description": "DIRC or DIRNC alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the C Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to C or !C; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRZ",
              "DIRNZ",
              "DIRL",
              "DIRH",
              "DIRNOT",
              "DIRRND"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Test pin and either store, AND, OR, or XOR the result or inverse result into C/Z.": {
        "count": 1,
        "description": "I/O Pin Instruction - Test pin and either store, AND, OR, or XOR the result or inverse result into C/Z.",
        "instructions": {
          "TESTPN": {
            "mnemonic": "TESTPN",
            "syntax": "TESTPN  {#}D           WC/WZ",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111",
            "description": "TESTP or TESTPN reads the state (0/1) of the I/O pin designated by Dest, possibly inverts that result, and either Result: The state of the I/O pin described by Dest is read, possibly inverted, and either stored as-is, or bitwise ANDed, ORed, or XORed into C or Z. Z = C/Z XOR !IN[D[5:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR !IN[D[5:0]]",
                "when": "IN[D[5:0]]"
              }
            },
            "parameters": [
              "Dest is the register or 6-bit literal whose value identifies the I/O pin to test.",
              "WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C or Z flag."
            ],
            "related": [
              "TESTB",
              "TESTBN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 31
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_testp",
                "pattern": "D/#0..511 WC/ANDC/ORC/XORC | WZ/ANDZ/ORZ/XORZ",
                "description": "Test pin: destination/immediate pin number 0-511 with REQUIRED logic function",
                "valueType": 31
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch Repeat": {
        "count": 1,
        "description": "Branch Repeat",
        "instructions": {
          "REP": {
            "mnemonic": "REP",
            "syntax": "REP     {#}D,{#}S",
            "encoding": "EEEE 1100110 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Execute next D[8:0] instructions S times. If S = 0, repeat instructions in\ufb01nitely. If D[8:0] = 0, nothing repeats.",
            "timing": {
              "cycles": "2/2",
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 17
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_rep",
                "pattern": "@,S/# | D/#,S/#",
                "description": "Repeat block: (@,count) for block end or (count,repetitions)",
                "valueType": 17
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Add two unsigned extended values.": {
        "count": 1,
        "description": "Math Instruction - Add two unsigned extended values.",
        "instructions": {
          "ADDX": {
            "mnemonic": "ADDX",
            "syntax": "ADDX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001001 CZI DDDDDDDDD SSSSSSSSS                   D          carry of (D+S+C) Z AND (Result = 0)            2",
            "description": "ADDX sums the unsigned values of Dest and Src plus C together and stores the result into the Dest register. The Result: Sum of unsigned Src plus C and unsigned Dest is stored in Dest.\n\nADDX sums the unsigned values of Dest and Src plus C together and stores the result into the Dest register. The\n\nADDX instruction is used to perform unsigned multi-long (extended) addition, such as 64-bit addition.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the summation resulted in an unsigned carry, or is\n\ncleared (0) if no carry. Use WC or WCZ on preceding ADD and ADDX instructions for proper \ufb01nal C \ufb02ag. If C is set\n\nafter the last ADDX in a multi-long addition, it indicates unsigned over\ufb02ow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and the result of Dest + Src + C is\n\nzero, or it is cleared (0) if non-zero. Use WZ or WCZ on preceding ADD and ADDX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo add unsigned multi-long values, use ADD followed by one or more ADDX instructions as described in Adding\n\nTwo Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "carry of (D+S+C)",
              "Z": "(Result = 0)"
            },
            "parameters": [
              "Dest is a register containing the value to add Src pluc C to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADD",
              "ADDSX",
              "SUBX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one unsigned value from another (in reverse order to SUB).": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned value from another (in reverse order to SUB).",
        "instructions": {
          "SUBR": {
            "mnemonic": "SUBR",
            "syntax": "SUBR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010110 CZI DDDDDDDDD SSSSSSSSS                     D          borrow of (S - D)      Result = 0               2",
            "description": "SUBR subtracts the unsigned Dest from the unsigned Src and stores the result into the Dest register. This is the Result: Difference of unsigned Src and unsigned Dest is stored in Dest and optionally the C and Z flags are updated to the borrow and zero status.\n\nSUBR subtracts the unsigned Dest from the unsigned Src and stores the result into the Dest register. This is the\n\nreverse of the subtraction order of SUB.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the subtraction results in a 32-bit under\ufb02ow (unsigned\n\nborrow), or is cleared (0) if no borrow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest - Src is zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to subtract from Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted by Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SUB"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Increment value and jump if zero or not zero.": {
        "count": 2,
        "description": "Flow Control Instruction - Increment value and jump if zero or not zero.",
        "instructions": {
          "IJNZ": {
            "mnemonic": "IJNZ",
            "syntax": "IJNZ    D,{#}S",
            "encoding": "EEEE 1011100 01I DDDDDDDDD SSSSSSSSS",
            "description": "IJZ or IJNZ increments the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is incremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is incremented and tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "IJZ": {
            "mnemonic": "IJZ",
            "syntax": "IJZ     D,{#}S",
            "encoding": "EEEE 1011100 00I DDDDDDDDD SSSSSSSSS",
            "description": "IJZ or IJNZ increments the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is incremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is incremented and tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear selectable event 1, 2, 3, or 4 \ufb02ag.": {
        "count": 4,
        "description": "Event Monitor Instruction - Wait for and clear selectable event 1, 2, 3, or 4 \ufb02ag.",
        "instructions": {
          "WAITSE1": {
            "mnemonic": "WAITSE1",
            "syntax": "WAITSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010100 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010101 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010110 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010111 000100100                 \u2014          Timeout Abort       Timeout Abort              2+"
            ],
            "description": "Wait for SE1 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE1, WAITSE2, WAITSE3, or WAITSE4 waits for a selectable event to occur (unless the event \ufb02ag is already\n\nset), then clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITSEx can time-out if the selectable event doesn't occur soon enough; setting C and/or\n\nZ \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITSEx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "POLLSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "WAITSE4": {
            "mnemonic": "WAITSE4",
            "syntax": "WAITSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010100 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010101 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010110 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010111 000100100                 \u2014          Timeout Abort       Timeout Abort              2+"
            ],
            "description": "Wait for SE4 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE1, WAITSE2, WAITSE3, or WAITSE4 waits for a selectable event to occur (unless the event \ufb02ag is already\n\nset), then clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITSEx can time-out if the selectable event doesn't occur soon enough; setting C and/or\n\nZ \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITSEx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "POLLSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "WAITSE2": {
            "mnemonic": "WAITSE2",
            "syntax": "WAITSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010100 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010101 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010110 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010111 000100100                 \u2014          Timeout Abort       Timeout Abort              2+"
            ],
            "description": "Wait for SE2 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE1, WAITSE2, WAITSE3, or WAITSE4 waits for a selectable event to occur (unless the event \ufb02ag is already\n\nset), then clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITSEx can time-out if the selectable event doesn't occur soon enough; setting C and/or\n\nZ \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITSEx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "POLLSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "WAITSE3": {
            "mnemonic": "WAITSE3",
            "syntax": "WAITSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010100 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010101 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010110 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
              "EEEE 1101011 CZ0 000010111 000100100                 \u2014          Timeout Abort       Timeout Abort              2+"
            ],
            "description": "Wait for SE3 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITSE1, WAITSE2, WAITSE3, or WAITSE4 waits for a selectable event to occur (unless the event \ufb02ag is already\n\nset), then clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITSEx can time-out if the selectable event doesn't occur soon enough; setting C and/or\n\nZ \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITSEx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "POLLSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input/output according to Z or !Z.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to input/output according to Z or !Z.",
        "instructions": {
          "DIRZ": {
            "mnemonic": "DIRZ",
            "syntax": "DIRZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000100",
            "description": "DIRZ or DIRNZ alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the Z Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to Z or !Z; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DIRNZ": {
            "mnemonic": "DIRNZ",
            "syntax": "DIRNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000101",
            "description": "DIRZ or DIRNZ alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the Z Result: The I/O pin direction bit(s), described by Dest, are set to output/input according to Z or !Z; the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRNOT",
              "DIRRND",
              "DIRL",
              "DIRH"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Interrupt Instruction - Prevent further interrupts.": {
        "count": 1,
        "description": "Interrupt Instruction - Prevent further interrupts.",
        "instructions": {
          "STALLI": {
            "mnemonic": "STALLI",
            "syntax": "STALLI",
            "encoding": "EEEE 1101011 000 000100001 000100100                    \u2014                 \u2014                   \u2014                    2",
            "description": "STALLI disables interrupt branching. STALLI is the complement of the ALLOWI instruction\u2014 both are used to Result: All future interrupts are disallowed.\n\nSTALLI disables interrupt branching. STALLI is the complement of the ALLOWI instruction\u2014 both are used to\n\nprotect short, vital sections of main code from timing jitter or state loss caused by asynchronous interrupt\n\nhandling.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [
              "ALLOWI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub RAM - Write": {
        "count": 7,
        "description": "Hub RAM - Write",
        "instructions": {
          "PUSHA": {
            "mnemonic": "PUSHA",
            "syntax": "PUSHA   {#}D",
            "encoding": "EEEE 1100011 0L1 DDDDDDDDD 101100001",
            "description": "Write long in D[31:0] to hub address PTRA++.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "D is a register or 9-bit literal value to push onto the stack at PTRA",
              "PTRA is automatically incremented after the write"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 32
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pushpop",
                "pattern": "D/# | D",
                "description": "Push immediate/register or Pop to register (PUSHA/PUSHB/POPA/POPB)",
                "valueType": 32
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WMLONG_": {
            "mnemonic": "WMLONG_",
            "syntax": "WMLONG_ D,S/#/PTRA/PTRB",
            "encoding": "TBD",
            "description": "Write memory long (alternate form). Writes long data to hub memory with specific addressing mode.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "WMLONG_ D,S/#/PTRA/PTRB",
              "encoding": {
                "bits": 32,
                "opcode": 335,
                "effects": 0,
                "operandFormat": 15,
                "rawValue": 31055
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_dsp",
                "pattern": "D,S/#/PTRA/PTRB",
                "description": "Destination, source/immediate/pointer register",
                "valueType": 15
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          },
          "WRLONG": {
            "mnemonic": "WRLONG",
            "syntax": "WRLONG  {#}D,{#}S/P",
            "encoding": "EEEE 1100011 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Write long in D[31:0] to hub address {#}S/PTRx. Prior SETQ/SETQ2 invokes cog/LUT block transfer.              3...10 1 / 3...20",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "WRLONG D/#,S/#/PTRA/PTRB",
              "encoding": {
                "bits": 32,
                "opcode": 396,
                "effects": 0,
                "operandFormat": 16,
                "rawValue": 33164
              },
              "category": "Memory and I/O",
              "effects": [],
              "operand_format": {
                "name": "operand_lsp",
                "pattern": "D/#,S/#/PTRA/PTRB",
                "description": "Memory operation: destination/immediate, source/immediate/pointer",
                "valueType": 16
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WRWORD": {
            "mnemonic": "WRWORD",
            "syntax": "WRWORD  {#}D,{#}S/P",
            "encoding": "EEEE 1100010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Write word in D[15:0] to hub address {#}S/PTRx.                                                               3...10 1 / 3...20",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 16
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_lsp",
                "pattern": "D/#,S/#/PTRA/PTRB",
                "description": "Memory operation: destination/immediate, source/immediate/pointer",
                "valueType": 16
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WRBYTE": {
            "mnemonic": "WRBYTE",
            "syntax": "WRBYTE  {#}D,{#}S/P",
            "encoding": "EEEE 1100010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Write byte in D[7:0] to hub address {#}S/PTRx.",
            "timing": {
              "cycles": 3,
              "type": "variable",
              "range": "3...10 / 3...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 16
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_lsp",
                "pattern": "D/#,S/#/PTRA/PTRB",
                "description": "Memory operation: destination/immediate, source/immediate/pointer",
                "valueType": 16
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WMLONG": {
            "mnemonic": "WMLONG",
            "syntax": "WMLONG  D,{#}S/P",
            "encoding": "EEEE 1010011 11I DDDDDDDDD SSSSSSSSS",
            "description": "Write only non-$00 bytes in D[31:0] to hub address {#}S/PTRx. Prior SETQ/SETQ2 invokes cog/LUT block transfer.",
            "timing": {
              "cycles": 3,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {},
              "category": "",
              "effects": [],
              "operand_format": {}
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "PUSHB": {
            "mnemonic": "PUSHB",
            "syntax": "PUSHB   {#}D",
            "encoding": "EEEE 1100011 0L1 DDDDDDDDD 111100001",
            "description": "Write long in D[31:0] to hub address PTRB++.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "D is a register or 9-bit literal value to push onto the stack at PTRB",
              "PTRB is automatically incremented after the write"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 32
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pushpop",
                "pattern": "D/# | D",
                "description": "Push immediate/register or Pop to register (PUSHA/PUSHB/POPA/POPB)",
                "valueType": 32
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Hub FIFO - New Read": {
        "count": 1,
        "description": "Hub FIFO - New Read",
        "instructions": {
          "RDFAST": {
            "mnemonic": "RDFAST",
            "syntax": "RDFAST  {#}D,{#}S",
            "encoding": "EEEE 1100011 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Begin new fast hub read via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units\n(0 = max), S[19:0] = block start address.\n\nKey features:\n- Automatic sequential reading from HUB\n- Background FIFO refill\n- Perfect for streaming data processing\n- Essential for checksum/CRC calculations\n- Used with RFBYTE/RFWORD/RFLONG instructions\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent BITxxx instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent BITxxx instruction.",
        "instructions": {
          "ALTB": {
            "mnemonic": "ALTB",
            "syntax": "ALTB Dest, {#}Src",
            "encoding": [
              "EEEE 1001100 11I DDDDDDDDD SSSSSSSSS                     D1                  \u2014                   \u2014                    2",
              "EEEE 1001100 111 DDDDDDDDD 000000000                     D 1"
            ],
            "description": "ALTB should be followed by a BITxxx instruction\u2014 it modifies the BITxxx instruction's Dest value, enabling code Result: The next instruction's pipelined Dest value is altered to be (Src + Dest[13:5]) & $1FF, or just Dest[13:5] for syntax 2.\n\nALTB should be followed by a BITxxx instruction\u2014 it modi\ufb01es the BITxxx instruction's Dest value, enabling code\n\nto iterate through multiple bits of data across a range of Reg RAM. BITxxx's Dest value is changed to (Src +\n\nDest[13:5]) & $1FF (for syntax 1), or to Dest[13:5] (for syntax 2).\n\nDest[13:5] corresponds to the target long register's 9-bit address and Dest[4:0] is the bit ID within it; values of\n\n0\u201331 identify individual bits, by position, in least-signi\ufb01cant bit order. Iteratively executing ALTB followed by a\n\nBITxxx instruction, and each time incrementing ALTB's 14-bit Dest value by one, effectively writes a stream of bit\n\nvalues to Reg RAM as if it were all made of bit-sized registers.\n\nWarning: BITxxx instructions optionally operate on a range of bits, encoded in the Src value\u2014 they don't limit\n\nthemselves to only reading Src[4:0] for the bit number. For this reason, care must be taken when using ALTB with\n\nBITxxx or the index value (often used for the Src of the altered instruction) will be misinterpreted as multiple bits\n\nto affect. One way to solve this is to use a SETQ #0 followed by the ALTB then BITxxx instructions to force\n\nBITxxx's Src[9:5] bits to 0; i.e. no extra bits beyond the single bit described by Src[4:0].\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of bits begins. ALTB adds the long index (Dest[13:5])\n\nto the base (Src[8:0]) to locate the register holding the target bit. The bit ID (Dest[4:0]) identi\ufb01es the bit's\n\nposition within that long register.\n\n\u25cf   At the end of ALTB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 14-bit\n\nindex (Dest) for a future ALTB+BITxxx iteration.\n\nIn syntax 2, Dest serves as the full bit address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its bit index instead of the long's relative index (to add to a base) and bit index.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D1"
              }
            },
            "parameters": [
              "Dest is the register whose 14-bit value is the index, or the full bit address, for the BITxxx instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[13:5]) for BITxxx) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution).",
              "The base is the Reg RAM address where the series of bits begins. ALTB adds the long index (Dest[13:5]) to the base (Src[8:0]) to locate the register holding the target bit. The bit ID (Dest[4:0]) identi\ufb01es the bit's position within that long register.",
              "At the end of ALTB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 14-bit index (Dest) for a future ALTB+BITxxx iteration.",
              "The instruction following ALTB is shielded from interrupt",
              "ALTB alters the next instruction regardless of its kind\u2014 the intention is for it to be a BITxxx",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Adjust signed value by other C-negated or !C-negated value.": {
        "count": 1,
        "description": "Math Instruction - Adjust signed value by other C-negated or !C-negated value.",
        "instructions": {
          "SUMNC": {
            "mnemonic": "SUMNC",
            "syntax": "SUMNC   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0011101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "SUMC or SUMNC adjusts the signed Dest value by Src or -Src (depending on C or !C) and stores the result into the Result: The sum of signed Dest and either Src or -Src (according to C) is stored in Dest and optionally the C and Z flags are updated to the sign and zero status.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "0 then D = D - S, else D = D + S"
              }
            },
            "parameters": [
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if C=0 or !C=0) or negated value (if C=1 or !C=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [
              "SUMZ",
              "SUMNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Cog Control Instruction - Get current cog\u2019s ID or any cog's status by ID.": {
        "count": 1,
        "description": "Cog Control Instruction - Get current cog\u2019s ID or any cog's status by ID.",
        "instructions": {
          "COGID": {
            "mnemonic": "COGID",
            "syntax": "COGID {#}Dest {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000001 D if reg and !WC              Cog Running              \u2014           2\u20139, +2 if result",
            "description": "COGID writes the current cog's ID into Dest (if Dest is a register and WC is omitted) or sets/clears the C flag Result: Current cog's ID is written to Dest or C is set (1) or cleared (0) if the Dest cog is running or stopped. C = 1 if on.\n\nCOGID writes the current cog's ID into Dest (if Dest is a register and WC is omitted) or sets/clears the C \ufb02ag\n\naccording to the running/stopped state of the cog indicated by Dest[2:0] (if WC is given).\n\nIf the WC effect is speci\ufb01ed, the C \ufb02ag is set (1) if the Dest[2:0] cog is running, or is cleared (0) if stopped.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if on"
              }
            },
            "parameters": [
              "Dest is the register where the current cog's ID will be written, or is the register or 9-bit literal whose value (lower 3-bits) indicates which cog to get the status for.",
              "WC is an optional effect to update the C \ufb02ag with the Dest cog's running status."
            ],
            "related": [
              "COGINIT",
              "COGSTOP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Augmentation Instruction - Augment next literal Dest to 32-bits.": {
        "count": 1,
        "description": "Augmentation Instruction - Augment next literal Dest to 32-bits.",
        "instructions": {
          "AUGD": {
            "mnemonic": "AUGD",
            "syntax": "AUGD #Dest",
            "encoding": "EEEE 11111DD DDD DDDDDDDDD DDDDDDDDD Hidden D Queue                     \u2014                 \u2014                   2",
            "description": "AUGD is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits Result: The 23-bit value formed from Dest is queued to prefix the next literal Dest occurrence (#Dest) to form a 32-bit literal for that instruction; interrupts are also temporarily disabled..\n\nAUGD is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits\n\navailable for literal Dest values; enough for many uses, but not all. AUGD augments the next occurrence of a literal\n\nDest value to be a full 32-bits. When the instruction with the soon-to-be-augmented literal is later executed, the\n\ncog uses the lower 9 bits encoded in the instruction's Dest \ufb01eld and prepends AUGD's 23 bits to it.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a 32-bit literal whose upper 23 bits are prepended to the next literal Dest occurrence.",
              "All instructions following AUGD are shielded from interrupt until after the instruction with the",
              "Dest value augmentation occurs in the instruction pipeline only; code is not altered, value does not persist",
              "SETQ / SETQ2 does not affect AUGD\u2014 the Q value passes through to the next instruction"
            ],
            "related": [
              "AUGS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 23
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_aug",
                "pattern": "#S",
                "description": "Augment: immediate 23-bit value for AUGS/AUGD",
                "valueType": 23
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear selectable event 1, 2, 3, or 4 \ufb02ag.": {
        "count": 4,
        "description": "Event Monitor Instruction - Retrieve and clear selectable event 1, 2, 3, or 4 \ufb02ag.",
        "instructions": {
          "POLLSE4": {
            "mnemonic": "POLLSE4",
            "syntax": "POLLSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000100 000100100                  \u2014             SE1 Event          SE1 Event                2",
              "EEEE 1101011 CZ0 000000101 000100100                  \u2014             SE2 Event          SE2 Event                2",
              "EEEE 1101011 CZ0 000000110 000100100                  \u2014             SE3 Event          SE3 Event                2",
              "EEEE 1101011 CZ0 000000111 000100100                  \u2014             SE4 Event          SE4 Event                2"
            ],
            "description": "Get SE4 event flag into C/Z, then clear it.\n\nPOLLSE1, POLLSE2, POLLSE3, or POLLSE4 copies the state of the selectable event 1, 2, 3, or 4 \ufb02ag into C and/or\n\nZ and then clears the \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\nselectable event \ufb02ag prior to clearing it.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "WAITSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "POLLSE3": {
            "mnemonic": "POLLSE3",
            "syntax": "POLLSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000100 000100100                  \u2014             SE1 Event          SE1 Event                2",
              "EEEE 1101011 CZ0 000000101 000100100                  \u2014             SE2 Event          SE2 Event                2",
              "EEEE 1101011 CZ0 000000110 000100100                  \u2014             SE3 Event          SE3 Event                2",
              "EEEE 1101011 CZ0 000000111 000100100                  \u2014             SE4 Event          SE4 Event                2"
            ],
            "description": "Get SE3 event flag into C/Z, then clear it.\n\nPOLLSE1, POLLSE2, POLLSE3, or POLLSE4 copies the state of the selectable event 1, 2, 3, or 4 \ufb02ag into C and/or\n\nZ and then clears the \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\nselectable event \ufb02ag prior to clearing it.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "WAITSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "POLLSE2": {
            "mnemonic": "POLLSE2",
            "syntax": "POLLSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000100 000100100                  \u2014             SE1 Event          SE1 Event                2",
              "EEEE 1101011 CZ0 000000101 000100100                  \u2014             SE2 Event          SE2 Event                2",
              "EEEE 1101011 CZ0 000000110 000100100                  \u2014             SE3 Event          SE3 Event                2",
              "EEEE 1101011 CZ0 000000111 000100100                  \u2014             SE4 Event          SE4 Event                2"
            ],
            "description": "Get SE2 event flag into C/Z, then clear it.\n\nPOLLSE1, POLLSE2, POLLSE3, or POLLSE4 copies the state of the selectable event 1, 2, 3, or 4 \ufb02ag into C and/or\n\nZ and then clears the \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\nselectable event \ufb02ag prior to clearing it.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "WAITSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "POLLSE1": {
            "mnemonic": "POLLSE1",
            "syntax": "POLLSE1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000000100 000100100                  \u2014             SE1 Event          SE1 Event                2",
              "EEEE 1101011 CZ0 000000101 000100100                  \u2014             SE2 Event          SE2 Event                2",
              "EEEE 1101011 CZ0 000000110 000100100                  \u2014             SE3 Event          SE3 Event                2",
              "EEEE 1101011 CZ0 000000111 000100100                  \u2014             SE4 Event          SE4 Event                2"
            ],
            "description": "Get SE1 event flag into C/Z, then clear it.\n\nPOLLSE1, POLLSE2, POLLSE3, or POLLSE4 copies the state of the selectable event 1, 2, 3, or 4 \ufb02ag into C and/or\n\nZ and then clears the \ufb02ag (unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the corresponding\n\nselectable event \ufb02ag prior to clearing it.\n\nThe selectable event 1, 2, 3, or 4 \ufb02ag is set whenever the corresponding con\ufb01gured event occurs. The selectable\n\nevent \ufb02ag is cleared upon execution of the corresponding SETSEx, POLLSEx, WAITSEx, JSEx, or JNSEx\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETSEx",
              "WAITSEx",
              "JSEx",
              "JNSEx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a byte left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a byte left into a value.",
        "instructions": {
          "ROLBYTE": {
            "mnemonic": "ROLBYTE",
            "syntax": "ROLBYTE Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1001000 NNI DDDDDDDDD SSSSSSSSS                  D                \u2014                  \u2014                     2",
              "EEEE 1001000 000 DDDDDDDDD 000000000                  D                \u2014                  \u2014                     2"
            ],
            "description": "ROLBYTE reads the byte identified by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB Result: Byte Num (0\u20133) of Src, or a byte from a source described by prior ALTGB instruction, is rotated left into Dest.\n\nROLBYTE reads the byte identi\ufb01ed by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB\n\ninstruction, and rotates it left into Dest.\n\nROLBYTE achieves the same effect as two instructions\u2014 an 8-bit SHL followed by SETBYTE into byte 0.\n\nNum (0\u20133) identi\ufb01es a value's individual bytes, by position, in least-signi\ufb01cant byte order.\n\nSyntax 2 is intended for use after an ALTGB instruction; i.e. in a loop to iteratively read a series of byte values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the byte into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target byte to read.",
              "Num is a 2-bit literal identifying the nibble ID (0\u20133) of Src to read."
            ],
            "related": [
              "ALTGB",
              "ROLNIB",
              "ROLWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 9
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds2get",
                "pattern": "D{,S/#,#0..3}",
                "description": "Get byte: destination, optional source and byte index 0-3",
                "valueType": 9
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-empty event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-empty event \ufb02ag.",
        "instructions": {
          "WAITXMT": {
            "mnemonic": "WAITXMT",
            "syntax": "WAITXMT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011010 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITXMT waits for a streamer-empty event to occur (unless the event flag is already set), then clears the event Result: Wait for streamer-empty event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITXMT waits for a streamer-empty event to occur (unless the event \ufb02ag is already set), then clears the event\n\n\ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction. Optionally,\n\nWAITXMT can time-out if the streamer-empty event doesn't occur soon enough; setting C and/or Z \ufb02ags and then\n\nresuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITXMT.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe streamer-empty event \ufb02ag is set whenever the streamer is ready for a new command. The streamer-empty\n\nevent \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXMT, WAITXMT, JXMT, or JNXMT instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual         \u25aa   Page 143"
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXMT",
              "JXMT",
              "JNXMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test D, or bitwise AND D with S, to affect \ufb02ags.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test D, or bitwise AND D with S, to affect \ufb02ags.",
        "instructions": {
          "TEST": {
            "mnemonic": "TEST",
            "syntax": "TEST Dest               {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0111110 CZ0 DDDDDDDDD DDDDDDDDD                    \u2014             Parity of D           D=0                     2",
              "EEEE 0111110 CZI DDDDDDDDD SSSSSSSSS                    \u2014          Parity of (D & S)     (D & S) = 0                2",
              "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS                   \u2014             IN[D[4:0]]          IN[D[4:0]]                2",
              "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C AND IN[D[4:0]] Z AND IN[D[4:0]]                 2",
              "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS                   \u2014          C OR IN[D[4:0]]     Z OR IN[D[4:0]]              2",
              "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C XOR IN[D[4:0]] Z XOR IN[D[4:0]]                 2",
              "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS                   \u2014            !IN[D[4:0]]         !IN[D[4:0]]                2",
              "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C AND !IN[D[4:0]] Z AND !IN[D[4:0]]               2",
              "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C OR !IN[D[4:0]]     Z OR !IN[D[4:0]]             2",
              "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C XOR !IN[D[4:0]] Z XOR !IN[D[4:0]]               2"
            ],
            "description": "TEST determines the parity (number of high (1) bits) and the zero or non-zero state of Dest, or of Dest bitwise Result: The parity and zero-state of Dest, or of Dest bitwise ANDed with Src, is stored in the C and Z flags. C = parity of (D & S).\n\nTEST determines the parity (number of high (1) bits) and the zero or non-zero state of Dest, or of Dest bitwise\n\nANDed with Src, and stores the results in the C and/or Z \ufb02ag.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the number of high (1) bits in Dest (or Dest ANDed with\n\nSrc) is odd, or is cleared (0) if it is even.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest (or Dest ANDed with Src) is zero, or is cleared (0) if it\n\nis not zero.\n\nTESTB / TESTBN\n\nTest bit or bit not\n\nBit Operation Instruction - Test bit of D or !D and either store, AND, OR, or XOR the result into \ufb02ags.\n\nTESTB     Dest, {#}Src WC|WZ\n\nTESTB     Dest, {#}Src ANDC|ANDZ\n\nTESTB     Dest, {#}Src ORC|ORZ\n\nTESTB     Dest, {#}Src XORC|XORZ\n\nTESTBN Dest, {#}Src WC|WZ\n\nTESTBN Dest, {#}Src ANDC|ANDZ\n\nTESTBN Dest, {#}Src ORC|ORZ\n\nTESTBN Dest, {#}Src XORC|XORZ\n\nResult: The state of Dest's bit Src is read, possibly inverted, and either stored as-is, or bitwise ANDed, ORed, or\n\nXORed into C or Z.\n\n\u25cf    Dest is the register whose value will have a single bit tested.\n\n\u25cf    Src is a register or 5-bit literal whose value identi\ufb01es the bit (0\u201331) of Dest to test.\n\n\u25cf    WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C\n\nor Z \ufb02ag.\n\nCOND INSTR         FX     DEST          SRC           Write            C Flag              Z Flag              Clocks\n\nEEEE 0100000 CZI DDDDDDDDD SSSSSSSSS                   \u2014             IN[D[4:0]]          IN[D[4:0]]                2\n\nEEEE 0100010 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C AND IN[D[4:0]] Z AND IN[D[4:0]]                 2\n\nEEEE 0100100 CZI DDDDDDDDD SSSSSSSSS                   \u2014          C OR IN[D[4:0]]     Z OR IN[D[4:0]]              2\n\nEEEE 0100110 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C XOR IN[D[4:0]] Z XOR IN[D[4:0]]                 2\n\nEEEE 0100001 CZI DDDDDDDDD SSSSSSSSS                   \u2014            !IN[D[4:0]]         !IN[D[4:0]]                2\n\nEEEE 0100011 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C AND !IN[D[4:0]] Z AND !IN[D[4:0]]               2\n\nEEEE 0100101 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C OR !IN[D[4:0]]     Z OR !IN[D[4:0]]             2\n\nEEEE 0100111 CZI DDDDDDDDD SSSSSSSSS                   \u2014         C XOR !IN[D[4:0]] Z XOR !IN[D[4:0]]               2\n\nRelated: TESTP and TESTPN\n\nTESTB or TESTBN reads the state (0/1) of a bit in Dest designated by Src, possibly inverts that result, and either\n\nstores it as-is, or bitwise ANDs, ORs, or XORs it into the C or Z \ufb02ag.\n\nSrc[4:0] indicates the bit number (0\u201331) to test.\n\nIf the WC or WZ effect is speci\ufb01ed, the C or Z \ufb02ag is overwritten with the state or inverse state of the bit.\n\nIf the ANDC or ANDZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise ANDed with the state or inverse state of the bit.\n\nIf the ORC or ORZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise ORed with the state or inverse state of the bit.\n\nIf the XORC or XORZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise XORed with the state or inverse state of the bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of (D & S)"
              },
              "Z": {
                "formula": "((D & S) == 0)"
              }
            },
            "parameters": [
              "Dest is the register whose value will be tested.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is ANDed with Dest.",
              "WC, WZ, and WCZ are optional effects to update \ufb02ags.",
              "Dest is the register whose value will have a single bit tested.",
              "Src is a register or 5-bit literal whose value identi\ufb01es the bit (0\u201331) of Dest to test.",
              "WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C or Z \ufb02ag. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual              \u25aa   Page 134"
            ],
            "related": [
              "TESTP",
              "TESTPN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear counter 1, 2, or 3 event \ufb02ag.": {
        "count": 3,
        "description": "Event Monitor Instruction - Wait for and clear counter 1, 2, or 3 event \ufb02ag.",
        "instructions": {
          "WAITCT3": {
            "mnemonic": "WAITCT3",
            "syntax": "WAITCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010001 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010010 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010011 000100100                 \u2014          Timeout Abort     Timeout Abort               2+"
            ],
            "description": "Wait for CT3 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT1, WAITCT2, or WAITCT3 waits for a counter 1, 2, or 3 event to occur (unless the event \ufb02ag is already set),\n\nthen clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITCTx can time-out if the counter event doesn't occur soon enough; setting C and/or Z\n\n\ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITCTx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "POLLCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "WAITCT2": {
            "mnemonic": "WAITCT2",
            "syntax": "WAITCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010001 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010010 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010011 000100100                 \u2014          Timeout Abort     Timeout Abort               2+"
            ],
            "description": "Wait for CT2 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT1, WAITCT2, or WAITCT3 waits for a counter 1, 2, or 3 event to occur (unless the event \ufb02ag is already set),\n\nthen clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITCTx can time-out if the counter event doesn't occur soon enough; setting C and/or Z\n\n\ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITCTx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "POLLCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "WAITCT1": {
            "mnemonic": "WAITCT1",
            "syntax": "WAITCT1 {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000010001 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010010 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 CZ0 000010011 000100100                 \u2014          Timeout Abort     Timeout Abort               2+"
            ],
            "description": "Wait for CT1 event \ufb02ag, then clear it. Prior SETQ sets optional CT timeout value. C/Z = timeout.                              2+\n\nWAITCT1, WAITCT2, or WAITCT3 waits for a counter 1, 2, or 3 event to occur (unless the event \ufb02ag is already set),\n\nthen clears the event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next\n\ninstruction. Optionally, WAITCTx can time-out if the counter event doesn't occur soon enough; setting C and/or Z\n\n\ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITCTx.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe counter 1, 2, or 3 event \ufb02ag is set whenever the System Counter (CT) passes the value in the CT1, CT2, or CT3\n\nevent trigger register, respectively; i.e. MSB of (CT - CTx is 0). The counter event \ufb02ags are cleared upon execution\n\nof the corresponding ADDCTx, POLLCTx, WAITCTx, JCTx, or JNCTx instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDCTx",
              "POLLCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) low/high according to C or !C.": {
        "count": 2,
        "description": "Bit Operation Instruction - Set bit(s) low/high according to C or !C.",
        "instructions": {
          "BITNC": {
            "mnemonic": "BITNC",
            "syntax": "BITNC   D,{#}S         {WCZ}",
            "encoding": "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITC or BITNC alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the C flag. All other Result: Dest bit(s) described by Src are set to C or !C; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "BITC": {
            "mnemonic": "BITC",
            "syntax": "BITC    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITC or BITNC alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the C flag. All other Result: Dest bit(s) described by Src are set to C or !C; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - Write": {
        "count": 3,
        "description": "Hub FIFO - Write",
        "instructions": {
          "WFBYTE": {
            "mnemonic": "WFBYTE",
            "syntax": "WFBYTE  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010101",
            "description": "Used after WRFAST. Write byte in D[7:0] into FIFO.                                                                     2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WFWORD": {
            "mnemonic": "WFWORD",
            "syntax": "WFWORD  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010110",
            "description": "Used after WRFAST. Write word in D[15:0] into FIFO.                                                                    2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "WFLONG": {
            "mnemonic": "WFLONG",
            "syntax": "WFLONG  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000010111",
            "description": "Used after WRFAST. Write long in D[31:0] into FIFO.                                                                    2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "CORDIC Solver": {
        "count": 10,
        "description": "CORDIC Solver",
        "instructions": {
          "QVECTOR": {
            "mnemonic": "QVECTOR",
            "syntax": "QVECTOR {#}D,{#}S",
            "encoding": "EEEE 1101010 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Convert cartesian coordinates (X, Y) to polar coordinates (length, angle). Takes X coordinate in D and Y coordinate in S as 32-bit signed values. Results retrieved via GETQX (length) and GETQY (angle) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QFRAC": {
            "mnemonic": "QFRAC",
            "syntax": "QFRAC   {#}D,{#}S",
            "encoding": "EEEE 1101001 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Perform 64\u00f732 unsigned fractional division with D as upper 32 bits. Numerator formed from {D, SETQ value or 32'b0}, divided by S. Results retrieved via GETQX (quotient) and GETQY (remainder) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QLOG": {
            "mnemonic": "QLOG",
            "syntax": "QLOG    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000001110",
            "description": "Convert 32-bit unsigned integer to 5:27-bit logarithm format. Takes unsigned integer in D operand and produces logarithm with 5-bit whole exponent and 27-bit fractional exponent. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "GETQX": {
            "mnemonic": "GETQX",
            "syntax": "GETQX   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011000",
            "description": "{WC/WZ/WCZ}   Retrieve CORDIC result X into D. Waits, in case result not ready. C = X[31]. 1",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "2...58"
            },
            "flags_affected": {
              "C": {
                "formula": "X[31]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "GETQY": {
            "mnemonic": "GETQY",
            "syntax": "GETQY   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 000011001",
            "description": "{WC/WZ/WCZ}   Retrieve CORDIC result Y into D. Waits, in case result not ready. C = Y[31].",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "2...58"
            },
            "flags_affected": {
              "C": {
                "formula": "Y[31]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "QEXP": {
            "mnemonic": "QEXP",
            "syntax": "QEXP    {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000001111",
            "description": "Convert 5:27-bit logarithm to 32-bit unsigned integer. Takes logarithm in 5:27 format (5-bit whole exponent, 27-bit fractional exponent) in D operand. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QDIV": {
            "mnemonic": "QDIV",
            "syntax": "QDIV    {#}D,{#}S",
            "encoding": "EEEE 1101000 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Perform 64\u00f732 unsigned division with 32-bit quotient and remainder. Numerator formed from {SETQ value or 32'b0, D}, divided by S. Results retrieved via GETQX (quotient) and GETQY (remainder) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QROTATE": {
            "mnemonic": "QROTATE",
            "syntax": "QROTATE {#}D,{#}S",
            "encoding": "EEEE 1101010 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Rotate a 32-bit signed (X, Y) point around origin (0, 0) by a specified angle. X coordinate comes from D operand, Y coordinate from SETQ value (or 0 if SETQ not used). Angle specified in S operand. Results retrieved via GETQX (X) and GETQY (Y) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QMUL": {
            "mnemonic": "QMUL",
            "syntax": "QMUL    {#}D,{#}S",
            "encoding": "EEEE 1101000 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Perform 32\u00d732 unsigned multiplication producing 64-bit result. Multiplies D operand by S operand. Results retrieved via GETQX (lower 32 bits) and GETQY (upper 32 bits) instructions 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "QMUL D/#,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 416,
                "effects": 0,
                "operandFormat": 13,
                "rawValue": 27040
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          },
          "QSQRT": {
            "mnemonic": "QSQRT",
            "syntax": "QSQRT   {#}D,{#}S",
            "encoding": "EEEE 1101001 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Calculate square root of 64-bit unsigned number formed from {S, D}. Takes upper 32 bits from S operand and lower 32 bits from D operand. Result retrieved via GETQX instruction 55 clocks later.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "p2_datasheet",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Bitwise AND a value with another, or with the NOT of another.": {
        "count": 2,
        "description": "Bit Operation Instruction - Bitwise AND a value with another, or with the NOT of another.",
        "instructions": {
          "AND": {
            "mnemonic": "AND",
            "syntax": "AND     D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "AND or ANDN performs a bitwise AND of the value in Src (or !Src) into that of Dest. Result: Dest AND Src (or Dest AND !Src) is stored in Dest and flags are optionally updated with parity and zero status.\n\nIf the WC or WCZ effect is specified, the C flag is set (1) if the result contains an odd number of high (1) bits, or is cleared (0) if it contains an even number of high bits.\n\nIf the WZ or WCZ effect is specified, the Z flag is set (1) if the Dest AND Src (or Dest AND !Src) equals zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register containing the value to bitwise AND with Src (or with !Src) and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (or inverse value) will be bitwise ANDed into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Page 49",
            "documentation_level": "comprehensive"
          },
          "ANDN": {
            "mnemonic": "ANDN",
            "syntax": "ANDN    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "AND or ANDN performs a bitwise AND of the value in Src (or !Src) into that of Dest. Result: Dest AND Src (or Dest AND !Src) is stored in Dest and flags are optionally updated with parity and zero status.\n\nIf the WC or WCZ effect is specified, the C flag is set (1) if the result contains an odd number of high (1) bits, or is cleared (0) if it contains an even number of high bits.\n\nIf the WZ or WCZ effect is specified, the Z flag is set (1) if the Dest AND Src (or Dest AND !Src) equals zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register containing the value to bitwise AND with Src (or with !Src) and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (or inverse value) will be bitwise ANDed into Dest.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Page 49",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Pixel Mixer": {
        "count": 5,
        "description": "Pixel Mixer",
        "instructions": {
          "MULPIX": {
            "mnemonic": "MULPIX",
            "syntax": "MULPIX  D,{#}S",
            "encoding": "EEEE 1010010 01I DDDDDDDDD SSSSSSSSS",
            "description": "Multiply bytes of S into bytes of D, where $FF = 1.0 and $00 = 0.0.",
            "timing": {
              "cycles": 7,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETPIX": {
            "mnemonic": "SETPIX",
            "syntax": "SETPIX  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111110",
            "description": "Set MIXPIX mode to D[5:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETPIV": {
            "mnemonic": "SETPIV",
            "syntax": "SETPIV  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000111101",
            "description": "Set BLNPIX/MIXPIX blend factor to D[7:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "BLNPIX": {
            "mnemonic": "BLNPIX",
            "syntax": "BLNPIX  D,{#}S",
            "encoding": "EEEE 1010010 10I DDDDDDDDD SSSSSSSSS",
            "description": "Alpha-blend bytes of S into bytes of D, using SETPIV value.",
            "timing": {
              "cycles": 7,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "MIXPIX": {
            "mnemonic": "MIXPIX",
            "syntax": "MIXPIX  D,{#}S",
            "encoding": "EEEE 1010010 11I DDDDDDDDD SSSSSSSSS",
            "description": "Mix bytes of S into bytes of D, using SETPIX and SETPIV values.",
            "timing": {
              "cycles": 7,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Subtract one unsigned value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned value from another.",
        "instructions": {
          "SUB": {
            "mnemonic": "SUB",
            "syntax": "SUB Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001100 CZI DDDDDDDDD SSSSSSSSS                     D          borrow of (D - S)      Result = 0               2",
            "description": "SUB subtracts the unsigned Src from the unsigned Dest and stores the result into the Dest register. Result: Difference of unsigned Dest and unsigned Src is stored in Dest and optionally the C and Z flags are updated to the borrow and zero status.\n\nSUB subtracts the unsigned Src from the unsigned Dest and stores the result into the Dest register.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the subtraction results in a 32-bit under\ufb02ow (unsigned\n\nborrow), or is cleared (0) if no borrow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest - Src is zero, or is cleared (0) if it is\n\nnon-zero.\n\nTo subtract unsigned, multi-long values, use SUB followed by SUBX as described in Subtracting Two Multi-Long\n\nValues. SUB and SUBX are also used in subtracting signed, multi-long values with SUBSX ending the sequence.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SUBX",
              "SUBS",
              "SUBSX",
              "ADD",
              "SUBR"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Substitute next instruction's \ufb01eld values from template, per con\ufb01guration.": {
        "count": 1,
        "description": "Indirection Instruction - Substitute next instruction's \ufb01eld values from template, per con\ufb01guration.",
        "instructions": {
          "ALTI": {
            "mnemonic": "ALTI",
            "syntax": "ALTI Dest, {#}Src",
            "encoding": [
              "EEEE 1001101 00I DDDDDDDDD SSSSSSSSS                       D                \u2014                \u2014                     2",
              "EEEE 1001101 001 DDDDDDDDD 101100100                      \u2014                 \u2014                \u2014                     2"
            ],
            "description": "ALTI substitutes fields from Dest for one or more of the next instruction's pipelined Dest, Src, Result, Instr, FX, Result: The next instruction's pipelined field value values are substituted from the Dest template, and Dest is modified per Src configuration (syntax 1), or the entire Dest opcode (instruction) is executed in place of the next instruction (syntax 2).\n\nALTI substitutes \ufb01elds from Dest for one or more of the next instruction's pipelined Dest, Src, Result, Instr, FX,\n\nand/or Cond values, and ALTI's Dest is then modi\ufb01ed per Src con\ufb01guration (syntax 1), or the entire Dest opcode\n\n(instruction) is executed in place of the next instruction (syntax 2).\n\nThe Dest register contains the ALTI template; a 32-bit value with the following format similar to an opcode:\n\nBits            31:28 (4 bits)          27:19 (9 bits)          18            17:9 (9 bits)           8:0 (9 bits)\n\nField Description      Condition Field         Result Field     Indirect \"I\" Field   Dest \"D\" Field        Source \"S\" Field\n\nIn syntax 1, Src consists of the following six 3-bit \ufb01elds that describe \ufb01eld substitution and Dest modi\ufb01cation.\n\n%rrr_ddd_sss_RRR_DDD_SSS\n\n\u25cf   %rrr = Result \ufb01eld increment/decrement mask size\n\n\u25cf   %ddd = Dest \ufb01eld increment/decrement mask size\n\n\u25cf   %sss = Src \ufb01eld increment/decrement mask size\n\n\u25cf   %RRR = Result/Instruction \ufb01eld control\n\n\u25cf   %DDD = Dest \ufb01eld control\n\n\u25cf   %SSS = Src \ufb01eld control\n\nField Increment/Decrement Mask Size\n\n%rrr\n\n%ddd Mask Selection\n\n%sss\n\n000   Unlimited Increment/Decrement of 9 bits (default, full 512-register Reg RAM span)\n\n001   Limit Increment/Decrement to 8 LSBs (256-register Reg RAM looped buffer)\n\n010   Limit Increment/Decrement to 7 LSBs (128-register Reg RAM looped buffer)\n\n011    Limit Increment/Decrement to 6 LSBs (64-register Reg RAM looped buffer)\n\n100    Limit Increment/Decrement to 5 LSBs (32-register Reg RAM looped buffer)\n\n101    Limit Increment/Decrement to 4 LSBs (16-register Reg RAM looped buffer)\n\n110    Limit Increment/Decrement to 3 LSBs (8-register Reg RAM looped buffer)\n\n111    Limit Increment/Decrement to 2 LSBs (4-register Reg RAM looped buffer)\n\nResult/Instruction Field Control\n\n%RRR Substitution                                       Dest[27:19] Adjustment    Notes\n\n000    None                                             None\n\n001    None                                             None                      Cancel next instruction's Result write\n\n010    None                                             Decrements per %rrr\n\n011    None                                             Increments per %rrr\n\n100    Dest[27:19] \u21e8 next instruction's Result field    None\n\n101    Dest[31:18] \u21e8 next instruction's [31:18]         None                      Cond+Instr+Fx substitution1, 2\n\n110    Dest[27:19] \u21e8 next instruction's Result field    Decrements per %rrr\n\n111    Dest[27:19] \u21e8 next instruction's Result field    Increments per %rrr\n\n1\n\nSubstitutes for next instruction's conditional execution mode, instruction class, and/or effects (WC/WZ, I, etc.)\n\n2\n\nCan use with %DDD=1xx and %SSS=1xx for full instruction substitution; i.e. execute Dest opcode in place of next instruction\n\nDest Field Control\n\n%DDD Substitution                                      Dest[17:9] Adjustment     Notes\n\n000    None                                            None\n\n001    None                                            None                      Same as %000\n\n010    None                                            Decrements per %ddd\n\n011    None                                            Increments per %ddd\n\n100    Dest[17:9] \u21e8 next instruction's Dest field      None                      Execute Dest w/ RRR = %101, SSS = %1xx\n\n101    Dest[17:9] \u21e8 next instruction's Dest field      None                      Execute Dest w/ RRR = %101, SSS = %1xx\n\n110    Dest[17:9] \u21e8 next instruction's Dest field      Decrements per %ddd       Execute Dest w/ RRR = %101, SSS = %1xx\n\n111    Dest[17:9] \u21e8 next instruction's Dest field      Increments per %ddd       Execute Dest w/ RRR = %101, SSS = %1xx\n\nSrc Field Control\n\n%SSS Substitution                                      Src[8:0] Adjustment       Notes\n\n000    None                                            None\n\n001    None                                            None                      Same as %000\n\n010    None                                            Decrements per %sss\n\n011    None                                            Increments per %sss\n\n100    Dest[8:0] \u21e8 next instruction's Src field        None                      Execute Dest w/ RRR = %101, DDD = %1xx\n\n101    Dest[8:0] \u21e8 next instruction's Src field        None                      Execute Dest w/ RRR = %101, DDD = %1xx\n\n110    Dest[8:0] \u21e8 next instruction's Src field        Decrements per %sss       Execute Dest w/ RRR = %101, DDD = %1xx\n\n111    Dest[8:0] \u21e8 next instruction's Src field        Increments per %sss       Execute Dest w/ RRR = %101, DDD = %1xx\n\nIn syntax 2, Dest serves as the full opcode value\u2014 it is executed as-is in place of the next instruction and Dest\n\nremains unaltered afterward.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value contains one or more of the next instruction's \ufb01eld substitutes or an entire 32-bit opcode for full substitution.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value describes the substitutions and Dest modi\ufb01cations to perform.",
              "%rrr = Result \ufb01eld increment/decrement mask size",
              "%ddd = Dest \ufb01eld increment/decrement mask size",
              "%sss = Src \ufb01eld increment/decrement mask size",
              "%RRR = Result/Instruction \ufb01eld control",
              "%DDD = Dest \ufb01eld control",
              "%SSS = Src \ufb01eld control",
              "The instruction following ALTI is shielded from interrupt",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [
              "SETD",
              "SETS",
              "SETR",
              "ALTD",
              "ALTS",
              "ALTR"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 4
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duii",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (ALTI instruction modifier)",
                "valueType": 4
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) high (1) or low (0).": {
        "count": 2,
        "description": "Bit Operation Instruction - Set bit(s) high (1) or low (0).",
        "instructions": {
          "BITL": {
            "mnemonic": "BITL",
            "syntax": "BITL    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITH or BITL alters the Dest bit(s) designated by Src to be high (1) or low (0). All other bits are left unchanged. Result: Dest bit(s) described by Src are set high (1) or low (0); the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set high or low.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "BITH": {
            "mnemonic": "BITH",
            "syntax": "BITH    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITH or BITL alters the Dest bit(s) designated by Src to be high (1) or low (0). All other bits are left unchanged. Result: Dest bit(s) described by Src are set high (1) or low (0); the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set high or low.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Handling Instruction - Set one of three counter events' trigger time.": {
        "count": 3,
        "description": "Event Handling Instruction - Set one of three counter events' trigger time.",
        "instructions": {
          "ADDCT1": {
            "mnemonic": "ADDCT1",
            "syntax": "ADDCT1 Dest, {#}Src",
            "encoding": [
              "EEEE 1010011 00I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 01I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 10I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2"
            ],
            "description": "Set CT1 event to trigger on CT = D + S. Adds S into D.\n\nADDCT1, ADDCT2, or ADDCT3 sets the hidden CT1, CT2, or CT3 event trigger register (respectively) to the value of\n\nDest + Src. The result is also written to Dest.\n\nUse the xxxxCTx Event Handling instructions to process time-based events.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest."
            ],
            "related": [
              "POLLCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "ADDCT3": {
            "mnemonic": "ADDCT3",
            "syntax": "ADDCT1 Dest, {#}Src",
            "encoding": [
              "EEEE 1010011 00I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 01I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 10I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2"
            ],
            "description": "Set CT3 event to trigger on CT = D + S. Adds S into D.\n\nADDCT1, ADDCT2, or ADDCT3 sets the hidden CT1, CT2, or CT3 event trigger register (respectively) to the value of\n\nDest + Src. The result is also written to Dest.\n\nUse the xxxxCTx Event Handling instructions to process time-based events.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest."
            ],
            "related": [
              "POLLCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          },
          "ADDCT2": {
            "mnemonic": "ADDCT2",
            "syntax": "ADDCT1 Dest, {#}Src",
            "encoding": [
              "EEEE 1010011 00I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 01I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2",
              "EEEE 1010011 10I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    2"
            ],
            "description": "Set CT2 event to trigger on CT = D + S. Adds S into D.\n\nADDCT1, ADDCT2, or ADDCT3 sets the hidden CT1, CT2, or CT3 event trigger register (respectively) to the value of\n\nDest + Src. The result is also written to Dest.\n\nUse the xxxxCTx Event Handling instructions to process time-based events.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest."
            ],
            "related": [
              "POLLCTx",
              "WAITCTx",
              "JCTx",
              "JNCTx"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Decrement value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).": {
        "count": 2,
        "description": "Flow Control Instruction - Decrement value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).",
        "instructions": {
          "DJF": {
            "mnemonic": "DJF",
            "syntax": "DJF     D,{#}S",
            "encoding": "EEEE 1011011 10I DDDDDDDDD SSSSSSSSS",
            "description": "DJF or DJNF decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is decremented and tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DJNF": {
            "mnemonic": "DJNF",
            "syntax": "DJNF    D,{#}S",
            "encoding": "EEEE 1011011 11I DDDDDDDDD SSSSSSSSS",
            "description": "DJF or DJNF decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Dest is a register whose value is decremented and tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context in the Hub long at PTRA++ or PTRB++.": {
        "count": 2,
        "description": "Flow Control Instruction - Call a subroutine; store return context in the Hub long at PTRA++ or PTRB++.",
        "instructions": {
          "CALLB": {
            "mnemonic": "CALLB",
            "syntax": "CALLB   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101111 RAA AAAAAAAAA AAAAAAAAA",
            "description": "Write current C and Z flags and address of the next instruction into the 4-byte Hub RAM location at PTRA or PTRB, increment pointer, set PC to new relative or absolute address, and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.",
              "WC, WZ, or WCZ are optional effects to update the flags from Dest's upper bit states."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 19
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_call",
                "pattern": "#S | D",
                "description": "Call: immediate address or register",
                "valueType": 19
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "CALLA": {
            "mnemonic": "CALLA",
            "syntax": "CALLA   D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101110 RAA AAAAAAAAA AAAAAAAAA",
            "description": "Write current C and Z flags and address of the next instruction into the 4-byte Hub RAM location at PTRA or PTRB, increment pointer, set PC to new relative or absolute address, and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.",
              "WC, WZ, or WCZ are optional effects to update the flags from Dest's upper bit states."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 19
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_call",
                "pattern": "#S | D",
                "description": "Call: immediate address or register",
                "valueType": 19
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Write Z or not Z to register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Write Z or not Z to register.",
        "instructions": {
          "WRNZ": {
            "mnemonic": "WRNZ",
            "syntax": "WRNZ    D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101111",
            "description": "WRZ or WRNZ writes the state or inverse state of Z (0 or 1) to Dest. Result: Dest value is replaced with state of Z or !Z.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value will be replaced with the state of Z or !Z."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and toggle to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and toggle to the opposite output level.",
        "instructions": {
          "DRVNOT": {
            "mnemonic": "DRVNOT",
            "syntax": "DRVNOT {#}Dest {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011111 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
            "description": "DRVNOT sets the I/O pin(s) designated by Dest to the output direction and to their opposite output level(s); i.e. Result: The I/O pins described by Dest are set to the output direction and to their opposite output level(s); the rest are left as-is. Z = OUT bit.\n\nDRVNOT sets the I/O pin(s) designated by Dest to the output direction and to their opposite output level(s); i.e.\n\nalters the pin's direction and output registers. All other pins are left unchanged. This instruction can affect one or\n\nmore of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nDRVNOT achieves the same effect as two instructions\u2014 OUTNOT followed by DIRH.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DRVNOT instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DRVNOT's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to the output direction and toggle to opposite output levels.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub Control - Locks": {
        "count": 4,
        "description": "Hub Control - Locks",
        "instructions": {
          "LOCKREL": {
            "mnemonic": "LOCKREL",
            "syntax": "LOCKREL {#}D            {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000111",
            "description": "Release LOCK D[3:0]. If D is a register and WC, get current/last cog id of LOCK owner into\nD and LOCK status into C.\n\nKey features:\n- Releases previously acquired lock\n- Optional owner identification with WC\n- Essential for proper resource cleanup\n- Must balance with LOCKTRY calls\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "LOCKRET": {
            "mnemonic": "LOCKRET",
            "syntax": "LOCKRET {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000101",
            "description": "Return LOCK D[3:0] for reallocation.                                                                                     2...9 / same",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "LOCKTRY": {
            "mnemonic": "LOCKTRY",
            "syntax": "LOCKTRY {#}D            {WC}",
            "encoding": "EEEE 1101011 C0L DDDDDDDDD 000000110",
            "description": "Try to acquire lock D[3:0]. C = 1 if got LOCK.\n\nP2 provides 16 hardware locks (0-15) for inter-COG synchronization:\n- Atomic test-and-set operation\n- Non-blocking (returns immediately)\n- Perfect for resource protection\n- Essential for multi-COG coordination\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if got LOCK"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          },
          "LOCKNEW": {
            "mnemonic": "LOCKNEW",
            "syntax": "LOCKNEW D               {WC}",
            "encoding": "EEEE 1101011 C00 DDDDDDDDD 000000100",
            "description": "{WC}   Request a LOCK. D will be written with the LOCK number (0 to 15). C = 1 if no LOCK available.                           4...11 / same",
            "timing": {
              "cycles": 4,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1 if no LOCK available"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-\ufb01nished event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-\ufb01nished event \ufb02ag.",
        "instructions": {
          "WAITXFI": {
            "mnemonic": "WAITXFI",
            "syntax": "WAITXFI {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011011 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITXFI waits for a streamer-finished event to occur (unless the event flag is already set), then clears the event Result: Wait for streamer-finished event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITXFI waits for a streamer-\ufb01nished event to occur (unless the event \ufb02ag is already set), then clears the event\n\n\ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction. Optionally,\n\nWAITXFI can time-out if the streamer-\ufb01nished doesn't occur soon enough; setting C and/or Z \ufb02ags and then\n\nresuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITXFI.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe streamer-\ufb01nished event \ufb02ag is set whenever the streamer runs out of commands to process. The\n\nstreamer-\ufb01nished event \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXFI, WAITXFI, JXFI, or\n\nJNXFI instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXFI",
              "JXFI",
              "JNXFI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - New Write": {
        "count": 1,
        "description": "Hub FIFO - New Write",
        "instructions": {
          "WRFAST": {
            "mnemonic": "WRFAST",
            "syntax": "WRFAST  {#}D,{#}S",
            "encoding": "EEEE 1100100 0LI DDDDDDDDD SSSSSSSSS",
            "description": "Begin new fast hub write via FIFO. D[31] = no wait, D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
            "timing": {
              "cycles": 2,
              "type": "conditional"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Add two signed values.": {
        "count": 1,
        "description": "Math Instruction - Add two signed values.",
        "instructions": {
          "ADDS": {
            "mnemonic": "ADDS",
            "syntax": "ADDS Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001010 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D + S)       Result = 0               2",
            "description": "ADDS sums the two signed values of Dest and Src together and stores the result into the Dest register. If Src is a Result: Sum of signed Src and signed Dest is stored in Dest.\n\nADDS sums the two signed values of Dest and Src together and stores the result into the Dest register. If Src is a\n\n9-bit literal, its value is interpreted as positive (0-511; it is not sign-extended) \u2014 use ##Value (or insert a prior\n\nAUGS instruction) for a 32-bit signed value; negative or positive.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the summation results in a signed over\ufb02ow (signed\n\ncarry), or is cleared (0) if no over\ufb02ow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest + Src is zero, or is cleared (0) if it is\n\nnon-zero.\n\nTo add signed, multi-long values, use ADD (not ADDS) followed possibly by ADDX, and \ufb01nally ADDSX as described\n\nin Adding Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADD",
              "ADDX",
              "ADDSX",
              "SUBS"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output (high; 1) or input (low; 0).": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to output (high; 1) or input (low; 0).",
        "instructions": {
          "DIRH": {
            "mnemonic": "DIRH",
            "syntax": "DIRH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000001",
            "description": "DIRH or DIRL alters the direction register's bit(s) designated by Dest to be high (1) or low (0); i.e. set to the output Result: The I/O pin direction bit(s), described by Dest, are set high (1; output) or low (0; input); the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DIRL": {
            "mnemonic": "DIRL",
            "syntax": "DIRL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000000",
            "description": "DIRH or DIRL alters the direction register's bit(s) designated by Dest to be high (1) or low (0); i.e. set to the output Result: The I/O pin direction bit(s), described by Dest, are set high (1; output) or low (0; input); the rest are left as-is. Z = DIR bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRZ",
              "DIRNZ",
              "DIRNOT",
              "DIRRND"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values (in reverse order to CMP).": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values (in reverse order to CMP).",
        "instructions": {
          "CMPR": {
            "mnemonic": "CMPR",
            "syntax": "CMPR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010100 CZI DDDDDDDDD SSSSSSSSS                  \u2014          Unsigned (S < D)      D=S                    2",
            "description": "CMP compares the unsigned values of Dest and Src (by subtracting Dest from Src) and optionally setting the C Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMP compares the unsigned values of Dest and Src (by subtracting Dest from Src) and optionally setting the C\n\nand Z \ufb02ags accordingly.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Src is less than Dest.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest equals Src.\n\nTo compare unsigned, multi-long values, use CMP (instead) followed by CMPX as described in Comparing Two\n\nMulti-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "borrow of (S - D)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "CMP"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear FIFO-interface-block-wrap event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear FIFO-interface-block-wrap event \ufb02ag.",
        "instructions": {
          "WAITFBW": {
            "mnemonic": "WAITFBW",
            "syntax": "WAITFBW {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011001 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITFBW waits for a FIFO-interface-block-wrap event to occur (unless the event flag is already set), then clears Result: Wait for FIFO-interface-block-wrap event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITFBW waits for a FIFO-interface-block-wrap event to occur (unless the event \ufb02ag is already set), then clears\n\nthe event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction.\n\nOptionally, WAITFBW can time-out if the FIFO-interface-block-wrap event doesn't occur soon enough; setting C\n\nand/or Z \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITFBW.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe FIFO-interface-block-wrap event \ufb02ag is set whenever the Hub RAM FIFO interface exhausts its block count\n\nand reloads its block count and start address. The FIFO-interface-block-wrap event \ufb02ag is cleared upon execution\n\nof RDFAST, WRFAST, FBLOCK, POLLFBW, WAITFBW, JFBW, or JNFBW instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "RDFAST",
              "WRFAST",
              "FBLOCK",
              "POLLFBW",
              "JFBW",
              "JNFBW"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Resume": {
        "count": 4,
        "description": "Branch S - Resume",
        "instructions": {
          "RESI1": {
            "mnemonic": "RESI1",
            "syntax": "RESI1",
            "encoding": "EEEE 1011001 110 111110100 111110101",
            "description": "Resume from INT1. (CALLD $1F4,$1F5 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RESI0": {
            "mnemonic": "RESI0",
            "syntax": "RESI0",
            "encoding": "EEEE 1011001 110 111111110 111111111",
            "description": "Resume from INT0. (CALLD $1FE,$1FF WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RESI3": {
            "mnemonic": "RESI3",
            "syntax": "RESI3",
            "encoding": "EEEE 1011001 110 111110000 111110001",
            "description": "Resume from INT3. (CALLD $1F0,$1F1 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RESI2": {
            "mnemonic": "RESI2",
            "syntax": "RESI2",
            "encoding": "EEEE 1011001 110 111110010 111110011",
            "description": "Resume from INT2. (CALLD $1F2,$1F3 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          }
        }
      },
      "Bit Operation Instruction - Decode value (0\u201431) into single-high-bit long.": {
        "count": 1,
        "description": "Bit Operation Instruction - Decode value (0\u201431) into single-high-bit long.",
        "instructions": {
          "DECOD": {
            "mnemonic": "DECOD",
            "syntax": "DECOD Dest, {#}Src",
            "encoding": [
              "EEEE 1001110 00I DDDDDDDDD SSSSSSSSS                  D                 \u2014                  \u2014                   2",
              "EEEE 1001110 000 DDDDDDDDD DDDDDDDDD                  D                 \u2014                  \u2014                   2",
              "EEEE 1101011 CZL DDDDDDDDD 001000010                DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1101011 CZL DDDDDDDDD 001000011                DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1101011 CZL DDDDDDDDD 001000001                 DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1101011 CZL DDDDDDDDD 001000000                 DIRx       Orig DIRx base bit Orig DIRx base bit           2"
            ],
            "description": "DECOD generates a 32-bit value with just one bit high, corresponding to the Src, or Dest, value (0\u201431) and stores Result: A 32-bit value, with the bit position corresponding to Src, or Dest, value (0\u201431) set high, is stored in Dest.\n\nDECOD generates a 32-bit value with just one bit high, corresponding to the Src, or Dest, value (0\u201431) and stores\n\nthat result in Dest.\n\nIn effect, Dest becomes %1 << value via the DECOD instruction; where value is Src[4:0] or Dest[4:0].\n\n\u25cf   A value of 0 generates %00000000_00000000_00000000_00000001.\n\n\u25cf   A value of 5 generates %00000000_00000000_00000000_00100000.\n\n\u25cf   A value of 15 generates %00000000_00000000_10000000_00000000.\n\nDECOD is the complement of ENCOD.\n\nDIRC / DIRNC\n\nDirection C or not C\n\nI/O Pin Instruction - Set pin(s) direction to input/output according to C or !C.\n\nDIRC    {#}Dest {WCZ}\n\nDIRNC {#}Dest {WCZ}\n\nResult: The I/O pin direction bit(s), described by Dest, are set to output/input according to C or !C; the rest are left\n\nas-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput or input.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR        FX     DEST          SRC           Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001000010                DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nEEEE 1101011 CZL DDDDDDDDD 001000011                DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nRelated: DIRZ, DIRNZ, DIRL, DIRH, DIRNOT, and DIRRND\n\nDIRC or DIRNC alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the C\n\n\ufb02ag; i.e. set pin to the output (1) or input (0) direction. All other bits (pins) are left unchanged. Each of these\n\ninstructions, DIRC and DIRNC, can affect one or more of the bits within the DIRA or DIRB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DIRC / DIRNC instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DIRC / DIRNC's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of DIRA / DIRB's base bit,\n\nidenti\ufb01ed by Dest.\n\nDIRH / DIRL\n\nDirection high or low\n\nI/O Pin Instruction - Set pin(s) direction to output (high; 1) or input (low; 0).\n\nDIRH {#}Dest {WCZ}\n\nDIRL {#}Dest {WCZ}\n\nResult: The I/O pin direction bit(s), described by Dest, are set high (1; output) or low (0; input); the rest are left\n\nas-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput or input.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX     DEST         SRC            Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001000001                 DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nEEEE 1101011 CZL DDDDDDDDD 001000000                 DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nRelated: DIRC, DIRNC, DIRZ, DIRNZ, DIRNOT, and DIRRND\n\nDIRH or DIRL alters the direction register's bit(s) designated by Dest to be high (1) or low (0); i.e. set to the output\n\nor input direction. All other bits (pins) are left unchanged. Each of these instructions, DIRH and DIRL, can affect\n\none or more of the bits within the DIRA or DIRB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DIRH / DIRL instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DIRH / DIRL's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of DIRA / DIRB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the decoded value and optionally begins by containing the 5-bit bit position value it is requesting (syntax 2).",
              "Src is an optional register or 5-bit literal whose value is the bit position to set high in the decoded value.",
              "A value of 0 generates %00000000_00000000_00000000_00000001.",
              "A value of 5 generates %00000000_00000000_00000000_00100000.",
              "A value of 15 generates %00000000_00000000_10000000_00000000.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRZ",
              "DIRNZ",
              "DIRNOT",
              "DIRRND"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level high (1) or low (0).": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level high (1) or low (0).",
        "instructions": {
          "DRVL": {
            "mnemonic": "DRVL",
            "syntax": "DRVL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011000",
            "description": "DRVH or DRVL sets the I/O pin(s) designated by Dest to the output direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the output direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DRVH": {
            "mnemonic": "DRVH",
            "syntax": "DRVH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011001",
            "description": "DRVH or DRVL sets the I/O pin(s) designated by Dest to the output direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the output direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Call a subroutine; store return context on the stack.": {
        "count": 1,
        "description": "Flow Control Instruction - Call a subroutine; store return context on the stack.",
        "instructions": {
          "CALL": {
            "mnemonic": "CALL",
            "syntax": "CALL Dest {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101101 RAA AAAAAAAAA AAAAAAAAA                 K1 and PC              \u2014                   \u2014               4 / 13\u201320",
              "EEEE 1101011 CZ0 DDDDDDDDD 000101101                 K1 and PC            D[31]               D[30]             4 / 13\u201320",
              "EEEE 1101110 RAA AAAAAAAAA AAAAAAAAA                    1"
            ],
            "description": "CALL records the current state of the C and Z flags and the address of the next instruction (PC + 1 if Cog/LUT Result: Push current C and Z flags and address of the next instruction onto the hardware stack, set PC to new relative or absolute address, and optionally update C and/or Z to new state. R = 1 then PC += A, else PC = A.\n\nCALL records the current state of the C and Z \ufb02ags and the address of the next instruction (PC + 1 if Cog/LUT\n\nexecution; PC + 4 if Hub execution) by pushing to the stack (K), potentially updates the C and Z \ufb02ags with new\n\ngiven states, and jumps to the given address or offset. The routine at the new address should eventually execute\n\na RET instruction, or an instruction with a _RET_ condition, to return to the recorded address (the instruction\n\nfollowing the CALL) and optionally restore the C and Z \ufb02ag state as it was prior.\n\nIn syntax 1, #Addr and #\\Addr encodes the instruction with relative and absolute addressing, respectively. The\n\nrelative form (the default) is vital for creating relocatable code. In either case, use symbolic references for Addr\n\nand the assembler will encode it properly. Examples: CALL #SendBit or CALL #\\DebugStatus\n\nIn syntax 2, the format of the value at Dest is CZxxxxxx_xxxxAAAA_AAAAAAAA_AAAAAAAA. C is the new C \ufb02ag\n\nstate, Z is the new Z \ufb02ag state, A is the new 20-bit address to jump to, and x are don't-care bits. Syntax 2\n\neffectively swaps the \ufb02ags and PC with the value in the Dest register (and RET swaps them back), making it\n\nconvenient for switching between two threads.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to match D[31], after its original state is recorded.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is updated to match D[30], after its original state is recorded.\n\nCALLA / CALLB\n\nCall A or B\n\nFlow Control Instruction - Call a subroutine; store return context in the Hub long at PTRA++ or PTRB++.\n\nCALLA #{\\}Addr\n\nCALLA Dest {WC|WZ|WCZ}\n\nCALLB #{\\}Addr\n\nCALLB Dest {WC|WZ|WCZ}\n\nResult: Write current C and Z \ufb02ags and address of the next instruction into the 4-byte Hub RAM location at PTRA\n\nor PTRB, increment pointer, set PC to new relative or absolute address, and optionally update C and/or Z to new\n\nstate.\n\n\u25cf   Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the\n\ndefault; use '\\' to force absolute addressing.\n\n\u25cf   Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.\n\n\u25cf   WC, WZ, or WCZ are optional effects to update the \ufb02ags from Dest's upper bit states.\n\nCOND INSTR            FX      DEST          SRC            Write             C Flag              Z Flag              Clocks\n\nEEEE 1101110 RAA AAAAAAAAA AAAAAAAAA                    1\n\nHub and PC               \u2014                   \u2014            5\u2013122 / 14\u2013322\n\nEEEE 1101011 CZ0 DDDDDDDDD 000101110               Hub1 and PC            D[31]               D[30]          5\u2013122 / 14\u2013322\n\nEEEE 1101111 RAA AAAAAAAAA AAAAAAAAA                    1\n\nHub and PC               \u2014                   \u2014            5\u2013122 / 14\u2013322\n\nEEEE 1101011 CZ0 DDDDDDDDD 000101111               Hub1 and PC            D[31]               D[30]          5\u2013122 / 14\u2013322\n\n1\n\nThe current C, Z, and effective next PC values are written to the Hub RAM long (H) referenced by PTRA or PTRB prior to\n\nreplacing them with that of Addr or Dest.\n\n2\n\n+1 clock cycle if target address isn't long-aligned in Hub RAM.\n\nCALLA and CALLB records the current state of the C and Z \ufb02ags and the address of the next instruction (PC + 1 if\n\nCog/LUT execution; PC + 4 if Hub execution) by writing them to the Hub RAM long (H) referenced by PTRA or\n\nPTRB, increments PTRA or PTRB, potentially updates the C and Z \ufb02ags with new given states, and jumps to the\n\ngiven address or offset. The routine at the new address should eventually execute a RETA or RETB instruction to\n\nreturn to the recorded address (the instruction following the CALLA or CALLB) and optionally restore the C and Z\n\n\ufb02ag state as it was prior.\n\nIn syntax 1 and 3, #Addr and #\\Addr encodes the instruction with relative and absolute addressing, respectively.\n\nThe relative form (the default) is vital for creating relocatable code. In either case, use symbolic references for\n\nAddr and the assembler will encode it properly. Examples: CALLA #SendBit or CALLB #\\DebugStatus\n\nIn syntax 2 and 4, the format of the value at Dest is CZxxxxxx_xxxxAAAA_AAAAAAAA_AAAAAAAA. C is the new C\n\n\ufb02ag state, Z is the new Z \ufb02ag state, A is the new 20-bit address to jump to, and x are don't-care bits. Syntax 2\n\neffectively swaps the \ufb02ags and PC with the value in the Dest register (and RETA or RETB swaps them back),\n\nmaking it convenient for switching between two threads.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to match D[31], after its original state is recorded.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is updated to match D[30], after its original state is recorded.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "D[31] D[30] 4"
            },
            "parameters": [
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.",
              "WC, WZ, or WCZ are optional effects to update the \ufb02ags from Dest's upper bit states. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual              \u25aa   Page 56",
              "Addr is a symbolic reference to the target subroutine; the location to set PC to. Relative addressing is the default; use '\\' to force absolute addressing.",
              "Dest is a register containing the 20-bit absolute address to set PC to and optional new C and Z states.",
              "WC, WZ, or WCZ are optional effects to update the \ufb02ags from Dest's upper bit states."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "CALL #S | D",
              "encoding": {
                "bits": 32,
                "opcode": 436,
                "effects": 0,
                "operandFormat": 19,
                "rawValue": 39348
              },
              "category": "Control Flow",
              "effects": [],
              "operand_format": {
                "name": "operand_call",
                "pattern": "#S | D",
                "description": "Call: immediate address or register",
                "valueType": 19
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate bits left.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate bits left.",
        "instructions": {
          "ROL": {
            "mnemonic": "ROL",
            "syntax": "ROL Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000001 CZI DDDDDDDDD SSSSSSSSS                            D         Last bit out   1",
            "description": "ROL rotates Dest's binary value left by Src places (0\u201331 bits). All MSBs rotated out are moved into the new LSBs. Result: The bits of Dest are rotated left by Src bits; any departing MSBs are moved into LSBs.\n\nROL rotates Dest's binary value left by Src places (0\u201331 bits). All MSBs rotated out are moved into the new LSBs.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit rotated out (effectively C =\n\nresult bit \"0\") if Src is 1\u201331, or to Dest[31] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero. Since no bits are lost by this operation, the result will only be zero if Dest started at zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate left by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Write C or not C to register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Write C or not C to register.",
        "instructions": {
          "WRNC": {
            "mnemonic": "WRNC",
            "syntax": "WRNC    D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101101",
            "description": "Write 0 or 1 to D, according to !C. D = {31'b0, !C).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose value will be replaced with the state of C or !C."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-LUT-RAM-rollover event \ufb02ag": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-LUT-RAM-rollover event \ufb02ag",
        "instructions": {
          "WAITXRL": {
            "mnemonic": "WAITXRL",
            "syntax": "WAITXRL {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011101 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITXRL waits for a streamer-LUT-RAM-rollover event to occur (unless the event flag is already set), then clears Result: Wait for streamer-LUT-RAM-rollover event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITXRL waits for a streamer-LUT-RAM-rollover event to occur (unless the event \ufb02ag is already set), then clears\n\nthe event \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction.\n\nOptionally, WAITXRL can time-out if the streamer-LUT-RAM-rollover event doesn't occur soon enough; setting C\n\nand/or Z \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITXRL.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe streamer-LUT-RAM-rollover event \ufb02ag is set whenever location $1FF of the Lookup RAM is read by the\n\nstreamer. The streamer-LUT-RAM-rollover event \ufb02ag is cleared upon cog start or upon execution of POLLXRL,\n\nWAITXRL, JXRL, or JNXRL instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXRL",
              "JXRL",
              "JNXRL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch S - Return": {
        "count": 4,
        "description": "Branch S - Return",
        "instructions": {
          "RETI3": {
            "mnemonic": "RETI3",
            "syntax": "RETI3",
            "encoding": "EEEE 1011001 110 111111111 111110001",
            "description": "Return from INT3. (CALLD $1FF,$1F1 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RETI2": {
            "mnemonic": "RETI2",
            "syntax": "RETI2",
            "encoding": "EEEE 1011001 110 111111111 111110011",
            "description": "Return from INT2. (CALLD $1FF,$1F3 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RETI1": {
            "mnemonic": "RETI1",
            "syntax": "RETI1",
            "encoding": "EEEE 1011001 110 111111111 111110101",
            "description": "Return from INT1. (CALLD $1FF,$1F5 WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          },
          "RETI0": {
            "mnemonic": "RETI0",
            "syntax": "RETI0",
            "encoding": "EEEE 1011001 110 111111111 111111111",
            "description": "Return from INT0. (CALLD $1FF,$1FF WCZ).",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "structured"
          }
        }
      },
      "Bit Operation Instruction - Set discrete bit pairs of a value to non-zero bit pair states of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete bit pairs of a value to non-zero bit pair states of another.",
        "instructions": {
          "MUXNITS": {
            "mnemonic": "MUXNITS",
            "syntax": "MUXNITS Dest, {#}Src",
            "encoding": "EEEE 1001111 00I DDDDDDDDD SSSSSSSSS                     D                 \u2014                   \u2014                    2",
            "description": "MUXNITS copies any non-zero bit pairs from Src into the corresponding bit pairs of Dest and leaves the rest of Result: Dest bit pairs corresponding to non-zero Src bit pairs are set to those bit values; the rest are left as-is.\n\nMUXNITS copies any non-zero bit pairs from Src into the corresponding bit pairs of Dest and leaves the rest of\n\nDest's bit pairs as-is.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register whose value will be updated according to Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose non-zero bit pairs will replace the corresponding bit pairs in Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear interrupt-occurred event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear interrupt-occurred event \ufb02ag.",
        "instructions": {
          "POLLINT": {
            "mnemonic": "POLLINT",
            "syntax": "POLLINT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000000000 000100100                 \u2014            INT Event          INT Event                 2",
            "description": "POLLINT copies the state of the interrupt-occurred event flag into C and/or Z and then clears the flag (unless it's Result: Interrupt-occurred event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLINT copies the state of the interrupt-occurred event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless it's\n\nbeing set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the interrupt-occurred\n\nevent \ufb02ag prior to clearing it.\n\nThe interrupt-occurred event \ufb02ag is set whenever interrupt 1, 2, or 3 occurs\u2014 debug interrupts are ignored. The\n\ninterrupt-occurred event \ufb02ag is cleared upon cog start, or execution of POLLINT, WAITINT, JINT, or JNINT\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "WAITINT",
              "JINT",
              "JNINT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Divide signed 32-bit integer by power-of-two; a.k.a shift bits right, extending the MSB.": {
        "count": 1,
        "description": "Math Instruction - Divide signed 32-bit integer by power-of-two; a.k.a shift bits right, extending the MSB.",
        "instructions": {
          "SAR": {
            "mnemonic": "SAR",
            "syntax": "SAR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000110 CZI DDDDDDDDD SSSSSSSSS                            D      Last bit out   1",
            "description": "The bits of Dest are shifted right by Src bits, extending Dest[31] (the sign bit) into new leftmost bits.\n\nSAR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to that of the original\n\nDest[31]; preserving the sign of a signed integer. This is useful for bit stream manipulation and for swift division\u2014\n\nit is similar to SHR for swift division by a power-of-two, but is safe for both signed and unsigned integers.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out (effectively C =\n\nresult bit \"-1\") if Src is 1\u201331, or to Dest[0] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to arithmetically right shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to arithmetically shift right.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SHR",
              "SH"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) low/high according to Z or !Z.": {
        "count": 2,
        "description": "Bit Operation Instruction - Set bit(s) low/high according to Z or !Z.",
        "instructions": {
          "BITNZ": {
            "mnemonic": "BITNZ",
            "syntax": "BITNZ   D,{#}S         {WCZ}",
            "encoding": "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITZ or BITNZ alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the Z flag. All other Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "BITZ": {
            "mnemonic": "BITZ",
            "syntax": "BITZ    D,{#}S         {WCZ}",
            "encoding": "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS",
            "description": "BITZ or BITNZ alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the Z flag. All other Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Z = original D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identifies the bit(s) to modify.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Events - Configuration": {
        "count": 5,
        "description": "Events - Configuration",
        "instructions": {
          "SETSE1": {
            "mnemonic": "SETSE1",
            "syntax": "SETSE1  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100000",
            "description": "Set SE1 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETPAT": {
            "mnemonic": "SETPAT",
            "syntax": "SETPAT  {#}D,{#}S",
            "encoding": "EEEE 1011111 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set pin pattern for PAT event. C selects INA/INB, Z selects =/!=, D provides mask value, S provides match value.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          },
          "SETSE2": {
            "mnemonic": "SETSE2",
            "syntax": "SETSE2  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100001",
            "description": "Set SE2 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETSE3": {
            "mnemonic": "SETSE3",
            "syntax": "SETSE3  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100010",
            "description": "Set SE3 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "SETSE4": {
            "mnemonic": "SETSE4",
            "syntax": "SETSE4  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000100011",
            "description": "Set SE4 event configuration to D[8:0].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Reverse bits of value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Reverse bits of value.",
        "instructions": {
          "REV": {
            "mnemonic": "REV",
            "syntax": "REV Dest",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 001101001                            D              \u2014                 \u2014                    2",
            "description": "The 32-bit pattern in Dest is reversed.\n\n\u21d2\n\nREV performs a bitwise reverse (bits 31:0 bits 0:31) of the value in Dest and stores the result back into Dest.\n\nThis is useful for processing binary data in a different MSB/LSB order than it is transmitted with.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register containing the bit value to reverse."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate a nibble left into a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate a nibble left into a value.",
        "instructions": {
          "ROLNIB": {
            "mnemonic": "ROLNIB",
            "syntax": "ROLNIB Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 100010N NNI DDDDDDDDD SSSSSSSSS                  D                \u2014                  \u2014                     2",
              "EEEE 1000100 000 DDDDDDDDD 000000000                  D                \u2014                  \u2014                     2"
            ],
            "description": "ROLNIB reads the nibble identified by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN Result: Nibble Num (0\u20137) of Src, or a nibble from a source described by prior ALTGN instruction, is rotated left into Dest.\n\nROLNIB reads the nibble identi\ufb01ed by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN\n\ninstruction, and rotates it left into Dest.\n\nROLNIB achieves the same effect as two instructions\u2014 a 4-bit SHL followed by SETNIB into nibble 0.\n\nNum (0\u20137) identi\ufb01es a value's individual nibbles, by position, in least-signi\ufb01cant nibble order.\n\nSyntax 2 is intended for use after an ALTGN instruction; i.e. in a loop to iteratively read a series of nibble values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to rotate the nibble into.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target nibble to read.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Src to read."
            ],
            "related": [
              "ALTGN",
              "ROLBYTE",
              "ROLWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 7
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds3get",
                "pattern": "D{,S/#,#0..7}",
                "description": "Get nibble: destination, optional source and nibble index 0-7",
                "valueType": 7
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch Return": {
        "count": 3,
        "description": "Branch Return",
        "instructions": {
          "RETB": {
            "mnemonic": "RETB",
            "syntax": "RETB             {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101111",
            "description": "Return by reading hub long (L) at --PTRB. C = L[31], Z = L[30], PC = L[19:0].                                             11...18 1 / 20...40",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "L[31], Z = L[30], PC = L[19:0]"
              },
              "Z": {
                "formula": "L[30], PC = L[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RETA": {
            "mnemonic": "RETA",
            "syntax": "RETA             {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101110",
            "description": "Return by reading hub long (L) at --PTRA. C = L[31], Z = L[30], PC = L[19:0].                                             11...18 1 / 20...40",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "L[31], Z = L[30], PC = L[19:0]"
              },
              "Z": {
                "formula": "L[30], PC = L[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          },
          "RET": {
            "mnemonic": "RET",
            "syntax": "RET              {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 000000000 000101101",
            "description": "Return by popping stack (K). C = K[31], Z = K[30], PC = K[19:0].",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {
              "C": {
                "formula": "K[31], Z = K[30], PC = K[19:0]"
              },
              "Z": {
                "formula": "K[30], PC = K[19:0]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 33
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_xlat",
                "pattern": "",
                "description": "No operands - translated instruction (RET*/RESI*/XSTOP)",
                "valueType": 33
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Math Instruction - Subtract one signed extended value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one signed extended value from another.",
        "instructions": {
          "SUBSX": {
            "mnemonic": "SUBSX",
            "syntax": "SUBSX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001111 CZI DDDDDDDDD SSSSSSSSS                     D          sign of D-(S+C)    Z AND (Result = 0)           2",
            "description": "SUBSX subtracts the signed value of Src plus C from the signed Dest and stores the result into the Dest register. Result: Difference of signed Dest and signed Src (plus C) is stored in Dest and optionally the C and Z flags are updated to the extended sign and zero status.\n\nSUBSX subtracts the signed value of Src plus C from the signed Dest and stores the result into the Dest register.\n\nThe SUBSX instruction is used to perform signed multi-long (extended) subtraction, such as 64-bit subtraction.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative (Result[31] = 1), or is cleared (0) if\n\npositive. Use WC or WCZ on preceding SUB and SUBX instructions for proper \ufb01nal C \ufb02ag.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and the result of Dest - (Src + C) is\n\nzero, or it is cleared (0) if non-zero. Use WZ or WCZ on preceding SUB and SUBX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo subtract signed multi-long values, use SUB (not SUBS) followed possibly by SUBX, and \ufb01nally SUBSX as\n\ndescribed in Subtracting Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "(Result = 0)"
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src plus C from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SUB",
              "SUBX",
              "SUBSX",
              "ADDSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to high (1) or low (0).": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) output level to high (1) or low (0).",
        "instructions": {
          "OUTH": {
            "mnemonic": "OUTH",
            "syntax": "OUTH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001001",
            "description": "OUTH or OUTL alters the output level register's bit(s) designated by Dest to be high (1) or low (0). All other bits Result: The I/O pin output level bit(s), described by Dest, are set high (1) or low (0); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "OUTL": {
            "mnemonic": "OUTL",
            "syntax": "OUTL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001000",
            "description": "OUTH or OUTL alters the output level register's bit(s) designated by Dest to be high (1) or low (0). All other bits Result: The I/O pin output level bit(s), described by Dest, are set high (1) or low (0); the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter D \ufb01eld of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter D \ufb01eld of next instruction.",
        "instructions": {
          "ALTD": {
            "mnemonic": "ALTD",
            "syntax": "ALTD Dest, {#}Src",
            "encoding": "EEEE 1001100 01I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTD modifies the next instruction's Dest value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax Result: The next instruction's pipelined Dest value is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.\n\nALTD modi\ufb01es the next instruction's Dest value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax\n\n2).\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base value (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base represents a starting point. ALTD adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine\n\nthe next instruction's Dest value.\n\n\u25cf   At the end of ALTD execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset\n\n(Dest) for a future ALTD+instruction iteration.\n\nIn syntax 2, Dest serves as the full value\u2014 it is used as-is for the next instruction's substitute Dest value.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution).",
              "The base represents a starting point. ALTD adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine the next instruction's Dest value.",
              "At the end of ALTD execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset (Dest) for a future ALTD+instruction iteration.",
              "The instruction following ALTD is shielded from interrupt",
              "ALTD alters the next instruction regardless of its kind",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to C.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to C.",
        "instructions": {
          "FLTNC": {
            "mnemonic": "FLTNC",
            "syntax": "FLTNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010011",
            "description": "FLTC or FLTNC sets the I/O pin(s) designated by Dest to the input direction and to a low/high output level Result: The I/O pins described by Dest are set to the input direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "FLTC": {
            "mnemonic": "FLTC",
            "syntax": "FLTC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010010",
            "description": "FLTC or FLTNC sets the I/O pin(s) designated by Dest to the input direction and to a low/high output level Result: The I/O pins described by Dest are set to the input direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub Control - Multi": {
        "count": 1,
        "description": "Hub Control - Multi",
        "instructions": {
          "HUBSET": {
            "mnemonic": "HUBSET",
            "syntax": "HUBSET  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000000000",
            "description": "Set hub con\ufb01guration to D.                                                                                               2...9 / same",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "I/O Pin Instruction - Toggle pin(s) to the opposite direction.": {
        "count": 1,
        "description": "I/O Pin Instruction - Toggle pin(s) to the opposite direction.",
        "instructions": {
          "DIRNOT": {
            "mnemonic": "DIRNOT",
            "syntax": "DIRNOT {#}Dest {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000111                 DIRx       Orig DIRx base bit Orig DIRx base bit           2",
            "description": "DIRNOT alters the direction register's bit(s) designated by Dest to their inverse state. All other bits are left Result: The I/O pin direction bit(s), described by Dest, are toggled to their opposite state(s); the rest are left as-is. Z = DIR bit.\n\nDIRNOT alters the direction register's bit(s) designated by Dest to their inverse state. All other bits are left\n\nunchanged.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DIRNOT instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DIRNOT's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of DIRA / DIRB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to toggle to the opposite direction.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "DIRRND",
              "DIRL",
              "DIRH",
              "DIRC",
              "DIRNC",
              "DIRZ",
              "DIRNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "System Control Instruction": {
        "count": 2,
        "description": "System Control Instruction",
        "instructions": {
          "DEBUG": {
            "mnemonic": "DEBUG",
            "syntax": "DEBUG",
            "encoding": "TBD",
            "description": "Debug instruction. Provides debugging functionality during program execution.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "DEBUG",
              "encoding": {
                "bits": 32,
                "opcode": 54,
                "effects": 0,
                "operandFormat": 37,
                "rawValue": 75830
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_debug",
                "pattern": "",
                "description": "Debug instruction - no operands",
                "valueType": 37
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          },
          "ASMCLK": {
            "mnemonic": "ASMCLK",
            "syntax": "ASMCLK",
            "encoding": "TBD",
            "description": "Assembly clock instruction. Controls assembly-time clock operations.",
            "timing": {
              "cycles": "TBD",
              "type": "TBD"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "ASMCLK",
              "encoding": {
                "bits": 32,
                "opcode": 0,
                "effects": 0,
                "operandFormat": 35,
                "rawValue": 71680
              },
              "category": "Miscellaneous",
              "effects": [],
              "operand_format": {
                "name": "operand_asmclk",
                "pattern": "",
                "description": "Assembly clock instruction - no operands",
                "valueType": 35
              }
            },
            "documentation_source": "PNUT_TS_compiler_analysis",
            "documentation_level": "minimal"
          }
        }
      },
      "Math Instruction - Compare two signed values.": {
        "count": 1,
        "description": "Math Instruction - Compare two signed values.",
        "instructions": {
          "CMPS": {
            "mnemonic": "CMPS",
            "syntax": "CMPS Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010010 CZI DDDDDDDDD SSSSSSSSS                  \u2014           Signed (D < S)       D=S                    2",
            "description": "CMPS compares the signed values of Dest and Src (by subtracting Src from Dest) and optionally setting the C and Result: Greater/lesser and equality status is optionally written to the C and Z flags.\n\nCMPS compares the signed values of Dest and Src (by subtracting Src from Dest) and optionally setting the C and\n\nZ \ufb02ags to indicate the comparison and operation results.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest is less than Src.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest equals Src.\n\nTo compare signed, multi-long values, use CMP (not CMPS) followed possibly by CMPX, and \ufb01nally CMPSX as\n\ndescribed in Comparing Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "correct sign of (D - S)"
              },
              "Z": {
                "formula": "(D == S)"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with that of Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "CMP",
              "CMPX",
              "CMPSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Subtract one unsigned extended value from another.": {
        "count": 1,
        "description": "Math Instruction - Subtract one unsigned extended value from another.",
        "instructions": {
          "SUBX": {
            "mnemonic": "SUBX",
            "syntax": "SUBX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0001101 CZI DDDDDDDDD SSSSSSSSS                   D         borrow of D-(S+C) Z AND (Result = 0)             2",
              "EEEE 0011100 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2",
              "EEEE 0011101 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2",
              "EEEE 0011110 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2",
              "EEEE 0011111 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2"
            ],
            "description": "SUBX subtracts the unsigned value of Src plus C from the unsigned Dest and stores the result into the Dest Result: Difference of unsigned Dest and unsigned Src (plus C) is stored in Dest and optionally the C and Z flags are updated to the extended borrow and zero status.\n\nSUBX subtracts the unsigned value of Src plus C from the unsigned Dest and stores the result into the Dest\n\nregister. The SUBX instruction is used to perform unsigned multi-long (extended) subtraction, such as 64-bit\n\nsubtraction.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the subtraction results in an unsigned borrow, or is\n\ncleared (0) if no borrow. Use WC or WCZ on preceding SUB and SUBX instructions for proper \ufb01nal C \ufb02ag. If C is set\n\nafter the last SUBX in a multi-long subtraction, it indicates unsigned under\ufb02ow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and the result of Dest - (Src + C) is\n\nzero, or it is cleared (0) if non-zero. Use WZ or WCZ on preceding SUB and SUBX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo subtract unsigned multi-long values, use SUB followed by one or more SUBX instructions as described in\n\nSubtracting Two Multi-Long Values.\n\nSUMC / SUMNC\n\nSum C or Sum not C\n\nMath Instruction - Adjust signed value by other C-negated or !C-negated value.\n\nSUMC Dest, {#}Src       {WC|WZ|WCZ}\n\nSUMNC Dest, {#}Src {WC|WZ|WCZ}\n\nResult: The sum of signed Dest and either Src or -Src (according to C) is stored in Dest and optionally the C and Z\n\n\ufb02ags are updated to the sign and zero status.\n\n\u25cf    Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.\n\n\u25cf    Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if C=0 or !C=0) or negated value (if\n\nC=1 or !C=1) is added into Dest.\n\n\u25cf    WC, WZ, or WCZ are optional effects to update \ufb02ags.\n\nCOND INSTR         FX      DEST          SRC           Write             C Flag              Z Flag             Clocks\n\nEEEE 0011100 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2\n\nEEEE 0011101 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2\n\nRelated: SUMZ and SUMNZ\n\nSUMC or SUMNC adjusts the signed Dest value by Src or -Src (depending on C or !C) and stores the result into the\n\nDest register. Prior to adding to Dest, the Src value is negated if C (SUMC) or !C (SUMNC) is 1.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest +/- Src is zero, or is cleared (0) if it is\n\nnon-zero.\n\nSUMZ / SUMNZ\n\nSum Z or Sum not Z\n\nMath Instruction - Adjust signed value by other Z-negated or !Z-negated value.\n\nSUMZ Dest, {#}Src       {WC|WZ|WCZ}\n\nSUMNZ Dest, {#}Src {WC|WZ|WCZ}\n\nResult: The sum of signed Dest and either Src or -Src (according to Z) is stored in Dest and optionally the C and Z\n\n\ufb02ags are updated to the sign and zero status.\n\n\u25cf    Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.\n\n\u25cf    Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0 or !Z=0) or negated value (if\n\nZ=1 or !Z=1) is added into Dest.\n\n\u25cf    WC, WZ, or WCZ are optional effects to update \ufb02ags.\n\nCOND INSTR         FX      DEST          SRC           Write             C Flag              Z Flag             Clocks\n\nEEEE 0011110 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2\n\nEEEE 0011111 CZI DDDDDDDDD SSSSSSSSS                    D           sign of (D +/- S)     Result = 0                2\n\nRelated: SUMC and SUMNC\n\nSUMZ or SUMNZ adjusts the signed Dest value by Src or -Src (depending on Z or !Z) and stores the result into the\n\nDest register. Prior to adding to Dest, the Src value is negated if Z (SUMZ) or !Z (SUMNZ) is 1.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest +/- Src is zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to subtract Src plus C from, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if C=0 or !C=0) or negated value (if C=1 or !C=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "Dest is a register containing the signed value to adjust by Src or -Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0 or !Z=0) or negated value (if Z=1 or !Z=1) is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SUMC",
              "SUMNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set bit(s) random low/high.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set bit(s) random low/high.",
        "instructions": {
          "BITRND": {
            "mnemonic": "BITRND",
            "syntax": "BITRND Dest, {#}Src {WCZ}",
            "encoding": [
              "EEEE 0100110 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit         2",
              "EEEE 0100100 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit         2",
              "EEEE 0100101 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit         2"
            ],
            "description": "BITRND alters the Dest bit(s) designated by Src to each be an independent random low and high value, based on Result: Dest bit(s) described by Src are each set randomly low or high; the rest are left as-is. Z = original D[S[4:0]].\n\nBITRND alters the Dest bit(s) designated by Src to each be an independent random low and high value, based on\n\nbit(s) from the Xoroshiro128** PRNG. All other bits are left unchanged.\n\nSrc[4:0] indicates the bit number (0\u201431). For a range of bits, Src[4:0] indicates the base bit number (0\u201431) and\n\nSrc[9:5] indicates how many contiguous bits beyond the base should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the base bit (Src[4:0]) and a range of up to 16 contiguous bits (Src[8:5]). If\n\nneeded, use the augmented literal feature (##Src) to augment Src to a 10-bit literal value\u2014 this inserts an AUGS\n\ninstruction prior.\n\nWhen Src is a register, the register's value bits [9:0] are used as-is to form the 10-bit ID range, unless a SETQ\n\ninstruction immediately precedes the BITRND instruction; substituting SETQ's Dest[4:0] in place of value bits[9:5],\n\nfor BITRND's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of Dest's base bit, identi\ufb01ed by Src.\n\nBITZ / BITNZ\n\nBit Z or not Z\n\nBit Operation Instruction - Set bit(s) low/high according to Z or !Z.\n\nBITZ    Dest, {#}Src {WCZ}\n\nBITNZ Dest, {#}Src {WCZ}\n\nResult: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is.\n\n\u25cf   Dest is the register whose value will have one or more bits set to Z or !Z.\n\n\u25cf   Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX     DEST          SRC           Write            C Flag              Z Flag             Clocks\n\nEEEE 0100100 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit         2\n\nEEEE 0100101 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit         2\n\nBITZ or BITNZ alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the Z \ufb02ag. All other\n\nbits are left unchanged.\n\nSrc[4:0] indicates the bit number (0\u201431). For a range of bits, Src[4:0] indicates the base bit number (0\u201431) and\n\nSrc[9:5] indicates how many contiguous bits beyond the base should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the base bit (Src[4:0]) and a range of up to 16 contiguous bits (Src[8:5]). If\n\nneeded, use the augmented literal feature (##Src) to augment Src to a 10-bit literal value\u2014 this inserts an AUGS\n\ninstruction prior.\n\nWhen Src is a register, the register's value bits [9:0] are natrally used as-is to form the 10-bit ID range, unless a\n\nSETQ instruction immediately precedes the BITZ / BITNZ instruction; substituting SETQ's Dest[4:0] in place of\n\nvalue bits[9:5], for BITZ / BITNZ's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of Dest's base bit, identi\ufb01ed by Src.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set randomly low or high.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to Z.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to Z.",
        "instructions": {
          "FLTNZ": {
            "mnemonic": "FLTNZ",
            "syntax": "FLTNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010101",
            "description": "The I/O pins described by Dest are set to the input direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "FLTZ": {
            "mnemonic": "FLTZ",
            "syntax": "FLTZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010100",
            "description": "The I/O pins described by Dest are set to the input direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry and zero \ufb02ags right into value (2-bit rotate right).": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry and zero \ufb02ags right into value (2-bit rotate right).",
        "instructions": {
          "RCZR": {
            "mnemonic": "RCZR",
            "syntax": "RCZR Dest {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 DDDDDDDDD 001101010                     D                   D[1]                D[0]                2",
            "description": "RCZR shifts Dest's binary value right by two places and sets Dest[31] to C and Dest[30] to Z. Result: The bits of Dest are shifted right by two places and C and Z are inserted as new MSBs.\n\nRCZR shifts Dest's binary value right by two places and sets Dest[31] to C and Dest[30] to Z.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the original Dest[1] state.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z is \ufb02ag is updated to the original Dest[0] state.\n\nRegisters\n\nSpecial Purpose Registers - Rotate a byte left into a value.\n\nMost Reg RAM registers are general-purpose (used for code and data) while a small set has a special purpose.\n\nName Address                  Access2             Special Purpose\n\nIJMP3        $1F01               Read/Write           Interrupt call address for INT3; set by code\n\nIRET3        $1F1 1\n\nRead/Write           Interrupt return address and C/Z flags for INT3; set by cog\n\nIJMP2        $1F21               Read/Write           Interrupt call address for INT2; set by code\n\nIRET2        $1F31               Read/Write           Interrupt return address and C/Z flags for INT2; set by cog\n\nIJMP1        $1F4 1\n\nRead/Write           Interrupt call address for INT1; set by code\n\nIRET1        $1F5 1\n\nRead/Write           Interrupt return address and C/Z flags for INT1; set by cog\n\nPA      $1F61               Read/Write           CALLD-imm return, CALLPA parameter, or LOC address\n\nPB      $1F71               Read/Write           CALLD-imm return, CALLPB parameter, or LOC address\n\nPTRA     $1F8       Read Special / Write Special Pointer A to Hub RAM\n\nPTRB     $1F9       Read Special / Write Special Pointer B to Hub RAM\n\nDIRA     $1FA            Read / Write Special     Output enables (direction bits) for P31..P0\n\nDIRB     $1FB            Read / Write Special     Output enables (direction bits) for P63..P32\n\nOUTA     $1FC            Read / Write Special     Output states for P31..P0\n\nOUTB     $1FD            Read / Write Special     Output states for P63..P32\n\nINA      $1FE3              Read Special          Input states for P31..P0\n\n4\n\nINB      $1FF               Read Special          Input states for P63..P32\n\n1\n\nLocations $1F0\u2013$1F7 are general-purpose code/data registers by default but become these named special-purpose\n\nregisters if their associated functions are enabled.\n\n2\n\nMost reads and writes involve the underlying Reg RAM at these locations; however, those marked \"special\" may read from a\n\nspecial internal register (instead of Reg RAM) or write to both the Reg RAM location as well as to a special internal register.\n\n3\n\nAlso debug interrupt call address.\n\n4\n\nAlso debug interrupt return address.\n\nAdditionally, for PASM2 code that is either in-line (within a Spin2 method) or called (by a Spin2 method), the\n\nregisters $1D8\u2013$1DF are readable/writable by both languages using the symbols PR0\u2013PR7. PASM2 code that is\n\nlaunched into another cog does not share this Reg RAM space with Spin2.\n\nName           Address           Access        Special Purpose\n\nPR0\u2013PR7         $1D8\u2013$1DF         Read/Write      PASM2        \u21c4 Spin2 communication mechanism",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "D[1], Z = D[0]",
                "when": "D"
              },
              "Z": {
                "formula": "D[0]",
                "when": "D[1]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate the carry and zero \ufb02ags right into.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a value into a register.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a value into a register.",
        "instructions": {
          "MOV": {
            "mnemonic": "MOV",
            "syntax": "MOV Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0110000 CZI DDDDDDDDD SSSSSSSSS                    D               S[31]            Result = 0                  2",
            "description": "Mov stores the Src value into Dest. Result: The Src value is stored in Dest and optionally flags are updated with the sign bit and zero status.\n\nMov stores the Src value into Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to be Src[31].\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "S[31] Result =",
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register to receive the Src value.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "MOV D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 192,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1728
              },
              "category": "Data Movement",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Toggle pin(s) to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Toggle pin(s) to the opposite output level.",
        "instructions": {
          "OUTNOT": {
            "mnemonic": "OUTNOT",
            "syntax": "OUTNOT {#}Dest {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001001111                OUTx       Orig OUTx base bit Orig OUTx base bit            2",
            "description": "OUTNOT alters the output level register's bit(s) designated by Dest to their inverse state. All other bits are left Result: The I/O pin output level bit(s), described by Dest, are toggled to their opposite state(s); the rest are left as-is. Z = OUT bit.\n\nOUTNOT alters the output level register's bit(s) designated by Dest to their inverse state. All other bits are left\n\nunchanged.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the OUTNOT instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for OUTNOT's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to toggle to the opposite output level.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO": {
        "count": 1,
        "description": "Hub FIFO",
        "instructions": {
          "GETPTR": {
            "mnemonic": "GETPTR",
            "syntax": "GETPTR  D",
            "encoding": "EEEE 1101011 000 DDDDDDDDD 000110100",
            "description": "Get current FIFO hub pointer into D.                                                                                   2 / FIFO IN USE",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 24
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_d",
                "pattern": "D",
                "description": "Destination register only",
                "valueType": 24
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Bitwise XOR a value with another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Bitwise XOR a value with another.",
        "instructions": {
          "XOR": {
            "mnemonic": "XOR",
            "syntax": "XOR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0101011 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0               2",
            "description": "XOR performs a bitwise XOR of the value in Src into that of Dest. Result: Dest XOR Src is stored in Dest and flags are optionally updated with parity and zero status.\n\nXOR performs a bitwise XOR of the value in Src into that of Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result contains an odd number of high (1) bits, or is\n\ncleared (0) if it contains an even number of high bits.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest XOR Src result equals zero, or is cleared (0) if it\n\nis non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register containing the value to bitwise XOR with Src and is the destination in which to write the result.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value will be bitwise XORed into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Interrupt Instruction - Trigger breakpoint in current cog.": {
        "count": 1,
        "description": "Interrupt Instruction - Trigger breakpoint in current cog.",
        "instructions": {
          "BRK": {
            "mnemonic": "BRK",
            "syntax": "BRK {#}Dest",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110110               Code/Cond.1             \u2014                  \u2014                    2",
            "description": "BRK triggers a breakpoint in the current cog and either defines a breakpoint code or the\nnext breakpoint Result: If debug interrupts are enabled, a debug interrupt is triggered in the current\ncog and Dest's value becomes the debug code or the next debug condition.\n\nKey uses:\n- Software breakpoints for debugging\n- Conditional debug triggers\n- Communication with debug monitor\n- Assertion failures and error handling\n\n\nBRK triggers a breakpoint in the current cog and either de\ufb01nes a breakpoint code or the next breakpoint\n\ncondition(s). The cog must have debug interrupts enabled, and if BRK is to be executed within the normal\n\nprogram (outside the Debug ISR), the \"BRK instruction\" interrupt must \ufb01rst be enabled from within a prior Debug\n\nISR (interrupt service routine).\n\nDuring normal program execution, the BRK instruction is used to generate a debug interrupt with an 8-bit code\n\n(from D[7:0]) which can be read within the Debug ISR using a GETBRK instruction.\n\nDuring a Debug ISR, the BRK instruction is used instead to establish the next debug interrupt condition(s) and to\n\nselect INA/INB, instead of the IJMP0/IRET0 registers exposed during the ISR, so that the pins' inputs states may\n\nbe read.\n\nThe format of Dest for Debug ISR use is %AAAAAAAAAAAAAAAAAAAA_BCDEFGHIJKLM\n\nA: 20-bit breakpoint address or 4-bit event code\n\nB: 1 = map INA/INB normally, 0 = map IJMP0/IRET0 at INA/INB (default during ISR). If Debug ISR sets B\n\nto 1, it must reset it to 0 before exiting the Debug ISR so the RETI0 instruction sees IJMP0 and IRET0.\n\nC: 1 = enable interrupt on breakpoint address match\n\nD: 1 = enable interrupt on event %eeee\n\nE: 1 = enable interrupt on asynchronous breakpoint (via COGBRK from another cog)\n\nF: 1 = enable interrupt on INT3 ISR entry\n\nG: 1 = enable interrupt on INT2 ISR entry\n\nH: 1 = enable interrupt on INT1 ISR entry\n\nI: 1 = enable interrupt on BRK instruction\n\nJ: 1 = enable interrupt on INT3 ISR code (single step)\n\nK: 1 = enable interrupt on INT2 ISR code (single step)\n\nL: 1 = enable interrupt on INT1 ISR code (single step)\n\nM: 1 = enable interrupt on non-ISR code (single step)\n\nUpon Debug ISR entry, bits B through M are cleared (0). If a subsequent debug interrupt is desired, a BRK\n\ninstruction must be executed before exiting the Debug ISR in order to establish the next breakpoint condition(s).",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "Code/Cond.1"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 32-bit augmented literal whose value becomes the debug code or condition depending on the state of execution (outside or inside of a Debug ISR)."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and to an output level of high (1) or low (0).": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and to an output level of high (1) or low (0).",
        "instructions": {
          "FLTL": {
            "mnemonic": "FLTL",
            "syntax": "FLTL    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010000",
            "description": "FLTH or FLTL sets the I/O pin(s) designated by Dest to the input direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the input direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "FLTH": {
            "mnemonic": "FLTH",
            "syntax": "FLTH    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010001",
            "description": "FLTH or FLTL sets the I/O pin(s) designated by Dest to the input direction and to a high or low output level; i.e. Result: The I/O pins described by Dest are set to the input direction and to an output level of high or low; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to input direction and output levels of high or low.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Get the absolute value of a number.": {
        "count": 1,
        "description": "Math Instruction - Get the absolute value of a number.",
        "instructions": {
          "ABS": {
            "mnemonic": "ABS",
            "syntax": "ABS Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110010 CZI DDDDDDDDD SSSSSSSSS                    D                S[31]            Result = 0              2",
              "EEEE 0110010 CZ0 DDDDDDDDD DDDDDDDDD                    D                D[31]            Result = 0              2"
            ],
            "description": "ABS determines the absolute value of Src or Dest and writes the result into Dest. Result: Absolute Src (or Dest) value is stored in Dest.\n\nABS determines the absolute value of Src or Dest and writes the result into Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the original Src or Dest value was negative, or is cleared\n\n(0) if it was positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.\n\nLiteral Src values are zero-extended, so ABS is really best used with register Src (or augmented Src) values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "D[31] Result =",
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register in which to write the absolute value of Dest or Src.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose absolute value is written to Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "NEG"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Interrupt Instruction - Allow interrupts.": {
        "count": 1,
        "description": "Interrupt Instruction - Allow interrupts.",
        "instructions": {
          "ALLOWI": {
            "mnemonic": "ALLOWI",
            "syntax": "ALLOWI",
            "encoding": "EEEE 1101011 000 000100000 000100100                      \u2014                  \u2014                   \u2014                    2",
            "description": "ALLOWI re-enables interrupt branching; the default on cog start. ALLOWI is the complement of the STALLI Result: Any stalled and future interrupts are allowed.\n\nALLOWI re-enables interrupt branching; the default on cog start. ALLOWI is the complement of the STALLI\n\ninstruction\u2014 both are used to protect short, vital sections of main code from timing jitter or state loss caused by\n\nasynchronous interrupt handling.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [
              "STALLI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Create signed 18-bit scale value for next instruction's S value.": {
        "count": 1,
        "description": "Math Instruction - Create signed 18-bit scale value for next instruction's S value.",
        "instructions": {
          "SCAS": {
            "mnemonic": "SCAS",
            "syntax": "SCAS Dest, {#}Src {WZ}",
            "encoding": "EEEE 1010001 1ZI DDDDDDDDD SSSSSSSSS                      \u2014                 \u2014          Product = 0                2",
            "description": "SCAS multiplies the lower, signed 16-bits of each of Dest and Src together, right shifts the 32-bit product by 14 (to Result: The upper 18 bits of the signed product from the 16-bit Dest and Src multiplication is substituted as the next instruction's Src value and optionally the Z flag is updated to the zero status.\n\nSCAS multiplies the lower, signed 16-bits of each of Dest and Src together, right shifts the 32-bit product by 14 (to\n\nscale down the result), and substitutes this value as the next instruction's Src value.\n\nIf the WZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the product (before scaling down) is zero, or is cleared (0) if\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register containing the signed 16-bit value to multiply with Src.",
              "Src is a register, 9-bit literal, or signed 16-bit augmented literal whose value is multiplied with Dest.",
              "WZ is an optional effect to update the Z \ufb02ag."
            ],
            "related": [
              "SCA"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear pin-pattern-detected event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear pin-pattern-detected event \ufb02ag.",
        "instructions": {
          "POLLPAT": {
            "mnemonic": "POLLPAT",
            "syntax": "POLLPAT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001000 000100100                 \u2014            PAT Event         PAT Event                 2",
            "description": "POLLPAT copies the state of the pin-pattern-detected event flag into C and/or Z and then clears the flag (unless Result: Pin-pattern-detected event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLPAT copies the state of the pin-pattern-detected event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless\n\nit's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the pin-pattern-detected\n\nevent \ufb02ag prior to clearing it.\n\nThe pin-pattern-detected event \ufb02ag is set whenever the masked input pins match or don't match the pattern\n\ndescribed by a previous SETPAT instruction. The pin-pattern-detected event \ufb02ag is cleared upon execution of\n\nSETPAT, POLLPAT, WAITPAT, JPAT, or JNPAT instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "SETPAT",
              "WAITPAT",
              "JPAT",
              "JNPAT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to Z or !Z.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to Z or !Z.",
        "instructions": {
          "DRVNZ": {
            "mnemonic": "DRVNZ",
            "syntax": "DRVNZ   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011101",
            "description": "DRVZ or DRVNZ sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DRVZ": {
            "mnemonic": "DRVZ",
            "syntax": "DRVZ    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011100",
            "description": "DRVZ or DRVNZ sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to Z or !Z; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to C.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to C.",
        "instructions": {
          "NEGC": {
            "mnemonic": "NEGC",
            "syntax": "NEGC Dest, {#}Src       {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110100 CZI DDDDDDDDD SSSSSSSSS                    D            Sign of result       Result = 0               2",
              "EEEE 0110100 CZ0 DDDDDDDDD DDDDDDDDD                    D            Sign of result       Result = 0               2"
            ],
            "description": "NEGC negates Src (syntax 1) or Dest (syntax 2) if C = 1 and stores the result in the Dest register. If C = 0, the Src Result: The Src or Dest value, possibly negated according to C, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.\n\nNEGC negates Src (syntax 1) or Dest (syntax 2) if C = 1 and stores the result in the Dest register. If C = 0, the Src\n\nor Dest value is left as-is (not negated) and is stored into Dest. If the negation is performed, it \ufb02ips the value's\n\nsign; ex: 5 becomes -5, or -200 becomes 200.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to C.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if C=0) or negated value (if C=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "NEGNC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test D by bitwise ANDing with !S to affect \ufb02ags only.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test D by bitwise ANDing with !S to affect \ufb02ags only.",
        "instructions": {
          "TESTN": {
            "mnemonic": "TESTN",
            "syntax": "TESTN Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0111111 CZI DDDDDDDDD SSSSSSSSS                   \u2014         Parity of (D & !S)     (D & !S) = 0               2",
              "EEEE 1101011 CZL DDDDDDDDD 001000000                  \u2014            IN[D[5:0]]         IN[D[5:0]]                2",
              "EEEE 1101011 CZL DDDDDDDDD 001000010                  \u2014        C AND IN[D[5:0]] Z AND IN[D[5:0]]                2",
              "EEEE 1101011 CZL DDDDDDDDD 001000100                  \u2014         C OR IN[D[5:0]]    Z OR IN[D[5:0]]              2",
              "EEEE 1101011 CZL DDDDDDDDD 001000110                  \u2014        C XOR IN[D[5:0]] Z XOR IN[D[5:0]]                2",
              "EEEE 1101011 CZL DDDDDDDDD 001000001                  \u2014            !IN[D[5:0]]        !IN[D[5:0]]               2",
              "EEEE 1101011 CZL DDDDDDDDD 001000011                  \u2014        C AND !IN[D[5:0]] Z AND !IN[D[5:0]]              2",
              "EEEE 1101011 CZL DDDDDDDDD 001000101                  \u2014         C OR !IN[D[5:0]]   Z OR !IN[D[5:0]]             2",
              "EEEE 1101011 CZL DDDDDDDDD 001000111                  \u2014        C XOR !IN[D[5:0]] Z XOR !IN[D[5:0]]              2",
              "EEEE 1011101 00I DDDDDDDDD SSSSSSSSS                        PC    1",
              "EEEE 1011101 10I DDDDDDDDD SSSSSSSSS                        PC    1"
            ],
            "description": "TESTN determines the parity (number of high (1) bits) and the zero or non-zero state of Dest bitwise ANDed with Result: The parity and zero-state of Dest bitwise ANDed with !Src is stored in the C and Z flags. C = parity of (D & !S).\n\nTESTN determines the parity (number of high (1) bits) and the zero or non-zero state of Dest bitwise ANDed with\n\n!Src and stores the results in the C and/or Z \ufb02ag.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the number of high (1) bits in Dest ANDed with !Src is\n\nodd, or is cleared (0) if it is even.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Dest ANDed with !Src is zero, or is cleared (0) if it is not\n\nzero.\n\nTESTP / TESTPN\n\nTest pin or pin not\n\nI/O Pin Instruction - Test pin and either store, AND, OR, or XOR the result or inverse result into C/Z.\n\nTESTP    {#}Dest WC|WZ\n\nTESTP    {#}Dest ANDC|ANDZ\n\nTESTP    {#}Dest ORC|ORZ\n\nTESTP    {#}Dest XORC|XORZ\n\nTESTPN {#}Dest WC|WZ\n\nTESTPN {#}Dest ANDC|ANDZ\n\nTESTPN {#}Dest ORC|ORZ\n\nTESTPN {#}Dest XORC|XORZ\n\nResult: The state of the I/O pin described by Dest is read, possibly inverted, and either stored as-is, or bitwise\n\nANDed, ORed, or XORed into C or Z.\n\n\u25cf   Dest is the register or 6-bit literal whose value identi\ufb01es the I/O pin to test.\n\n\u25cf   WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C\n\nor Z \ufb02ag.\n\nCOND INSTR        FX     DEST          SRC           Write            C Flag            Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001000000                  \u2014            IN[D[5:0]]         IN[D[5:0]]                2\n\nEEEE 1101011 CZL DDDDDDDDD 001000010                  \u2014        C AND IN[D[5:0]] Z AND IN[D[5:0]]                2\n\nEEEE 1101011 CZL DDDDDDDDD 001000100                  \u2014         C OR IN[D[5:0]]    Z OR IN[D[5:0]]              2\n\nEEEE 1101011 CZL DDDDDDDDD 001000110                  \u2014        C XOR IN[D[5:0]] Z XOR IN[D[5:0]]                2\n\nEEEE 1101011 CZL DDDDDDDDD 001000001                  \u2014            !IN[D[5:0]]        !IN[D[5:0]]               2\n\nEEEE 1101011 CZL DDDDDDDDD 001000011                  \u2014        C AND !IN[D[5:0]] Z AND !IN[D[5:0]]              2\n\nEEEE 1101011 CZL DDDDDDDDD 001000101                  \u2014         C OR !IN[D[5:0]]   Z OR !IN[D[5:0]]             2\n\nEEEE 1101011 CZL DDDDDDDDD 001000111                  \u2014        C XOR !IN[D[5:0]] Z XOR !IN[D[5:0]]              2\n\nRelated: TESTB and TESTBN\n\nTESTP or TESTPN reads the state (0/1) of the I/O pin designated by Dest, possibly inverts that result, and either\n\nstores it as-is, or bitwise ANDs, ORs, or XORs it into the C or Z \ufb02ag. Dest[5:0] indicates the pin number (0\u201363) to\n\ntest.\n\nIf the WC or WZ effect is speci\ufb01ed, the C or Z \ufb02ag is overwritten with the state or inverse state of the pin.\n\nIf the ANDC or ANDZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise ANDed with the state or inverse state of the pin.\n\nIf the ORC or ORZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise ORed with the state or inverse state of the pin.\n\nIf the XORC or XORZ effect is speci\ufb01ed, the C or Z \ufb02ag is bitwise XORed with the state or inverse state of the pin.\n\nTJF / TJNF\n\nTest, jump if full or not full\n\nFlow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).\n\nTJF        Dest, {#}Src\n\nTJNF Dest, {#}Src\n\nResult: Dest is tested and if it's full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src)\n\naddress.\n\n\u25cf    Dest is a register whose value is tested for full or not full.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC             Write       C Flag             Z Flag             Clocks\n\nEEEE 1011101 00I DDDDDDDDD SSSSSSSSS                        PC    1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011101 01I DDDDDDDDD SSSSSSSSS                        PC1         \u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when Dest is full (or not full in syntax 2).\n\nTJF or TJNF tests the value in Dest and jumps to the address described by Src if the result is full (-1; $FFFF_FFFF;\n\nin syntax 1) or not full (<> -1; <> $FFFF_FFFF; in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the TJF / TJNF. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).\n\nTJS / TJNS\n\nTest, jump if signed or not signed\n\nFlow Control Instruction - Test value and jump if signed or not signed.\n\nTJS        Dest, {#}Src\n\nTJNS Dest, {#}Src\n\nResult: Dest is tested and if it's signed (or not signed in syntax 2), PC is set to a new relative (#Src) or absolute\n\n(Src) address.\n\n\u25cf    Dest is a register whose value is tested for sign or no sign.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC             Write       C Flag             Z Flag             Clocks\n\nEEEE 1011101 10I DDDDDDDDD SSSSSSSSS                        PC    1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011101 11I DDDDDDDDD SSSSSSSSS                        PC    1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when Dest is signed (or not signed in syntax 2).\n\nTJS or TJNS tests the value in Dest and jumps to the address described by Src if the result is signed (Dest[31] = 1)\n\nor not signed (Dest[31] = 0).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the TJS / TJNS. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of (D & !S)"
              },
              "Z": {
                "formula": "((D & !S) == 0)"
              }
            },
            "parameters": [
              "Dest is the register whose value will be tested.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose inverse value is ANDed with Dest.",
              "WC, WZ, and WCZ are optional effects to update \ufb02ags.",
              "Dest is the register or 6-bit literal whose value identi\ufb01es the I/O pin to test.",
              "WC, WZ, ANDC, ANDZ, ORC, ORZ, XORC, and XORZ is a required effect to update or bitwise manipulate the C or Z \ufb02ag.",
              "Dest is a register whose value is tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Dest is a register whose value is tested for sign or no sign.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [
              "TESTB",
              "TESTBN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Miscellaneous Instruction - No operation, just elapse two cycles.": {
        "count": 1,
        "description": "Miscellaneous Instruction - No operation, just elapse two cycles.",
        "instructions": {
          "NOP": {
            "mnemonic": "NOP",
            "syntax": "NOP",
            "encoding": "0000 0000000 000 000000000 000000000",
            "description": "NOP simply consumes two clock cycles; no other operation is performed. Result: Two clock cycles are consumed.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 36
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_nop",
                "pattern": "",
                "description": "No operation - no operands",
                "valueType": 36
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear attention \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear attention \ufb02ag.",
        "instructions": {
          "POLLATN": {
            "mnemonic": "POLLATN",
            "syntax": "POLLATN {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001110 000100100                  \u2014            ATN Event           ATN Event                 2",
            "description": "POLLATN copies the state of the attention event flag into C and/or Z and then clears the flag (unless it's being set Result: Attention event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLATN copies the state of the attention event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless it's being set\n\nagain by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the attention event \ufb02ag\n\nprior to clearing it.\n\nThe attention event \ufb02ag is set whenever another cog issues an attention request for this cog. The attention event\n\n\ufb02ag is cleared upon cog start, or execution of POLLATN, WAITATN, JATN, or JNATN instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "COGATN",
              "WAITATN",
              "JATN",
              "JNATN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instructions - Set discrete bits to Z or !Z": {
        "count": 2,
        "description": "Bit Operation Instructions - Set discrete bits to Z or !Z",
        "instructions": {
          "MUXNZ": {
            "mnemonic": "MUXNZ",
            "syntax": "MUXNZ   D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "MUXZ or MUXNZ alters the Dest bit(s) designated by Src (high bits) to equal the state, or inverse state, of the Z flag. Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Flags are optionally updated with parity and zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identifies the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "MUXZ": {
            "mnemonic": "MUXZ",
            "syntax": "MUXZ    D,{#}S   {WC/WZ/WCZ}",
            "encoding": "EEEE 0101110 CZI DDDDDDDDD SSSSSSSSS",
            "description": "MUXZ or MUXNZ alters the Dest bit(s) designated by Src (high bits) to equal the state, or inverse state, of the Z flag. Result: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Flags are optionally updated with parity and zero status of the result.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "parity of result"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identifies the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if over\ufb02owed.": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if over\ufb02owed.",
        "instructions": {
          "TJV": {
            "mnemonic": "TJV",
            "syntax": "TJV Dest, {#}Src",
            "encoding": [
              "EEEE 1011110 00I DDDDDDDDD SSSSSSSSS                     PC   1",
              "EEEE 1011100 10I DDDDDDDDD SSSSSSSSS                     PC   1"
            ],
            "description": "Test D and jump to S** if D overflowed (D[31] != C, C = 'correct sign' from last addition/subtraction).\n\n\nTJV tests the value in Dest against C and jumps to the address described by Src if Dest has over\ufb02owed\n\n(Dest[31] != C). This instruction requires that C be updated (to the correct sign) by the previous ADDS / ADDSX /\n\nSUBS / SUBSX / CMPS / CMPSX / SUMx instruction.\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the TJV. The signed offset value is in units of whole\n\ninstructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to PC\n\nwhen in Hub execution mode (long-aligned Hub code not required).\n\nTJZ / TJNZ\n\nTest, jump if zero or not zero\n\nFlow Control Instruction - Test value and jump if zero or not zero.\n\nTJZ        Dest, {#}Src\n\nTJNZ Dest, {#}Src\n\nResult: Dest is tested and if it's zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src)\n\naddress.\n\n\u25cf    Dest is a register whose value is tested for zero or not zero.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST           SRC            Write         C Flag             Z Flag             Clocks\n\nEEEE 1011100 10I DDDDDDDDD SSSSSSSSS                     PC   1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011100 11I DDDDDDDDD SSSSSSSSS                     PC   1\n\n\u2014                  \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when Dest is zero (or not zero in syntax 2).\n\nTJZ or TJNZ tests the value in Dest and jumps to the address described by Src if the result is zero (syntax 1) or\n\nnot zero (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the TJZ / TJNZ. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "'correct sign' from last addition/subtraction"
            },
            "parameters": [
              "Dest is a register whose value is tested for over\ufb02ow (Dest[31] != C).",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Dest is a register whose value is tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate a value.": {
        "count": 1,
        "description": "Math Instruction - Negate a value.",
        "instructions": {
          "NEG": {
            "mnemonic": "NEG",
            "syntax": "NEG Dest, {#}Src        {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110011 CZI DDDDDDDDD SSSSSSSSS                    D            Sign of result       Result = 0               2",
              "EEEE 0110011 CZ0 DDDDDDDDD DDDDDDDDD                    D            Sign of result       Result = 0               2"
            ],
            "description": "NEG negates Src (syntax 1) or Dest (syntax 2) and stores the result in the Dest register. The negation flips the Result: The Src or Dest value is negated and stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.\n\nNEG negates Src (syntax 1) or Dest (syntax 2) and stores the result in the Dest register. The negation \ufb02ips the\n\nvalue's sign; ex: 78 becomes -78, or -306 becomes 306.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register to receive the -Src value (syntax 1), or contains the value to negate (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose negated value is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ABS",
              "NEGC",
              "NEGNC",
              "NEGZ",
              "NEGNZ"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter Result register address of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter Result register address of next instruction.",
        "instructions": {
          "ALTR": {
            "mnemonic": "ALTR",
            "syntax": "ALTR Dest, {#}Src",
            "encoding": "EEEE 1001100 00I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTR modifies the next instruction's Result address to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for Result: The next instruction's pipelined Result address (Dest address by default) is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.\n\nALTR modi\ufb01es the next instruction's Result address to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for\n\nsyntax 2).\n\nThe Result address is the Dest address by default\u2014 it identi\ufb01es where the result value from the instruction's\n\nexecution is written at the end of execution. During execution, the pipeline holds an instruction's Dest address\n\nand the Result address as two separate entities, normally set to the same location. ALTR causes the next\n\ninstruction's Result to redirect to a different address; changing an instruction from a destructive (operand\n\noverwriting) operation to a non-destructive (operand preserving) operation.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base value (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf    The base represents a starting point. ALTR adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine\n\nthe next instruction's Result address.\n\n\u25cf    At the end of ALTR execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset\n\n(Dest) for a future ALTR+instruction iteration.\n\nIn syntax 2, Dest serves as the full value\u2014 it is used as-is for the next instruction's substitute Result address.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution).",
              "The base represents a starting point. ALTR adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine the next instruction's Result address.",
              "At the end of ALTR execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset (Dest) for a future ALTR+instruction iteration.",
              "The instruction following ALTR is shielded from interrupt",
              "ALTR alters the next instruction regardless of its kind",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Negate value according to Z.": {
        "count": 1,
        "description": "Math Instruction - Negate value according to Z.",
        "instructions": {
          "NEGZ": {
            "mnemonic": "NEGZ",
            "syntax": "NEGZ Dest, {#}Src        {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0110110 CZI DDDDDDDDD SSSSSSSSS                    D            Sign of result       Result = 0               2",
              "EEEE 0110110 CZ0 DDDDDDDDD DDDDDDDDD                    D            Sign of result       Result = 0               2"
            ],
            "description": "NEGZ negates Src (syntax 1) or Dest (syntax 2) if Z = 1 and stores the result in the Dest register. If Z = 0, the Src or Result: The Src or Dest value, possibly negated according to Z, is stored into Dest and optionally the C and Z flags are updated to the resulting sign and zero status.\n\nNEGZ negates Src (syntax 1) or Dest (syntax 2) if Z = 1 and stores the result in the Dest register. If Z = 0, the Src or\n\nDest value is left as-is (not negated) and is stored into Dest. If the negation is performed, it \ufb02ips the value's sign;\n\nex: 526 becomes -526, or -41 becomes 41.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative, or is cleared (0) if positive.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register to receive the Src or -Src value (syntax 1), or contains the value to negate (syntax 2) according to Z.",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value (if Z=0) or negated value (if Z=1) is stored into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "NEGNZ",
              "NEGC",
              "NEGNC"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Multiply signed 16-bit x 16-bit values.": {
        "count": 1,
        "description": "Math Instruction - Multiply signed 16-bit x 16-bit values.",
        "instructions": {
          "MULS": {
            "mnemonic": "MULS",
            "syntax": "MULS Dest, {#}Src {WZ}",
            "encoding": [
              "EEEE 1010000 1ZI DDDDDDDDD SSSSSSSSS                   D                 \u2014            (D = 0) | (S = 0)              2",
              "EEEE 0101100 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0                   2",
              "EEEE 0101101 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0                   2"
            ],
            "description": "MULS multiplies the signed lower 16-bits of each of Dest and Src together and stores the 32-bit signed product Result: The 32-bit signed product of the signed 16-bit Dest and Src multiplication is stored into Dest and optionally the Z flag is updated to the Dest or Src zero status. D = signed (D[15:0] * S[15:0]).\n\nMULS multiplies the signed lower 16-bits of each of Dest and Src together and stores the 32-bit signed product\n\nresult into the Dest register. This is a fast (2-clock) signed 16 x 16 bit multiplication operation\u2014 to multiply larger\n\nfactors, use the CORDIC Solver QMUL instruction.\n\nIf the WZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if either the Dest or Src values are zero, or is cleared (0) if both are\n\nnon-zero.\n\nMUXC / MUXNC\n\nMux C or mux not C\n\nBit Operation Instructions - Set discrete bits to C or !C\n\nMUXC    Dest, {#}Src {WC|WZ|WCZ}\n\nMUXNC Dest, {#}Src {WC|WZ|WCZ}\n\nResult: Dest bit(s) described by Src are set to C or !C; the rest are left as-is. Flags are optionally updated with\n\nparity and zero status of the result.\n\n\u25cf   Dest is the register whose value will have one or more bits set to C or !C.\n\n\u25cf   Src is a register, 9-bit literal, or 32-bit augmented literal whose value identi\ufb01es the bit(s) to modify.\n\n\u25cf   WC, WZ, or WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX     DEST          SRC           Write            C Flag              Z Flag                Clocks\n\nEEEE 0101100 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0                   2\n\nEEEE 0101101 CZI DDDDDDDDD SSSSSSSSS                   D          Parity of Result      Result = 0                   2\n\nMUXC or MUXNC alters the Dest bit(s) designated by Src (high bits) to equal the state, or inverse state, of the C \ufb02ag.\n\nAll Dest bits corresponding to high (1) bits in Src are modi\ufb01ed; all other Dest bits are left unchanged.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the number of high (1) bits in the result is odd, or is\n\ncleared (0) if it is even.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is not zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the signed 16-bit value to multiply with Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or signed 16-bit augmented literal whose value is multiplied into Dest.",
              "WZ is an optional effect to update the Z \ufb02ag.",
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "MUL",
              "SCA",
              "QMUL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Jump": {
        "count": 1,
        "description": "Branch D - Jump",
        "instructions": {
          "JMPREL": {
            "mnemonic": "JMPREL",
            "syntax": "JMPREL  {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110000",
            "description": "Jump ahead/back by D instructions. For cogex, PC += D[19:0]. For hubex, PC += D[17:0] << 2.",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to C or !C.": {
        "count": 2,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to C or !C.",
        "instructions": {
          "DRVNC": {
            "mnemonic": "DRVNC",
            "syntax": "DRVNC   {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011011",
            "description": "DRVC or DRVNC sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DRVC": {
            "mnemonic": "DRVC",
            "syntax": "DRVC    {#}D           {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001011010",
            "description": "DRVC or DRVNC sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level Result: The I/O pins described by Dest are set to the output direction and to an output level of low/high according to C or !C; the rest are left as-is. Z = OUT bit.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identifies the I/O pin(s) to set to output direction and output levels of low or high.",
              "WCZ is an optional effect to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to input and toggle to the opposite output level.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to input and toggle to the opposite output level.",
        "instructions": {
          "FLTNOT": {
            "mnemonic": "FLTNOT",
            "syntax": "FLTNOT {#}Dest {WCZ}",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001010111 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
            "description": "FLTNOT sets the I/O pin(s) designated by Dest to the input direction and to their opposite output level(s); i.e. Result: The I/O pins described by Dest are set to the input direction and to their opposite output level(s); the rest are left as-is. Z = OUT bit.\n\nFLTNOT sets the I/O pin(s) designated by Dest to the input direction and to their opposite output level(s); i.e.\n\nalters the pin's direction and output registers. All other pins are left unchanged. This instruction can affect one or\n\nmore of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nFLTNOT achieves the same effect as two instructions\u2014 DIRL followed by OUTNOT.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the FLTNOT instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for FLTNOT's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to the input direction and toggle to opposite output levels.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a word to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a word to new value.",
        "instructions": {
          "SETWORD": {
            "mnemonic": "SETWORD",
            "syntax": "SETWORD Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1001001 0NI DDDDDDDDD SSSSSSSSS                        D                   \u2014                 \u2014                    2",
              "EEEE 1001001 00I 000000000 SSSSSSSSS                       D   1"
            ],
            "description": "SETWORD stores Src[15:0] into the word identified by Num within Dest, or the word and register described by a Result: Src[15:0] is written to word Num (0\u20131) of Dest, or to another register word described by prior ALTSW instruction.\n\nSETWORD stores Src[15:0] into the word identi\ufb01ed by Num within Dest, or the word and register described by a\n\nprior ALTSW instruction. No other bits are modi\ufb01ed.\n\nNum (0\u20131) identi\ufb01es a value's individual words, by position, in least-signi\ufb01cant word order.\n\nSyntax 2 is intended for use after an ALTSW instruction; i.e. in a loop to iteratively affect a series of word values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to modify a word.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose bits [15:0] will be stored in the designated location.",
              "Num is a 1-bit literal identifying the word ID (0\u20131) of Dest to modify."
            ],
            "related": [
              "ALTSW",
              "SETNIB",
              "SETBYTE",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 10
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds1set",
                "pattern": "S/#{,D,#0..1}",
                "description": "Set word: source/immediate, optional destination and word index 0-1",
                "valueType": 10
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Add two unsigned values.": {
        "count": 1,
        "description": "Math Instruction - Add two unsigned values.",
        "instructions": {
          "ADD": {
            "mnemonic": "ADD",
            "syntax": "ADD Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001000 CZI DDDDDDDDD SSSSSSSSS                    D           carry of (D + S)      Result = 0               2",
            "description": "ADD sums the two unsigned values of Dest and Src together and stores the result into the Dest register. Result: Sum of unsigned Src and unsigned Dest is stored in Dest.\n\nADD sums the two unsigned values of Dest and Src together and stores the result into the Dest register.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the summation results in a 32-bit over\ufb02ow (unsigned\n\ncarry), or is cleared (0) if no over\ufb02ow.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result of Dest + Src is zero, or is cleared (0) if it is\n\nnon-zero.\n\nTo add unsigned, multi-long values, use ADD followed by ADDX as described in Adding Two Multi-Long Values.\n\nADD and ADDX are also used in adding signed, multi-long values with ADDSX ending the sequence.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": "carry of (D",
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADDX",
              "ADDS",
              "ADDSX",
              "SUB"
            ],
            "compiler_info": {
              "syntax": "ADD D,S/#",
              "encoding": {
                "bits": 32,
                "opcode": 32,
                "effects": 3,
                "operandFormat": 0,
                "rawValue": 1568
              },
              "category": "Arithmetic",
              "effects": [
                {
                  "name": "wc",
                  "symbol": "WC",
                  "value": 1,
                  "description": "Write Carry flag",
                  "bitPattern": "01"
                },
                {
                  "name": "wz",
                  "symbol": "WZ",
                  "value": 2,
                  "description": "Write Zero flag",
                  "bitPattern": "10"
                },
                {
                  "name": "wcz",
                  "symbol": "WCZ",
                  "value": 3,
                  "description": "Write Carry and Zero flags",
                  "bitPattern": "11"
                }
              ],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if signed or not signed.": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if signed or not signed.",
        "instructions": {
          "TJNS": {
            "mnemonic": "TJNS",
            "syntax": "TJNS    D,{#}S",
            "encoding": "EEEE 1011101 11I DDDDDDDDD SSSSSSSSS",
            "description": "TJS or TJNS tests the value in Dest and jumps to the address described by Src if the result is signed (Dest[31] = 1) Result: Dest is tested and if it's signed (or not signed in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is a register whose value is tested for sign or no sign.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer empty event flag set or clear.": {
        "count": 2,
        "description": "Event Branch Instruction - Jump if streamer empty event flag set or clear.",
        "instructions": {
          "JXMT": {
            "mnemonic": "JXMT",
            "syntax": "JXMT    {#}S",
            "encoding": "EEEE 1011110 01I 000001010 SSSSSSSSS",
            "description": "JXMT or JNXMT checks the cog's streamer empty event flag and jumps to the address described by Src if the flag Result: If streamer empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "JNXMT": {
            "mnemonic": "JNXMT",
            "syntax": "JNXMT   {#}S",
            "encoding": "EEEE 1011110 01I 000011010 SSSSSSSSS",
            "description": "JXMT or JNXMT checks the cog's streamer empty event flag and jumps to the address described by Src if the flag Result: If streamer empty event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin (Smart Logic) Instruction - Acknowledge smart pin(s).": {
        "count": 1,
        "description": "I/O Pin (Smart Logic) Instruction - Acknowledge smart pin(s).",
        "instructions": {
          "AKPIN": {
            "mnemonic": "AKPIN",
            "syntax": "AKPIN {#}Src",
            "encoding": "EEEE 1100000 01I 000000001 SSSSSSSSS                Ack Bus              \u2014                  \u2014                   2",
            "description": "AKPIN acknowledges the Smart Pin(s) designated by Src. This lowers the corresponding IN signal(s) so that Result: One or more Smart Pins is acknowledged; lowering their corresponding IN signal(s).\n\nAKPIN acknowledges the Smart Pin(s) designated by Src. This lowers the corresponding IN signal(s) so that\n\nfuture Smart Pin events may raise them again later.\n\nSrc[5:0] indicates the pin number (0\u201363). For a range of Smart Pins, Src[5:0] indicates the \ufb01rst pin number (0\u201363)\n\nand Src[10:6] indicates how many contiguous pins beyond the \ufb01rst should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the starting pin (Src[5:0]) and a range of up to 8 contiguous pins (Src[8:6]).\n\nIf needed, use the augmented literal feature (##Src) to augment Src to the required 11-bit literal value\u2014 this\n\ninserts an AUGS instruction prior.\n\nWhen Src is a register, the register's value bits [10:0] are used as-is to form the 11-bit Smart Pin range, unless a\n\nSETQ instruction immediately precedes the AKPIN instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for AKPIN's use.\n\nThe range calculation (from Src[5:0] up to Src[5:0]+Src[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB); it will not cross the port boundary.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the Smart Pin(s) to acknowledge."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 34
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_akpin",
                "pattern": "S/#",
                "description": "Acknowledge pin: pin number/immediate",
                "valueType": 34
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETBYTE / ROLBYTE instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETBYTE / ROLBYTE instruction.",
        "instructions": {
          "ALTGB": {
            "mnemonic": "ALTGB",
            "syntax": "ALTGB Dest, {#}Src",
            "encoding": "EEEE 1001011 01I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTGB should be followed by GETBYTE or ROLBYTE\u2014 it modifies the GETBYTE / ROLBYTE instruction's\nSrc and Result: The next instruction's pipelined Src and Num fields are altered to be (Src + Dest[10:2])\n& $1FF, or just Dest[10:2] for syntax 2, and Dest[1:0], respectively.\n\nPerfect for:\n- Table lookups (commutation tables, sine tables)\n- String processing with auto-increment\n- Byte array traversal\n- Character mapping and translation\n\n\nALTGB should be followed by GETBYTE or ROLBYTE\u2014 it modi\ufb01es the GETBYTE / ROLBYTE instruction's Src and\n\nNum values, enabling code to iterate through multiple bytes of data across a range of Reg RAM. GETBYTE /\n\nROLBYTE's Src value is changed to (Src + Dest[10:2]) & $1FF (for syntax 1), or to Dest[10:2] (for syntax 2), and its\n\nNum value is changed to Dest[1:0].\n\nDest[10:2] corresponds to the target long register's 9-bit address and Dest[1:0] is the byte ID within it; values of\n\n0\u20133 identify individual bytes, by position, in least-signi\ufb01cant byte order. Iteratively executing ALTGB followed by\n\nGETBYTE or ROLBYTE, and each time incrementing ALTGB's 11-bit Dest value by one, effectively reads a stream of\n\nbyte values from Reg RAM as if it were all made of byte-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of bytes begins. ALTGB adds the long index\n\n(Dest[10:2]) to the base (Src[8:0]) to locate the register holding the target byte. The byte ID (Dest[1:0])\n\nidenti\ufb01es the byte's position within that long register.\n\n\u25cf   At the end of ALTGB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 11-bit\n\nindex (Dest) for a future ALTGB+GETBYTE or ROLBYTE iteration.\n\nIn syntax 2, Dest serves as the full byte address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its byte index instead of the long's relative index (to add to a base) and byte index.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 11-bit value is the index, or the full byte address, for the GETBYTE / ROLBYTE instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[10:2]) for GETBYTE / ROLBYTE) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution).",
              "The base is the Reg RAM address where the series of bytes begins. ALTGB adds the long index (Dest[10:2]) to the base (Src[8:0]) to locate the register holding the target byte. The byte ID (Dest[1:0]) identi\ufb01es the byte's position within that long register.",
              "At the end of ALTGB execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 11-bit index (Dest) for a future ALTGB+GETBYTE or ROLBYTE iteration.",
              "The instruction following ALTGB is shielded from interrupt Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual               \u25aa   Page 40",
              "ALTGB alters the next instruction regardless of its kind\u2014 the intention is for it to be a GETBYTE / ROLBYTE",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a nibble from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a nibble from a value.",
        "instructions": {
          "GETNIB": {
            "mnemonic": "GETNIB",
            "syntax": "GETNIB Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 100001N NNI DDDDDDDDD SSSSSSSSS                  D                \u2014                  \u2014                    2",
              "EEEE 1000010 000 DDDDDDDDD 000000000                  D                \u2014                  \u2014                    2"
            ],
            "description": "GETNIB reads the nibble identified by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN Result: Nibble Num (0\u20137) of Src, or a nibble from a source described by prior ALTGN instruction, is written to Dest.\n\nGETNIB reads the nibble identi\ufb01ed by Num (0\u20137) from Src, or a nibble from the source described by a prior ALTGN\n\ninstruction.\n\nNum (0\u20137) identi\ufb01es a value's individual nibbles, by position, in least-signi\ufb01cant nibble order.\n\nSyntax 2 is intended for use after an ALTGN instruction; i.e. in a loop to iteratively read a series of nibble values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the nibble.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target nibble to read.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Src to read."
            ],
            "related": [
              "ALTGN",
              "GETBYTE",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 7
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds3get",
                "pattern": "D{,S/#,#0..7}",
                "description": "Get nibble: destination, optional source and nibble index 0-7",
                "valueType": 7
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force unsigned value to be less than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force unsigned value to be less than or equal to another.",
        "instructions": {
          "FLE": {
            "mnemonic": "FLE",
            "syntax": "FLE Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0011001 CZI DDDDDDDDD SSSSSSSSS                    D           limit enforced        Result = 0              2",
            "description": "FLE sets unsigned Dest to unsigned Src if Dest is greater than Src. This is also known as a limit maximum Result: Unsigned Dest is set to unsigned Src if Dest was greater than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.\n\nFLE sets unsigned Dest to unsigned Src if Dest is greater than Src. This is also known as a limit maximum\n\nfunction; preventing Dest from rising above Src.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was limited (Dest was greater than Src and now\n\nDest is equal to Src), or is cleared (0) if not limited.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the unsigned value to limit to a maximum of unsigned Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose unsigned value is the upper limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "FGE",
              "FLES",
              "FGES"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Sign-extend value beyond designated bit.": {
        "count": 1,
        "description": "Math Instruction - Sign-extend value beyond designated bit.",
        "instructions": {
          "SIGNX": {
            "mnemonic": "SIGNX",
            "syntax": "SIGNX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0111011 CZI DDDDDDDDD SSSSSSSSS                    D            MSB of result        Result = 0               2",
            "description": "SIGNX fills the bits of Dest, above the bit indicated by Src[4:0], with the value of that identified bit; i.e. Result: The Dest value is sign-extended above the bit indicated by Src and is stored in Dest. Optionally the C and Z flags are updated to the resulting MSB and zero status. C = MSB of result.\n\nSIGNX \ufb01lls the bits of Dest, above the bit indicated by Src[4:0], with the value of that identi\ufb01ed bit; i.e.\n\nsign-extending the value. This is handy when converting encoded or received signed values from a small bit width\n\nto a large bit with; i.e. 32 bits.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set to the result's MSB value.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to sign-extend above bit Src[4:0] and is where the result is written.",
              "Src is a register or 9-bit literal whose value (lower 5 bits) identi\ufb01es the bit of Dest to zero-extend beyond.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ZEROX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETWORD / ROLWORD instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETWORD / ROLWORD instruction.",
        "instructions": {
          "ALTGW": {
            "mnemonic": "ALTGW",
            "syntax": "ALTGW Dest, {#}Src",
            "encoding": "EEEE 1001011 11I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTGW should be followed by GETWORD or ROLWORD\u2014 it modifies the GETWORD / ROLWORD instruction's Src and Result: The next instruction's pipelined Src and Num fields are altered to be (Src + Dest[9:1]) & $1FF, or just Dest[9:1] for syntax 2, and Dest[0], respectively.\n\nALTGW should be followed by GETWORD or ROLWORD\u2014 it modi\ufb01es the GETWORD / ROLWORD instruction's Src and\n\nNum values, enabling code to iterate through multiple words of data across a range of Reg RAM. GETWORD /\n\nROLWORD's Src value is changed to (Src + Dest[9:1]) & $1FF (for syntax 1), or to Dest[9:1] (for syntax 2), and its\n\nNum value is changed to Dest[0].\n\nDest[9:1] corresponds to the target long register's 9-bit address and Dest[0] is the word ID within it; values of 0\u20131\n\nidentify individual words, by position, in least-signi\ufb01cant word order. Iteratively executing ALTGW followed by\n\nGETWORD or ROLWORD, and each time incrementing ALTGW's 10-bit Dest value by one, effectively reads a stream of\n\nword values from Reg RAM as if it were all made of word-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of words begins. ALTGW adds the long index\n\n(Dest[9:1]) to the base (Src[8:0]) to locate the register holding the target word. The word ID (Dest[0])\n\nidenti\ufb01es the word's position within that long register.\n\n\u25cf   At the end of ALTGW execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 10-bit\n\nindex (Dest) for a future ALTGW+GETWORD or ROLWORD iteration.\n\nIn syntax 2, Dest serves as the full word address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its word index instead of the long's relative index (to add to a base) and word index.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 10-bit value is the index, or the full word address for the GETWORD / ROLWORD instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[9:1]) for GETWORD / ROLWORD) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution).",
              "The base is the Reg RAM address where the series of words begins. ALTGW adds the long index (Dest[9:1]) to the base (Src[8:0]) to locate the register holding the target word. The word ID (Dest[0]) identi\ufb01es the word's position within that long register.",
              "At the end of ALTGW execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 10-bit index (Dest) for a future ALTGW+GETWORD or ROLWORD iteration.",
              "The instruction following ALTGW is shielded from interrupt",
              "ALTGW alters the next instruction regardless of its kind\u2014 the intention is for it to be a GETWORD / ROLWORD",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Hub FIFO - New Block": {
        "count": 1,
        "description": "Hub FIFO - New Block",
        "instructions": {
          "FBLOCK": {
            "mnemonic": "FBLOCK",
            "syntax": "FBLOCK  {#}D,{#}S",
            "encoding": "EEEE 1100100 1LI DDDDDDDDD SSSSSSSSS",
            "description": "Set next block for when block wraps. D[13:0] = block size in 64-byte units (0 = max), S[19:0] = block start address.",
            "timing": {
              "cycles": 2,
              "type": "mode_dependent"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 13
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ls",
                "pattern": "D/#,S/#",
                "description": "Two operands: destination/immediate, source/immediate",
                "valueType": 13
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry \ufb02ag left into value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry \ufb02ag left into value.",
        "instructions": {
          "RCL": {
            "mnemonic": "RCL",
            "syntax": "RCL Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000101 CZI DDDDDDDDD SSSSSSSSS                            D      Last bit out   1",
            "description": "The bits of Dest are shifted left by Src bits, inserting C as new LSBs.\n\nRCL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to C.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out if Src is 1\u201331, or to\n\nDest[31] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to rotate carry left by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear streamer-NCO-rollover event \ufb02ag": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear streamer-NCO-rollover event \ufb02ag",
        "instructions": {
          "WAITXRO": {
            "mnemonic": "WAITXRO",
            "syntax": "WAITXRO {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 1101011 CZ0 000011100 000100100                   \u2014          Timeout Abort     Timeout Abort               2+",
              "EEEE 1101011 000 DDDDDDDDD 001101100                   D                \u2014                 \u2014                     2",
              "EEEE 1101011 000 DDDDDDDDD 001101101                   D                \u2014                 \u2014                     2",
              "EEEE 1101011 000 DDDDDDDDD 001101110                   D                 \u2014                  \u2014                    2",
              "EEEE 1101011 000 DDDDDDDDD 001101111                   D                 \u2014                  \u2014                    2"
            ],
            "description": "WAITXRO waits for a streamer-NCO-rollover event to occur (unless the event flag is already set), then clears the Result: Wait for streamer-NCO-rollover event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITXRO waits for a streamer-NCO-rollover event to occur (unless the event \ufb02ag is already set), then clears the\n\nevent \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction.\n\nOptionally, WAITXRO can time-out if the streamer-NCO-rollover event doesn't occur soon enough; setting C and/or\n\nZ \ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITXRO.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe streamer-NCO-rollover event \ufb02ag is set whenever the streamer's numerically-controlled oscillator (NCO) rolls\n\nover. The streamer-NCO-rollover event \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXRO,\n\nWAITXRO, JXRO, or JNXRO instructions.\n\nWRC / WRNC\n\nWrite C or not C\n\nBit Operation Instruction - Write C or not C to register.\n\nWRC       Dest\n\nWRNC      Dest\n\nResult: Dest value is replaced with state of C or !C.\n\n\u25cf   Dest is the register whose value will be replaced with the state of C or !C.\n\nCOND INSTR         FX     DEST          SRC          Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 000 DDDDDDDDD 001101100                   D                \u2014                 \u2014                     2\n\nEEEE 1101011 000 DDDDDDDDD 001101101                   D                \u2014                 \u2014                     2\n\nWRC or WRNC writes the state or inverse state of C (0 or 1) to Dest.\n\nWRZ / WRNZ\n\nWrite Z or not Z\n\nBit Operation Instruction - Write Z or not Z to register.\n\nWRZ       Dest\n\nWRNZ      Dest\n\nResult: Dest value is replaced with state of Z or !Z.\n\n\u25cf   Dest is the register whose value will be replaced with the state of Z or !Z.\n\nCOND INSTR         FX      DEST         SRC           Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 000 DDDDDDDDD 001101110                   D                 \u2014                  \u2014                    2\n\nEEEE 1101011 000 DDDDDDDDD 001101111                   D                 \u2014                  \u2014                    2\n\nWRZ or WRNZ writes the state or inverse state of Z (0 or 1) to Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "Dest is the register whose value will be replaced with the state of C or !C.",
              "Dest is the register whose value will be replaced with the state of Z or !Z."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "POLLXRO",
              "JXRO",
              "JNXRO."
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter S \ufb01eld of next instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter S \ufb01eld of next instruction.",
        "instructions": {
          "ALTS": {
            "mnemonic": "ALTS",
            "syntax": "ALTS Dest, {#}Src",
            "encoding": "EEEE 1001100 10I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTS modifies the next instruction's Src value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax Result: The next instruction's pipelined Src value is altered to be (Src + Dest) & $1FF, or just Dest[8:0] in syntax 2.\n\nALTS modi\ufb01es the next instruction's Src value to be (Src + Dest) & $1FF (for syntax 1), or to Dest[8:0] (for syntax\n\n2).\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base value (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base represents a starting point. ALTS adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine\n\nthe next instruction's Src value.\n\n\u25cf   At the end of ALTS execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset\n\n(Dest) for a future ALTS+instruction iteration.\n\nIn syntax 2, Dest serves as the full value\u2014 it is used as-is for the next instruction's substitute Src value.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 9-bit value is the offset, or the full value, for the next instruction to operate on.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base (Src[8:0]; added to offset (Dest) for the next instruction) and also an optional auto-indexer value (Src[17:9]; added to Dest at the end of execution).",
              "The base represents a starting point. ALTS adds the offset (Dest[8:0]) to the base (Src[8:0]) to determine the next instruction's Src value.",
              "At the end of ALTS execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the offset (Dest) for a future ALTS+instruction iteration.",
              "The instruction following ALTS is shielded from interrupt",
              "ALTS alters the next instruction regardless of its kind",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).": {
        "count": 1,
        "description": "Flow Control Instruction - Test value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).",
        "instructions": {
          "TJNF": {
            "mnemonic": "TJNF",
            "syntax": "TJNF    D,{#}S",
            "encoding": "EEEE 1011101 01I DDDDDDDDD SSSSSSSSS",
            "description": "TJF or TJNF tests the value in Dest and jumps to the address described by Src if the result is full (-1; $FFFF_FFFF; Result: Dest is tested and if it's full (or not full in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "PC1"
              }
            },
            "parameters": [
              "Dest is a register whose value is tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if FIFO interface block wrap event flag is set or clear.": {
        "count": 2,
        "description": "Event Branch Instruction - Jump if FIFO interface block wrap event flag is set or clear.",
        "instructions": {
          "JFBW": {
            "mnemonic": "JFBW",
            "syntax": "JFBW    {#}S",
            "encoding": "EEEE 1011110 01I 000001001 SSSSSSSSS",
            "description": "JFBW or JNFBW checks the cog's FIFO interface block wrap flag and jumps to the address described by Src if the Result: If FIFO interface block wrap event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "JNFBW": {
            "mnemonic": "JNFBW",
            "syntax": "JNFBW   {#}S",
            "encoding": "EEEE 1011110 01I 000011001 SSSSSSSSS",
            "description": "JFBW or JNFBW checks the cog's FIFO interface block wrap flag and jumps to the address described by Src if the Result: If FIFO interface block wrap event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get 1..32-bit mask into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get 1..32-bit mask into Dest.",
        "instructions": {
          "BMASK": {
            "mnemonic": "BMASK",
            "syntax": "BMASK Dest, {#}Src",
            "encoding": [
              "EEEE 1001110 01I DDDDDDDDD SSSSSSSSS                  D                \u2014                  \u2014                   2",
              "EEEE 1001110 010 DDDDDDDDD DDDDDDDDD                  D                \u2014                  \u2014                   2"
            ],
            "description": "BMASK generates an LSB-justified bit mask (all ones) of Src+1 or Dest+1 length and stores it in Dest. The size Result: Bit mask of size Src+1, or Dest+1 (1\u201432 bits) is stored into Dest.\n\nBMASK generates an LSB-justi\ufb01ed bit mask (all ones) of Src+1 or Dest+1 length and stores it in Dest. The size\n\nvalue, whether speci\ufb01ed by Src or Dest, is in the range 0\u201431 to generate 1 to 32 bits of bit mask.\n\nIn effect, Dest becomes (%10 << size) - 1 via the BMASK instruction.\n\n\u25cf   A size value of 0 generates a bit mask of %00000000_00000000_00000000_00000001.\n\n\u25cf   A size value of 5 generates a bit mask of %00000000_00000000_00000000_00111111.\n\n\u25cf   A size value of 15 generates a bit mask of %00000000_00000000_11111111_11111111.\n\nA bit mask is often useful in bitwise operations (AND, OR, XOR) to \ufb01lter out or affect special groups of bits.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the generated bit mask and optionally begins by containing the 5-bit mask size it is requesting (syntax 2).",
              "Src is an optional register or 5-bit literal whose value is the size of the bit mask to generate.",
              "A size value of 0 generates a bit mask of %00000000_00000000_00000000_00000001.",
              "A size value of 5 generates a bit mask of %00000000_00000000_00000000_00111111.",
              "A size value of 15 generates a bit mask of %00000000_00000000_11111111_11111111."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Alter subsequent GETNIB / ROLNIB instruction.": {
        "count": 1,
        "description": "Indirection Instruction - Alter subsequent GETNIB / ROLNIB instruction.",
        "instructions": {
          "ALTGN": {
            "mnemonic": "ALTGN",
            "syntax": "ALTGN Dest, {#}Src",
            "encoding": "EEEE 1001010 11I DDDDDDDDD SSSSSSSSS                     D 1",
            "description": "ALTGN should be followed by GETNIB or ROLNIB\u2014 it modifies the GETNIB / ROLNIB instruction's Src and Num Result: The next instruction's pipelined Src and Num values are altered to be (Src + Dest[11:3]) & $1FF, or just Dest[11:3] for syntax 2, and Dest[2:0], respectively.\n\nALTGN should be followed by GETNIB or ROLNIB\u2014 it modi\ufb01es the GETNIB / ROLNIB instruction's Src and Num\n\nvalues, enabling code to iterate through multiple nibbles of data across a range of Reg RAM. GETNIB / ROLNIB's\n\nSrc value is changed to (Src + Dest[11:3]) & $1FF (for syntax 1), or to Dest[11:3] (for syntax 2), and its Num value\n\nis changed to Dest[2:0].\n\nDest[11:3] corresponds to the target long register's 9-bit address and Dest[2:0] is the nibble ID within it; values of\n\n0\u20137 identify individual nibbles, by position, in least-signi\ufb01cant nibble order. Iteratively executing ALTGN followed\n\nby GETNIB or ROLNIB, and each time incrementing ALTGN's 12-bit Dest value by one, effectively reads a stream\n\nof nibble values from Reg RAM as if it were all made of nibble-sized registers.\n\nIn syntax 1, Src consists of two 9-bit \ufb01elds; a base address (Src[8:0]) and a signed auto-indexer (Src[17:9]).\n\n\u25cf   The base is the Reg RAM address where the series of nibbles begins. ALTGN adds the long index\n\n(Dest[11:3]) to the base (Src[8:0]) to locate the register holding the target nibble. The nibble ID (Dest[2:0])\n\nidenti\ufb01es the nibble's position within that long register.\n\n\u25cf   At the end of ALTGN execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 12-bit\n\nindex (Dest) for a future ALTGN+GETNIB or ROLNIB iteration.\n\nIn syntax 2, Dest serves as the full nibble address\u2014 it's the same format as in syntax 1, but represents the target\n\nlong's absolute address and its nibble index instead of the long's relative index (to add to a base) and nibble index.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register whose 12-bit value is the index, or the full nibble address, for the next GETNIB / ROLNIB instruction to read.",
              "Src is an optional register, 9-bit literal, or 18-bit augmented literal whose value contains a base long address (Src[8:0]; added to index (Dest[11:3]) for GETNIB / ROLNIB) and also an optional auto-indexer value (Src[17:9]; added to Dest at end of execution).",
              "The base is the Reg RAM address where the series of nibbles begins. ALTGN adds the long index (Dest[11:3]) to the base (Src[8:0]) to locate the register holding the target nibble. The nibble ID (Dest[2:0]) identi\ufb01es the nibble's position within that long register.",
              "At the end of ALTGN execution, the optional auto-indexer value (usually 0, 1, or -1) is added to the 12-bit index (Dest) for a future ALTGN+GETNIB or ROLNIB iteration.",
              "The instruction following ALTGN is shielded from interrupt",
              "ALTGN alters the next instruction regardless of its kind\u2014 the intention is for it to be a GETNIB / ROLNIB",
              "Field value modi\ufb01cation occurs in the instruction pipeline only; code is not altered, values do not persist",
              "SETQ / SETQ2 does not affect ALTx instructions\u2014 the Q value passes through to the next instruction Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual               \u25aa   Page 41"
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 5
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_duiz",
                "pattern": "D{,S/#}",
                "description": "Destination, optional source (immediate bit set if no source)",
                "valueType": 5
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Branch Instruction - Jump if streamer LUT RAM rollover event flag set or clear.": {
        "count": 2,
        "description": "Event Branch Instruction - Jump if streamer LUT RAM rollover event flag set or clear.",
        "instructions": {
          "JXRL": {
            "mnemonic": "JXRL",
            "syntax": "JXRL    {#}S",
            "encoding": "EEEE 1011110 01I 000001101 SSSSSSSSS",
            "description": "JXRL or JNXRL checks the cog's streamer LUT RAM rollover event flag and jumps to the address described by Src Result: If streamer LUT RAM rollover event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "JNXRL": {
            "mnemonic": "JNXRL",
            "syntax": "JNXRL   {#}S",
            "encoding": "EEEE 1011110 01I 000011101 SSSSSSSSS",
            "description": "JXRL or JNXRL checks the cog's streamer LUT RAM rollover event flag and jumps to the address described by Src Result: If streamer LUT RAM rollover event flag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 21
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_jpoll",
                "pattern": "S/#",
                "description": "Poll jump: target address/immediate",
                "valueType": 21
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Add two signed extended values.": {
        "count": 1,
        "description": "Math Instruction - Add two signed extended values.",
        "instructions": {
          "ADDSX": {
            "mnemonic": "ADDSX",
            "syntax": "ADDSX Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0001011 CZI DDDDDDDDD SSSSSSSSS                   D          sign of (D+S+C)   Z AND (Result = 0)           2",
            "description": "ADDSX sums the signed values of Dest and Src plus C together and stores the result into the Dest register. The Result: Sum of signed Src plus C and signed Dest is stored in Dest.\n\nADDSX sums the signed values of Dest and Src plus C together and stores the result into the Dest register. The\n\nADDSX instruction is used to perform signed multi-long (extended) addition, such as 64-bit addition.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the result is negative (Result[31] = 1), or is cleared (0) if\n\npositive. Use WC or WCZ on preceding ADD and ADDX instructions for proper \ufb01nal C \ufb02ag.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if Z was previously set and the result of Dest + Src + C is\n\nzero, or it is cleared (0) if non-zero. Use WZ or WCZ on preceding ADD and ADDX instructions for proper \ufb01nal Z \ufb02ag.\n\nTo add signed multi-long values, use ADD (not ADDS) followed possibly by ADDX, and \ufb01nally ADDSX as described in\n\nAdding Two Multi-Long Values.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "(Result = 0)"
            },
            "parameters": [
              "Dest is a register containing the value to add Src pluc C to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value plus C is added into Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "ADD",
              "ADDX",
              "ADDSX",
              "SUBSX"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Test bit of D or !D and either store, AND, OR, or XOR the result into flags.": {
        "count": 1,
        "description": "Bit Operation Instruction - Test bit of D or !D and either store, AND, OR, or XOR the result into flags.",
        "instructions": {
          "TESTBN": {
            "mnemonic": "TESTBN",
            "syntax": "TESTBN  D,{#}S         WC/WZ",
            "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS",
            "description": "TESTB or TESTBN reads the state (0/1) of a bit in Dest designated by Src, possibly inverts that result, and either Result: The state of Dest's bit Src is read, possibly inverted, and either stored as-is, or bitwise ANDed, ORed, or XORed into C or Z. Z = C/Z XOR !D[S[4:0]].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR !D[S[4:0]]",
                "when": "IN[D[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have a single bit tested.",
              "Src is a register or 5-bit literal whose value identifies the bit (0\u201331) of Dest to test."
            ],
            "related": [
              "TESTP",
              "TESTPN"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 2
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_testb",
                "pattern": "D,S/#",
                "description": "Test bit with logic function: Destination register, bit position",
                "valueType": 2
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation / Math Instruction - Shift bits left; a.k.a. multiply 32-bit integer by power-of-two.": {
        "count": 1,
        "description": "Bit Operation / Math Instruction - Shift bits left; a.k.a. multiply 32-bit integer by power-of-two.",
        "instructions": {
          "SHL": {
            "mnemonic": "SHL",
            "syntax": "SHL Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000011 CZI DDDDDDDDD SSSSSSSSS                            D      Last bit out   1",
            "description": "SHL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to 0. This is useful for Result: The bits of Dest are shifted left by Src bits, inserting zeros (0) as new rightmost bits.\n\nSHL shifts Dest's binary value left by Src places (0\u201331 bits) and sets the new LSBs to 0. This is useful for\n\nbit-stream manipulation as well as for swift multiplication; signed or unsigned 32-bit integer multiplication by a\n\npower-of-two. Care must be taken for power-of-two multiplications since upper bits will shift through the MSB\n\n(sign bit); mangling large signed values.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out (effectively C =\n\nresult bit \"32\") if Src is 1\u201331, or to Dest[31] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[31]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to left shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to shift left.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a byte to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a byte to new value.",
        "instructions": {
          "SETBYTE": {
            "mnemonic": "SETBYTE",
            "syntax": "SETBYTE Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1000110 NNI DDDDDDDDD SSSSSSSSS                      D                 \u2014               \u2014                     2",
              "EEEE 1000110 00I 000000000 SSSSSSSSS                      D1"
            ],
            "description": "SETBYTE stores Src[7:0] into the byte identified by Num within Dest, or the byte and register described by a prior Result: Src[7:0] is written to byte Num (0\u20133) of Dest, or to another register byte described by prior ALTSB instruction.\n\nSETBYTE stores Src[7:0] into the byte identi\ufb01ed by Num within Dest, or the byte and register described by a prior\n\nALTSB instruction. No other bits are modi\ufb01ed.\n\nNum (0\u20133) identi\ufb01es a value's individual bytes, by position, in least-signi\ufb01cant byte order.\n\nSyntax 2 is intended for use after an ALTSB instruction; i.e. in a loop to iteratively affect a series of byte values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to modify a byte.",
              "Src is a register or 8-bit literal whose bits [7:0] will be stored in the designated location.",
              "Num is a 2-bit literal identifying the nibble ID (0\u20133) of Dest to modify."
            ],
            "related": [
              "ALTSB",
              "SETNIB",
              "SETWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 8
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds2set",
                "pattern": "S/#{,D,#0..3}",
                "description": "Set byte: source/immediate, optional destination and byte index 0-3",
                "valueType": 8
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Indirection Instruction - Set template S \ufb01eld for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template S \ufb01eld for ALTI.",
        "instructions": {
          "SETS": {
            "mnemonic": "SETS",
            "syntax": "SETS Dest, {#}Src",
            "encoding": "EEEE 1001101 11I DDDDDDDDD SSSSSSSSS                        D                   \u2014                 \u2014                    2",
            "description": "SETS copies Src[8:0] to the S field of the template, Dest, to be used with an ALTI instruction. Bits outside the S Result: The S field [8:0] of template Dest is set to Src[8:0].\n\nSETS copies Src[8:0] to the S \ufb01eld of the template, Dest, to be used with an ALTI instruction. Bits outside the S\n\n\ufb01eld remain unaffected. The S \ufb01eld (or Src \ufb01eld) holds the address of a register or literal value for an instruction\n\nto use as it's source value during its execution.\n\nThe ALTI template is a 32-bit value with the following format:\n\nBits             31:28 (4 bits)          27:19 (9 bits)             18              17:9 (9 bits)        8:0 (9 bits)\n\nField Description       Condition Field         Result Field        Indirect \"I\" Field    Dest \"D\" Field      Source \"S\" Field\n\nSETS can also be used in self-modifying Reg RAM code. Unlike with ALTx instructions, when used this way, \ufb01eld\n\nvalue modi\ufb01cation occurs in the program code itself (not the instruction pipeline); code is altered, values persist.\n\nDue to the instruction pipeline nature, after modifying a code register, it is necessary to elapse at least two\n\ninstructions before executing the modi\ufb01ed register.\n\nSETS         inst, op                        'set \"inst\" register[8:0] to op[8:0]\n\nNOP                                          '\ufb01rst spacer instruction, could be anything\n\nNOP                                          'second spacer instruction, could be anything\n\ninst      MOV          x, y                            'operate on x using y; y may become any register/value per SETS",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction.",
              "Src is a register or 9-bit literal whose value (Src[8:0]) is copied to the S \ufb01eld of Dest."
            ],
            "related": [
              "SETD",
              "SETR",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flag Modification Instruction - Modify C and/or Z flag(s) according to modifier mode and current state(s).": {
        "count": 3,
        "description": "Flag Modification Instruction - Modify C and/or Z flag(s) according to modifier mode and current state(s).",
        "instructions": {
          "MODC": {
            "mnemonic": "MODC",
            "syntax": "MODC    c               {WC}",
            "encoding": "EEEE 1101011 C01 0cccc0000 001101111",
            "description": "MODC, MODZ, or MODCZ sets or clears the C and/or Z flag based on the mode described by the given Modifier Result: The C and/or Z flag is set or cleared according to the given Modifier and the current state of the C and/or Z flags. C = cccc[{C,Z}], Z = zzzz[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "cccc[{C,Z}], Z = zzzz[{C,Z}]"
              },
              "Z": {
                "formula": "zzzz[{C,Z}]"
              }
            },
            "parameters": [
              "CModifer is a Modifier symbol for the designated mode to apply to the C flag.",
              "ZModifer is a Modifier symbol for the designated mode to apply to the Z flag.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 27
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_cz",
                "pattern": "#C{,#Z}",
                "description": "Modify condition flags: C flag value (4-bit), optional Z flag value (4-bit)",
                "valueType": 27
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "MODZ": {
            "mnemonic": "MODZ",
            "syntax": "MODZ    z               {WZ}",
            "encoding": "EEEE 1101011 0Z1 00000zzzz 001101111",
            "description": "MODC, MODZ, or MODCZ sets or clears the C and/or Z flag based on the mode described by the given Modifier Result: The C and/or Z flag is set or cleared according to the given Modifier and the current state of the C and/or Z flags. C = cccc[{C,Z}], Z = zzzz[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "cccc[{C,Z}], Z = zzzz[{C,Z}]"
              },
              "Z": {
                "formula": "zzzz[{C,Z}]"
              }
            },
            "parameters": [
              "CModifer is a Modifier symbol for the designated mode to apply to the C flag.",
              "ZModifer is a Modifier symbol for the designated mode to apply to the Z flag.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 27
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_cz",
                "pattern": "#C{,#Z}",
                "description": "Modify condition flags: C flag value (4-bit), optional Z flag value (4-bit)",
                "valueType": 27
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "MODCZ": {
            "mnemonic": "MODCZ",
            "syntax": "MODCZ   c,z      {WC/WZ/WCZ}",
            "encoding": "EEEE 1101011 CZ1 0cccczzzz 001101111",
            "description": "MODC, MODZ, or MODCZ sets or clears the C and/or Z flag based on the mode described by the given Modifier Result: The C and/or Z flag is set or cleared according to the given Modifier and the current state of the C and/or Z flags. C = cccc[{C,Z}], Z = zzzz[{C,Z}].",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "cccc[{C,Z}], Z = zzzz[{C,Z}]"
              },
              "Z": {
                "formula": "zzzz[{C,Z}]"
              }
            },
            "parameters": [
              "CModifer is a Modifier symbol for the designated mode to apply to the C flag.",
              "ZModifer is a Modifier symbol for the designated mode to apply to the Z flag.",
              "WC, WZ, or WCZ are optional effects to update flags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 27
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_cz",
                "pattern": "#C{,#Z}",
                "description": "Modify condition flags: C flag value (4-bit), optional Z flag value (4-bit)",
                "valueType": 27
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Color Manipulation Instruction - Add RGB colors with full saturation.": {
        "count": 1,
        "description": "Color Manipulation Instruction - Add RGB colors with full saturation.",
        "instructions": {
          "ADDPIX": {
            "mnemonic": "ADDPIX",
            "syntax": "ADDPIX Dest, {#}Src",
            "encoding": "EEEE 1010010 00I DDDDDDDDD SSSSSSSSS                    D                  \u2014                  \u2014                    7",
            "description": "ADDPIX sums individual RGB (reg, green, blue) color values of Src into that of Dest and stores the result in the Result: Src color value bytes are added into Dest color value bytes with full saturation.\n\nADDPIX sums individual RGB (reg, green, blue) color values of Src into that of Dest and stores the result in the\n\nDest register.",
            "timing": {
              "cycles": 7,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register containing the RGB color value to add Src to, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose RGB color value bytes are added into Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get number of 1s from Dest or Src into Dest.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get number of 1s from Dest or Src into Dest.",
        "instructions": {
          "ONES": {
            "mnemonic": "ONES",
            "syntax": "ONES Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0111101 CZI DDDDDDDDD SSSSSSSSS                    D           Result is odd        Result = 0                2",
              "EEEE 0111101 CZ0 DDDDDDDDD DDDDDDDDD                    D           Result is odd        Result = 0                2",
              "EEEE 1101011 CZL DDDDDDDDD 001001010                  OUTx       Orig OUTx base bit Orig OUTx base bit             2",
              "EEEE 1101011 CZL DDDDDDDDD 001001011                  OUTx       Orig OUTx base bit Orig OUTx base bit             2",
              "EEEE 1101011 CZL DDDDDDDDD 001001001                 OUTx        Orig OUTx base bit Orig OUTx base bit             2",
              "EEEE 1101011 CZL DDDDDDDDD 001001000                 OUTx        Orig OUTx base bit Orig OUTx base bit             2"
            ],
            "description": "ONES tallies the number of high bits of Src, or Dest, and stores the count into Dest. Result: The number of high bits in Src, or Dest, is stored in Dest.\n\nONES tallies the number of high bits of Src, or Dest, and stores the count into Dest.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the count is odd, or is cleared (0) if it is even.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result equals zero, or is cleared (0) if not zero.\n\nOUTC / OUTNC\n\nOutput C or not C\n\nI/O Pin Instruction - Set pin(s) output level to low/high according to C or !C.\n\nOUTC    {#}Dest {WCZ}\n\nOUTNC {#}Dest {WCZ}\n\nResult: The I/O pin output level bit(s), described by Dest, are set to low/high according to C or !C; the rest are left\n\nas-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) for which\n\noutput levels are to be set low or high.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX     DEST          SRC           Write             C Flag             Z Flag                 Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001001010                  OUTx       Orig OUTx base bit Orig OUTx base bit             2\n\nEEEE 1101011 CZL DDDDDDDDD 001001011                  OUTx       Orig OUTx base bit Orig OUTx base bit             2\n\nOUTC or OUTNC alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of\n\nthe C \ufb02ag; i.e. set pin's output level low or high. All other bits (pins) are left unchanged. Each of these\n\ninstructions, OUTC and OUTNC, can affect one or more of the bits within the OUTA or OUTB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the OUTC / OUTNC instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for OUTC / OUTNC's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (OUTA or\n\nOUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nOUTH / OUTL\n\nOutput high or low\n\nI/O Pin Instruction - Set pin(s) output level to high (1) or low (0).\n\nOUTH {#}Dest {WCZ}\n\nOUTL {#}Dest {WCZ}\n\nResult: The I/O pin output level bit(s), described by Dest, are set high (1) or low (0); the rest are left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set high\n\nor low.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX     DEST          SRC           Write             C Flag            Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001001001                 OUTx        Orig OUTx base bit Orig OUTx base bit             2\n\nEEEE 1101011 CZL DDDDDDDDD 001001000                 OUTx        Orig OUTx base bit Orig OUTx base bit             2\n\nOUTH or OUTL alters the output level register's bit(s) designated by Dest to be high (1) or low (0). All other bits\n\n(pins) are left unchanged. Each of these instructions, OUTH and OUTL, can affect one or more of the bits within\n\nthe OUTA or OUTB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the OUTH / OUTL instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for OUTH / OUTL's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (OUTA or\n\nOUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register in which to store the number of high bits found and optionally it begins by containing the value to check (syntax 2).",
              "Src is an optional register, 9-bit literal, or 32-bit augmented literal whose value is to be checked for ones.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set high or low.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 3
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_du",
                "pattern": "D{,S/#}",
                "description": "Destination register, optional Source register or immediate (unary/binary)",
                "valueType": 3
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Multiply unsigned 16-bit x 16-bit values.": {
        "count": 1,
        "description": "Math Instruction - Multiply unsigned 16-bit x 16-bit values.",
        "instructions": {
          "MUL": {
            "mnemonic": "MUL",
            "syntax": "MUL Dest, {#}Src {WZ}",
            "encoding": "EEEE 1010000 0ZI DDDDDDDDD SSSSSSSSS                    D                  \u2014           (D = 0) | (S = 0)             2",
            "description": "The 32-bit unsigned product of the 16-bit Dest and Src multiplication is stored into Dest and optionally the Z flag is updated to the Dest or Src zero status. D = unsigned (D[15:0] * S[15:0]).\n\nMUL multiplies the lower 16-bits of each of Dest and Src together and stores the 32-bit product result into the Dest\n\nregister. This is a fast (2-clock) 16 x 16 bit multiplication operation\u2014 to multiply larger factors, use the CORDIC\n\nSolver QMUL instruction.\n\nIf the WZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if either the Dest or Src values are zero, or is cleared (0) if both are\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "(S == 0) | (D == 0)"
              }
            },
            "parameters": [
              "Dest is a register containing the 16-bit value to multiply with Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 16-bit augmented literal whose value is multiplied into Dest.",
              "WZ is an optional effect to update the Z \ufb02ag."
            ],
            "related": [
              "MULS",
              "SCA",
              "QMUL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation / Math Instruction - Shift bits right; a.k.a. divide unsigned 32-bit integer by power-of-two.": {
        "count": 1,
        "description": "Bit Operation / Math Instruction - Shift bits right; a.k.a. divide unsigned 32-bit integer by power-of-two.",
        "instructions": {
          "SHR": {
            "mnemonic": "SHR",
            "syntax": "SHR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000010 CZI DDDDDDDDD SSSSSSSSS                            D      Last bit out   1",
            "description": "SHR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to 0. This is useful for Result: The bits of Dest are shifted right by Src bits, inserting zeros (0) as new leftmost bits.\n\nSHR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to 0. This is useful for\n\nbit-stream manipulation as well as for swift division; unsigned 32-bit integer division by a power-of-two. For\n\nsimilar division of a signed value, use SAR instead.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out (effectively C =\n\nresult bit \"-1\") if Src is 1\u201331, or to Dest[0] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "last bit shifted out if S[4:0] > 0, else D[0]"
              }
            },
            "parameters": [
              "Dest is the register containing the value to right shift by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bits to shift right.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Decrement with modulus.": {
        "count": 1,
        "description": "Math Instruction - Decrement with modulus.",
        "instructions": {
          "DECMOD": {
            "mnemonic": "DECMOD",
            "syntax": "DECMOD Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0111001 CZI DDDDDDDDD SSSSSSSSS                     D         Modulus triggered       Result = 0               2",
            "description": "DECMOD compares Dest with 0\u2014 if not equal, it decrements Dest; otherwise it sets Dest equal to Src. If Dest Result: If Dest was not equal to 0, it is decremented by 1; otherwise Dest is reset to Src. Optionally, C and Z are updated to indicate reset and zero result status.\n\nDECMOD compares Dest with 0\u2014 if not equal, it decrements Dest; otherwise it sets Dest equal to Src. If Dest\n\nbegins in the range 0 to Src, iterations of DECMOD will decrement Dest repetitively from Src to 0.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was equal to 0 and subsequently reset to Src; or is\n\ncleared (0) if not reset.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.\n\nDECMOD does not limit Dest within the speci\ufb01ed range\u2014 if Dest begins as greater than Src, iterations of DECMOD\n\nwill continue to decrement it down through Src before it will effectively cycle from Src to 0.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to decrement down to 0 with modulus, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is the modulus limit to apply to Dest's decrement operation.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "INCMOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to output and output level to random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to output and output level to random low/high.",
        "instructions": {
          "DRVRND": {
            "mnemonic": "DRVRND",
            "syntax": "DRVRND {#}Dest {WCZ}",
            "encoding": [
              "EEEE 1101011 CZL DDDDDDDDD 001011110 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
              "EEEE 1101011 CZL DDDDDDDDD 001011100 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2",
              "EEEE 1101011 CZL DDDDDDDDD 001011101 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2"
            ],
            "description": "DRVRND sets the I/O pin(s) designated by Dest to the output direction and with output level(s) set randomly low Result: The I/O pins described by Dest are set to the output direction and each output level is set randomly low or high; the rest are left as-is. Z = OUT bit.\n\nDRVRND sets the I/O pin(s) designated by Dest to the output direction and with output level(s) set randomly low\n\nand high, based on bit(s) from the Xoroshiro128** PRNG. All other pins are left unchanged. This instruction can\n\naffect one or more of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nDRVRND achieves the same effect as two instructions\u2014 OUTRND followed by DIRH.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DRVRND instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DRVRND's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nDRVZ / DRVNZ\n\nDrive Z or not Z\n\nI/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to Z or !Z.\n\nDRVZ       {#}Dest {WCZ}\n\nDRVNZ {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the output direction and to an output level of low/high according\n\nto Z or !Z; the rest are left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput direction and output levels of low or high.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR            FX     DEST          SRC            Write             C Flag             Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001011100 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2\n\nEEEE 1101011 CZL DDDDDDDDD 001011101 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a DRVZ or DRVNZ.\n\nDRVZ or DRVNZ sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level\n\naccording to the state, or inverse state, of the Z \ufb02ag; i.e. alters the pin's direction and output registers. All other\n\npins are left unchanged. Each of these instructions, DRVZ and DRVNZ, can affect one or more of the bits within\n\nthe DIRA or DIRB and OUTA or OUTB registers.\n\nDRVZ or DRVNZ achieves the same effect as two instructions\u2014 OUTZ, or OUTNZ, followed by DIRH.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DRVZ / DRVNZ instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DRVZ / DRVNZ's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to the output direction and with output level(s) set randomly to low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output direction and output levels of low or high.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Increment with modulus.": {
        "count": 1,
        "description": "Math Instruction - Increment with modulus.",
        "instructions": {
          "INCMOD": {
            "mnemonic": "INCMOD",
            "syntax": "INCMOD Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0111000 CZI DDDDDDDDD SSSSSSSSS                      D          Modulus triggered   Result = 0              2",
              "EEEE 1011110 01I 000001110 SSSSSSSSS                     PC   1",
              "EEEE 1011110 01I 000000001 SSSSSSSSS                     PC1                 \u2014             \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000000010 SSSSSSSSS                     PC1                 \u2014             \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000000011 SSSSSSSSS                     PC   1",
              "EEEE 1011110 01I 000001001 SSSSSSSSS                      PC   1",
              "EEEE 1011110 01I 000000000 SSSSSSSSS                      PC   1",
              "EEEE 1011110 01I 000001000 SSSSSSSSS                      PC   1",
              "EEEE 1011110 01I 000001111 SSSSSSSSS                      PC1                 \u2014                   \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000011111 SSSSSSSSS                      PC1                 \u2014                   \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000000100 SSSSSSSSS                      PC   1",
              "EEEE 1011110 01I 000001011 SSSSSSSSS                     PC   1",
              "EEEE 1011110 01I 000001010 SSSSSSSSS                     PC1                 \u2014               \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000011010 SSSSSSSSS                     PC1                 \u2014               \u2014           2 or 4 / 2 or 13\u201320",
              "EEEE 1011110 01I 000001101 SSSSSSSSS                     PC   1",
              "EEEE 1011110 01I 000001100 SSSSSSSSS                     PC   1",
              "EEEE 1101011 C01 0cccc0000 001101111                \u2014           C=cccc[{C,Z}]          \u2014                     2",
              "EEEE 1101011 0Z1 00000zzzz 001101111                \u2014                \u2014            Z=zzzz[{C,Z}]              2",
              "EEEE 1101011 CZ1 0cccczzzz 001101111                \u2014           C=cccc[{C,Z}]     Z=zzzz[{C,Z}]              2"
            ],
            "description": "INCMOD compares Dest with Src\u2014 if not equal, it increments Dest; otherwise it sets Dest equal to 0. If Dest Result: If Dest was not equal to Src, it is incremented by 1; otherwise Dest is reset to 0. Optionally, C and Z are updated to indicate reset and zero result status.\n\nINCMOD compares Dest with Src\u2014 if not equal, it increments Dest; otherwise it sets Dest equal to 0. If Dest\n\nbegins in the range 0 to Src, iterations of INCMOD will increment Dest repetitively from 0 to Src.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was equal to Src and subsequently reset to 0; or is\n\ncleared (0) if not reset.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.\n\nINCMOD does not limit Dest within the speci\ufb01ed range\u2014 if Dest begins as greater than Src, iterations of INCMOD\n\nwill continue to increment it through the 32-bit rollover point (back to 0) before it will effectively cycle from 0 to\n\nSrc.\n\nJATN / JNATN\n\nJump if attention or not attention\n\nEvent Branch Instruction - Jump if attention \ufb02ag is set or clear.\n\nJATN        {#}Src\n\nJNATN {#}Src\n\nResult: If ATN event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST           SRC            Write             C Flag          Z Flag             Clocks\n\nEEEE 1011110 01I 000001110 SSSSSSSSS                     PC   1\n\n\u2014              \u2014          2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011110 SSSSSSSSS                     PC   1\n\n\u2014              \u2014          2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the ATN event \ufb02ag is set (or is clear in syntax 2).\n\nJATN or JNATN checks the cog's attention signal and jumps to the address described by Src if attention is set (in\n\nsyntax 1) or is clear (in syntax 2). The cog's attention signal, when set, indicates that one or more other cogs are\n\nrequesting this cog's attention. See the Hardware Manual's Cog Attention section for more information.\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JATN / JNATN. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJCT1/2/3 / JNCT1/2/3\n\nJump if counter 1/2/3 or not counter 1/2/3\n\nEvent Branch Instruction - Jump if counter 1, 2, or 3 event \ufb02ag is set or clear.\n\nJCT1        {#}Src\n\nJCT2        {#}Src\n\nJCT3        {#}Src\n\nJNCT1 {#}Src\n\nJNCT2 {#}Src\n\nJNCT3 {#}Src\n\nResult: If counter 1, 2, or 3 event \ufb02ag is set (or is clear in syntax 4\u20136), PC is set to a new relative (#Src) or absolute\n\n(Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST           SRC            Write             C Flag         Z Flag             Clocks\n\nEEEE 1011110 01I 000000001 SSSSSSSSS                     PC1                 \u2014             \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000000010 SSSSSSSSS                     PC1                 \u2014             \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000000011 SSSSSSSSS                     PC   1\n\n\u2014             \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010001 SSSSSSSSS                     PC   1\n\n\u2014             \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010010 SSSSSSSSS                     PC   1\n\n\u2014             \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010001 SSSSSSSSS                     PC   1\n\n\u2014             \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the counter event \ufb02ag is set (or is clear in syntax 4\u20136).\n\nJCT1, JCT2, JCT3, or JNCT1, JNCT2, JNCT3 checks the cog's counter 1, 2, or 3 event \ufb02ag and jumps to the\n\naddress described by Src if the \ufb02ag is set (in syntax 1\u20133) or is clear (in syntax 4\u20136). The cog's hidden registers,\n\nCT1, CT2, and CT3 are dedicated to System Counter timing and events\u2014 when a counter event \ufb02ag is set, it means\n\na speci\ufb01ed time period has elapsed. See the Hardware Manual's System Counter section for more information.\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JCTx / JNCTx. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nRelated instructions are ADDCTx, POLLCTx, and WAITCTx.\n\nJFBW / JNFBW\n\nJump if FIFO block wrap or not FIFO block wrap\n\nEvent Branch Instruction - Jump if FIFO interface block wrap event \ufb02ag is set or clear.\n\nJFBW        {#}Src\n\nJNFBW {#}Src\n\nResult: If FIFO interface block wrap event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC            Write              C Flag             Z Flag             Clocks\n\nEEEE 1011110 01I 000001001 SSSSSSSSS                      PC   1\n\n\u2014                    \u2014        2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011001 SSSSSSSSS                      PC   1\n\n\u2014                    \u2014        2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the FIFO interface block wrap event \ufb02ag is set (or is clear in syntax 2).\n\nJFBW or JNFBW checks the cog's FIFO interface block wrap \ufb02ag and jumps to the address described by Src if the\n\n\ufb02ag is set (in syntax 1) or is clear (in syntax 2). The cog's Fast Sequential FIFO Interface is used to swiftly transfer\n\ndata between Hub and Cog. When the FIFO runs out of data (block count), it sets this \ufb02ag before wrapping\n\naround to the start of the block again.\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JFBW / JNFBW. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJINT / JNINT\n\nJump if interrupt or not interrupt\n\nEvent Branch Instruction - Jump if interrupt-occurred event \ufb02ag is set or clear.\n\nJINT        {#}Src\n\nJNINT {#}Src\n\nResult: If interrupt-occurred event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute\n\n(Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC            Write              C Flag             Z Flag             Clocks\n\nEEEE 1011110 01I 000000000 SSSSSSSSS                      PC   1\n\n\u2014                    \u2014        2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010000 SSSSSSSSS                      PC   1\n\n\u2014                    \u2014        2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the interrupt event \ufb02ag is set (or is clear in syntax 2).\n\nJINT or JNINT checks the cog's interrupt-occurred \ufb02ag and jumps to the address described by Src if the \ufb02ag is\n\nset (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JINT / JNINT. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJPAT / JNPAT\n\nJump if pattern or not pattern\n\nEvent Branch Instruction - Jump if pin pattern event \ufb02ag set or clear.\n\nJPAT        {#}Src\n\nJNPAT {#}Src\n\nResult: If pin pattern event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute (Src)\n\naddress.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST          SRC             Write              C Flag              Z Flag             Clocks\n\nEEEE 1011110 01I 000001000 SSSSSSSSS                      PC   1\n\n\u2014                   \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011000 SSSSSSSSS                      PC   1\n\n\u2014                   \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the pin pattern event \ufb02ag is set (or is clear in syntax 2).\n\nJPAT or JNPAT checks the cog's pin-pattern-detected event \ufb02ag and jumps to the address described by Src if the\n\n\ufb02ag is set (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JPAT / JNPAT. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJQMT / JNQMT\n\nJump if CORDIC empty or not CORDIC empty\n\nEvent Branch Instruction - Jump if CORDIC-read-but-empty event \ufb02ag set or clear.\n\nJQMT        {#}Src\n\nJNQMT {#}Src\n\nResult: If CORDIC-read-but-empty event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST          SRC             Write              C Flag              Z Flag             Clocks\n\nEEEE 1011110 01I 000001111 SSSSSSSSS                      PC1                 \u2014                   \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011111 SSSSSSSSS                      PC1                 \u2014                   \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the CORDIC-read-but-empty event \ufb02ag is set (or is clear in syntax 2).\n\nJQMT or JNQMT checks the cog's CORDIC results event \ufb02ag and jumps to the address described by Src if the \ufb02ag\n\nis set (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JQMT / JNQMT. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJSE1/2/3/4 / JNSE1/2/3/4\n\nJump if selectable event 1/2/3/4 or not selectable event 1/2/3/4\n\nEvent Branch Instruction - Jump if selectable event 1, 2, 3, or 4 \ufb02ag is set or clear.\n\nJSE1        {#}Src\n\nJSE2        {#}Src\n\nJSE3        {#}Src\n\nJSE4        {#}Src\n\nJNSE1 {#}Src\n\nJNSE2 {#}Src\n\nJNSE3 {#}Src\n\nJNSE4 {#}Src\n\nResult: If selectable event 1, 2, 3, or 4 \ufb02ag is set (or is clear in syntax 5\u20138), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC            Write              C Flag               Z Flag             Clocks\n\nEEEE 1011110 01I 000000100 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000000101 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000000110 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000000111 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010100 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010101 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010110 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000010111 SSSSSSSSS                      PC   1\n\n\u2014                     \u2014         2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the selectable event 1, 2, 3, or 4 \ufb02ag is set (or is clear in syntax 5\u20138).\n\nJSE1, JSE2, JSE3, JSE4, or JNSE1, JNSE2, JNSE3, JNSE4 checks the cog's selectable event 1, 2, 3, or 4 event\n\n\ufb02ag and jumps to the address described by Src if the \ufb02ag is set (in syntax 1\u20134) or is clear (in syntax 5\u20138).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JSEx / JNSEx. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJXFI / JNXFI\n\nJump if streamer \ufb01nished or not streamer \ufb01nished\n\nEvent Branch Instruction - Jump if streamer \ufb01nished event \ufb02ag set or clear.\n\nJXFI       {#}Src\n\nJNXFI {#}Src\n\nResult: If streamer \ufb01nished event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute\n\n(Src) address.\n\n\u25cf   Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST          SRC            Write              C Flag           Z Flag             Clocks\n\nEEEE 1011110 01I 000001011 SSSSSSSSS                     PC   1\n\n\u2014               \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011011 SSSSSSSSS                     PC   1\n\n\u2014               \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the streamer \ufb01nished event \ufb02ag is set (or is clear in syntax 2).\n\nJXFI or JNXFI checks the cog's streamer \ufb01nished event \ufb02ag and jumps to the address described by Src if the\n\n\ufb02ag is set (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JXFI / JNXFI. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJXMT / JNXMT\n\nJump if streamer empty or not streamer empty\n\nEvent Branch Instruction - Jump if streamer empty event \ufb02ag set or clear.\n\nJXMT       {#}Src\n\nJNXMT {#}Src\n\nResult: If streamer empty event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or absolute\n\n(Src) address.\n\n\u25cf   Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST          SRC            Write              C Flag           Z Flag             Clocks\n\nEEEE 1011110 01I 000001010 SSSSSSSSS                     PC1                 \u2014               \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011010 SSSSSSSSS                     PC1                 \u2014               \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the streamer empty event \ufb02ag is set (or is clear in syntax 2).\n\nJXMT or JNXMT checks the cog's streamer empty event \ufb02ag and jumps to the address described by Src if the \ufb02ag\n\nis set (in syntax 1) or is clear (in syntax 2). The address (Src) can be absolute or relative. To specify an absolute\n\naddress, Src must be a register containing a 20-bit address value. To specify a relative address, use #Label for a\n\n9-bit signed offset (a range of -256 to +255 instructions) or use ##Label (or insert a prior AUGS instruction) for a\n\n20-bit signed offset (a range of -524288 to +524287). Offsets are relative to the instruction following the JXMT /\n\nJNXMT. The signed offset value is in units of whole instructions\u2014 it is added to PC as-is when in Cog/LUT\n\nexecution mode and is multiplied by 4 then added to PC when in Hub execution mode (long-aligned Hub code not\n\nrequired).\n\nJXRL / JNXRL\n\nJump if streamer rollover LUT or not streamer rollover LUT\n\nEvent Branch Instruction - Jump if streamer LUT RAM rollover event \ufb02ag set or clear.\n\nJXRL       {#}Src\n\nJNXRL {#}Src\n\nResult: If streamer LUT RAM rollover event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf   Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST          SRC             Write             C Flag                Z Flag             Clocks\n\nEEEE 1011110 01I 000001101 SSSSSSSSS                     PC   1\n\n\u2014                    \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011101 SSSSSSSSS                     PC   1\n\n\u2014                    \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the streamer LUT RAM rollover event \ufb02ag is set (or is clear in syntax 2).\n\nJXRL or JNXRL checks the cog's streamer LUT RAM rollover event \ufb02ag and jumps to the address described by Src\n\nif the \ufb02ag is set (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JXRL / JNXRL. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nJXRO / JNXRO\n\nJump if streamer rollover NCO or not streamer rollover NCO\n\nEvent Branch Instruction - Jump if streamer NCO rollover event \ufb02ag set or clear.\n\nJXRO       {#}Src\n\nJNXRO {#}Src\n\nResult: If streamer NCO rollover event \ufb02ag is set (or is clear in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf   Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR            FX      DEST          SRC             Write             C Flag                Z Flag             Clocks\n\nEEEE 1011110 01I 000001100 SSSSSSSSS                     PC   1\n\n\u2014                    \u2014           2 or 4 / 2 or 13\u201320\n\nEEEE 1011110 01I 000011100 SSSSSSSSS                     PC   1\n\n\u2014                    \u2014           2 or 4 / 2 or 13\u201320\n\n1\n\nPC is written only when the streamer NCO rollover event \ufb02ag is set (or is clear in syntax 2).\n\nJXRO or JNXRO checks the cog's streamer NCO rollover event \ufb02ag and jumps to the address described by Src if\n\nthe \ufb02ag is set (in syntax 1) or is clear (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the JXRO / JNXRO. The signed offset value is in units\n\nof whole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added\n\nto PC when in Hub execution mode (long-aligned Hub code not required).\n\nMODC / MODZ / MODCZ\n\nModify C, Z, or C and Z\n\nFlag Modi\ufb01cation Instruction - Modify C and/or Z \ufb02ag(s) according to modi\ufb01er mode and current state(s).\n\nMODC    CModi\ufb01er {WC}\n\nMODZ    ZModi\ufb01er {WZ}\n\nMODCZ CModi\ufb01er, ZModi\ufb01er {WC|WZ|WCZ}\n\nResult: The C and/or Z \ufb02ag is set or cleared according to the given Modi\ufb01er and the current state of the C and/or\n\nZ \ufb02ags.\n\n\u25cf   CModifer is a Modi\ufb01er symbol for the designated mode to apply to the C \ufb02ag.\n\n\u25cf   ZModifer is a Modi\ufb01er symbol for the designated mode to apply to the Z \ufb02ag.\n\n\u25cf   WC, WZ, or WCZ are optional effects to update \ufb02ags.\n\nCOND INSTR        FX     DEST        SRC           Write            C Flag            Z Flag             Clocks\n\nEEEE 1101011 C01 0cccc0000 001101111                \u2014           C=cccc[{C,Z}]          \u2014                     2\n\nEEEE 1101011 0Z1 00000zzzz 001101111                \u2014                \u2014            Z=zzzz[{C,Z}]              2\n\nEEEE 1101011 CZ1 0cccczzzz 001101111                \u2014           C=cccc[{C,Z}]     Z=zzzz[{C,Z}]              2\n\nMODC, MODZ, or MODCZ sets or clears the C and/or Z \ufb02ag based on the mode described by the given Modi\ufb01er\n\nsymbol(s) and the current state of the C and/or Z \ufb02ag. The WC, WZ, and WCZ effects are required to affect the\n\ndesignated \ufb02ag.\n\nThese \ufb02ag modi\ufb01er instructions allow code to preset \ufb02ags to a desired state which may be required for entry into\n\ncertain code routines, or to set a special state based on multiple events that are otherwise not possible to realize\n\nwith a single instruction.\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C, Z, or both C and Z \ufb02ags are updated according to the given\n\nCModi\ufb01er or ZModi\ufb01er. See the Modi\ufb01er Symbols table for details.\n\nModifier Symbols (for MODC / MODZ / MODCZ)\n\nModifier1      Encoding2      Description\n\n_CLR              %0000      Clear C/Z (C == 0 and/or Z == 0)\n\n_E                %1010      Set C/Z if comparison/subtraction was equal (C == Z and/or Z == Z)\n\n_NE               %0101      Set C/Z if comparison/subtraction was not equal (C == !Z and/or Z == !Z)\n\n_GT               %0001      Set C/Z if comparison/subtraction was greater than (C == !C AND !Z and/or Z == !C AND !Z)\n\n_GE               %0011      Set C/Z if comparison/subtraction was greater than or equal (C == !C and/or Z == !C)\n\n_LT               %1100      Set C/Z if comparison/subtraction was less than (C == C and/or Z == C)\n\n_LE               %1110      Set C/Z if comparison/subtraction was less than or equal (C == C OR Z and/or Z == C OR Z)\n\n_C                %1100      Set C/Z to C (C == C and/or Z == C)\n\n_NC               %0011      Set C/Z to inverse of C (C == !C and/or Z == !C)\n\n_Z                %1010      Set C/Z to Z (C == Z and/or Z == Z)\n\n_NZ               %0101      Set C/Z to inverse of Z (C == !Z and/or Z == !Z)\n\n_C_EQ_Z           %1001      Set C/Z if C equal to Z (C == C = Z and/or Z == C = Z)\n\n_C_NE_Z           %0110      Set C/Z if C not equal to Z (C == C <> Z and/or Z == C <> Z)\n\n_C_AND_Z          %1000      Set C/Z to C AND Z (C == C AND Z and/or Z == C AND Z)\n\n_C_AND_NZ         %0100      Set C/Z to C AND NOT Z (C == C AND !Z and/or Z == C AND !Z)\n\n_NC_AND_Z         %0010      Set C/Z to NOT C AND Z (C == !C AND Z and/or Z == !C AND Z)\n\n_NC_AND_NZ        %0001      Set C/Z to NOT C AND NOT Z (C == !C AND !Z and/or Z == !C AND !Z)\n\n_C_OR_Z           %1110      Set C/Z to C OR Z (C == C OR Z and/or Z == C OR Z)\n\n_C_OR_NZ          %1101      Set C/Z to C OR NOT Z (C == C OR !Z and/or Z == C OR !Z)\n\n_NC_OR_Z          %1011      Set C/Z to NOT C OR Z (C == !C OR Z and/or Z == !C OR Z)\n\n_NC_OR_NZ         %0111      Set C/Z to NOT C OR NOT Z (C == !C OR !Z and/or Z == !C OR !Z)\n\n_Z_EQ_C           %1001      Set C/Z if Z equal to C (C == Z = C and/or Z == Z = C)\n\n_Z_NE_C           %0110      Set C/Z if Z not equal to C (C == Z <> C and/or Z == Z <> C)\n\n_Z_AND_C          %1000      Set C/Z to Z AND C (C == Z AND C and/or Z == Z AND C)\n\n_Z_AND_NC         %0010      Set C/Z to Z AND NOT C (C == Z AND !C and/or Z == Z AND !C)\n\n_NZ_AND_C         %0100      Set C/Z to NOT Z AND C (C == !Z AND C and/or Z == !Z AND C)\n\n_NZ_AND_NC        %0001      Set C/Z to NOT Z AND NOT C (C == !Z AND !C and/or Z == !Z AND !C)\n\n_Z_OR_C           %1110      Set C/Z to Z OR C (C == Z OR C and/or Z == Z OR C)\n\n_Z_OR_NC          %1011      Set C/Z to Z OR NOT C (C == Z OR !C and/or Z == Z OR !C)\n\n_NZ_OR_C          %1101      Set C/Z to NOT Z OR C (C == !Z OR C and/or Z == !Z OR C)\n\n_NZ_OR_NC         %0111      Set C/Z to NOT Z OR NOT C (C == !Z OR !C and/or Z == !Z OR !C)\n\n_SET              %1111      Set C/Z (C == 1 and/or Z == 1)\n\n1\n\nUse Modi\ufb01er symbol(s) in MODC, MODZ, and MODCZ instructions. Note that the symbol and description is similar to, and\n\nthe encoding exactly matches, that of the related Conditions used to include/exclude instructions at run time.\n\n2\n\nThe encoding is the 4-bit value placed into the MODC, MODZ, and MODCZ instruction's cccc or zzzz opcode \ufb01eld by the\n\ncompiler.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the value to increment up to Src with modulus, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is the modulus limit to apply to Dest's increment operation.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "CModifer is a Modi\ufb01er symbol for the designated mode to apply to the C \ufb02ag.",
              "ZModifer is a Modi\ufb01er symbol for the designated mode to apply to the Z \ufb02ag.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "DECMOD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear pin-pattern-detected event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear pin-pattern-detected event \ufb02ag.",
        "instructions": {
          "WAITPAT": {
            "mnemonic": "WAITPAT",
            "syntax": "WAITPAT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000011000 000100100                 \u2014          Timeout Abort       Timeout Abort              2+",
            "description": "WAITPAT waits for a pin-pattern-detected event to occur (unless the event flag is already set), then clears the Result: Wait for pin-pattern-detected event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITPAT waits for a pin-pattern-detected event to occur (unless the event \ufb02ag is already set), then clears the\n\nevent \ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction.\n\nOptionally, WAITPAT can time-out if the pin-pattern-detected event doesn't occur soon enough; setting C and/or Z\n\n\ufb02ags and then resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITPAT.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe pin-pattern-detected event \ufb02ag is set whenever the masked input pins match or don't match the pattern\n\ndescribed by a previous SETPAT instruction. The pin-pattern-detected event \ufb02ag is cleared upon execution of\n\nSETPAT, POLLPAT, WAITPAT, JPAT, or JNPAT instructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual         \u25aa   Page 141"
            ],
            "related": [
              "SETPAT",
              "POLLPAT",
              "JPAT",
              "JNPAT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Rotate carry \ufb02ag right into value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Rotate carry \ufb02ag right into value.",
        "instructions": {
          "RCR": {
            "mnemonic": "RCR",
            "syntax": "RCR Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0000100 CZI DDDDDDDDD SSSSSSSSS                           D      Last bit out1    Result = 0               2",
            "description": "RCR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to C. Result: The bits of Dest are shifted right by Src bits, inserting C as new MSBs.\n\nRCR shifts Dest's binary value right by Src places (0\u201331 bits) and sets the new MSBs to C.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is updated to the value of the last bit shifted out if Src is 1\u201331, or to\n\nDest[0] if Src is 0.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the Dest result equals zero, or is cleared (0) if it is\n\nnon-zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is the register containing the value to rotate carry right by Src bits.",
              "Src is a register or 5-bit literal whose value indicates the number of bit positions to rotate.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a byte from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a byte from a value.",
        "instructions": {
          "GETBYTE": {
            "mnemonic": "GETBYTE",
            "syntax": "GETBYTE Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1000111 NNI DDDDDDDDD SSSSSSSSS                  D                 \u2014                  \u2014                    2",
              "EEEE 1000111 000 DDDDDDDDD 000000000                  D                 \u2014                  \u2014                    2"
            ],
            "description": "GETBYTE reads the byte identified by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB Result: Byte Num (0\u20133) of Src, or a byte from a source described by prior ALTGB instruction, is written to Dest.\n\nGETBYTE reads the byte identi\ufb01ed by Num (0\u20133) from Src, or a byte from the source described by a prior ALTGB\n\ninstruction.\n\nNum (0\u20133) identi\ufb01es a value's individual bytes, by position, in least-signi\ufb01cant byte order.\n\nSyntax 2 is intended for use after an ALTGB instruction; i.e. in a loop to iteratively read a series of byte values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the byte.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target byte to read.",
              "Num is a 2-bit literal identifying the byte ID (0\u20133) of Src to read."
            ],
            "related": [
              "ALTGB",
              "GETNIB",
              "GETWORD",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 9
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds2get",
                "pattern": "D{,S/#,#0..3}",
                "description": "Get byte: destination, optional source and byte index 0-3",
                "valueType": 9
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Compare two unsigned values and subtract the second if it is lesser or equal.": {
        "count": 1,
        "description": "Math Instruction - Compare two unsigned values and subtract the second if it is lesser or equal.",
        "instructions": {
          "CMPSUB": {
            "mnemonic": "CMPSUB",
            "syntax": "CMPSUB Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": "EEEE 0010111 CZI DDDDDDDDD SSSSSSSSS                 D1",
            "description": "CMPSUB compares the unsigned values of Dest and Src, and if Src is less than or equal to Dest then it is Result: Dest is decremented by Src unless it is less than Src, and the comparison results are optionally written to the C and Z flags.\n\nCMPSUB compares the unsigned values of Dest and Src, and if Src is less than or equal to Dest then it is\n\nsubtracted from Dest. Optionally, the C and Z \ufb02ags are set to indicate the comparison and operation results.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was greater than or equal to Src.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result equals 0.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "formula": "1, else D same and C = 0"
              }
            },
            "parameters": [
              "Dest is the register containing the value to compare with Src and is the destination written to if a subtraction is performed.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value is compared with and possibly subtracted from Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set discrete bits of a value to that of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete bits of a value to that of another.",
        "instructions": {
          "MUXQ": {
            "mnemonic": "MUXQ",
            "syntax": "MUXQ Dest, {#}Src",
            "encoding": [
              "EEEE 1001111 10I DDDDDDDDD SSSSSSSSS                     D                 \u2014                   \u2014                    2",
              "EEEE 0101110 CZI DDDDDDDDD SSSSSSSSS                     D          Parity of Result      Result = 0                2",
              "EEEE 0101111 CZI DDDDDDDDD SSSSSSSSS                     D          Parity of Result      Result = 0                2"
            ],
            "description": "MUXQ copies all bits from Src corresponding to high (1) bits of Q into the corresponding\nbits of Dest. All other bits remain unchanged.\n\nCritical for parallel bit operations, especially RGB LED driving where\nmultiple data lines need simultaneous updates.\n\n\nMUXQ copies all bits from Src corresponding to high (1) bits of Q into the corresponding bits of Dest. All other\n\nDest bits are left as-is.\n\nMUXQ must be preceded by SETQ to function properly since the Q value's high bits identify the bits to target in Src\n\nand Dest.\n\nMUXZ / MUXNZ\n\nMux Z or mux not Z\n\nBit Operation Instructions - Set discrete bits to Z or !Z\n\nMUXZ     Dest, {#}Src {WC|WZ|WCZ}\n\nMUXNZ Dest, {#}Src {WC|WZ|WCZ}\n\nResult: Dest bit(s) described by Src are set to Z or !Z; the rest are left as-is. Flags are optionally updated with\n\nparity and zero status of the result.\n\n\u25cf    Dest is the register whose value will have one or more bits set to Z or !Z.\n\n\u25cf    Src is a register, 9-bit literal, or 32-bit augmented literal whose value identi\ufb01es the bit(s) to modify.\n\n\u25cf    WC, WZ, or WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR         FX      DEST          SRC           Write             C Flag              Z Flag              Clocks\n\nEEEE 0101110 CZI DDDDDDDDD SSSSSSSSS                     D          Parity of Result      Result = 0                2\n\nEEEE 0101111 CZI DDDDDDDDD SSSSSSSSS                     D          Parity of Result      Result = 0                2\n\nMUXZ or MUXNZ alters the Dest bit(s) designated by Src (high bits) to equal the state, or inverse state, of the Z \ufb02ag.\n\nAll Dest bits corresponding to high (1) bits in Src are modi\ufb01ed; all other Dest bits are left unchanged.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if the number of high (1) bits in the result is odd, or is\n\ncleared (0) if it is even.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is not zero.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register whose bits will be updated according to Q and Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose select bits will replace the corresponding bits in Dest.",
              "Dest is the register whose value will have one or more bits set to Z or !Z.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WC, WZ, or WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-\ufb01nished event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-\ufb01nished event \ufb02ag.",
        "instructions": {
          "POLLXFI": {
            "mnemonic": "POLLXFI",
            "syntax": "POLLXFI {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001011 000100100                  \u2014             XFI Event          XFI Event                2",
            "description": "Streamer-finished event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLXFI copies the state of the streamer-\ufb01nished event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless it's\n\nbeing set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the streamer-\ufb01nished\n\nevent \ufb02ag prior to clearing it.\n\nThe streamer-\ufb01nished event \ufb02ag is set whenever the streamer runs out of commands to process. The\n\nstreamer-\ufb01nished event \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXFI, WAITXFI, JXFI, or\n\nJNXFI instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXFI",
              "JXFI",
              "JNXFI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-empty event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-empty event \ufb02ag.",
        "instructions": {
          "POLLXMT": {
            "mnemonic": "POLLXMT",
            "syntax": "POLLXMT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001010 000100100                \u2014            XMT Event         XMT Event                2",
            "description": "POLLXMT copies the state of the streamer-empty event flag into C and/or Z and then clears the flag (unless it's Result: Streamer-empty event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLXMT copies the state of the streamer-empty event \ufb02ag into C and/or Z and then clears the \ufb02ag (unless it's\n\nbeing set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the streamer-empty\n\nevent \ufb02ag prior to clearing it.\n\nThe streamer-empty event \ufb02ag is set whenever the streamer is ready for a new command. The streamer-empty\n\nevent \ufb02ag is cleared upon execution of XINIT, XZERO, XCONT, POLLXMT, WAITXMT, JXMT, or JNXMT instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXMT",
              "JXMT",
              "JNXMT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set a nibble to new value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set a nibble to new value.",
        "instructions": {
          "SETNIB": {
            "mnemonic": "SETNIB",
            "syntax": "SETNIB Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 100000N NNI DDDDDDDDD SSSSSSSSS                        D                    \u2014                \u2014                     2",
              "EEEE 1000000 00I 000000000 SSSSSSSSS                       D   1"
            ],
            "description": "SETNIB stores Src[3:0] into the nibble identified by Num within Dest, or the nibble and register described by a prior Result: Src[3:0] is written to nibble Num (0\u20137) of Dest, or to another register nibble described by prior ALTSN instruction.\n\nSETNIB stores Src[3:0] into the nibble identi\ufb01ed by Num within Dest, or the nibble and register described by a prior\n\nALTSN instruction. No other bits are modi\ufb01ed.\n\nNum (0\u20137) identi\ufb01es a value's individual nibbles, by position, in least-signi\ufb01cant nibble order.\n\nSyntax 2 is intended for use after an ALTSN instruction; i.e. in a loop to iteratively affect a series of nibble values\n\nwithin contiguous long registers.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Dest is the register in which to modify a nibble.",
              "Src is a register or 4-bit literal whose bits [3:0] will be stored in the designated location.",
              "Num is a 3-bit literal identifying the nibble ID (0\u20137) of Dest to modify."
            ],
            "related": [
              "ALTSN",
              "SETBYTE",
              "SETWORD",
              "GETNIB",
              "GETBYTE",
              "GETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 6
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds3set",
                "pattern": "S/#{,D,#0..7}",
                "description": "Set nibble: source/immediate, optional destination and nibble index 0-7",
                "valueType": 6
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Flow Control Instruction - Decrement, jump if zero or not zero.": {
        "count": 2,
        "description": "Flow Control Instruction - Decrement, jump if zero or not zero.",
        "instructions": {
          "DJNZ": {
            "mnemonic": "DJNZ",
            "syntax": "DJNZ    D,{#}S",
            "encoding": "EEEE 1011011 01I DDDDDDDDD SSSSSSSSS",
            "description": "DJZ or DJNZ decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          },
          "DJZ": {
            "mnemonic": "DJZ",
            "syntax": "DJZ     D,{#}S",
            "encoding": "EEEE 1011011 00I DDDDDDDDD SSSSSSSSS",
            "description": "DJZ or DJNZ decrements the value in Dest, writes the result, and jumps to the address described by Src if the Result: Dest is decremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or absolute (Src) address.",
            "timing": {
              "cycles": 2,
              "type": "variable",
              "range": "13...20"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              },
              "Z": {
                "when": "and"
              }
            },
            "parameters": [
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 12
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_dsj",
                "pattern": "D,S/@",
                "description": "Jump with destination and relative address: register, relative address",
                "valueType": 12
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) output level to random low/high.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) output level to random low/high.",
        "instructions": {
          "OUTRND": {
            "mnemonic": "OUTRND",
            "syntax": "OUTRND {#}Dest {WCZ}",
            "encoding": [
              "EEEE 1101011 CZL DDDDDDDDD 001001110                OUTx       Orig OUTx base bit Orig OUTx base bit            2",
              "EEEE 1101011 CZL DDDDDDDDD 001001100                OUTx       Orig OUTx base bit Orig OUTx base bit            2",
              "EEEE 1101011 CZL DDDDDDDDD 001001101                OUTx       Orig OUTx base bit Orig OUTx base bit            2"
            ],
            "description": "OUTRND alters the output level register's bit(s) designated by Dest to be random low and high, based on bit(s) Result: The I/O pin output level bit(s), described by Dest, are each set randomly low or high; the rest are left as-is. Z = OUT bit.\n\nOUTRND alters the output level register's bit(s) designated by Dest to be random low and high, based on bit(s)\n\nfrom the Xoroshiro128** PRNG. All other bits are left unchanged.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the OUTRND instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for OUTRND's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nOUTZ / OUTNZ\n\nOutput Z or not Z\n\nI/O Pin Instruction - Set pin(s) output level to low/high according to Z or !Z.\n\nOUTZ    {#}Dest {WCZ}\n\nOUTNZ {#}Dest {WCZ}\n\nResult: The I/O pin output level bit(s), described by Dest, are set to low/high according to Z or !Z; the rest are left\n\nas-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) for which\n\noutput levels are to be set low or high.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR        FX     DEST          SRC           Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001001100                OUTx       Orig OUTx base bit Orig OUTx base bit            2\n\nEEEE 1101011 CZL DDDDDDDDD 001001101                OUTx       Orig OUTx base bit Orig OUTx base bit            2\n\nOUTZ or OUTNZ alters the output level register's bit(s) designated by Dest to equal the state, or inverse state, of\n\nthe Z \ufb02ag; i.e. set pin's output level low or high. All other bits (pins) are left unchanged. Each of these\n\ninstructions, OUTZ and OUTNZ, can affect one or more of the bits within the OUTA or OUTB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the OUTZ / OUTNZ instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for OUTZ / OUTNZ's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (OUTA or\n\nOUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "OUT bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the pins set randomly to low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) for which output levels are to be set low or high.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch D - Jump+Skip": {
        "count": 1,
        "description": "Branch D - Jump+Skip",
        "instructions": {
          "SKIPF": {
            "mnemonic": "SKIPF",
            "syntax": "SKIPF\u00a0\u00a0 {#}D",
            "encoding": "EEEE 1101011 00L DDDDDDDDD 000110010",
            "description": "Skip cog/LUT instructions fast per D. Like SKIP, but instead of cancelling instructions, the PC leaps over them.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 26
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_l",
                "pattern": "D/#0..511",
                "description": "Destination or immediate value 0-511",
                "valueType": 26
              }
            },
            "documentation_source": "original",
            "documentation_level": "enhanced"
          }
        }
      },
      "Bit Operation Instruction - Toggle bit(s) to the opposite state.": {
        "count": 1,
        "description": "Bit Operation Instruction - Toggle bit(s) to the opposite state.",
        "instructions": {
          "BITNOT": {
            "mnemonic": "BITNOT",
            "syntax": "BITNOT Dest, {#}Src {WCZ}",
            "encoding": "EEEE 0100111 CZI DDDDDDDDD SSSSSSSSS                  D         Original D base bit Original D base bit          2",
            "description": "BITNOT alters the Dest bit(s) designated by Src to their inverse state. All other bits are left unchanged. Result: Dest bit(s) described by Src are toggled to their opposite state(s); the rest are left as-is. Z = original D[S[4:0]].\n\nBITNOT alters the Dest bit(s) designated by Src to their inverse state. All other bits are left unchanged.\n\nSrc[4:0] indicates the bit number (0\u201431). For a range of bits, Src[4:0] indicates the base bit number (0\u201431) and\n\nSrc[9:5] indicates how many contiguous bits beyond the base should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the base bit (Src[4:0]) and a range of up to 16 contiguous bits (Src[8:5]). If\n\nneeded, use the augmented literal feature (##Src) to augment Src to a 10-bit literal value\u2014 this inserts an AUGS\n\ninstruction prior.\n\nWhen Src is a register, the register's value bits [9:0] are used as-is to form the 10-bit ID range, unless a SETQ\n\ninstruction immediately precedes the BITNOT instruction; substituting SETQ's Dest[4:0] in place of value bits[9:5],\n\nfor BITNOT's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of Dest's base bit, identi\ufb01ed by Src.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "original D[S[4:0]]"
              }
            },
            "parameters": [
              "Dest is the register whose value will have one or more bits toggled.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 1
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_bitx",
                "pattern": "D,S/#",
                "description": "Bit manipulation with optional effect flags: Destination register, bit position",
                "valueType": 1
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Math Instruction - Force signed value to be less than or equal to another.": {
        "count": 1,
        "description": "Math Instruction - Force signed value to be less than or equal to another.",
        "instructions": {
          "FLES": {
            "mnemonic": "FLES",
            "syntax": "FLES Dest, {#}Src {WC|WZ|WCZ}",
            "encoding": [
              "EEEE 0011011 CZI DDDDDDDDD SSSSSSSSS                       D        limit enforced        Result = 0              2",
              "EEEE 1101011 CZL DDDDDDDDD 001010010 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
              "EEEE 1101011 CZL DDDDDDDDD 001010001 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit"
            ],
            "description": "FLES sets signed Dest to signed Src if Dest is greater than Src. This is also known as a limit maximum function; Result: Signed Dest is set to signed Src if Dest was greater than Src. Optionally the C and Z flag indicates if the replacement happened and the zero status of the result.\n\nFLES sets signed Dest to signed Src if Dest is greater than Src. This is also known as a limit maximum function;\n\npreventing Dest from rising above Src.\n\nIf the WC or WCZ effect is speci\ufb01ed, the C \ufb02ag is set (1) if Dest was limited (Dest was greater than Src and now\n\nDest is equal to Src), or is cleared (0) if not limited.\n\nIf the WZ or WCZ effect is speci\ufb01ed, the Z \ufb02ag is set (1) if the result is zero, or is cleared (0) if it is non-zero.\n\nFLTC / FLTNC\n\nFloat C or not C\n\nI/O Pin Instruction - Set pin(s) direction to input and an output level of low/high according to C.\n\nFLTC       {#}Dest {WCZ}\n\nFLTNC {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the input direction and to an output level of low/high according\n\nto C or !C; the rest are left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\ninput direction and output levels of low or high.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR            FX     DEST          SRC            Write             C Flag             Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001010010 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\nEEEE 1101011 CZL DDDDDDDDD 001010011 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a FLTC or FLTNC.\n\nFLTC or FLTNC sets the I/O pin(s) designated by Dest to the input direction and to a low/high output level\n\naccording to the state, or inverse state, of the C \ufb02ag; i.e. alters the pin's direction and output registers. All other\n\npins are left unchanged. Each of these instructions, FLTC and FLTNC, can affect one or more of the bits within\n\nthe DIRA or DIRB and OUTA or OUTB registers.\n\nFLTC or FLTNC achieves the same effect as two instructions\u2014 DIRL followed by OUTC or OUTNC.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the FLTC / FLTNC instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for FLTC / FLTNC's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nFLTH / FLTL\n\nFloat high or low\n\nI/O Pin Instruction - Set pin(s) direction to input and to an output level of high (1) or low (0).\n\nFLTH {#}Dest {WCZ}\n\nFLTL {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the input direction and to an output level of high or low; the rest\n\nare left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\ninput direction and output levels of high or low.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR            FX     DEST          SRC            Write             C Flag             Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001010001 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\nEEEE 1101011 CZL DDDDDDDDD 001010000 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a FLTH or FLTL.\n\nFLTH or FLTL sets the I/O pin(s) designated by Dest to the input direction and to a high or low output level; i.e.\n\nalters the pin's direction and output registers. All other pins are left unchanged. Each of these instructions, FLTH\n\nand FLTL, can affect one or more of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nFLTH or FLTL achieves the same effect as two instructions\u2014 DIRL followed by OUTH or OUTL.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the FLTH / FLTL instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for FLTH / FLTL's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": "Result = 0"
            },
            "parameters": [
              "Dest is a register containing the signed value to limit to a maximum of signed Src, and is where the result is written.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose signed value is the upper limit to force upon Dest.",
              "WC, WZ, or WCZ are optional effects to update \ufb02ags. Copyright \u00a9 Parallax Inc. 2022/11/01 \u25aa Propeller 2 Assembly Language Manual            \u25aa   Page 82",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to input direction and output levels of low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to input direction and output levels of high or low.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "FGES",
              "FLE",
              "FGE"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "I/O Pin Instruction - Set pin(s) direction to random input/output.": {
        "count": 1,
        "description": "I/O Pin Instruction - Set pin(s) direction to random input/output.",
        "instructions": {
          "DIRRND": {
            "mnemonic": "DIRRND",
            "syntax": "DIRRND {#}Dest {WCZ}",
            "encoding": [
              "EEEE 1101011 CZL DDDDDDDDD 001000110                 DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1101011 CZI DDDDDDDDD 001000100                DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1101011 CZI DDDDDDDDD 001000101                DIRx       Orig DIRx base bit Orig DIRx base bit           2",
              "EEEE 1011011 10I DDDDDDDDD SSSSSSSSS                    D and PC   1",
              "EEEE 1011011 00I DDDDDDDDD SSSSSSSSS                   D and PC   1",
              "EEEE 1101011 CZL DDDDDDDDD 001011010 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit",
              "EEEE 1101011 CZL DDDDDDDDD 001011001 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2",
              "EEEE 1101011 CZL DDDDDDDDD 001011000 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit"
            ],
            "description": "DIRRND alters the direction register's bit(s) designated by Dest to be random low and high (input and output), Result: The I/O pin direction bit(s), described by Dest, are each set randomly low or high (input or output); the rest are left as-is. Z = DIR bit.\n\nDIRRND alters the direction register's bit(s) designated by Dest to be random low and high (input and output),\n\nbased on bit(s) from the Xoroshiro128** PRNG. All other bits are left unchanged.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DIRRND instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DIRRND's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of DIRA / DIRB's base bit,\n\nidenti\ufb01ed by Dest.\n\nDIRZ / DIRNZ\n\nDirection Z or not Z\n\nI/O Pin Instruction - Set pin(s) direction to input/output according to Z or !Z.\n\nDIRZ    {#}Dest {WCZ}\n\nDIRNZ {#}Dest {WCZ}\n\nResult: The I/O pin direction bit(s), described by Dest, are set to output/input according to Z or !Z; the rest are left\n\nas-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput or input.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR        FX     DEST          SRC           Write            C Flag             Z Flag             Clocks\n\nEEEE 1101011 CZI DDDDDDDDD 001000100                DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nEEEE 1101011 CZI DDDDDDDDD 001000101                DIRx       Orig DIRx base bit Orig DIRx base bit           2\n\nRelated: DIRC, DIRNC, DIRNOT, DIRRND, DIRL, and DIRH\n\nDIRZ or DIRNZ alters the direction register's bit(s) designated by Dest to equal the state, or inverse state, of the Z\n\n\ufb02ag; i.e. set pin to the output (1) or input (0) direction. All other bits (pins) are left unchanged. Each of these\n\ninstructions, DIRZ and DIRNZ, can affect one or more of the bits within the DIRA or DIRB registers.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DIRZ / DIRNZ instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DIRZ / DIRNZ's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of DIRA / DIRB's base bit,\n\nidenti\ufb01ed by Dest.\n\nDJF / DJNF\n\nDecrement, jump if full or not full\n\nFlow Control Instruction - Decrement value and jump if full (-1; $FFFF_FFFF) or not full (<> -1; <> $FFFF_FFFF).\n\nDJF        Dest, {#}Src\n\nDJNF Dest, {#}Src\n\nResult: Dest is decremented, and if the result is full (or not full in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Dest is a register whose value is decremented and tested for full or not full.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST           SRC             Write               C Flag               Z Flag             Clocks\n\nEEEE 1011011 10I DDDDDDDDD SSSSSSSSS                    D and PC   1\n\n\u2014                       \u2014        2 or 4 / 2 or 13\u201320\n\nEEEE 1011011 11I DDDDDDDDD SSSSSSSSS                    D and PC   1\n\n\u2014                       \u2014        2 or 4 / 2 or 13\u201320\n\n1\n\nDest is always written; PC is written only when the result in Dest is full (or not full in syntax 2).\n\nDJF or DJNF decrements the value in Dest, writes the result, and jumps to the address described by Src if the\n\nresult is full (-1; $FFFF_FFFF; in syntax 1) or not full (<> -1; <> $FFFF_FFFF; in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the DJF / DJNF. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).\n\nDJZ / DJNZ\n\nDecrement, jump if zero or not zero\n\nFlow Control Instruction - Decrement, jump if zero or not zero.\n\nDJZ        Dest, {#}Src\n\nDJNZ Dest, {#}Src\n\nResult: Dest is decremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Dest is a register whose value is decremented and tested for zero or not zero.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST          SRC             Write              C Flag              Z Flag             Clocks\n\nEEEE 1011011 00I DDDDDDDDD SSSSSSSSS                   D and PC   1\n\n\u2014                    \u2014          2 or 4 / 2 or 13\u201320\n\nEEEE 1011011 01I DDDDDDDDD SSSSSSSSS                   D and PC   1\n\n\u2014                    \u2014          2 or 4 / 2 or 13\u201320\n\n1\n\nDest is always written; PC is written only when the result in Dest is zero (or not zero in syntax 2).\n\nDJZ or DJNZ decrements the value in Dest, writes the result, and jumps to the address described by Src if the\n\nresult is zero (in syntax 1) or not zero (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the DJZ / DJNZ. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).\n\nDRVC / DRVNC\n\nDrive C or not C\n\nI/O Pin Instruction - Set pin(s) direction to output and output level to low/high according to C or !C.\n\nDRVC        {#}Dest {WCZ}\n\nDRVNC {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the output direction and to an output level of low/high according\n\nto C or !C; the rest are left as-is.\n\n\u25cf    Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput direction and output levels of low or high.\n\n\u25cf    WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR             FX      DEST          SRC             Write              C Flag              Z Flag             Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001011010 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\nEEEE 1101011 CZL DDDDDDDDD 001011011 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a DRVC or DRVNC.\n\nDRVC or DRVNC sets the I/O pin(s) designated by Dest to the output direction and to a low/high output level\n\naccording to the state, or inverse state, of the C \ufb02ag; i.e. alters the pin's direction and output registers. All other\n\npins are left unchanged. Each of these instructions, DRVC and DRVNC, can affect one or more of the bits within\n\nthe DIRA or DIRB and OUTA or OUTB registers.\n\nDRVC or DRVNC achieves the same effect as two instructions\u2014 OUTC, or OUTNC, followed by DIRH.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DRVC / DRVNC instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DRVC / DRVNC's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.\n\nDRVH / DRVL\n\nDrive high or low\n\nI/O Pin Instruction - Set pin(s) direction to output and output level high (1) or low (0).\n\nDRVH {#}Dest {WCZ}\n\nDRVL {#}Dest {WCZ}\n\nResult: The I/O pins described by Dest are set to the output direction and to an output level of high or low; the rest\n\nare left as-is.\n\n\u25cf   Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to\n\noutput direction and output levels of high or low.\n\n\u25cf   WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR            FX     DEST          SRC            Write             C Flag             Z Flag              Clocks\n\nEEEE 1101011 CZL DDDDDDDDD 001011001 DIRx1 + OUTx Orig OUTx base bit Orig OUTx base bit                           2\n\nEEEE 1101011 CZL DDDDDDDDD 001011000 DIRx + OUTx Orig OUTx base bit Orig OUTx base bit\n\n1\n\n2\n\n1\n\nNew DIRx state is not data-forwarded; the next pipelined instruction sees the old state. Make sure any instruction that reads\n\nor modi\ufb01es DIRx is at least two instructions after a DRVH or DRVL.\n\nDRVH or DRVL sets the I/O pin(s) designated by Dest to the output direction and to a high or low output level; i.e.\n\nalters the pin's direction and output registers. All other pins are left unchanged. Each of these instructions, DRVH\n\nand DRVL, can affect one or more of the bits within the DIRA or DIRB and OUTA or OUTB registers.\n\nDRVH or DRVL achieves the same effect as two instructions\u2014 OUTH, or OUTL, followed by DIRH.\n\nDest[5:0] indicates the pin number (0\u201363). For a range of pins, Dest[5:0] indicates the base pin number (0\u201363)\n\nand Dest[10:6] indicates how many contiguous pins beyond the base should be affected (1\u201331).\n\nA 9-bit literal Dest is enough to express the base pin (Dest[5:0]) and a range of up to 8 contiguous pins (Dest[8:6]).\n\nIf needed, use the augmented literal feature (##Dest) to augment Dest to an 11-bit literal value\u2014 this inserts an\n\nAUGD instruction prior.\n\nWhen Dest is a register, the register's value bits [10:0] are used as-is to form the 11-bit ID range, unless a SETQ\n\ninstruction immediately precedes the DRVH / DRVL instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[10:6], for DRVH / DRVL's use.\n\nThe range calculation (from Dest[5:0] up to Dest[5:0]+Dest[10:6]) will wrap within the same 32-pin group (DIRA or\n\nDIRB and OUTA or OUTB); it will not cross the port boundary.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of OUTA / OUTB's base bit,\n\nidenti\ufb01ed by Dest.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "DIR bit"
              }
            },
            "parameters": [
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the pins set randomly to inputs or outputs.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output or input.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is a register whose value is decremented and tested for full or not full.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Dest is a register whose value is decremented and tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output direction and output levels of low or high.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register, 9-bit literal, or 11-bit augmented literal whose value identi\ufb01es the I/O pin(s) to set to output direction and output levels of high or low.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "DIRC",
              "DIRNC",
              "DIRNOT",
              "DIRRND",
              "DIRL",
              "DIRH"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 30
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pinop",
                "pattern": "D/#0..511 {WC/WZ}",
                "description": "Pin operation: destination/immediate pin number 0-511, optional effect flags",
                "valueType": 30
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear streamer-LUT-RAM-rollover event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear streamer-LUT-RAM-rollover event \ufb02ag.",
        "instructions": {
          "POLLXRL": {
            "mnemonic": "POLLXRL",
            "syntax": "POLLXRL {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001101 000100100                \u2014            XRL Event         XRLEvent                 2",
            "description": "Streamer-LUT-RAM-rollover event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLXRL copies the state of the streamer-LUT-RAM-rollover event \ufb02ag into C and/or Z and then clears the \ufb02ag\n\n(unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the streamer-LUT-RAM-\n\nrollover event \ufb02ag prior to clearing it.\n\nThe streamer-LUT-RAM-rollover event \ufb02ag is set whenever location $1FF of the Lookup RAM is read by the\n\nstreamer. The streamer-LUT-RAM-rollover event \ufb02ag is cleared upon cog start or upon execution of POLLXRL,\n\nWAITXRL, JXRL, or JNXRL instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "XINIT",
              "XZERO",
              "XCONT",
              "WAITXRL",
              "JXRL",
              "JNXRL"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Set discrete nibbles of a value to non-zero nibble states of another.": {
        "count": 1,
        "description": "Bit Operation Instruction - Set discrete nibbles of a value to non-zero nibble states of another.",
        "instructions": {
          "MUXNIBS": {
            "mnemonic": "MUXNIBS",
            "syntax": "MUXNIBS Dest, {#}Src",
            "encoding": "EEEE 1001111 01I DDDDDDDDD SSSSSSSSS                     D                 \u2014                   \u2014                    2",
            "description": "MUXNIBS copies any non-zero nibbles from Src into the corresponding nibbles of Dest and leaves the rest of Result: Dest nibbles corresponding to non-zero Src nibbles are set to those nibble values; the rest are left as-is.\n\nMUXNIBS copies any non-zero nibbles from Src into the corresponding nibbles of Dest and leaves the rest of\n\nDest's nibbles as-is.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is a register whose value will be updated according to Src.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose non-zero nibbles will replace the corresponding nibbles in Dest."
            ],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Wait for and clear interrupt-occurred event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Wait for and clear interrupt-occurred event \ufb02ag.",
        "instructions": {
          "WAITINT": {
            "mnemonic": "WAITINT",
            "syntax": "WAITINT {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000010000 000100100                 \u2014          Timeout Abort     Timeout Abort               2+",
            "description": "WAITINT waits for an interrupt-occurred event to occur (unless the event flag is already set), then clears the event Result: Wait for interrupt-occurred event, then clear the flag; optionally aborting on timeout and setting C and/or Z on abort. Z = timeout.\n\nWAITINT waits for an interrupt-occurred event to occur (unless the event \ufb02ag is already set), then clears the event\n\n\ufb02ag (unless it's being set again by the event sensor) and resumes execution at the next instruction. Optionally,\n\nWAITINT can time-out if the interrupt-occurred event doesn't occur soon enough; setting C and/or Z \ufb02ags and\n\nthen resuming execution at the next instruction.\n\nTo set the optional timeout, insert a SETQ (with a future System Counter target value) right before WAITINT.\n\nThe WC, WZ, or WCZ effect is recommended only if the optional timeout is speci\ufb01ed, in which case the C \ufb02ag and/or\n\nZ \ufb02ag is set (1) if a timeout occurred before the event, or is cleared (0) if the event occurred before the timeout.\n\nDuring a wait, the pipeline is stalled; no instructions execute and no interrupts are processed in the cog until the\n\nwait condition ends.\n\nThe interrupt-occurred event \ufb02ag is set whenever interrupt 1, 2, or 3 occurs\u2014 debug interrupts are ignored. The\n\ninterrupt-occurred event \ufb02ag is cleared upon cog start, or execution of POLLINT, WAITINT, JINT, or JNINT\n\ninstructions.",
            "timing": {
              "cycles": 2,
              "type": "variable"
            },
            "flags_affected": {
              "Z": {
                "formula": "timeout"
              }
            },
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "POLLINT",
              "JINT",
              "JNINT"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Bit Operation Instruction - Get a word from a value.": {
        "count": 1,
        "description": "Bit Operation Instruction - Get a word from a value.",
        "instructions": {
          "GETWORD": {
            "mnemonic": "GETWORD",
            "syntax": "GETWORD Dest, {#}Src, #Num",
            "encoding": [
              "EEEE 1001001 1NI DDDDDDDDD SSSSSSSSS                  D                \u2014                  \u2014                    2",
              "EEEE 1001001 100 DDDDDDDDD 000000000                  D                \u2014                  \u2014                    2",
              "EEEE 1011100 00I DDDDDDDDD SSSSSSSSS                   D and PC   1"
            ],
            "description": "GETWORD reads the word identified by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW Result: Word Num (0\u20131) of Src, or a word from a source described by prior ALTGW instruction, is written to Dest.\n\nGETWORD reads the word identi\ufb01ed by Num (0\u20131) from Src, or a word from the source described by a prior ALTGW\n\ninstruction.\n\nNum (0\u20131) identi\ufb01es a value's words, by position, in least-signi\ufb01cant word order.\n\nSyntax 2 is intended for use after an ALTGW instruction; i.e. in a loop to iteratively read a series of word values\n\nwithin contiguous long registers.\n\nIF_x (Conditions)\n\nSee Conditions ( IF_x ).\n\nIJZ / IJNZ\n\nIncrement, jump if zero or not zero\n\nFlow Control Instruction - Increment value and jump if zero or not zero.\n\nIJZ        Dest, {#}Src\n\nIJNZ Dest, {#}Src\n\nResult: Dest is incremented, and if the result is zero (or not zero in syntax 2), PC is set to a new relative (#Src) or\n\nabsolute (Src) address.\n\n\u25cf    Dest is a register whose value is incremented and tested for zero or not zero.\n\n\u25cf    Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to\n\nset PC to. Use # for relative addressing; omit # for absolute addressing.\n\nCOND INSTR             FX      DEST          SRC             Write              C Flag              Z Flag             Clocks\n\nEEEE 1011100 00I DDDDDDDDD SSSSSSSSS                   D and PC   1\n\n\u2014                    \u2014          2 or 4 / 2 or 13\u201320\n\nEEEE 1011100 01I DDDDDDDDD SSSSSSSSS                   D and PC   1\n\n\u2014                    \u2014          2 or 4 / 2 or 13\u201320\n\n1\n\nDest is always written; PC is written only when the result in Dest is zero (or not zero in syntax 2).\n\nIJZ or IJNZ increments the value in Dest, writes the result, and jumps to the address described by Src if the\n\nresult is zero (syntax 1) or not zero (in syntax 2).\n\nThe address (Src) can be absolute or relative. To specify an absolute address, Src must be a register containing a\n\n20-bit address value. To specify a relative address, use #Label for a 9-bit signed offset (a range of -256 to +255\n\ninstructions) or use ##Label (or insert a prior AUGS instruction) for a 20-bit signed offset (a range of -524288 to\n\n+524287). Offsets are relative to the instruction following the IJZ / IJNZ. The signed offset value is in units of\n\nwhole instructions\u2014 it is added to PC as-is when in Cog/LUT execution mode and is multiplied by 4 then added to\n\nPC when in Hub execution mode (long-aligned Hub code not required).",
            "timing": {
              "cycles": 1,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register in which to store the word.",
              "Src is a register, 9-bit literal, or 32-bit augmented literal whose value contains the target word to read.",
              "Num is a 1-bit literal identifying the word ID (0\u20131) of Src to read.",
              "Dest is a register whose value is incremented and tested for zero or not zero.",
              "Src is a register, 9-bit literal, or 20-bit augmented literal whose value is the absolute or relative address to set PC to. Use # for relative addressing; omit # for absolute addressing."
            ],
            "related": [
              "ALTGW",
              "GETNIB",
              "GETBYTE",
              "SETNIB",
              "SETBYTE",
              "SETWORD",
              "ROLNIB",
              "ROLBYTE",
              "ROLWORD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 11
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds1get",
                "pattern": "D{,S/#,#0..1}",
                "description": "Get word: destination, optional source and word index 0-1",
                "valueType": 11
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Pins": {
        "count": 1,
        "description": "Pins",
        "instructions": {
          "TESTP": {
            "mnemonic": "TESTP",
            "syntax": "TESTP   {#}D           WC/WZ",
            "encoding": "EEEE 1101011 CZL DDDDDDDDD 001000110",
            "description": "Test pin state with optional XOR operation. Z = C/Z XOR IN[D[5:0]].\n\nCommon uses:\n- Test pin state and set flags\n- Hall sensor reading for motor control\n- Digital input edge detection\n- Pin state monitoring with conditional logic\n",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "Z": {
                "formula": "C/Z XOR IN[D[5:0]]"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 31
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_testp",
                "pattern": "D/#0..511 WC/ANDC/ORC/XORC | WZ/ANDZ/ORZ/XORZ",
                "description": "Test pin: destination/immediate pin number 0-511 with REQUIRED logic function",
                "valueType": 31
              }
            },
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Augmentation Instruction - Augment next literal Src to 32-bits.": {
        "count": 1,
        "description": "Augmentation Instruction - Augment next literal Src to 32-bits.",
        "instructions": {
          "AUGS": {
            "mnemonic": "AUGS",
            "syntax": "AUGS",
            "encoding": [
              "EEEE 11110SS SSS SSSSSSSSS SSSSSSSSS Hidden S Queue                     \u2014                  \u2014                   2",
              "EEEE 0100010 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit           2",
              "EEEE 0100011 CZI DDDDDDDDD SSSSSSSSS                   D         Original D base bit Original D base bit           2",
              "EEEE 0100001 CZI DDDDDDDDD SSSSSSSSS                  D         Original D base bit Original D base bit          2",
              "EEEE 0100000 CZI DDDDDDDDD SSSSSSSSS                  D         Original D base bit Original D base bit          2"
            ],
            "description": "AUGS is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits Result: The 23-bit value formed from Src is queued to prefix the next literal Src occurrence (#Src) to form a 32-bit literal for that instruction; interrupts are also temporarily disabled.\n\nAUGS is an assistant instruction to aid with literal values that exceed 9 bits. Most PASM2 instructions have 9 bits\n\navailable for literal Src values; enough for many uses, but not all. AUGS augments the next occurrence of a literal\n\nSrc value to be a full 32-bits. When the instruction with the soon-to-be-augmented literal is later executed, the cog\n\nuses the lower 9 bits encoded in the instruction's Src \ufb01eld and prepends AUGS's 23 bits to it.\n\nBITC or BITNC alters the Dest bit(s) designated by Src to equal the state, or inverse state, of the C \ufb02ag. All other\n\nbits are left unchanged.\n\nSrc[4:0] indicates the bit number (0\u201431). For a range of bits, Src[4:0] indicates the base bit number (0\u201431) and\n\nSrc[9:5] indicates how many contiguous bits beyond the base should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the base bit (Src[4:0]) and a range of up to 16 contiguous bits (Src[8:5]). If\n\nneeded, use the augmented literal feature (##Src) to augment Src to a 10-bit literal value\u2014 this inserts an AUGS\n\ninstruction prior.\n\nWhen Src is a register, the register's value bits [9:0] are used as-is to form the 10-bit ID range, unless a SETQ\n\ninstruction immediately precedes the BITC / BITNC instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[9:5], for BITC / BITNC's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of Dest's base bit, identi\ufb01ed by Src.\n\nBITH / BITL\n\nBit high or low\n\nBit Operation Instruction - Set bit(s) high (1) or low (0).\n\nBITH Dest, {#}Src {WCZ}\n\nBITL Dest, {#}Src {WCZ}\n\nResult: Dest bit(s) described by Src are set high (1) or low (0); the rest are left as-is.\n\n\u25cf    Dest is the register whose value will have one or more bits set high or low.\n\n\u25cf    Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.\n\n\u25cf    WCZ is an optional effect to update \ufb02ags.\n\nCOND INSTR        FX      DEST         SRC           Write            C Flag              Z Flag              Clocks\n\nEEEE 0100001 CZI DDDDDDDDD SSSSSSSSS                  D         Original D base bit Original D base bit          2\n\nEEEE 0100000 CZI DDDDDDDDD SSSSSSSSS                  D         Original D base bit Original D base bit          2\n\nBITH or BITL alters the Dest bit(s) designated by Src to be high (1) or low (0). All other bits are left unchanged.\n\nSrc[4:0] indicates the bit number (0\u201431). For a range of bits, Src[4:0] indicates the base bit number (0\u201431) and\n\nSrc[9:5] indicates how many contiguous bits beyond the base should be affected (1\u201331).\n\nA 9-bit literal Src is enough to express the base bit (Src[4:0]) and a range of up to 16 contiguous bits (Src[8:5]). If\n\nneeded, use the augmented literal feature (##Src) to augment Src to a 10-bit literal value\u2014 this inserts an AUGS\n\ninstruction prior.\n\nWhen Src is a register, the register's value bits [9:0] are used as-is to form the 10-bit ID range, unless a SETQ\n\ninstruction immediately precedes the BITH / BITL instruction; substituting SETQ's Dest[4:0] in place of value\n\nbits[9:5], for BITH / BITL's use.\n\nIf the WCZ effect is speci\ufb01ed, the C and Z \ufb02ags are updated to the original state of Dest's base bit, identi\ufb01ed by Src.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "Src is a 32-bit literal whose upper 23 bits are prepended to the next literal Src occurrence.",
              "All instructions following AUGS are shielded from interrupt until after the instruction with the",
              "Src value augmentation occurs in the instruction pipeline only; code is not altered, value does not persist",
              "SETQ / SETQ2 does not affect AUGS\u2014 the Q value passes through to the next instruction",
              "Dest is the register whose value will have one or more bits set to C or !C.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WCZ is an optional effect to update \ufb02ags.",
              "Dest is the register whose value will have one or more bits set high or low.",
              "Src is a register, 9-bit literal, or 10-bit augmented literal whose value identi\ufb01es the bit(s) to modify.",
              "WCZ is an optional effect to update \ufb02ags."
            ],
            "related": [
              "AUGD"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 23
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_aug",
                "pattern": "#S",
                "description": "Augment: immediate 23-bit value for AUGS/AUGD",
                "valueType": 23
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Event Monitor Instruction - Retrieve and clear FIFO-interface-block-wrap event \ufb02ag.": {
        "count": 1,
        "description": "Event Monitor Instruction - Retrieve and clear FIFO-interface-block-wrap event \ufb02ag.",
        "instructions": {
          "POLLFBW": {
            "mnemonic": "POLLFBW",
            "syntax": "POLLFBW {WC|WZ|WCZ}",
            "encoding": "EEEE 1101011 CZ0 000001001 000100100                 \u2014            FBW Event         FBW Event                  2",
            "description": "POLLFBW copies the state of the FIFO-interface-block-wrap event flag into C and/or Z and then clears the flag Result: FIFO-interface-block-wrap event flag is optionally copied into C and/or Z, then it is cleared.\n\nPOLLFBW copies the state of the FIFO-interface-block-wrap event \ufb02ag into C and/or Z and then clears the \ufb02ag\n\n(unless it's being set again by the event sensor).\n\nIf the WC, WZ, or WCZ effect is speci\ufb01ed, the C \ufb02ag and/or Z \ufb02ag is updated to the state of the FIFO-interface\u2011block\u2011\n\nwrap event \ufb02ag prior to clearing it.\n\nThe FIFO-interface-block-wrap event \ufb02ag is set whenever the Hub RAM FIFO interface exhausts its block count\n\nand reloads its block count and start address. The FIFO-interface-block-wrap event \ufb02ag is cleared upon execution\n\nof RDFAST, WRFAST, FBLOCK, POLLFBW, WAITFBW, JFBW, or JNFBW instructions.",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {},
            "parameters": [
              "WC, WZ, or WCZ are optional effects to update \ufb02ags."
            ],
            "related": [
              "RDFAST",
              "WRFAST",
              "FBLOCK",
              "WAITFBW",
              "JFBW",
              "JNFBW"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 28
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_pollwait",
                "pattern": "",
                "description": "No operands - poll/wait instruction (moves S to D, sets S to $024)",
                "valueType": 28
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      },
      "Branch A - Jump": {
        "count": 1,
        "description": "Branch A - Jump",
        "instructions": {
          "JMP": {
            "mnemonic": "JMP",
            "syntax": "JMP     D        {WC/WZ/WCZ}",
            "encoding": "EEEE 1101100 RAA AAAAAAAAA AAAAAAAAA",
            "description": "Jump to A. If R = 1 then PC += A, else PC = A. \"\\\" forces R = 0.",
            "timing": {
              "cycles": 4,
              "type": "variable",
              "range": "4 / 13...20"
            },
            "flags_affected": {
              "C": {
                "formula": "A"
              }
            },
            "parameters": [],
            "related": [],
            "compiler_info": {
              "syntax": "JMP",
              "encoding": {
                "bits": 32,
                "opcode": 432,
                "effects": 0,
                "operandFormat": 18,
                "rawValue": 37296
              },
              "category": "Control Flow",
              "effects": [],
              "operand_format": {
                "name": "operand_jmp",
                "pattern": "#S | D",
                "description": "Jump: immediate address or register",
                "valueType": 18
              }
            },
            "documentation_source": "PASM2 Manual 2022-11-01",
            "documentation_level": "enhanced"
          }
        }
      },
      "Indirection Instruction - Set template Result \ufb01eld for ALTI.": {
        "count": 1,
        "description": "Indirection Instruction - Set template Result \ufb01eld for ALTI.",
        "instructions": {
          "SETR": {
            "mnemonic": "SETR",
            "syntax": "SETR Dest, {#}Src",
            "encoding": "EEEE 1001101 01I DDDDDDDDD SSSSSSSSS                        D                  \u2014                   \u2014                     2",
            "description": "SETR copies Src[8:0] to the Result field of the template, Dest, to be used with an ALTI instruction. Bits outside the Result: The Result field [27:19] of template Dest is set to Src[8:0].\n\nSETR copies Src[8:0] to the Result \ufb01eld of the template, Dest, to be used with an ALTI instruction. Bits outside the\n\nResult \ufb01eld remain unaffected. The Result \ufb01eld does not exist in instruction opcodes, but takes its value from the\n\nDest \ufb01eld, holding the address of a register for the instruction to use as its result destination upon execution.\n\nThe ALTI template is a 32-bit value with the following format:\n\nBits             31:28 (4 bits)          27:19 (9 bits)            18              17:9 (9 bits)           8:0 (9 bits)\n\nField Description       Condition Field         Result Field       Indirect \"I\" Field    Dest \"D\" Field         Source \"S\" Field\n\nSETR can also be used in self-modifying Reg RAM code, though it won't affect the Register \ufb01eld (which doesn't\n\nexist in instruction opcodes) but rather will affect the Instr \ufb01eld and the upper two bits of the FX \ufb01eld. Unlike with\n\nALTx instructions, when used this way, \ufb01eld value modi\ufb01cation occurs in the program code itself (not the\n\ninstruction pipeline); code is altered, values persist. Due to the instruction pipeline nature, after modifying a code\n\nregister, it is necessary to elapse at least two instructions before executing the modi\ufb01ed register.\n\nSETR          inst, op                        'set \"inst\" register[27:19] to op[8:0]\n\nNOP                                           '\ufb01rst spacer instruction, could be anything\n\nNOP                                           'second spacer instruction, could be anything\n\ninst     MOV           x, y                            'operate on x using y; MOV can become AND/OR/etc. per SETR",
            "timing": {
              "cycles": 2,
              "type": "fixed"
            },
            "flags_affected": {
              "C": {
                "when": "D"
              }
            },
            "parameters": [
              "Dest is the register whose 32-bit value is a template for use with an ALTI instruction.",
              "Src is a register or 9-bit literal whose value (Src[8:0]) is copied to the D \ufb01eld of Dest."
            ],
            "related": [
              "SETD",
              "SETS",
              "ALTI"
            ],
            "compiler_info": {
              "syntax": "",
              "encoding": {
                "operandFormat": 0
              },
              "category": "",
              "effects": [],
              "operand_format": {
                "name": "operand_ds",
                "pattern": "D,S/#",
                "description": "Destination register, Source register or immediate value",
                "valueType": 0
              }
            },
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive"
          }
        }
      }
    }
  },
  "condition_codes": {
    "supported": true,
    "flags": [
      "C",
      "Z"
    ],
    "prefixes": {
      "_RET_": "Execute if returning",
      "IF_": "Execute conditionally",
      "IF_C": "Execute if Carry set",
      "IF_NC": "Execute if Carry clear",
      "IF_Z": "Execute if Zero set",
      "IF_NZ": "Execute if Zero clear"
    }
  },
  "memory_model": {
    "cog_ram": {
      "size": "512 longs",
      "addressing": "$000-$1FF",
      "special_registers": "$1F0-$1FF"
    },
    "lut_ram": {
      "size": "512 longs",
      "addressing": "$200-$3FF",
      "shared_access": true
    },
    "hub_ram": {
      "size": "512KB",
      "addressing": "$00000-$7FFFF",
      "byte_addressable": true
    }
  },
  "gaps": {
    "boot_process": {
      "status": "missing",
      "workaround": "Use serial boot for development",
      "needed_from": "Chip Gracey"
    },
    "usb_support": {
      "status": "missing",
      "workaround": "Use serial communication",
      "needed_from": "Parallax"
    },
    "smart_pins_complete": {
      "status": "partial",
      "available_modes": 10,
      "total_modes": 32,
      "workaround": "Use documented modes only",
      "pending_from": "Jon Titus documentation"
    },
    "bytecode_interpreter": {
      "status": "missing",
      "workaround": "Use PASM2 or external compiler",
      "needed_from": "Chip Gracey"
    },
    "streamer_fifo": {
      "status": "partial",
      "workaround": "Use basic RDFAST/WRFAST",
      "needed_from": "Documentation team"
    }
  },
  "discovery": {
    "has_architecture": true,
    "has_instruction_set": true,
    "has_memory_model": true,
    "has_pin_control": true,
    "has_cordic": true,
    "has_interrupts": true,
    "has_boot_process": false,
    "has_usb": false,
    "has_complete_timing": false,
    "has_all_smart_pins": false,
    "has_bytecode": false
  },
  "code_generation_ready": {
    "basic_assembly": true,
    "hub_memory_access": true,
    "pin_control": true,
    "cog_launching": true,
    "cordic_math": true,
    "smart_pins_basic": true,
    "interrupts": false,
    "usb": false,
    "boot_configuration": false
  },
  "spin2": {
    "version": "1.51.5",
    "source": "engineering/knowledge-base/P2/language/spin2/",
    "extraction_date": "2025-09-20T11:50:14.608029",
    "categories": {
      "keywords": {
        "count": 36,
        "elements": {
          "LOOKDOWNZ": {
            "keyword": "LOOKDOWNZ",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns zero-based index of matching value in list\n",
            "syntax": "LOOKDOWNZ(value : list)",
            "examples": [
              "index := LOOKDOWNZ(color : RED, GREEN, BLUE)"
            ]
          },
          "FROM": {
            "keyword": "FROM",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Starting value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "STEP": {
            "keyword": "STEP",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Increment value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end STEP increment\n  statements\n",
            "examples": [
              "REPEAT i FROM 0 TO 100 STEP 5\n  process(i)"
            ]
          },
          "RETURN": {
            "keyword": "RETURN",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Return from method with optional value\n",
            "syntax": "RETURN [value]",
            "examples": [
              "RETURN",
              "RETURN result"
            ]
          },
          "ELSEIFNOT": {
            "keyword": "ELSEIFNOT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch with negated condition\n",
            "syntax": "ELSEIFNOT condition\n  statements\n",
            "examples": [
              "ELSEIFNOT flag\n  result := \"false case\""
            ]
          },
          "IF": {
            "keyword": "IF",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution based on expression\n",
            "syntax": "IF condition\n  statements\n",
            "examples": [
              "IF temperature > 80\n  turn_on_fan()"
            ]
          },
          "IFNOT": {
            "keyword": "IFNOT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Conditional execution with negated condition\n",
            "syntax": "IFNOT condition\n  statements\n",
            "examples": [
              "IFNOT sensor_active\n  error_handler()"
            ]
          },
          "ELSEIF": {
            "keyword": "ELSEIF",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Additional conditional branch in IF statement\n",
            "syntax": "ELSEIF condition\n  statements\n",
            "examples": [
              "ELSEIF x > 10\n  result := \"high\""
            ]
          },
          "OBJ": {
            "keyword": "OBJ",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Object section - declares object instances\n",
            "syntax": "OBJ\n  name : \"filename\"\n",
            "examples": [
              "OBJ\n  serial : \"FullDuplexSerial\""
            ]
          },
          "CON": {
            "keyword": "CON",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Constants section - defines named constant values\n",
            "syntax": "CON\n  identifier = expression\n",
            "examples": [
              "CON\n  LED_PIN = 56\n  BAUD_RATE = 115200"
            ]
          },
          "OTHER": {
            "keyword": "OTHER",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in CASE statement\n",
            "syntax": "CASE expression\n  value1: statements\n  OTHER: statements\n",
            "examples": [
              "CASE status\n  0: handle_success()\n  OTHER: handle_error()"
            ]
          },
          "NEXT": {
            "keyword": "NEXT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Continue to next iteration of loop\n",
            "syntax": "NEXT",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  IF i == 5\n    NEXT\n  process(i)"
            ]
          },
          "FILE": {
            "keyword": "FILE",
            "type": "keyword",
            "category": "Special",
            "description": "Compiler directive for file inclusion\n",
            "syntax": "FILE filename",
            "examples": [
              "FILE \"config.spin2\""
            ]
          },
          "QUIT": {
            "keyword": "QUIT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Exit loop immediately\n",
            "syntax": "QUIT",
            "examples": [
              "REPEAT\n  IF error_condition\n    QUIT\n  process_data()"
            ]
          },
          "BYTE": {
            "keyword": "BYTE",
            "type": "keyword",
            "category": "Data Types",
            "description": "8-bit unsigned integer type (0-255)\n",
            "syntax": "BYTE variable[count]",
            "examples": [
              "BYTE flag",
              "BYTE buffer[128]"
            ]
          },
          "ABORT": {
            "keyword": "ABORT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Abort method execution with optional error value\n",
            "syntax": "ABORT [expression]",
            "examples": [
              "ABORT",
              "ABORT error_code"
            ]
          },
          "REPEAT": {
            "keyword": "REPEAT",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop construct with various forms\n",
            "syntax": "REPEAT [count]\nREPEAT variable FROM start TO end [STEP increment]\nREPEAT WHILE condition\nREPEAT UNTIL condition\n",
            "examples": [
              "REPEAT 10",
              "REPEAT i FROM 1 TO 100 STEP 2",
              "REPEAT WHILE sensor_active"
            ]
          },
          "CASE_FAST": {
            "keyword": "CASE_FAST",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Optimized case statement for sequential values\n",
            "syntax": "CASE_FAST expression\n  value: statements\n",
            "examples": [
              "CASE_FAST status\n  0: handle_ok()\n  1: handle_error()"
            ]
          },
          "TO": {
            "keyword": "TO",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Ending value in REPEAT loop range\n",
            "syntax": "REPEAT variable FROM start TO end\n  statements\n",
            "examples": [
              "REPEAT i FROM 1 TO 10\n  sum += i"
            ]
          },
          "DAT": {
            "keyword": "DAT",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Data section - contains data and inline assembly\n",
            "syntax": "DAT\n  label type value\n",
            "examples": [
              "DAT\n  message BYTE \"Hello World\", 0"
            ]
          },
          "VAR": {
            "keyword": "VAR",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Variables section - declares instance variables\n",
            "syntax": "VAR\n  type variable[count]\n",
            "examples": [
              "VAR\n  LONG counter\n  BYTE buffer[256]"
            ]
          },
          "STRING": {
            "keyword": "STRING",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Convert expression to string representation\n",
            "syntax": "STRING(expression)",
            "examples": [
              "text := STRING(number)"
            ]
          },
          "WORD": {
            "keyword": "WORD",
            "type": "keyword",
            "category": "Data Types",
            "description": "16-bit unsigned integer type (0-65535)\n",
            "syntax": "WORD variable[count]",
            "examples": [
              "WORD address",
              "WORD lookup_table[128]"
            ]
          },
          "BYTEFIT": {
            "keyword": "BYTEFIT",
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a byte constant\n",
            "examples": [
              "CON\n  SMALL_VALUE = BYTEFIT(200)"
            ]
          },
          "LONG": {
            "keyword": "LONG",
            "type": "keyword",
            "category": "Data Types",
            "description": "32-bit signed integer type\n",
            "syntax": "LONG variable[count]",
            "examples": [
              "LONG counter",
              "LONG data_buffer[256]"
            ]
          },
          "LOOKDOWN": {
            "keyword": "LOOKDOWN",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns index of matching value in list\n",
            "syntax": "LOOKDOWN(value : list)",
            "examples": [
              "index := LOOKDOWN(day : \"Mon\", \"Tue\", \"Wed\")"
            ]
          },
          "UNTIL": {
            "keyword": "UNTIL",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue until condition becomes true\n",
            "syntax": "REPEAT UNTIL condition\n  statements\n",
            "examples": [
              "REPEAT UNTIL sensor_triggered\n  check_sensor()"
            ]
          },
          "WITH": {
            "keyword": "WITH",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Object context specifier for method calls\n",
            "syntax": "WITH object",
            "examples": [
              "WITH serial\n  str(\"Hello World\")"
            ]
          },
          "CASE": {
            "keyword": "CASE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Multi-way branch based on expression value\n",
            "syntax": "CASE expression\n  value1: statements\n  value2: statements\n",
            "examples": [
              "CASE day\n  1: month_name := \"January\"\n  2: month_name := \"February\""
            ]
          },
          "LOOKUP": {
            "keyword": "LOOKUP",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given index\n",
            "syntax": "LOOKUP(index : list)",
            "examples": [
              "day_name := LOOKUP(day : \"Sun\", \"Mon\", \"Tue\")"
            ]
          },
          "PRI": {
            "keyword": "PRI",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Private method declaration - accessible only within object\n",
            "syntax": "PRI method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PRI calculate_sum(a, b) : result\n  result := a + b"
            ]
          },
          "LOOKUPZ": {
            "keyword": "LOOKUPZ",
            "type": "keyword",
            "category": "Built-in Functions",
            "description": "Returns value from list at given zero-based index\n",
            "syntax": "LOOKUPZ(index : list)",
            "examples": [
              "color := LOOKUPZ(index : RED, GREEN, BLUE)"
            ]
          },
          "WORDFIT": {
            "keyword": "WORDFIT",
            "type": "keyword",
            "category": "Data Types",
            "description": "Expression that fits in a word constant\n",
            "examples": [
              "CON\n  MID_VALUE = WORDFIT(32000)"
            ]
          },
          "WHILE": {
            "keyword": "WHILE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Loop condition - continue while condition remains true\n",
            "syntax": "REPEAT WHILE condition\n  statements\n",
            "examples": [
              "REPEAT WHILE data_available\n  process_data()"
            ]
          },
          "PUB": {
            "keyword": "PUB",
            "type": "keyword",
            "category": "Block Structure",
            "description": "Public method declaration - accessible from other objects\n",
            "syntax": "PUB method_name(parameters) : return_variables | local_variables\n  statements\n",
            "examples": [
              "PUB start(pin) : success\n  configure_pin(pin)\n  success := TRUE"
            ]
          },
          "ELSE": {
            "keyword": "ELSE",
            "type": "keyword",
            "category": "Control Flow",
            "description": "Default case in IF statement\n",
            "syntax": "ELSE\n  statements\n",
            "examples": [
              "ELSE\n  result := 0"
            ]
          }
        }
      },
      "operators": {
        "count": 74,
        "elements": {
          "^^": {
            "operator": "^^",
            "type": "operator",
            "description": "Logical XOR operator\n",
            "category": "Bitwise",
            "examples": [
              "IF state1 ^^ state2\n  toggle()"
            ]
          },
          "?": {
            "operator": "?",
            "type": "operator",
            "description": "Conditional selection\n",
            "category": "Ternary"
          },
          "FRAC": {
            "operator": "FRAC",
            "type": "operator",
            "description": "Calculate fraction\n",
            "category": "Math",
            "examples": [
              "frac := dividend FRAC divisor"
            ]
          },
          ":": {
            "operator": ":",
            "type": "operator",
            "description": "Conditional selection\n",
            "category": "Ternary"
          },
          "!&&": {
            "operator": "!&&",
            "type": "operator",
            "description": "Boolean AND/NAND\n",
            "category": "Logical AND"
          },
          "+<": {
            "operator": "+<",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "ROR": {
            "operator": "ROR",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "-.": {
            "operator": "-.",
            "type": "operator",
            "description": "Integer/float subtraction\n",
            "category": "Subtract"
          },
          ">=": {
            "operator": ">=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "/.": {
            "operator": "/.",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "SCA": {
            "operator": "SCA",
            "type": "operator",
            "description": "Scale value (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "scaled := value SCA factor"
            ]
          },
          "+.": {
            "operator": "+.",
            "type": "operator",
            "description": "Integer/float addition\n",
            "category": "Add"
          },
          "SIGNX": {
            "operator": "SIGNX",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "NOT": {
            "operator": "NOT",
            "type": "operator",
            "description": "Logical NOT (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF NOT ready\n  wait()"
            ]
          },
          "+>=": {
            "operator": "+>=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "&&": {
            "operator": "&&",
            "type": "operator",
            "description": "Boolean AND/NAND\n",
            "category": "Logical AND"
          },
          ">": {
            "operator": ">",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "+<=>": {
            "operator": "+<=>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "??": {
            "operator": "??",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "ADDBITS": {
            "operator": "ADDBITS",
            "type": "operator",
            "description": "Add bit count to pin number\n",
            "category": "Pin",
            "examples": [
              "pin_range := start_pin ADDBITS bit_count"
            ]
          },
          "BMASK": {
            "operator": "BMASK",
            "type": "operator",
            "description": "Create bit mask from bit count (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "mask := BMASK(8)  // Returns $FF"
            ]
          },
          "FABS": {
            "operator": "FABS",
            "type": "operator",
            "description": "Floating point absolute value\n",
            "category": "Math",
            "examples": [
              "distance := FABS(float_difference)"
            ]
          },
          "XOR": {
            "operator": "XOR",
            "type": "operator",
            "description": "Logical XOR (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF state1 XOR state2\n  toggle()"
            ]
          },
          "ABS": {
            "operator": "ABS",
            "type": "operator",
            "description": "` `^^` `ENCOD` `DECOD` `ONES` `SQRT` `QLOG` `QEXP`\n",
            "category": "\\"
          },
          "SCAS": {
            "operator": "SCAS",
            "type": "operator",
            "description": "Scale value signed (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "scaled := value SCAS factor"
            ]
          },
          "<#": {
            "operator": "<#",
            "type": "operator",
            "description": "Max/min limiting\n",
            "category": "Limit"
          },
          "<=": {
            "operator": "<=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ">=.": {
            "operator": ">=.",
            "type": "operator",
            "description": "Floating point greater than or equal comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF temp >=. threshold\n  activate()"
            ]
          },
          "REV": {
            "operator": "REV",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "QLOG": {
            "operator": "QLOG",
            "type": "operator",
            "description": "Quick logarithm (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "log_val := QLOG(value)"
            ]
          },
          "<>>": {
            "operator": "<>>",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "+<=": {
            "operator": "+<=",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ":=": {
            "operator": ":=",
            "type": "operator",
            "description": "Assignment operator\n",
            "category": "Assignment",
            "examples": [
              "variable := value",
              "result := calculate(x, y)"
            ]
          },
          "SAR": {
            "operator": "SAR",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "--": {
            "operator": "--",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "ROL": {
            "operator": "ROL",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "#>": {
            "operator": "#>",
            "type": "operator",
            "description": "Max/min limiting\n",
            "category": "Limit"
          },
          "||": {
            "operator": "||",
            "type": "operator",
            "description": "Logical OR operator\n",
            "category": "Bitwise",
            "examples": [
              "IF error || timeout\n  abort()"
            ]
          },
          "++": {
            "operator": "++",
            "type": "operator",
            "description": "Pre/post increment/decrement/random\n",
            "category": "Var-modify"
          },
          "AND": {
            "operator": "AND",
            "type": "operator",
            "description": "Logical AND (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF ready AND enabled\n  start()"
            ]
          },
          "===": {
            "operator": "===",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "-": {
            "operator": "-",
            "type": "operator",
            "description": "Integer/float subtraction\n",
            "category": "Subtract"
          },
          "...": {
            "operator": "...",
            "type": "operator",
            "category": "Special",
            "description": "Line continuation operator - allows a single logical line to span multiple physical lines in SPIN2\n",
            "syntax": [
              "statement ... continuation",
              "expression part1 + part2 + ...",
              "          part3 + part4"
            ],
            "examples": [
              "result := value1 + value2 + ...\n          value3 + value4\n",
              "IF condition1 AND condition2 AND ...\n   condition3 AND condition4\n  ' Execute if all conditions true\n",
              "REPEAT count FROM 1 TO 100 STEP ...\n                  increment_value\n"
            ],
            "notes": [
              "The three dots must be the last non-comment item on the line",
              "The continuation appears on the next line with appropriate indentation",
              "Comments can appear after the ellipsis"
            ],
            "documentation_source": "SPIN2 Language Reference",
            "documentation_level": "comprehensive"
          },
          "<<": {
            "operator": "<<",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "+>": {
            "operator": "+>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "QEXP": {
            "operator": "QEXP",
            "type": "operator",
            "description": "Quick exponential (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "exp_val := QEXP(value)"
            ]
          },
          "+//": {
            "operator": "+//",
            "name": "Unsigned Modulo Add",
            "category": "arithmetic_operators",
            "description": "Add with unsigned modulo (circular arithmetic)",
            "documentation_source": "code_analysis",
            "documentation_level": "comprehensive",
            "created": "2025-09-09",
            "overview": "The +// operator performs addition with unsigned modulo, creating circular\narithmetic perfect for buffer management and wrap-around counters. This is\na key operator for implementing circular queues and ring buffers in Spin2.\n",
            "syntax": {
              "format": "result := value +// modulus",
              "parameters": {
                "value": "The value to operate on",
                "modulus": "The wrap-around point (result will be 0 to modulus-1)"
              },
              "returns": "Value modulo modulus"
            },
            "operation": {
              "description": "Performs (value % modulus) where % is unsigned modulo.\nResult ranges from 0 to (modulus - 1).\nEquivalent to: value // modulus\n",
              "formula": "result = value MOD modulus (unsigned)"
            },
            "examples": {
              "circular_buffer_increment": {
                "description": "Increment buffer index with wrap-around",
                "code": "VAR\n  LONG head, tail\n  BYTE buffer[32]\n\nPUB addByte(data)\n  ' Calculate next tail position\n  nextTail := (tail + 1) +// 32\n  \n  ' Check if buffer full\n  if nextTail == head\n    return FALSE  ' Buffer full\n    \n  ' Add data and update tail\n  buffer[tail] := data\n  tail := nextTail\n  return TRUE\n",
                "source": "P2-OctoSerial pattern"
              },
              "modulo_arithmetic": {
                "description": "Various modulo operations",
                "code": "' Simple wrap-around\nindex := (index + 1) +// BUFFER_SIZE\n\n' Increment by N with wrap\nposition := (position + step) +// MAX_POSITION\n\n' Calculate distance in circular buffer\ndistance := (head - tail) +// BUFFER_SIZE\n"
              },
              "queue_management": {
                "description": "Circular queue push operation",
                "code": "PRI rxCheckInternal(portHandle) : nChar\n  nChar := NO_CHAR\n  if rxTailIdx[portHandle] <> rxHeadIdx[portHandle]\n    ' Increment with modulo\n    rxHeadIdx[portHandle] := (rxHeadIdx[portHandle] + 1) +// BUF_SIZE\n    ' Read from new head position\n    nChar := BYTE[pRxBuf[portHandle]][rxHeadIdx[portHandle]]\n",
                "source": "P2-OctoSerial"
              }
            },
            "common_patterns": {
              "buffer_sizes": [
                "Power of 2 not required (unlike & mask method)",
                "Any buffer size works: +// 30, +// 100, etc.",
                "Typically used with constants for clarity"
              ],
              "typical_usage": [
                "Circular buffer index management",
                "Ring buffer wrap-around",
                "Cyclic counter implementation",
                "Round-robin scheduling indexes"
              ]
            },
            "comparison_with_alternatives": {
              "and_mask_method": {
                "description": "Alternative using AND mask (power of 2 only)",
                "code": "' Only works with power-of-2 sizes\nindex := (index + 1) & (BUFFER_SIZE - 1)  ' BUFFER_SIZE must be 2^n\n\n' +// works with any size\nindex := (index + 1) +// BUFFER_SIZE      ' Any size works\n"
              },
              "manual_method": {
                "description": "Manual wrap-around check",
                "code": "' Manual method\nindex++\nif index >= BUFFER_SIZE\n  index := 0\n  \n' Using +// operator\nindex := (index + 1) +// BUFFER_SIZE    ' One line, same result\n"
              }
            },
            "best_practices": [
              "Use parentheses for clarity with complex expressions",
              "Define buffer sizes as constants",
              "Remember result range is 0 to (modulus-1)",
              "Consider using for all circular arithmetic"
            ],
            "related_operators": [
              {
                "//": "Unsigned divide remainder (modulo)"
              },
              {
                "+/": "Unsigned divide quotient"
              },
              {
                "%%": "Signed modulo"
              },
              {
                "&": "AND mask (alternative for power-of-2)"
              }
            ],
            "notes": [
              "More flexible than AND mask method",
              "Works with any modulus value",
              "Essential for circular buffer implementation",
              "Commonly used in multi-port/multi-resource drivers"
            ],
            "references": [
              {
                "P2-OctoSerial": "Extensive use in circular buffers"
              },
              {
                "Spin2 documentation": "Arithmetic operators"
              },
              "Production code patterns from Iron Sheep Productions"
            ]
          },
          "/": {
            "operator": "/",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "<=.": {
            "operator": "<=.",
            "type": "operator",
            "description": "Floating point less than or equal comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF count <=. limit\n  continue()"
            ]
          },
          "OR": {
            "operator": "OR",
            "type": "operator",
            "description": "Logical OR (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "IF error OR timeout\n  abort()"
            ]
          },
          "<=>": {
            "operator": "<=>",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          "*.": {
            "operator": "*.",
            "type": "operator",
            "description": "Integer/float multiply\n",
            "category": "Multiply"
          },
          "ZEROX": {
            "operator": "ZEROX",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "+": {
            "operator": "+",
            "type": "operator",
            "description": "Integer/float addition\n",
            "category": "Add"
          },
          "ENCOD": {
            "operator": "ENCOD",
            "type": "operator",
            "description": "Encode highest bit position (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "bit_pos := ENCOD(mask)"
            ]
          },
          "==": {
            "operator": "==",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "<": {
            "operator": "<",
            "type": "operator",
            "description": "Signed/unsigned compare\n",
            "category": "Comparison"
          },
          ":=:": {
            "operator": ":=:",
            "type": "operator",
            "description": "Swap operator\n",
            "category": "Assignment",
            "examples": [
              "a :=: b  // swap values of a and b"
            ]
          },
          "SQRT": {
            "operator": "SQRT",
            "type": "operator",
            "description": "Integer square root\n",
            "category": "Math",
            "examples": [
              "side := SQRT(area)"
            ]
          },
          "+/": {
            "operator": "+/",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          "? :": {
            "operator": "? :",
            "type": "operator",
            "description": "Ternary conditional operator\n",
            "category": "Assignment",
            "examples": [
              "result := condition ? true_value : false_value"
            ]
          },
          "//": {
            "operator": "//",
            "type": "operator",
            "description": "Divide/float/modulo/unsigned\n",
            "category": "Divide"
          },
          ">.": {
            "operator": ">.",
            "type": "operator",
            "description": "Floating point greater than comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF speed >. max_speed\n  slow_down()"
            ]
          },
          "<>.": {
            "operator": "<>.",
            "type": "operator",
            "description": "Floating point inequality comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF result <>. 0.0\n  handle_error()"
            ]
          },
          "<.": {
            "operator": "<.",
            "type": "operator",
            "description": "Floating point less than comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF x <. y\n  smaller := x"
            ]
          },
          "DECOD": {
            "operator": "DECOD",
            "type": "operator",
            "description": "Decode bit position to mask (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "mask := DECOD(5)  // Returns $20"
            ]
          },
          "FSQRT": {
            "operator": "FSQRT",
            "type": "operator",
            "description": "Floating point square root\n",
            "category": "Math",
            "examples": [
              "side := FSQRT(float_area)"
            ]
          },
          "<>": {
            "operator": "<>",
            "type": "operator",
            "description": "Equal/not equal (logical/bitwise)\n",
            "category": "Equality"
          },
          "ONES": {
            "operator": "ONES",
            "type": "operator",
            "description": "Count number of 1 bits (also PASM2 instruction)\n",
            "category": "Unary",
            "examples": [
              "count := ONES(%10110101)  // Returns 5"
            ]
          },
          "*": {
            "operator": "*",
            "type": "operator",
            "description": "Integer/float multiply\n",
            "category": "Multiply"
          },
          "ADDPINS": {
            "operator": "ADDPINS",
            "type": "operator",
            "description": "Add pin count to pin number\n",
            "category": "Pin",
            "examples": [
              "pin_range := start_pin ADDPINS pin_count"
            ]
          },
          ">>": {
            "operator": ">>",
            "type": "operator",
            "description": "Bit manipulation\n",
            "category": "Shift/Rotate"
          },
          "==.": {
            "operator": "==.",
            "type": "operator",
            "description": "Floating point equality comparison\n",
            "category": "Float Compare",
            "examples": [
              "IF value ==. target\n  found()"
            ]
          }
        }
      },
      "methods": {
        "count": 87,
        "elements": {
          "GETCRC": {
            "method": "GETCRC",
            "type": "method",
            "description": "Calculate CRC using hardware CRC engine\n",
            "category": "Miscellaneous",
            "syntax": "crc := GETCRC(DataAddress, Polynomial, Count)",
            "parameters": [
              {
                "name": "DataAddress",
                "type": "address",
                "description": "Address of data to calculate CRC for"
              },
              {
                "name": "Polynomial",
                "type": "long",
                "description": "CRC polynomial to use"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to process"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Calculated CRC value"
            },
            "examples": [
              {
                "code": "' Calculate CRC-32\ncrc32 := GETCRC(@data, $EDB88320, size)\n",
                "description": "Calculate standard CRC-32"
              },
              {
                "code": "' Calculate CRC-16\ncrc16 := GETCRC(@buffer, $8005, length) & $FFFF\n",
                "description": "Calculate CRC-16"
              },
              {
                "code": "' Verify data integrity\ncalculated := GETCRC(@packet, polynomial, packet_size)\nif calculated == expected_crc\n  ' Data is valid\n",
                "description": "Verify data with CRC"
              }
            ],
            "notes": [
              "Uses P2's hardware CRC engine",
              "Common polynomials: CRC-32=$EDB88320, CRC-16=$8005",
              "Processes byte by byte",
              "Fast hardware implementation",
              "Initial CRC value is 0",
              "Result may need masking for < 32-bit CRCs"
            ],
            "timing": {
              "description": "Hardware accelerated",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "BYTEMOVE",
              "STRCOMP"
            ],
            "see_also": [
              "CRC calculation",
              "Data integrity",
              "Error detection"
            ]
          },
          "LONGFILL": {
            "method": "LONGFILL",
            "category": "memory_operations",
            "type": "method",
            "description": "Fill a specified region of hub RAM with a 32-bit long value.\nEfficiently sets multiple consecutive longs to the same value.\nCommonly used for clearing arrays, initializing data structures, and setting patterns.\n",
            "syntax": "LONGFILL(Destination, Value, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for correct operation.\nStarting address for the fill operation.\n"
              },
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit value to fill with.\nCan be any long value.\nCommon values: 0 (clear), -1 ($FFFFFFFF), pointers, patterns.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to fill (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "timing": {
              "performance": "~8 + (count * 2) clock cycles",
              "optimization": "Uses efficient hub block operations",
              "vs_loop": "5-10x faster than manual loop"
            },
            "examples": [
              {
                "code": "VAR\n  LONG buffer[256]\n  \nPUB clear_buffer()\n  LONGFILL(@buffer, 0, 256)\n",
                "description": "Clear array of longs"
              },
              {
                "code": "VAR\n  LONG stack[64]\n  \nPUB init_stack()\n  LONGFILL(@stack, $DEAD_BEEF, 64)\n  ' Helps identify stack overflow\n",
                "description": "Initialize stack with marker pattern"
              },
              {
                "code": "VAR\n  LONG pointers[100]\n  \nPUB init_pointers()\n  LONGFILL(@pointers, @default_handler, 100)\n",
                "description": "Initialize function pointer table"
              },
              {
                "code": "' Initialize mailbox system\nDAT\n  mailboxes LONG 0[8]\n  \nPUB clear_mailboxes()\n  LONGFILL(@mailboxes, -1, 8)  ' -1 = empty\n",
                "description": "Initialize inter-cog mailboxes"
              },
              {
                "code": "' Create test pattern\nVAR\n  LONG pattern[1000]\n  \nPUB create_patterns()\n  LONGFILL(@pattern[0], $12345678, 500)\n  LONGFILL(@pattern[500], $87654321, 500)\n",
                "description": "Create diagnostic patterns"
              }
            ],
            "common_uses": [
              "Array initialization",
              "Stack initialization",
              "Clearing data structures",
              "Setting default values",
              "Pattern generation",
              "Memory testing"
            ],
            "typical_values": {
              "0": "Clear/zero memory",
              "-1": "All bits set ($FFFFFFFF)",
              "$DEADBEEF": "Debug marker",
              "$BADC0DE": "Error marker",
              "pointer": "Function/data pointers"
            },
            "memory_patterns": {
              "debug": "LONGFILL(@memory, $DEADBEEF, count)\n' Easy to spot in debugger\n",
              "cleared": "LONGFILL(@memory, 0, count)\n' Standard initialization\n",
              "invalid": "LONGFILL(@memory, -1, count)\n' Mark as uninitialized\n"
            },
            "related_methods": [
              "BYTEFILL - Fill with byte value",
              "WORDFILL - Fill with word value",
              "LONGMOVE - Copy longs",
              "LONGCOMP - Compare longs"
            ],
            "performance_notes": [
              "Much faster than loops for large counts",
              "Optimized hub operations",
              "Alignment critical for correctness",
              "Count > 4 shows significant speedup"
            ],
            "notes": [
              "Count is in LONGS, not bytes",
              "Destination should be long-aligned",
              "Full 32-bit value is written",
              "Count of 0 is safe (no operation)",
              "Cannot fill cog or LUT RAM directly"
            ],
            "alignment_requirement": "CRITICAL: Destination must be long-aligned\nGood: LONG buffer[100]  ' Aligned by declaration\nBad:  BYTE buffer[400]  ' May not be aligned\nFix:  LONG buffer[100]  ' Use proper type\n",
            "warnings": [
              "Count is LONGS not BYTES",
              "Misalignment causes incorrect results",
              "Ensure destination has enough space",
              "Overwrites existing data"
            ],
            "see_also": [
              "language/spin2/methods/bytefill.yaml",
              "language/spin2/methods/wordfill.yaml",
              "language/spin2/methods/longmove.yaml"
            ]
          },
          "LOOKDOWNZ": {
            "method": "LOOKDOWNZ",
            "type": "method",
            "description": "Find 0-based index of value in list\n",
            "category": "Lookup Operations",
            "syntax": "index := LOOKDOWNZ(Value : Match0, Match1, ..., MatchN)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "0-based index of match, or -1 if not found"
            },
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWNZ(30 : 10, 20, 30, 40, 50)\n' Returns 2 (30 is at index 2)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Menu option mapping\nselection := LOOKDOWNZ(key : \"Q\", \"S\", \"L\", \"H\")\ncase selection\n  0: quit_program()\n  1: save_file()\n  2: load_file()\n  3: show_help()\n",
                "description": "Map key to action"
              },
              {
                "code": "' Validate input range\nif LOOKDOWNZ(value : 0..9, 16..25, 32..47) >= 0\n  ' Value is in valid range\n  process_value(value)\n",
                "description": "Check if value in valid ranges"
              }
            ],
            "notes": [
              "Returns 0-based index (0 = first match)",
              "Returns -1 if value not found",
              "Supports ranges with .. operator",
              "Searches left to right, returns first match",
              "Inverse operation of LOOKUPZ",
              "More common than LOOKDOWN for array-style operations"
            ],
            "related": [
              "LOOKDOWN",
              "LOOKUPZ",
              "LOOKUP"
            ],
            "see_also": [
              "Value searching",
              "Zero-based indexing",
              "Input validation"
            ]
          },
          "GETCT": {
            "method": "GETCT",
            "category": "timing",
            "type": "method",
            "description": "Get the current 32-bit system counter value.\nThe system counter increments once per clock cycle continuously from boot.\nWraps around from $FFFF_FFFF to $0000_0000 approximately every 21 seconds at 200MHz.\nEssential for precise timing measurements and delays.\n",
            "syntax": "GETCT() : Count",
            "parameters": "none",
            "returns": {
              "name": "Count",
              "type": "long",
              "description": "Current 32-bit system counter value.\nIncrements at system clock frequency.\nWraps from $FFFF_FFFF to $0000_0000.\n"
            },
            "timing": {
              "execution": "2 clock cycles",
              "precision": "Single clock cycle resolution",
              "wrap_time": "(2^32 / CLKFREQ) seconds",
              "examples": [
                "200MHz: ~21.47 seconds",
                "180MHz: ~23.86 seconds",
                "160MHz: ~26.84 seconds",
                "80MHz: ~53.69 seconds"
              ]
            },
            "examples": [
              {
                "code": "start := GETCT()\n' ... do something ...\nelapsed := GETCT() - start\n' elapsed now contains clock cycles\n",
                "description": "Measure execution time"
              },
              {
                "code": "' Convert cycles to microseconds\nstart := GETCT()\nprocess_data()\nelapsed_us := (GETCT() - start) / (CLKFREQ / 1_000_000)\n",
                "description": "Time measurement in microseconds"
              },
              {
                "code": "' Wait for exact 1 second\ntarget := GETCT() + CLKFREQ\nWAITCT(target)\n",
                "description": "Precise 1-second delay"
              },
              {
                "code": "' Create 10Hz precise loop\nnext_time := GETCT()\nREPEAT\n  next_time += CLKFREQ / 10\n  WAITCT(next_time)\n  do_10hz_task()\n",
                "description": "Precise periodic execution"
              },
              {
                "code": "' Timeout pattern\ntimeout := GETCT() + (CLKFREQ / 1000) * 100  ' 100ms timeout\nREPEAT WHILE (GETCT() - timeout) < 0\n  IF PINREAD(0)\n    ' Got response\n    QUIT\n' Timed out\n",
                "description": "Implement timeout"
              }
            ],
            "underlying_pasm": {
              "instruction": "GETCT",
              "description": "Direct access to CNT register"
            },
            "common_uses": [
              "Execution time measurement",
              "Creating precise delays with WAITCT",
              "Timeout implementation",
              "Performance profiling",
              "Timestamp generation",
              "Periodic task scheduling",
              "Bit-rate timing generation"
            ],
            "related_methods": [
              "WAITCT - Wait for specific counter value",
              "POLLCT - Check if counter value passed",
              "WAITMS - Simple millisecond delay",
              "WAITUS - Simple microsecond delay",
              "GETMS - Get milliseconds since boot",
              "GETSEC - Get seconds since boot"
            ],
            "notes": [
              "Counter runs continuously from boot",
              "Wraps around every 2^32 clocks",
              "Subtraction handles wrap correctly",
              "All cogs see same counter value",
              "Not affected by cog start/stop",
              "Resolution equals clock period"
            ],
            "wraparound_handling": "The 32-bit subtraction naturally handles wraparound:\nIf end_time < start_time (wrapped), the result is still correct\nExample: $0000_0010 - $FFFF_FFF0 = $20 (32 clocks elapsed)\n",
            "precision_considerations": [
              "Single clock accuracy when reading",
              "Hub access may add 0-7 clock variance",
              "Use WAITCT for cycle-accurate delays",
              "GETCT itself takes 2 clocks to execute"
            ],
            "see_also": [
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/pollct.yaml",
              "language/spin2/methods/getms.yaml",
              "language/pasm2/getct.yaml"
            ]
          },
          "NAN": {
            "method": "NAN",
            "type": "method",
            "description": "Check if floating-point value is Not-a-Number\n",
            "category": "Miscellaneous",
            "syntax": "result := NAN(FloatValue)",
            "parameters": [
              {
                "name": "FloatValue",
                "type": "float",
                "description": "Floating-point value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if NaN, FALSE (0) otherwise"
            },
            "examples": [
              {
                "code": "' Check for NaN\nif NAN(result)\n  ' Handle invalid result\n  result := 0.0\n",
                "description": "Check and handle NaN"
              },
              {
                "code": "' Validate calculation\nvalue := sqrt(-1.0)  ' Creates NaN\nif NAN(value)\n  debug(\"Invalid operation\")\n",
                "description": "Detect invalid math operation"
              },
              {
                "code": "' Filter NaN from data\nrepeat i from 0 to count-1\n  if not NAN(data[i])\n    process(data[i])\n",
                "description": "Skip NaN values in processing"
              }
            ],
            "notes": [
              "NaN results from invalid floating-point operations",
              "Examples: 0.0/0.0, sqrt(-1), inf-inf",
              "NaN != NaN in comparisons",
              "Any operation with NaN produces NaN",
              "IEEE 754 floating-point standard",
              "Important for robust float handling"
            ],
            "timing": {
              "description": "Immediate bit check",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "Float math operators"
            ],
            "see_also": [
              "Floating-point operations",
              "IEEE 754 standard",
              "Error handling"
            ]
          },
          "SETREGS": {
            "method": "SETREGS",
            "type": "method",
            "description": "Copy hub RAM to cog registers\n",
            "category": "Miscellaneous",
            "syntax": "SETREGS(HubAddress, CogAddress, Count)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM source address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Load PASM code into cog\nSETREGS(@pasm_code, $100, 50)  ' Load 50 longs\n",
                "description": "Load PASM code to cog RAM"
              },
              {
                "code": "' Restore saved registers\nVAR\n  LONG saved_regs[16]\n\nSETREGS(@saved_regs, $1F0, 16)  ' Restore $1F0-$1FF\n",
                "description": "Restore cog register state"
              },
              {
                "code": "' Initialize PASM variables\nVAR\n  LONG init_data[10]\n\nrepeat i from 0 to 9\n  init_data[i] := i * 100\nSETREGS(@init_data, $100, 10)\n",
                "description": "Set PASM variables in cog"
              }
            ],
            "notes": [
              "Copies from hub RAM to cog RAM",
              "Cog addresses are 0-511 (2KB)",
              "Each register is 32 bits (1 long)",
              "Can overwrite running code - use caution",
              "Useful for loading PASM code/data",
              "Count must not exceed remaining registers"
            ],
            "timing": {
              "description": "Hub transfer operation",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "GETREGS",
              "REGLOAD",
              "REGEXEC"
            ],
            "see_also": [
              "Cog memory access",
              "PASM loading",
              "Dynamic code loading"
            ]
          },
          "COGINIT": {
            "method": "COGINIT",
            "category": "cog_management",
            "type": "method",
            "description": "Start PASM2 code in a specified or available cog.\nLoads PASM2 code from hub RAM into cog RAM and begins execution.\nReturns the cog number that was started, or -1 if no cog was available.\nThis is the primary method for launching parallel processing cores.\n",
            "syntax": "COGINIT(CogNum, PASMaddr, PTRAvalue) : CogID",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- COGEXEC_NEW or NEWCOG (-1): Start any available cog\n- Bit 5 set: Execute from hub RAM (HUBEXEC mode)\n"
              },
              {
                "name": "PASMaddr",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute.\nUse @ operator to get address of code label.\nMust be long-aligned for cog execution.\n"
              },
              {
                "name": "PTRAvalue",
                "type": "long",
                "description": "Initial value for PTRA register in new cog.\nTypically used to pass parameter block address.\nCan be any 32-bit value.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using COGEXEC_NEW)\n"
            },
            "execution_modes": {
              "cogexec": "Default mode - code copied to cog RAM and executed there\nLimited to 512 longs (2KB) of code/data\nFastest execution, deterministic timing\n",
              "hubexec": "Set bit 5 of CogNum - code executes directly from hub RAM\nUnlimited code size (512KB hub RAM)\nSlightly slower, subject to hub timing variations\n"
            },
            "examples": [
              {
                "code": "DAT\n  ORG 0\nblink_code\n  DIRH  #56\n.loop\n  OUTNOT #56\n  WAITX ##25_000_000\n  JMP   #.loop\n  \nPUB start_blinker()\n  cog := COGINIT(COGEXEC_NEW, @blink_code, 0)\n  IF cog == -1\n    ' Failed to start\n",
                "description": "Start PASM blinker in any available cog"
              },
              {
                "code": "VAR\n  LONG params[4]\n  \nPUB start_driver()\n  params[0] := @buffer\n  params[1] := buffer_size\n  params[2] := pin_number\n  params[3] := 0  ' command\n  \n  COGINIT(COGEXEC_NEW, @driver_code, @params)\n",
                "description": "Start driver with parameter block"
              },
              {
                "code": "' Stop and restart cog 1 with new code\nCOGINIT(1, @new_code, @config)\n",
                "description": "Start specific cog (stops if running)"
              },
              {
                "code": "' Start hub execution mode\nCOGINIT(COGEXEC_NEW_PAIR | HUBEXEC, @hub_code, @data)\n",
                "description": "Start code in hub execution mode"
              }
            ],
            "common_uses": [
              "Launch parallel processing tasks",
              "Start hardware drivers",
              "Create dedicated I/O handlers",
              "Implement real-time controllers",
              "Run timing-critical code",
              "Parallel data processing"
            ],
            "related_methods": [
              "COGSPIN - Start Spin2 code in a cog",
              "COGSTOP - Stop a running cog",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running"
            ],
            "memory_layout": "Cog RAM after COGINIT:\n$000-$1F7: Your PASM code/data (504 longs)\n$1F8-$1FF: Special registers (PTRA, PTRB, etc.)\n",
            "notes": [
              "Code must start with ORG 0 for cog execution",
              "PTRA is set before code starts executing",
              "All cog registers cleared except PTRA",
              "Cog starts at address 0",
              "Previous cog contents completely replaced",
              "Cannot start Spin2 code with COGINIT (use COGSPIN)"
            ],
            "limitations": [
              "Maximum 496 longs of code+data in COGEXEC mode",
              "Only 8 cogs available total",
              "Cannot determine which cog when using COGEXEC_NEW",
              "No automatic cleanup if cog crashes"
            ],
            "see_also": [
              "language/pasm2/org.yaml",
              "language/spin2/methods/cogspin.yaml",
              "language/spin2/methods/cogstop.yaml",
              "architecture/cog.yaml"
            ]
          },
          "COGSPIN": {
            "method": "COGSPIN",
            "category": "cog_management",
            "type": "method",
            "description": "Start a Spin2 method in a specified or available cog.\nLoads the Spin2 interpreter into the cog and begins executing the specified method.\nReturns the cog number that was started, or -1 if no cog was available.\nEssential for parallel Spin2 execution.\n",
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive",
            "syntax": "COGSPIN(CogNum, Method({Parameters}), StackAddress) : CogID",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to start:\n- 0-7: Start specific cog (will stop if running)\n- NEWCOG or -1: Start any available cog\n"
              },
              {
                "name": "Method({Parameters})",
                "type": "method_call",
                "description": "Spin2 method to execute with optional parameters.\nMethod name followed by parameters in parentheses.\nCan be in current object or another object.\n"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Hub address of stack space for the new cog.\nUse @stack_array to get address.\nMinimum 32 longs recommended, more for complex code.\n"
              }
            ],
            "returns": {
              "name": "CogID",
              "type": "long",
              "description": "- 0-7: Successfully started cog number\n- -1: Failed (no cog available when using NEWCOG)\n"
            },
            "stack_requirements": {
              "minimum": "32 longs (128 bytes)",
              "typical": "64-128 longs (256-512 bytes)",
              "factors": [
                "Method call depth",
                "Local variable count",
                "Parameter count",
                "Expression complexity"
              ]
            },
            "examples": [
              {
                "code": "VAR\n  LONG stack[64]\n  LONG cog_id\n  \nPUB main()\n  cog_id := COGSPIN(NEWCOG, worker(), @stack)\n  IF cog_id == -1\n    ' Failed to start\n    \nPRI worker()\n  REPEAT\n    ' Do work in parallel\n    PINTOGGLE(56)\n    WAITMS(500)\n",
                "description": "Start worker method in new cog"
              },
              {
                "code": "VAR\n  LONG stack1[64], stack2[64]\n  LONG sensor_data\n  \nPUB start_sensors()\n  COGSPIN(NEWCOG, read_sensor(0, @sensor_data), @stack1)\n  COGSPIN(NEWCOG, read_sensor(1, @sensor_data), @stack2)\n  \nPRI read_sensor(pin, ptr)\n  REPEAT\n    LONG[ptr][pin] := read_adc(pin)\n    WAITMS(10)\n",
                "description": "Multiple sensor readers with parameters"
              },
              {
                "code": "OBJ\n  serial : \"serial_driver\"\n  \nVAR\n  LONG serial_stack[128]\n  \nPUB init()\n  ' Start serial driver in separate cog\n  COGSPIN(NEWCOG, serial.rx_handler(), @serial_stack)\n",
                "description": "Start object method in new cog"
              },
              {
                "code": "VAR\n  LONG cog_stacks[4][64]\n  \nPUB parallel_process()\n  REPEAT i FROM 0 TO 3\n    COGSPIN(NEWCOG, process_chunk(i), @cog_stacks[i])\n",
                "description": "Launch multiple parallel processors"
              },
              {
                "code": "' Multi-COG Flash FS stress test pattern\nCON\n  NUM_TESTER_COGS = 7\n  STACK_SIZE_LONGS = 64\n  \nDAT\n  ' Per-COG stacks in DAT for persistence\n  stacks  LONG  0[NUM_TESTER_COGS * STACK_SIZE_LONGS]\n  results BYTE  0[8]  ' One per COG\n  lock    LONG  -1    ' Shared resource lock\n  \nPUB stress_test() | idx\n  ' Initialize lock for file system access\n  lock := LOCKNEW()\n  \n  ' Launch test COGs with indexed stacks\n  REPEAT idx FROM 0 TO NUM_TESTER_COGS-1\n    COGSPIN(NEWCOG, fs_tester(idx), @stacks[idx * STACK_SIZE_LONGS])\n  \n  ' Monitor results\n  REPEAT\n    show_results()\n    WAITMS(1000)\n    \nPRI fs_tester(cog_index) | handle\n  ' Each COG performs random file operations\n  REPEAT\n    ' Random delay to create contention\n    WAITMS(GETRND() & $FF)\n    \n    ' Acquire lock for file system access\n    REPEAT WHILE NOT LOCKTRY(lock)\n    \n    ' Perform file operation\n    handle := open(\"test.dat\", \"r\")\n    IF handle >= 0\n      ' Read/write operations\n      results[cog_index]++\n      close(handle)\n    \n    ' Release lock\n    LOCKREL(lock)\n",
                "description": "Multi-COG flash filesystem stress test",
                "source": "P2-FLASH-FS"
              }
            ],
            "method_execution": {
              "interpreter": "Each cog gets its own Spin2 interpreter",
              "isolation": "Methods run independently",
              "variables": [
                "VAR variables are shared between cogs",
                "Local variables are private to each cog",
                "DAT section is shared"
              ]
            },
            "common_uses": [
              "Parallel task execution",
              "Background monitoring",
              "Concurrent I/O handling",
              "Multi-threaded applications",
              "Separate UI and processing",
              "Real-time event handlers",
              "Multi-COG stress testing",
              "Parallel file system access"
            ],
            "production_patterns": {
              "multi_cog_with_locks": {
                "description": "Pattern for safe multi-COG resource access",
                "pattern": "1. Allocate shared lock in DAT\n2. Create per-COG stacks in DAT\n3. Launch COGs with indexed stack addresses\n4. Use LOCKTRY/LOCKREL for resource protection\n5. Track per-COG results/status\n",
                "source": "P2-FLASH-FS"
              },
              "indexed_stack_allocation": {
                "description": "Efficient stack allocation for multiple COGs",
                "code": "DAT\n  stacks LONG 0[NUM_COGS * STACK_SIZE]\n  \nPUB start_cogs() | i\n  REPEAT i FROM 0 TO NUM_COGS-1\n    COGSPIN(NEWCOG, worker(i), @stacks[i * STACK_SIZE])\n",
                "benefits": [
                  "Predictable memory layout",
                  "Easy to adjust stack sizes",
                  "Persistent across method calls"
                ]
              }
            },
            "related_methods": [
              "COGINIT - Start PASM code in a cog",
              "COGSTOP - Stop a running cog",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running",
              "LOCKNEW - Allocate lock for synchronization",
              "LOCKTRY - Try to acquire lock",
              "LOCKREL - Release lock"
            ],
            "synchronization": {
              "shared_variables": "Use locks for thread-safe access",
              "communication": "Use hub RAM for data exchange",
              "coordination": "Use COGATN/POLLATN for signaling",
              "file_system_access": "Must use locks for flash FS operations"
            },
            "notes": [
              "Method runs until it returns or cog is stopped",
              "Stack overflow causes undefined behavior",
              "Each cog has independent method call stack",
              "Parameters are passed by value",
              "Cannot share local variables between cogs",
              "Flash FS requires lock protection for multi-COG access"
            ],
            "best_practices": [
              "Always check return value for -1",
              "Size stack appropriately for method complexity",
              "Use locks for shared variable access",
              "Initialize shared data before starting cogs",
              "Stop cogs cleanly when done",
              "Use DAT for persistent stack allocation",
              "Implement proper lock cleanup on errors"
            ],
            "warnings": [
              "Stack overflow is not detected",
              "Insufficient stack causes crashes",
              "VAR variables need synchronization",
              "No automatic resource cleanup",
              "File system not thread-safe without locks"
            ],
            "see_also": [
              "language/spin2/methods/coginit.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/locknew.yaml",
              "language/spin2/constructs/method_definition.yaml",
              "concepts/multi_cog_synchronization.yaml"
            ]
          },
          "CLKSET": {
            "method": "CLKSET",
            "type": "method",
            "description": "Safely set new clock mode and frequency\n",
            "category": "Miscellaneous",
            "syntax": "CLKSET(Mode, Frequency)",
            "parameters": [
              {
                "name": "Mode",
                "type": "long",
                "description": "Clock mode configuration bits"
              },
              {
                "name": "Frequency",
                "type": "long",
                "description": "New clock frequency in Hz"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Set to 200MHz with PLL\nCLKSET(clkmode_pll, 200_000_000)\n",
                "description": "Set high-speed PLL mode"
              },
              {
                "code": "' Drop to RCFAST for low power\nCLKSET(clkmode_rcfast, 20_000_000)\n",
                "description": "Switch to internal RC oscillator"
              },
              {
                "code": "' Dynamic frequency scaling\nif battery_low\n  CLKSET(clkmode_pll, 80_000_000)  ' Reduce to 80MHz\nelse\n  CLKSET(clkmode_pll, 180_000_000)  ' Normal 180MHz\n",
                "description": "Adjust clock for power management"
              }
            ],
            "notes": [
              "Performs safe clock transition",
              "Updates clkfreq variable automatically",
              "Temporarily switches to RCFAST during transition",
              "Mode bits configure PLL, crystal, dividers",
              "Affects all timing-dependent operations",
              "Maximum frequency depends on chip specs",
              "Use predefined clkmode_ constants"
            ],
            "timing": {
              "description": "Clock stabilization delay",
              "cycles": "~10-20ms for PLL lock"
            },
            "related": [
              "HUBSET",
              "WAITMS",
              "GETCT"
            ],
            "see_also": [
              "Clock configuration",
              "PLL setup",
              "Power management"
            ]
          },
          "PINHIGH": {
            "method": "PINHIGH",
            "aliases": [
              "PINH"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) high (output mode, logic 1).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) high (OUT=1).\nThis is equivalent to the PASM2 DIRH instruction.\n",
            "syntax": "PINHIGH(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive high. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINHIGH(56)",
                "description": "Drive pin 56 high (typically an LED pin)"
              },
              {
                "code": "PINHIGH(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 high simultaneously"
              },
              {
                "code": "PINHIGH(15..8)",
                "description": "Drive pins 8 through 15 high (note: reverse range)"
              },
              {
                "code": "CON\n  LED = 56\nPUB main()\n  PINHIGH(LED)\n",
                "description": "Use a constant for the pin number"
              }
            ],
            "underlying_pasm": {
              "instruction": "DIRH",
              "description": "Internally uses DIRH instruction which sets DIR=1 and OUT=1"
            },
            "common_uses": [
              "Turn on LEDs",
              "Set control signals high",
              "Drive communication pins to idle state",
              "Activate chip select or enable lines"
            ],
            "related_methods": [
              "PINLOW - Drive pin(s) low",
              "PINTOGGLE - Toggle pin state",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "Pin will remain high until explicitly changed",
              "Multiple pins can be controlled simultaneously"
            ],
            "see_also": [
              "language/pasm2/dirh.yaml",
              "language/spin2/methods/pinlow.yaml",
              "language/spin2/methods/pintoggle.yaml"
            ]
          },
          "WAITATN": {
            "method": "WAITATN",
            "type": "method",
            "description": "Wait for attention signal from another cog\n",
            "category": "COG Management",
            "syntax": "WAITATN()",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for signal from another cog\nWAITATN()  ' Block until ATN received\n' Process the signal\n",
                "description": "Simple cog synchronization"
              },
              {
                "code": "' Worker cog waiting for commands\nrepeat\n  WAITATN()  ' Wait for command signal\n  command := shared_variable\n  process_command(command)\n",
                "description": "Command-driven worker cog"
              },
              {
                "code": "' Multi-stage synchronization\n' Stage 1\ndo_work_stage1()\nsignal_complete()  ' Tell master\nWAITATN()         ' Wait for next stage\n' Stage 2\ndo_work_stage2()\n",
                "description": "Multi-stage cog coordination"
              }
            ],
            "notes": [
              "Blocks execution until ATN signal received",
              "ATN flag is cleared after WAITATN returns",
              "Another cog uses COGATN to send the signal",
              "Each cog has its own ATN flag",
              "More efficient than polling shared variables",
              "Use POLLATN for non-blocking check"
            ],
            "timing": {
              "description": "Waits until ATN signal received",
              "cycles": "Variable based on when signal arrives"
            },
            "related": [
              "COGATN",
              "POLLATN",
              "COGID"
            ],
            "see_also": [
              "Cog communication",
              "Inter-cog signaling",
              "Synchronization"
            ]
          },
          "COGATN": {
            "method": "COGATN",
            "category": "cog_management",
            "type": "method",
            "description": "Strobe the attention signal to one or more cogs.\nSets attention flags that can be polled or waited on by target cogs.\nProvides fast inter-cog signaling without using hub RAM.\nEssential for event notification and synchronization.\n",
            "syntax": "COGATN(CogMask)",
            "parameters": [
              {
                "name": "CogMask",
                "type": "long",
                "description": "16-bit mask specifying which cogs to signal:\n- Bits 0-7: Target cog selection (1 = signal that cog)\n- Bits 8-15: Must be zero\n- Can signal multiple cogs simultaneously\n- Use (1 << cog_num) to signal specific cog\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles",
              "signal_propagation": "Immediate to all specified cogs",
              "latency": "Target cog sees signal on next instruction"
            },
            "examples": [
              {
                "code": "' Signal cog 3\nCOGATN(1 << 3)\n",
                "description": "Signal single cog"
              },
              {
                "code": "' Signal cogs 0, 2, and 4\nCOGATN(%00010101)\n",
                "description": "Signal multiple cogs"
              },
              {
                "code": "' Broadcast to all other cogs\nCOGATN($FF ^ (1 << COGID()))\n",
                "description": "Signal all cogs except self"
              },
              {
                "code": "VAR\n  LONG worker_cogs\n  \nPUB signal_workers()\n  ' Signal all registered workers\n  COGATN(worker_cogs)\n  \nPUB register_worker()\n  worker_cogs |= (1 << COGID())\n",
                "description": "Dynamic cog group signaling"
              },
              {
                "code": "' Producer-consumer pattern\nPUB producer()\n  REPEAT\n    produce_data()\n    COGATN(1 << consumer_cog)  ' Data ready\n    \nPUB consumer()\n  REPEAT\n    WAITATN()  ' Wait for signal\n    process_data()\n",
                "description": "Producer-consumer synchronization"
              }
            ],
            "signal_mechanism": {
              "hardware": "Dedicated attention network between cogs",
              "persistence": "Signal is edge-triggered (strobe)",
              "clearing": "Automatically cleared when polled/waited",
              "queueing": "No queueing - multiple signals before check are seen as one"
            },
            "common_uses": [
              "Event notification",
              "Work ready signals",
              "Synchronization barriers",
              "Interrupt simulation",
              "Wake sleeping cogs",
              "Broadcast communications"
            ],
            "receiving_methods": {
              "polling": "IF POLLATN()\n  ' Attention was signaled\n  \n",
              "waiting": "WAITATN()  ' Block until signaled\n",
              "pasm": "POLLATN WC  ' Check and clear\nWAITATN     ' Wait for signal\n"
            },
            "related_methods": [
              "POLLATN - Check for attention signal",
              "WAITATN - Wait for attention signal",
              "COGID - Get current cog ID",
              "COGCHK - Check if cog is running"
            ],
            "synchronization_patterns": [
              {
                "pattern": "Barrier synchronization",
                "code": "VAR\n  BYTE ready_count\n  \nPUB barrier()\n  ready_count++\n  IF ready_count == 8\n    COGATN($FF)  ' Release all\n    ready_count := 0\n  ELSE\n    WAITATN()    ' Wait for release\n"
              },
              {
                "pattern": "Request-response",
                "code": "PUB request_service(cog)\n  COGATN(1 << cog)\n  WAITATN()  ' Wait for completion signal\n"
              },
              {
                "pattern": "Round-robin scheduling",
                "code": "PUB scheduler()\n  REPEAT cog FROM 0 TO 7\n    COGATN(1 << cog)  ' Give time slice\n    WAITMS(10)\n"
              }
            ],
            "notes": [
              "Cannot signal yourself (no effect)",
              "Signal doesn't queue - multiple signals merge",
              "No payload - just a signal",
              "Target cog must be running to receive",
              "More efficient than hub RAM polling"
            ],
            "best_practices": [
              "Use for time-critical signaling",
              "Combine with hub RAM for data passing",
              "Clear attention before waiting again",
              "Document signal meanings clearly",
              "Use masks for group operations"
            ],
            "limitations": [
              "No data payload",
              "No delivery guarantee if cog not waiting",
              "Single bit per cog - no message types",
              "No built-in acknowledgment"
            ],
            "see_also": [
              "language/spin2/methods/pollatn.yaml",
              "language/spin2/methods/waitatn.yaml",
              "language/pasm2/cogatn.yaml",
              "architecture/cog_attention.yaml"
            ]
          },
          "COGSTOP": {
            "method": "COGSTOP",
            "category": "cog_management",
            "type": "method",
            "description": "Stop a specified cog immediately.\nThe cog stops executing and becomes available for reuse.\nAll pins controlled by the cog are released to float state.\nNo effect if the cog is already stopped.\n",
            "syntax": "COGSTOP(CogNum)",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to stop:\n- 0-7: Stop specific cog\n- Can use COGID() to stop current cog\n- Invalid numbers have no effect\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "Immediate",
              "effect": "Cog stops within 1-2 clock cycles",
              "cleanup": "Pins released immediately"
            },
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB stop_driver()\n  IF driver_cog => 0\n    COGSTOP(driver_cog)\n    driver_cog := -1\n",
                "description": "Stop a driver cog and mark as stopped"
              },
              {
                "code": "' Emergency stop all other cogs\nREPEAT cog FROM 0 TO 7\n  IF cog <> COGID()\n    COGSTOP(cog)\n",
                "description": "Stop all cogs except current"
              },
              {
                "code": "' Self-termination\nCOGSTOP(COGID())\n' Code never reaches here\n",
                "description": "Stop current cog (suicide)"
              },
              {
                "code": "PUB restart_cog(n, code_addr, param)\n  COGSTOP(n)  ' Ensure stopped first\n  RETURN COGINIT(n, code_addr, param)\n",
                "description": "Restart a specific cog with new code"
              }
            ],
            "effects": {
              "immediate": [
                "Cog execution halts",
                "Cog RAM contents preserved but inaccessible",
                "Cog becomes available for COGINIT"
              ],
              "pin_control": [
                "All DIR bits cleared (pins become inputs)",
                "Smart pin modes disabled",
                "Pin states float"
              ],
              "resources": [
                "Locks owned by cog are NOT released",
                "Hub RAM is NOT affected",
                "Other cogs continue running"
              ]
            },
            "common_uses": [
              "Clean shutdown of drivers",
              "Resource management",
              "Error recovery",
              "Dynamic cog allocation",
              "Power saving (stopped cogs use less power)"
            ],
            "related_methods": [
              "COGINIT - Start a cog",
              "COGSPIN - Start Spin2 in a cog",
              "COGID - Get current cog number",
              "COGCHK - Check if cog is running"
            ],
            "notes": [
              "Safe to call on already-stopped cog",
              "Cannot stop cog -1 (no effect)",
              "Stopping current cog ends execution immediately",
              "No cleanup code runs in stopped cog",
              "Locks must be manually released before stopping"
            ],
            "best_practices": [
              "Track cog numbers in variables",
              "Set cog variable to -1 after stopping",
              "Release locks before stopping cog",
              "Stop dependent cogs in correct order",
              "Ensure pins are in safe state first"
            ],
            "warnings": [
              "Stopping a cog doesn't clean up its resources",
              "Pins float - may need pull-up/down resistors",
              "Cannot recover cog state after stopping",
              "No notification to other cogs"
            ],
            "see_also": [
              "language/spin2/methods/coginit.yaml",
              "language/spin2/methods/cogid.yaml",
              "language/spin2/methods/cogchk.yaml"
            ]
          },
          "BYTEMOVE": {
            "method": "BYTEMOVE",
            "category": "memory_operations",
            "type": "method",
            "description": "Copy a specified number of bytes from source to destination in hub RAM.\nHandles overlapping regions correctly (safe for moving data within same buffer).\nAutomatically determines forward or reverse copy direction to prevent data corruption.\n",
            "syntax": "BYTEMOVE(Destination, Source, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nCan be any valid hub address (0-524287).\nNo alignment requirements.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to copy.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "small_copy": "~8 + (2 * count) clock cycles",
              "large_copy": "Optimized for larger transfers",
              "overlap_handling": "Automatic, no performance penalty"
            },
            "direction_logic": {
              "forward_copy": "When Dest < Source or Dest >= Source + Count",
              "reverse_copy": "When Dest > Source and Dest < Source + Count",
              "purpose": "Prevents overwriting source data before it's copied"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[100]\n  BYTE backup[100]\n  \nPUB save_buffer()\n  BYTEMOVE(@backup, @buffer, 100)\n",
                "description": "Create backup copy of buffer"
              },
              {
                "code": "' Shift array elements right by 1\nVAR\n  BYTE array[50]\n  \nPUB insert_at_beginning(value)\n  BYTEMOVE(@array[1], @array[0], 49)\n  array[0] := value\n",
                "description": "Insert element at array beginning"
              },
              {
                "code": "' Copy string with length check\nPUB safe_strcopy(dest, source, max_len)\n  len := STRSIZE(source) <# (max_len - 1)\n  BYTEMOVE(dest, source, len)\n  BYTE[dest][len] := 0  ' Null terminate\n",
                "description": "Safe string copy with size limit"
              },
              {
                "code": "' Scroll buffer up one line (80 chars)\nVAR\n  BYTE screen[25][80]\n  \nPUB scroll_up()\n  BYTEMOVE(@screen[0], @screen[1], 24 * 80)\n  BYTEFILL(@screen[24], \" \", 80)\n",
                "description": "Scroll text display"
              },
              {
                "code": "' Extract substring\nPUB substring(dest, source, start, length)\n  BYTEMOVE(dest, source + start, length)\n  BYTE[dest][length] := 0\n",
                "description": "Extract portion of string"
              }
            ],
            "common_uses": [
              "Buffer copying",
              "String manipulation",
              "Array operations",
              "Data structure copying",
              "Screen/display scrolling",
              "Ring buffer management"
            ],
            "overlap_examples": {
              "safe_right_shift": "' Move data 10 bytes to the right\nBYTEMOVE(@buffer[10], @buffer[0], 90)\n' Copies in reverse to prevent corruption\n",
              "safe_left_shift": "' Move data 10 bytes to the left\nBYTEMOVE(@buffer[0], @buffer[10], 90)\n' Copies forward, no overlap issue\n"
            },
            "related_methods": [
              "WORDMOVE - Copy words",
              "LONGMOVE - Copy longs",
              "BYTEFILL - Fill with byte value",
              "BYTECOMP - Compare bytes",
              "BYTESWAP - Swap byte regions"
            ],
            "performance_notes": [
              "Optimized for common cases",
              "Handles alignment automatically",
              "Bulk transfers use efficient hub operations",
              "Small copies have minimal overhead"
            ],
            "notes": [
              "Safe for overlapping regions",
              "Direction chosen automatically",
              "Count of 0 is safe (no operation)",
              "No bounds checking on addresses",
              "Works with any hub RAM location"
            ],
            "warnings": [
              "No automatic null termination for strings",
              "Ensure destination has enough space",
              "Address validation is programmer's responsibility",
              "Cannot copy to/from cog or LUT RAM"
            ],
            "see_also": [
              "language/spin2/methods/wordmove.yaml",
              "language/spin2/methods/longmove.yaml",
              "language/spin2/methods/bytefill.yaml",
              "language/spin2/methods/strsize.yaml"
            ]
          },
          "WAITMS": {
            "method": "WAITMS",
            "category": "timing",
            "type": "method",
            "description": "Delay execution for a specified number of milliseconds.\nProvides a simple timing delay that automatically accounts for the system clock frequency.\nMore convenient than WAITCT for simple delays as it handles the math internally.\n",
            "syntax": "WAITMS(Milliseconds)",
            "parameters": [
              {
                "name": "Milliseconds",
                "type": "long",
                "description": "Number of milliseconds to delay (1-4,294,967 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "accuracy": "Within one system clock tick",
              "resolution": "1 millisecond",
              "calculation": "Uses CLKFREQ/1000 internally",
              "overhead": "Minimal setup overhead (~10 cycles)"
            },
            "examples": [
              {
                "code": "WAITMS(1000)",
                "description": "Delay for 1 second"
              },
              {
                "code": "REPEAT\n  PINHIGH(56)\n  WAITMS(500)\n  PINLOW(56)\n  WAITMS(500)\n",
                "description": "Blink LED at 1Hz"
              },
              {
                "code": "VAR\n  LONG delay_time\nPUB variable_delay()\n  delay_time := 100\n  REPEAT 10\n    PINTOGGLE(56)\n    WAITMS(delay_time)\n    delay_time += 50\n",
                "description": "Variable delay that increases each iteration"
              },
              {
                "code": "' Debounce a button\nIF PINREAD(0)\n  WAITMS(50)  ' Debounce delay\n  IF PINREAD(0)\n    ' Button really pressed\n",
                "description": "Button debouncing"
              }
            ],
            "underlying_implementation": {
              "description": "Internally calculates: WAITX((CLKFREQ/1000) * milliseconds - 1)\nAutomatically adjusts for system clock frequency.\n",
              "related_pasm": "WAITX instruction"
            },
            "common_uses": [
              "LED blinking and indicators",
              "Button debouncing",
              "Timing between operations",
              "Simple animation delays",
              "Sensor reading intervals",
              "Communication protocol delays"
            ],
            "related_methods": [
              "WAITUS - Delay for microseconds",
              "WAITCT - Wait for specific system counter value",
              "GETCT - Get current system counter",
              "POLLCT - Check if counter value passed"
            ],
            "notes": [
              "Blocks execution - cog cannot do other work during delay",
              "Not suitable for precise timing critical operations",
              "Maximum delay ~4,294 seconds (71 minutes)",
              "For delays less than 1ms, use WAITUS",
              "For cycle-accurate timing, use WAITCT",
              "Delay is relative to call time, not absolute"
            ],
            "limitations": [
              "1ms minimum resolution",
              "Blocking operation",
              "Subject to small jitter from hub timing"
            ],
            "see_also": [
              "language/spin2/methods/waitus.yaml",
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/getct.yaml",
              "language/pasm2/waitx.yaml"
            ]
          },
          "COGID": {
            "method": "COGID",
            "category": "cog_management",
            "type": "method",
            "description": "Get the ID number of the currently executing cog.\nReturns a value from 0 to 7 identifying which cog is running this code.\nEssential for cog self-identification and coordination.\n",
            "syntax": "COGID() : CogNum",
            "parameters": "none",
            "returns": {
              "name": "CogNum",
              "type": "long",
              "description": "Current cog's ID number (0-7).\nAlways returns valid cog number.\n"
            },
            "timing": {
              "execution": "2 clock cycles",
              "deterministic": "Yes - always same timing"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE cog_status[8]\n  \nPUB mark_ready()\n  cog_status[COGID()] := 1\n",
                "description": "Mark current cog as ready in status array"
              },
              {
                "code": "PUB self_stop()\n  ' Clean up resources\n  release_pins()\n  ' Stop myself\n  COGSTOP(COGID())\n",
                "description": "Cog self-termination"
              },
              {
                "code": "DAT\n  cog_mailbox LONG 0[8]\n  \nPUB get_my_mailbox() : address\n  address := @cog_mailbox[COGID()]\n",
                "description": "Get mailbox for current cog"
              },
              {
                "code": "PUB debug_print()\n  SEND(\"Cog \", COGID(), \" reporting\", 13)\n",
                "description": "Identify cog in debug output"
              },
              {
                "code": "PUB stop_all_except_me()\n  REPEAT n FROM 0 TO 7\n    IF n <> COGID()\n      COGSTOP(n)\n",
                "description": "Stop all other cogs"
              }
            ],
            "common_uses": [
              "Cog self-identification",
              "Accessing cog-specific data",
              "Debug output identification",
              "Self-termination",
              "Cog coordination",
              "Resource allocation by cog"
            ],
            "related_methods": [
              "COGSTOP - Stop a cog",
              "COGCHK - Check if cog is running",
              "COGINIT - Start PASM in a cog",
              "COGSPIN - Start Spin2 in a cog"
            ],
            "typical_patterns": [
              {
                "pattern": "Per-cog data structures",
                "code": "VAR\n  LONG cog_data[8][10]  ' 10 longs per cog\n  \nPUB my_data() : ptr\n  ptr := @cog_data[COGID()]\n"
              },
              {
                "pattern": "Cog-specific pin assignments",
                "code": "PUB my_led_pin() : pin\n  pin := 56 + COGID()  ' Each cog gets unique LED\n"
              },
              {
                "pattern": "Synchronized startup",
                "code": "VAR\n  BYTE ready_flags\n  \nPUB wait_all_ready()\n  ready_flags |= (1 << COGID())  ' Set my bit\n  REPEAT UNTIL ready_flags == $FF  ' Wait for all 8\n"
              }
            ],
            "notes": [
              "Always returns 0-7, never -1",
              "Cog 0 always starts first at boot",
              "Value doesn't change during cog's lifetime",
              "Can be called from PASM via Spin2",
              "Useful for multicore coordination"
            ],
            "underlying_pasm": {
              "instruction": "COGID",
              "description": "Direct register read of cog ID"
            },
            "see_also": [
              "language/pasm2/cogid.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/cogchk.yaml",
              "architecture/cog.yaml"
            ]
          },
          "PINFLOAT": {
            "method": "PINFLOAT",
            "aliases": [
              "PINF"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Float specified pin(s) to high-impedance state (input mode).\nClears the direction bit(s) to input (DIR=0), releasing the pin from being driven.\nThe pin becomes an input and can be read or driven by external circuitry.\nThis is equivalent to the PASM2 FLTL instruction.\n",
            "syntax": "PINFLOAT(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to float. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINFLOAT(0)",
                "description": "Float pin 0 to high-impedance"
              },
              {
                "code": "PINFLOAT(0 ADDPINS 7)",
                "description": "Float pins 0 through 7 (release bus)"
              },
              {
                "code": "' Charlieplexing example\nPINFLOAT(0 ADDPINS 7)  ' Float all pins first\nPINHIGH(3)             ' Drive one pin high\nPINLOW(0)              ' Drive another low\n' Others remain floating\n",
                "description": "Prepare pins for Charlieplexing LED matrix"
              },
              {
                "code": "' I2C bus release\nPINFLOAT(28 ADDPINS 1)  ' Release SDA and SCL (pins 28, 29)\n",
                "description": "Release I2C bus pins"
              }
            ],
            "underlying_pasm": {
              "instruction": "FLTL",
              "description": "Internally uses FLTL instruction which sets DIR=0"
            },
            "common_uses": [
              "Release shared bus lines",
              "Configure pins as inputs",
              "Charlieplexing LED matrices",
              "Tri-state bus operations",
              "Allow pull-up/pull-down resistors to set level",
              "Switch from output to input mode"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINLOW - Drive pin(s) low",
              "PINTOGGLE - Toggle pin state",
              "PINREAD - Read floating pin state"
            ],
            "notes": [
              "Pin becomes an input and can be read with PINREAD",
              "External pull-up/pull-down resistors will determine the level",
              "Pin will not drive any current in this state",
              "Smart pin modes may still operate while DIR=0",
              "Essential for bidirectional communication protocols",
              "Multiple pins can be floated simultaneously"
            ],
            "see_also": [
              "language/pasm2/fltl.yaml",
              "language/spin2/methods/pinread.yaml",
              "language/spin2/methods/pinhigh.yaml"
            ]
          },
          "PINSTART": {
            "method": "PINSTART",
            "type": "method",
            "description": "Configure and start smart pin with mode and parameters.\nSupports pin groups via ADDPINS operator for parallel operations.\n",
            "category": "Smart Pin Operations",
            "documentation_source": "enhanced",
            "documentation_level": "comprehensive",
            "syntax": "PINSTART(PinField, Mode, Xval, Yval)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression.\nUse ADDPINS to specify multiple consecutive pins:\n- Single pin: 16\n- Pin range: 16 ADDPINS 3 (pins 16-19)\n- Pin group: BASE_PIN ADDPINS (COUNT-1)\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "Smart pin mode configuration (P_* constants)"
              },
              {
                "name": "Xval",
                "type": "long",
                "description": "X parameter for smart pin mode"
              },
              {
                "name": "Yval",
                "type": "long",
                "description": "Y parameter for smart pin mode"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Start ADC on pin 16\nPINSTART(16, P_ADC | P_ADC_1X, 0, 0)\n",
                "description": "Configure pin as ADC input"
              },
              {
                "code": "' Start PWM on pin 8\nPINSTART(8, P_PWM_TRIANGLE, 1000, 500)\n",
                "description": "Configure PWM with period=1000, duty=500"
              },
              {
                "code": "' Start serial TX on pin 62\nPINSTART(62, P_ASYNC_TX | P_OE, clkfreq/115200, 0)\n",
                "description": "Configure asynchronous serial transmit"
              },
              {
                "code": "' Start quadrature encoder on pins 32-33\nPINSTART(32 ADDPINS 1, P_QUADRATURE_A, 0, 0)\n",
                "description": "Configure quadrature encoder input"
              },
              {
                "code": "' HUB75 RGB pin groups for LED panel\nCON\n  RGB_BASE = 16        ' Base pin for RGB data\n  RGB_COUNT = 6        ' 6 pins for RGB (2 per color)\n  CLK_PIN = 22\n  LAT_PIN = 23\n  OE_PIN = 24\n  \nPUB setup_hub75()\n  ' Configure 6 RGB data pins as outputs\n  PINSTART(RGB_BASE ADDPINS (RGB_COUNT-1), P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Configure control pins\n  PINSTART(CLK_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(LAT_PIN, P_HIGH_FAST | P_OE, 0, 0)\n  PINSTART(OE_PIN, P_HIGH_FAST | P_OE, 0, 0)\n",
                "description": "Configure HUB75 LED panel pin groups",
                "source": "hub75_driver"
              },
              {
                "code": "' Multi-pin ADC configuration for sensor array\nCON\n  SENSOR_BASE = 8\n  SENSOR_COUNT = 8      ' 8 sensors\n  \nPUB setup_sensors() | i\n  ' Configure 8 consecutive ADC pins\n  REPEAT i FROM 0 TO SENSOR_COUNT-1\n    PINSTART(SENSOR_BASE + i, P_ADC | P_ADC_1X, 0, 0)\n    \n  ' Or using ADDPINS for group config (same mode)\n  PINSTART(SENSOR_BASE ADDPINS (SENSOR_COUNT-1), P_HIGH_1K5, 0, 0)\n",
                "description": "Configure sensor array pins",
                "source": "sensor_array"
              },
              {
                "code": "' Flash FS SPI pin configuration\nCON\n  SPI_CLK = 56\n  SPI_MOSI = 57\n  SPI_MISO = 58\n  SPI_CS = 59\n  \nPUB setup_spi()\n  ' Configure SPI pins as group\n  PINSTART(SPI_CLK ADDPINS 3, P_HIGH_FAST | P_OE, 0, 0)\n  \n  ' Then set specific modes\n  PINSTART(SPI_CLK, P_TRANSITION_OUTPUT, 1, 0)\n  PINSTART(SPI_MOSI, P_SYNC_TX | P_OE, SPI_CLK<<24 | 8, 0)\n  PINSTART(SPI_MISO, P_SYNC_RX, SPI_CLK<<24 | 8, 0)\n",
                "description": "Configure SPI pins for flash filesystem",
                "source": "P2-FLASH-FS"
              }
            ],
            "pin_field_operators": {
              "ADDPINS": {
                "syntax": "base_pin ADDPINS count",
                "description": "Creates a pin field representing consecutive pins.\nThe count is 0-based (use n-1 for n pins).\n",
                "examples": [
                  "16 ADDPINS 0  ' Single pin (16)",
                  "16 ADDPINS 3  ' 4 pins (16-19)",
                  "16 ADDPINS 7  ' 8 pins (16-23)"
                ],
                "use_cases": [
                  "Parallel data buses",
                  "LED arrays",
                  "Sensor arrays",
                  "Multi-bit I/O"
                ]
              }
            },
            "critical_requirement": {
              "reset_before_configure": true,
              "description": "**CRITICAL**: PINSTART automatically resets the smart pin (DIR=0) before configuration.\nThis is REQUIRED to ensure proper smart pin operation. Never skip this reset step.\n",
              "internal_sequence": [
                "DIR[pin] := 0     ' AUTOMATIC: Reset smart pin (REQUIRED)",
                "WRPIN(pin, Mode)  ' Configure smart pin mode",
                "WXPIN(pin, Xval)  ' Set X parameter",
                "WYPIN(pin, Yval)  ' Set Y parameter",
                "DIR[pin] := 1     ' Enable smart pin"
              ]
            },
            "notes": [
              "**CRITICAL**: Automatically performs required DIR=0 reset before configuration",
              "Complete smart pin initialization sequence with proper reset",
              "Mode constants defined in Spin2 (P_ADC, P_PWM_TRIANGLE, etc.)",
              "X and Y parameters are mode-specific",
              "Pin starts operating immediately after DIR=1",
              "Use PINCLEAR to stop and reset smart pin before reconfiguration",
              "ADDPINS allows configuring multiple pins with same mode",
              "NEVER configure a smart pin without first resetting it (DIR=0)"
            ],
            "operations": [
              "DIR[pin] := 0 (reset)",
              "WRPIN(pin, Mode) (set mode)",
              "WXPIN(pin, Xval) (set X parameter)",
              "WYPIN(pin, Yval) (set Y parameter)",
              "DIR[pin] := 1 (enable)"
            ],
            "timing": {
              "description": "Multiple hub operations",
              "cycles": "20-90 clock cycles per pin"
            },
            "related": [
              "PINCLEAR",
              "WRPIN",
              "WXPIN",
              "WYPIN",
              "PINWRITE",
              "PINREAD"
            ],
            "production_patterns": {
              "hub75_panel": {
                "description": "HUB75 RGB LED panel uses pin groups",
                "pattern": "- 6 RGB data pins configured as group\n- Control pins (CLK, LAT, OE) individual\n- Use ADDPINS for efficient setup\n- Parallel output via SETQ/MUXQ\n",
                "source": "hub75_driver"
              },
              "flash_filesystem": {
                "description": "SPI pins for flash access",
                "pattern": "- Configure pins as group first\n- Then specialize each pin's mode\n- Maintains pin locality\n",
                "source": "P2-FLASH-FS"
              }
            },
            "see_also": [
              "Smart pin modes",
              "Smart pin configuration",
              "P2 smart pin constants",
              "concepts/inline_pasm2.yaml"
            ]
          },
          "TASKNEXT": {
            "method": "TASKNEXT",
            "type": "method",
            "description": "Yield control to next task in round-robin schedule\n",
            "category": "Task Operations",
            "syntax": "TASKNEXT()",
            "parameters": [],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Cooperative yield\nrepeat\n  do_work_chunk()\n  TASKNEXT()  ' Let other tasks run\n",
                "description": "Yield after work chunk"
              },
              {
                "code": "' Polling with yield\nrepeat\n  if data_ready\n    process_data()\n  TASKNEXT()  ' Don't hog CPU\n",
                "description": "Polling with cooperation"
              },
              {
                "code": "' Long computation with yields\nrepeat i from 0 to 1000\n  calculate_step(i)\n  if i // 10 == 0\n    TASKNEXT()  ' Yield every 10 iterations\n",
                "description": "Periodic yielding in long loop"
              }
            ],
            "notes": [
              "Voluntary context switch",
              "Enables cooperative multitasking",
              "Current task pauses, next task runs",
              "Returns when task gets control again",
              "Essential for task cooperation",
              "Prevents task starvation"
            ],
            "timing": {
              "description": "Context switch time",
              "cycles": "~20-40 clock cycles"
            },
            "related": [
              "TASKWAIT",
              "TASKSPIN",
              "TASKHALT"
            ],
            "see_also": [
              "Cooperative multitasking",
              "Task scheduling",
              "Context switching"
            ]
          },
          "STRSIZE": {
            "method": "STRSIZE",
            "type": "method",
            "description": "Get length of null-terminated string\n",
            "category": "String Operations",
            "syntax": "length := STRSIZE(StringAddress)",
            "parameters": [
              {
                "name": "StringAddress",
                "type": "address",
                "description": "Address of null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Number of characters (not including null terminator)"
            },
            "examples": [
              {
                "code": "' Get string length\nlen := STRSIZE(@message)\ndebug(\"Message length: \", udec(len))\n",
                "description": "Get string length"
              },
              {
                "code": "' Check if string fits in buffer\nif STRSIZE(@input) < buffer_size\n  STRCOPY(@buffer, @input, buffer_size)\n",
                "description": "Validate before copying"
              },
              {
                "code": "' Calculate total message size\ntotal := STRSIZE(@part1) + STRSIZE(@part2) + 1\n",
                "description": "Calculate combined length"
              }
            ],
            "notes": [
              "Returns character count, not byte count",
              "Does not include null terminator in count",
              "Stops counting at first null (0) byte",
              "Returns 0 for empty string (immediate null)",
              "No maximum length limit",
              "Useful for buffer allocation"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (1 per character) clock cycles"
            },
            "related": [
              "STRCOMP",
              "STRCOPY",
              "STRING"
            ],
            "see_also": [
              "String operations",
              "String measurement",
              "Buffer sizing"
            ]
          },
          "QSIN": {
            "method": "QSIN",
            "type": "method",
            "description": "Calculate sine of angle using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "sine := QSIN(Angle, Length)",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Sine value scaled by Length"
            },
            "examples": [
              {
                "code": "' Calculate sine of 30 degrees\nsine := QSIN($1555_5555, 1000)  ' 30\u00b0 with scale 1000\n' Result: sine \u2248 500\n",
                "description": "Basic sine calculation"
              },
              {
                "code": "' Generate sine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QSIN(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate sine wave plot"
              },
              {
                "code": "' Vertical position for circular motion\ny_pos := center_y + QSIN(angle, radius)\n",
                "description": "Calculate Y position on circle"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0",
              "Result = Length \u00d7 sin(Angle)",
              "Full 32-bit precision",
              "38-clock cycle operation",
              "Handles all quadrants correctly"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QCOS",
              "ROTXY",
              "POLXY"
            ],
            "see_also": [
              "CORDIC operations",
              "Trigonometric functions",
              "Waveform generation"
            ]
          },
          "REGLOAD": {
            "method": "REGLOAD",
            "type": "method",
            "description": "Load PASM2 code from hub to cog registers\n",
            "category": "Miscellaneous",
            "syntax": "REGLOAD(HubAddress)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Load PASM code\nREGLOAD(@pasm_routines)\n' Code now in cog, ready to CALL\n",
                "description": "Load PASM for later execution"
              },
              {
                "code": "' Update PASM code\nmodify_pasm(@buffer)  ' Modify code\nREGLOAD(@buffer)      ' Reload it\nresult := CALL($100)  ' Execute at cog address\n",
                "description": "Dynamic code modification"
              },
              {
                "code": "' Load different routines\nif mode == 1\n  REGLOAD(@fast_routines)\nelse\n  REGLOAD(@accurate_routines)\n",
                "description": "Conditional code loading"
              }
            ],
            "notes": [
              "Loads code but doesn't execute",
              "Use CALL to execute after loading",
              "Overwrites cog registers",
              "Preserves Spin2 interpreter area",
              "Maximum 496 longs can be loaded",
              "Useful for swapping PASM routines"
            ],
            "timing": {
              "description": "Hub to cog transfer",
              "cycles": "~8 + (size * 2) clock cycles"
            },
            "related": [
              "REGEXEC",
              "CALL",
              "SETREGS"
            ],
            "see_also": [
              "Code loading",
              "PASM2 management",
              "Dynamic routines"
            ]
          },
          "LONGSWAP": {
            "method": "LONGSWAP",
            "type": "method",
            "description": "Swap long values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "LONGSWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing long to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing long to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two long values\nLONGSWAP(@value1, @value2)\n",
                "description": "Exchange long values between variables"
              },
              {
                "code": "' Reverse long order in array\nrepeat i from 0 to size/2-1\n  LONGSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using long swapping"
              },
              {
                "code": "' Swap register values\nLONGSWAP(@reg_a, @reg_b)\n",
                "description": "Exchange 32-bit register values"
              }
            ],
            "notes": [
              "Atomically exchanges the 32-bit long values",
              "Both addresses must be long-aligned (addresses divisible by 4)",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange",
              "Each long is 4 bytes"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "BYTESWAP",
              "WORDSWAP",
              "LONGMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation",
              "Register operations"
            ]
          },
          "WORDMOVE": {
            "method": "WORDMOVE",
            "type": "method",
            "description": "Copy words from one memory location to another\n",
            "category": "Memory Operations",
            "syntax": "WORDMOVE(DestAddress, SourceAddress, Count)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM destination starting address for word copy"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Hub RAM source starting address for word copy"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words (16-bit values) to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Copy 100 words from source to destination\nWORDMOVE(@dest_array, @source_array, 100)\n",
                "description": "Copy 100 words between arrays"
              },
              {
                "code": "' Shift array elements up by one word\nWORDMOVE(@array[1], @array[0], 99)\n",
                "description": "Shift array elements with overlap handling"
              }
            ],
            "notes": [
              "Automatically handles overlapping source and destination regions",
              "Copies in appropriate direction to preserve data integrity",
              "Each word is 2 bytes (16 bits)",
              "Addresses must be word-aligned for optimal performance",
              "Count of 0 copies no data"
            ],
            "timing": {
              "description": "Varies based on count and hub timing",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTEMOVE",
              "LONGMOVE",
              "WORDFILL"
            ],
            "see_also": [
              "Memory block operations",
              "Hub RAM access"
            ]
          },
          "LOCKREL": {
            "method": "LOCKREL",
            "type": "method",
            "description": "Release a captured lock\n",
            "category": "Lock Operations",
            "syntax": "LOCKREL(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to release (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Basic lock usage pattern\nrepeat until LOCKTRY(lock_id)\n' Critical section - exclusive access\nmodify_shared_data()\nLOCKREL(lock_id)  ' Release for other cogs\n",
                "description": "Standard lock/unlock pattern"
              },
              {
                "code": "' Ensure lock release on error\nif LOCKTRY(lock_id)\n  result := process_data()\n  LOCKREL(lock_id)\n  if result < 0\n    abort\n",
                "description": "Release lock before error abort"
              },
              {
                "code": "' Multiple lock management\nLOCKREL(resource_a_lock)\nLOCKREL(resource_b_lock)\n",
                "description": "Release multiple locks"
              }
            ],
            "notes": [
              "Releases lock for other cogs to capture",
              "Only the cog that captured can release",
              "Safe to call even if not owner (no-op)",
              "Critical to release locks to prevent deadlock",
              "Lock becomes immediately available",
              "Does not return lock to pool (use LOCKRET for that)"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKTRY",
              "LOCKNEW",
              "LOCKRET",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Critical sections",
              "Resource sharing"
            ]
          },
          "PINTOGGLE": {
            "method": "PINTOGGLE",
            "aliases": [
              "PINT"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive and toggle specified pin(s).\nFirst sets the direction bit(s) to output (DIR=1), then inverts the current output state (OUT^=1).\nIf pin was high, it becomes low. If pin was low, it becomes high.\nThis is equivalent to the PASM2 DRVNOT instruction.\n",
            "syntax": "PINTOGGLE(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to toggle. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINTOGGLE(56)",
                "description": "Toggle pin 56 (LED will change state)"
              },
              {
                "code": "REPEAT\n  PINTOGGLE(56)\n  WAITMS(500)\n",
                "description": "Blink an LED at 1Hz"
              },
              {
                "code": "PINTOGGLE(0 ADDPINS 7)",
                "description": "Toggle pins 0 through 7 simultaneously"
              },
              {
                "code": "VAR\n  LONG status_pins\nPUB flash_status()\n  status_pins := 8 ADDPINS 3  ' Pins 8, 9, 10, 11\n  REPEAT 5\n    PINTOGGLE(status_pins)\n    WAITMS(100)\n",
                "description": "Flash multiple status LEDs"
              }
            ],
            "underlying_pasm": {
              "instruction": "DRVNOT",
              "description": "Internally uses DRVNOT instruction which sets DIR=1 and OUT^=1"
            },
            "common_uses": [
              "Blink LEDs without tracking state",
              "Generate square waves",
              "Toggle clock or strobe signals",
              "Create alternating patterns",
              "Debug output without state management"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINLOW - Drive pin(s) low",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "No need to track current pin state",
              "Multiple pins toggle independently based on their current states",
              "If pin is floating (input), it will first read the input state then toggle from that"
            ],
            "see_also": [
              "language/pasm2/drvnot.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pinlow.yaml"
            ]
          },
          "TASKHALT": {
            "method": "TASKHALT",
            "type": "method",
            "description": "Pause/halt a running task temporarily\n",
            "category": "Task Operations",
            "syntax": "TASKHALT(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to halt (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Pause a task\nTASKHALT(3)  ' Pause task 3\n' Do critical work...\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Pause and resume task"
              },
              {
                "code": "' Pause all tasks for critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKHALT(task_id)\n' Critical section\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKRESUME(task_id)\n",
                "description": "Pause all tasks temporarily"
              },
              {
                "code": "' Conditional task pause\nif buffer_full\n  TASKHALT(producer_task)\n",
                "description": "Pause producer when buffer full"
              }
            ],
            "notes": [
              "Task is paused, not terminated",
              "State and stack preserved",
              "Use TASKRESUME to continue",
              "Task won't execute until resumed",
              "Useful for synchronization",
              "Different from TASKSTOP (which terminates)"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKRESUME",
              "TASKSTOP",
              "TASKSPIN",
              "TASKCHK"
            ],
            "see_also": [
              "Task synchronization",
              "Task pausing",
              "Critical sections"
            ]
          },
          "LONGCOMP": {
            "method": "LONGCOMP",
            "type": "method",
            "description": "Compare blocks of longs in memory\n",
            "category": "Memory Operations",
            "syntax": "result := LONGCOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (long-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all longs match, FALSE (0) if any longs differ"
            },
            "examples": [
              {
                "code": "' Compare two long arrays\nif LONGCOMP(@results1, @results2, 256)\n  ' Arrays match (256 longs)\n",
                "description": "Compare long arrays"
              },
              {
                "code": "' Verify calculation results\nif LONGCOMP(@computed, @expected, 32)\n  ' All 32 computed values match expected\n",
                "description": "Verify 32-bit calculation results"
              },
              {
                "code": "' Check for signature pattern\nif LONGCOMP(@header, @valid_signature, 4)\n  ' Found valid 4-long signature\n",
                "description": "Validate header signature"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all longs match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Addresses should be long-aligned (divisible by 4) for best performance",
              "Each long is 32 bits (4 bytes)",
              "Efficient block comparison operation",
              "Native P2 word size for fastest comparison"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTECOMP",
              "WORDCOMP",
              "LONGMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "Array operations",
              "Pattern matching"
            ]
          },
          "RDPIN": {
            "method": "RDPIN",
            "type": "method",
            "description": "Read smart pin result and clear IN flag (acknowledge)\n",
            "category": "Smart Pin Operations",
            "syntax": "result := RDPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "examples": [
              {
                "code": "' Read ADC result from pin 16\nadc_value := RDPIN(16)\n",
                "description": "Read ADC conversion result"
              },
              {
                "code": "' Read pulse width measurement\nwidth := RDPIN(8) & $7FFF_FFFF  ' Mask off C flag\n",
                "description": "Read pulse width, remove C flag"
              },
              {
                "code": "' Check C flag while reading\nvalue := RDPIN(pin)\nif value < 0  ' C flag was set (bit 31)\n  ' Handle C flag condition\n",
                "description": "Read value and check C flag state"
              }
            ],
            "notes": [
              "Clears the smart pin's IN flag after reading",
              "Bit 31 of result contains the pin's C flag state",
              "Lower 31 bits contain the smart pin measurement/result",
              "Reading acknowledges the smart pin, allowing next measurement",
              "Use RQPIN to read without acknowledging",
              "Smart pin must be configured with WRPIN/WXPIN/WYPIN first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RQPIN",
              "AKPIN",
              "WRPIN",
              "WXPIN",
              "WYPIN"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin configuration",
              "Pin I/O operations"
            ]
          },
          "ROTXY": {
            "method": "ROTXY",
            "type": "method",
            "description": "Rotate X,Y coordinates by specified angle using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "X2, Y2 := ROTXY(X, Y, Angle)",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate to rotate (32-bit signed)"
              },
              {
                "name": "Angle",
                "type": "long",
                "description": "Rotation angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns rotated X2 and Y2 coordinates"
            },
            "examples": [
              {
                "code": "' Rotate point 45 degrees\nx2, y2 := ROTXY(100, 0, $2000_0000)  ' 45\u00b0 = $20000000\n' Result: x2 \u2248 71, y2 \u2248 71\n",
                "description": "Rotate point by 45 degrees"
              },
              {
                "code": "' Animate rotating point\nangle := 0\nrepeat\n  x2, y2 := ROTXY(radius, 0, angle)\n  plot(center_x + x2, center_y + y2)\n  angle += $0100_0000  ' Increment angle\n",
                "description": "Animate point rotating around origin"
              },
              {
                "code": "' Rotate sprite vertices\nrepeat i from 0 to num_vertices-1\n  vx[i], vy[i] := ROTXY(vx[i], vy[i], rotation)\n",
                "description": "Rotate all vertices of a shape"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Full 32-bit precision maintained",
              "Handles all quadrants correctly",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "POLXY",
              "XYPOL",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Coordinate rotation",
              "2D graphics"
            ]
          },
          "SEND": {
            "method": "SEND",
            "type": "method",
            "description": "Send data bytes using configured output method\n",
            "category": "Miscellaneous",
            "syntax": "SEND(DataItems...)",
            "parameters": [
              {
                "name": "DataItems",
                "type": "variable",
                "description": "One or more data items to send (bytes, strings, arrays)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Send single byte\nSEND($41)  ' Send 'A'\n",
                "description": "Send single byte"
              },
              {
                "code": "' Send string\nSEND(STRING(\"Hello, World!\"))\n",
                "description": "Send string constant"
              },
              {
                "code": "' Send multiple items\nSEND($0D, $0A, STRING(\"Ready\"), $0D, $0A)\n",
                "description": "Send mixed data types"
              },
              {
                "code": "' Send array data\nSEND(BYTE[@buffer, 10])  ' Send 10 bytes from buffer\n",
                "description": "Send array contents"
              }
            ],
            "notes": [
              "Output method must be configured first",
              "Typically used with serial drivers",
              "Can send bytes, words, longs, strings, arrays",
              "Blocking operation - waits for each byte",
              "Works with user-defined output methods",
              "Common for debug output"
            ],
            "timing": {
              "description": "Depends on output method",
              "cycles": "Variable based on driver"
            },
            "related": [
              "RECV",
              "DEBUG"
            ],
            "see_also": [
              "Serial communication",
              "Debug output",
              "Data transmission"
            ]
          },
          "CALL": {
            "method": "CALL",
            "type": "method",
            "description": "Call inline PASM2 code from Spin2\n",
            "category": "Miscellaneous",
            "syntax": "result := CALL(PASMAddress)",
            "parameters": [
              {
                "name": "PASMAddress",
                "type": "address",
                "description": "Address of PASM2 code to execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in PASM result register"
            },
            "examples": [
              {
                "code": "' Call inline PASM routine\nresult := CALL(@pasm_code)\n\nDAT\npasm_code\n  mov result1, #42\n  ret\n",
                "description": "Call simple PASM routine"
              },
              {
                "code": "' Pass parameters via PTRA/PTRB\nPTRA := @input_data\nPTRB := @output_buffer\nCALL(@process_data)\n",
                "description": "Call PASM with parameters"
              },
              {
                "code": "' Fast calculation in PASM\nvalue := CALL(@fast_multiply)\n\nDAT\nfast_multiply\n  mov pa, ptra\n  mov pb, ptrb\n  mul pa, pb\n  mov result1, pa\n  ret\n",
                "description": "PASM for fast math"
              }
            ],
            "notes": [
              "Executes PASM2 code in current cog",
              "PASM must end with RET instruction",
              "Parameters passed via PTRA/PTRB registers",
              "Result returned in result1 register",
              "Preserves Spin2 interpreter state",
              "Useful for performance-critical code",
              "PASM code must be in DAT section"
            ],
            "timing": {
              "description": "PASM execution time + call overhead",
              "cycles": "~20 + PASM cycles"
            },
            "related": [
              "REGEXEC",
              "REGLOAD",
              "COGINIT"
            ],
            "see_also": [
              "Inline assembly",
              "PASM2 programming",
              "Performance optimization"
            ]
          },
          "RQPIN": {
            "method": "RQPIN",
            "type": "method",
            "description": "Read smart pin result without clearing IN flag\n",
            "category": "Smart Pin Operations",
            "syntax": "result := RQPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "long",
              "description": "32-bit result with bit 31 containing the pin's C flag state"
            },
            "examples": [
              {
                "code": "' Peek at smart pin value without acknowledging\ncurrent_count := RQPIN(24)\n",
                "description": "Read current value without affecting measurement"
              },
              {
                "code": "' Monitor ADC without clearing ready flag\nif PINREAD(16)  ' Check if new data ready\n  preview := RQPIN(16)  ' Preview value\n  if preview > threshold\n    actual := RDPIN(16)  ' Now acknowledge\n",
                "description": "Preview value before deciding to acknowledge"
              },
              {
                "code": "' Check multiple pins without acknowledging\nrepeat pin from 8 to 15\n  values[pin] := RQPIN(pin)\n",
                "description": "Read multiple smart pins without clearing flags"
              }
            ],
            "notes": [
              "Does NOT clear the smart pin's IN flag",
              "Bit 31 contains the pin's C flag state",
              "Lower 31 bits contain the smart pin measurement/result",
              "Useful for peeking at current value without affecting operation",
              "Pin continues to assert IN flag after RQPIN",
              "Use RDPIN to read and acknowledge",
              "Smart pin must be configured with WRPIN/WXPIN/WYPIN first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RDPIN",
              "AKPIN",
              "WRPIN",
              "PINREAD"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin monitoring",
              "Non-destructive reading"
            ]
          },
          "WAITUS": {
            "method": "WAITUS",
            "category": "timing",
            "type": "method",
            "description": "Delay execution for a specified number of microseconds.\nProvides microsecond-resolution timing delay that automatically accounts for system clock frequency.\nMore precise than WAITMS for short delays.\n",
            "syntax": "WAITUS(Microseconds)",
            "parameters": [
              {
                "name": "Microseconds",
                "type": "long",
                "description": "Number of microseconds to delay (1-4,294,967,295 range).\nCan be a constant, variable, or expression.\nValue is treated as unsigned.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "accuracy": "Within one system clock tick",
              "resolution": "1 microsecond (at frequencies >= 1MHz)",
              "calculation": "Uses CLKFREQ/1_000_000 internally",
              "overhead": "Minimal setup overhead (~10 cycles)",
              "minimum_useful": "~2 microseconds at 200MHz"
            },
            "examples": [
              {
                "code": "WAITUS(10)",
                "description": "Delay for 10 microseconds"
              },
              {
                "code": "' Generate 50% duty cycle square wave\nREPEAT\n  PINHIGH(0)\n  WAITUS(10)\n  PINLOW(0)\n  WAITUS(10)\n",
                "description": "50kHz square wave (20\u00b5s period)"
              },
              {
                "code": "' Pulse width generation\nPUB pulse(pin, width_us)\n  PINHIGH(pin)\n  WAITUS(width_us)\n  PINLOW(pin)\n",
                "description": "Generate precise pulse width"
              },
              {
                "code": "' Bit-banged serial timing\nPUB send_bit(value)\n  PINWRITE(TX_PIN, value)\n  WAITUS(104)  ' 9600 baud bit time\n",
                "description": "Serial bit timing at 9600 baud"
              },
              {
                "code": "' I2C clock stretching\nPINHIGH(SCL)\nWAITUS(5)  ' Setup time\ndata := PINREAD(SDA)\nWAITUS(5)  ' Hold time\nPINLOW(SCL)\n",
                "description": "I2C timing compliance"
              }
            ],
            "underlying_implementation": {
              "description": "Internally calculates: WAITX((CLKFREQ/1_000_000) * microseconds - 1)\nAutomatically adjusts for system clock frequency.\nAt lower frequencies, resolution degrades.\n",
              "related_pasm": "WAITX instruction"
            },
            "common_uses": [
              "Pulse width generation",
              "Bit-banged communication protocols",
              "Sensor timing requirements",
              "Setup and hold times",
              "Servo control pulses",
              "Ultrasonic sensor timing",
              "Fine-grained delays"
            ],
            "related_methods": [
              "WAITMS - Delay for milliseconds",
              "WAITCT - Wait for specific system counter value",
              "GETCT - Get current system counter",
              "POLLCT - Check if counter value passed"
            ],
            "notes": [
              "Blocks execution - cog cannot do other work during delay",
              "Resolution limited by clock frequency (1\u00b5s requires \u22651MHz clock)",
              "For delays > 1000\u00b5s, consider using WAITMS",
              "For cycle-accurate timing, use WAITCT",
              "Very short delays may be dominated by overhead",
              "Delay is relative to call time, not absolute"
            ],
            "limitations": [
              "1\u00b5s minimum resolution (at sufficient clock speed)",
              "Blocking operation",
              "Subject to small jitter from hub timing",
              "Resolution degrades at low clock frequencies"
            ],
            "clock_frequency_impact": [
              "200MHz: 1\u00b5s = 200 clocks (excellent resolution)",
              "80MHz: 1\u00b5s = 80 clocks (good resolution)",
              "20MHz: 1\u00b5s = 20 clocks (marginal resolution)",
              "1MHz: 1\u00b5s = 1 clock (poor resolution)"
            ],
            "see_also": [
              "language/spin2/methods/waitms.yaml",
              "language/spin2/methods/waitct.yaml",
              "language/spin2/methods/getct.yaml",
              "language/pasm2/waitx.yaml"
            ]
          },
          "TASKWAIT": {
            "method": "TASKWAIT",
            "type": "method",
            "description": "Wait for specific condition with task yielding\n",
            "category": "Task Operations",
            "syntax": "TASKWAIT(Condition)",
            "parameters": [
              {
                "name": "Condition",
                "type": "expression",
                "description": "Boolean condition to wait for"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for flag\nTASKWAIT(ready_flag == TRUE)\n' Flag is now true\n",
                "description": "Wait for flag to be set"
              },
              {
                "code": "' Wait for buffer space\nTASKWAIT(buffer_count < MAX_SIZE)\n' Can now add to buffer\n",
                "description": "Wait for buffer availability"
              },
              {
                "code": "' Wait for multiple conditions\nTASKWAIT(data_ready AND not busy_flag)\n' Both conditions met\n",
                "description": "Wait for complex condition"
              }
            ],
            "notes": [
              "Yields to other tasks while waiting",
              "More efficient than busy waiting",
              "Condition checked between yields",
              "Returns when condition becomes true",
              "Prevents CPU hogging during waits",
              "Part of cooperative multitasking"
            ],
            "timing": {
              "description": "Depends on condition",
              "cycles": "Variable - yields while waiting"
            },
            "related": [
              "TASKNEXT",
              "WAITCT",
              "POLLCT"
            ],
            "see_also": [
              "Conditional waiting",
              "Task synchronization",
              "Efficient polling"
            ]
          },
          "QLOG": {
            "method": "QLOG",
            "type": "method",
            "description": "Calculate natural logarithm using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := QLOG(Value)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Input value (unsigned 32-bit)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Natural logarithm in 5.27 fixed-point format"
            },
            "examples": [
              {
                "code": "' Calculate natural log\nln_value := QLOG($1000_0000)  ' ln(0.0625)\n' Result in 5.27 fixed-point format\n",
                "description": "Basic logarithm calculation"
              },
              {
                "code": "' Calculate log base 10\nlog10_value := QLOG(value) * 39457 >> 17  ' Convert ln to log10\n",
                "description": "Convert natural log to log base 10"
              },
              {
                "code": "' Audio decibel calculation\ndb := QLOG(amplitude) * 1717 >> 12  ' 20*log10(amplitude)\n",
                "description": "Calculate decibels from amplitude"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Input range: 0.0625 to 2.0 (in unsigned 32-bit format)",
              "Result is natural logarithm (base e)",
              "Output in 5.27 fixed-point format",
              "38-clock cycle operation",
              "For values outside range, scale appropriately"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QEXP",
              "MULDIV64"
            ],
            "see_also": [
              "CORDIC operations",
              "Logarithmic functions",
              "Fixed-point math"
            ]
          },
          "STRCOMP": {
            "method": "STRCOMP",
            "type": "method",
            "description": "Compare two null-terminated strings\n",
            "category": "String Operations",
            "syntax": "result := STRCOMP(StringAddress1, StringAddress2)",
            "parameters": [
              {
                "name": "StringAddress1",
                "type": "address",
                "description": "Address of first null-terminated string"
              },
              {
                "name": "StringAddress2",
                "type": "address",
                "description": "Address of second null-terminated string"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if strings match, FALSE (0) if different"
            },
            "examples": [
              {
                "code": "' Compare two strings\nif STRCOMP(@input, STRING(\"hello\"))\n  ' Strings match\n",
                "description": "Basic string comparison"
              },
              {
                "code": "' Command parsing\nif STRCOMP(@command, STRING(\"QUIT\"))\n  quit_program()\nelseif STRCOMP(@command, STRING(\"HELP\"))\n  show_help()\n",
                "description": "Parse command strings"
              },
              {
                "code": "' Password check\nif STRCOMP(@entered_pass, @stored_pass)\n  ' Grant access\n  access_granted := TRUE\n",
                "description": "Validate password"
              }
            ],
            "notes": [
              "Case-sensitive comparison",
              "Stops at first null terminator (0)",
              "Returns TRUE (-1) for exact match",
              "Returns FALSE (0) for any difference",
              "Both strings must be null-terminated",
              "No length limit except available memory"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (2 per character) clock cycles"
            },
            "related": [
              "STRCOPY",
              "STRSIZE",
              "STRING",
              "BYTECOMP"
            ],
            "see_also": [
              "String operations",
              "String comparison",
              "Null-terminated strings"
            ]
          },
          "HUBSET": {
            "method": "HUBSET",
            "type": "method",
            "description": "Execute HUBSET instruction for low-level hub configuration\n",
            "category": "Miscellaneous",
            "syntax": "HUBSET(Value)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "32-bit configuration value for hub"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Enable debug output\nHUBSET($F0)  ' Enable debug pins\n",
                "description": "Configure debug pins"
              },
              {
                "code": "' Set clock mode bits\nHUBSET(clkmode_bits)\n",
                "description": "Direct clock configuration"
              },
              {
                "code": "' Reset specific hub feature\nHUBSET(config & !$100)  ' Clear bit 8\n",
                "description": "Modify hub configuration"
              }
            ],
            "notes": [
              "Low-level hub configuration",
              "Directly executes HUBSET instruction",
              "Affects global chip configuration",
              "Use CLKSET for safe clock changes",
              "Requires understanding of hub config bits",
              "Can affect all cogs",
              "Use with caution"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "CLKSET",
              "COGSTOP",
              "COGINIT"
            ],
            "see_also": [
              "Hub configuration",
              "Low-level control",
              "System configuration"
            ]
          },
          "SIZEOF": {
            "method": "SIZEOF",
            "type": "method",
            "description": "Get size of structure or data type in bytes\n",
            "category": "Miscellaneous",
            "syntax": "size := SIZEOF(Structure)",
            "parameters": [
              {
                "name": "Structure",
                "type": "structure_name",
                "description": "Name of structure defined in CON section"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "Size in bytes of the structure"
            },
            "examples": [
              {
                "code": "CON\n  ' Define structure\n  POINT = LONG[2]  ' X, Y coordinates\n\nPUB main()\n  size := SIZEOF(POINT)  ' Returns 8 (2 longs * 4 bytes)\n",
                "description": "Get structure size"
              },
              {
                "code": "CON\n  ' Complex structure\n  HEADER = LONG + WORD[4] + BYTE[16]\n\nVAR\n  BYTE buffer[SIZEOF(HEADER)]\n",
                "description": "Allocate buffer for structure"
              },
              {
                "code": "CON\n  ' Nested structures\n  VECTOR3 = LONG[3]\n  MATRIX3 = VECTOR3[3]\n\nPUB get_size()\n  return SIZEOF(MATRIX3)  ' Returns 36 (9 longs * 4)\n",
                "description": "Size of nested structure"
              }
            ],
            "notes": [
              "Structures defined in CON section",
              "Returns total byte count",
              "Accounts for data type sizes (BYTE=1, WORD=2, LONG=4)",
              "Useful for buffer allocation",
              "Compile-time evaluation",
              "Works with arrays and nested structures"
            ],
            "timing": {
              "description": "Compile-time constant",
              "cycles": "N/A - resolved at compile time"
            },
            "related": [
              "BYTE",
              "WORD",
              "LONG"
            ],
            "see_also": [
              "Structure definitions",
              "CON section",
              "Memory allocation"
            ]
          },
          "LOCKRET": {
            "method": "LOCKRET",
            "type": "method",
            "description": "Return allocated lock to available pool\n",
            "category": "Lock Operations",
            "syntax": "LOCKRET(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to return (0..15)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Return lock when done\nLOCKRET(lock_id)\n",
                "description": "Free a lock"
              },
              {
                "code": "' Cleanup in stop method\nPUB stop()\n  if lock_id >= 0\n    LOCKRET(lock_id)\n    lock_id := -1\n",
                "description": "Clean shutdown with lock release"
              },
              {
                "code": "' Return multiple locks\nrepeat i from 0 to num_locks-1\n  LOCKRET(locks[i])\n",
                "description": "Free multiple locks"
              }
            ],
            "notes": [
              "Returns lock to available pool",
              "Lock must have been allocated with LOCKNEW",
              "Automatically releases lock if captured",
              "Safe to call even if lock not captured",
              "Important to return locks to prevent exhaustion",
              "No error if invalid lock ID"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKNEW",
              "LOCKTRY",
              "LOCKREL",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Resource cleanup",
              "Lock management"
            ]
          },
          "TASKID": {
            "method": "TASKID",
            "type": "method",
            "description": "Get the current task's ID\n",
            "category": "Task Operations",
            "syntax": "id := TASKID()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Current task ID (0-31)"
            },
            "examples": [
              {
                "code": "' Get current task ID\nmy_id := TASKID()\ndebug(\"Running as task \", udec(my_id))\n",
                "description": "Display current task ID"
              },
              {
                "code": "' Task-specific behavior\ncase TASKID()\n  0: main_task_work()\n  1: worker1_work()\n  2: worker2_work()\n",
                "description": "Task-specific execution"
              },
              {
                "code": "' Store task ID for later\nVAR\n  LONG task_ids[32]\n\ntask_ids[TASKID()] := GETCT()  ' Store start time\n",
                "description": "Track task timing"
              }
            ],
            "notes": [
              "Returns ID of currently executing task",
              "Main task is typically ID 0",
              "Useful for task-specific storage/behavior",
              "Each task has unique ID 0-31",
              "ID remains constant for task lifetime"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKCHK",
              "TASKSPIN",
              "COGID"
            ],
            "see_also": [
              "Task identification",
              "Task management",
              "Task-local storage"
            ]
          },
          "LOCKCHK": {
            "method": "LOCKCHK",
            "type": "method",
            "description": "Check lock state and ownership without affecting it\n",
            "category": "Lock Operations",
            "syntax": "state := LOCKCHK(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to check (0..15)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Lock state: bit 31 = captured flag, bits 3:0 = owner cog ID"
            },
            "examples": [
              {
                "code": "' Check if lock is free\nstate := LOCKCHK(lock_id)\nif state < 0  ' Bit 31 set\n  ' Lock is captured\n  owner := state & $F  ' Get owner cog\n",
                "description": "Check lock availability"
              },
              {
                "code": "' Verify we own the lock\nstate := LOCKCHK(lock_id)\nif (state & $F) == COGID()\n  ' We own this lock\n",
                "description": "Verify lock ownership"
              },
              {
                "code": "' Debug lock status\nstate := LOCKCHK(lock_id)\nif state < 0\n  debug(\"Lock captured by cog \", udec(state & $F))\nelse\n  debug(\"Lock is free\")\n",
                "description": "Display lock status"
              }
            ],
            "notes": [
              "Non-destructive read of lock state",
              "Bit 31: 1 = captured, 0 = free",
              "Bits 3:0: Cog ID of owner (if captured)",
              "Does not affect lock state",
              "Useful for debugging and monitoring",
              "Can check any lock without owning it"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKTRY",
              "LOCKREL",
              "LOCKNEW",
              "COGID"
            ],
            "see_also": [
              "Hardware locks",
              "Lock debugging",
              "Lock monitoring"
            ]
          },
          "GETREGS": {
            "method": "GETREGS",
            "type": "method",
            "description": "Copy cog registers to hub RAM\n",
            "category": "Miscellaneous",
            "syntax": "GETREGS(HubAddress, CogAddress, Count)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub RAM destination address"
              },
              {
                "name": "CogAddress",
                "type": "integer",
                "description": "Starting cog register address (0-511)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of longs to copy"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Save cog registers\nVAR\n  LONG saved_regs[16]\n\nGETREGS(@saved_regs, $1F0, 16)  ' Save $1F0-$1FF\n",
                "description": "Save cog register state"
              },
              {
                "code": "' Debug cog registers\nVAR\n  LONG cog_dump[512]\n\nGETREGS(@cog_dump, 0, 512)  ' Dump entire cog\n",
                "description": "Complete cog memory dump"
              },
              {
                "code": "' Read PASM variables\nVAR\n  LONG pasm_vars[10]\n\nGETREGS(@pasm_vars, $100, 10)  ' Get PASM data\n",
                "description": "Read PASM variables from cog"
              }
            ],
            "notes": [
              "Copies from cog RAM to hub RAM",
              "Cog addresses are 0-511 (2KB)",
              "Each register is 32 bits (1 long)",
              "Useful for debugging PASM code",
              "Can read interpreter registers",
              "Count must not exceed remaining registers"
            ],
            "timing": {
              "description": "Hub transfer operation",
              "cycles": "~8 + (count * 2) clock cycles"
            },
            "related": [
              "SETREGS",
              "REGLOAD",
              "REGEXEC"
            ],
            "see_also": [
              "Cog memory access",
              "Register debugging",
              "PASM interaction"
            ]
          },
          "TASKCHK": {
            "method": "TASKCHK",
            "type": "method",
            "description": "Check if a task is running\n",
            "category": "Task Operations",
            "syntax": "result := TASKCHK(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to check (0-31)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if task is running, FALSE (0) if not"
            },
            "examples": [
              {
                "code": "' Check if task is running\nif TASKCHK(5)\n  ' Task 5 is active\n",
                "description": "Check single task status"
              },
              {
                "code": "' Count active tasks\ncount := 0\nrepeat task_id from 0 to 31\n  if TASKCHK(task_id)\n    count++\n",
                "description": "Count running tasks"
              },
              {
                "code": "' Wait for task to finish\nrepeat while TASKCHK(worker_task)\n  TASKNEXT()  ' Yield while waiting\n",
                "description": "Wait for task completion"
              }
            ],
            "notes": [
              "Non-destructive status check",
              "Returns TRUE for running or halted tasks",
              "Returns FALSE for stopped/unused tasks",
              "Useful for task monitoring",
              "Can check any task ID 0-31"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKID",
              "TASKSPIN",
              "TASKSTOP"
            ],
            "see_also": [
              "Task monitoring",
              "Task status",
              "Task management"
            ]
          },
          "TASKSTOP": {
            "method": "TASKSTOP",
            "type": "method",
            "description": "Stop and terminate a running task\n",
            "category": "Task Operations",
            "syntax": "TASKSTOP(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to stop (0-31) or THISTASK (-1) for current"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Stop specific task\nTASKSTOP(2)  ' Stop task ID 2\n",
                "description": "Stop task by ID"
              },
              {
                "code": "' Task stops itself\nPUB background_task()\n  repeat\n    if shutdown_flag\n      TASKSTOP(THISTASK)  ' Stop self\n",
                "description": "Task self-termination"
              },
              {
                "code": "' Stop all tasks except main\nrepeat task_id from 1 to 31\n  if TASKCHK(task_id)\n    TASKSTOP(task_id)\n",
                "description": "Stop all secondary tasks"
              }
            ],
            "notes": [
              "Immediately terminates the task",
              "Task's stack space can be reused",
              "THISTASK (-1) stops current task",
              "Main task (ID 0) typically shouldn't stop",
              "No cleanup - task stops immediately",
              "Task ID becomes available for reuse"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKSPIN",
              "TASKHALT",
              "TASKRESUME",
              "TASKCHK"
            ],
            "see_also": [
              "Task termination",
              "Task management",
              "Resource cleanup"
            ]
          },
          "WORDFILL": {
            "method": "WORDFILL",
            "type": "method",
            "description": "Fill memory with a repeated word value\n",
            "category": "Memory Operations",
            "syntax": "WORDFILL(DestAddress, Value, Count)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Hub RAM starting address to begin filling"
              },
              {
                "name": "Value",
                "type": "word",
                "description": "16-bit word value to fill with"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to fill"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Clear a word array to zero\nWORDFILL(@buffer, 0, 256)\n",
                "description": "Clear 256 words to zero"
              },
              {
                "code": "' Initialize array with pattern\nWORDFILL(@data, $FFFF, 100)\n",
                "description": "Fill 100 words with $FFFF"
              },
              {
                "code": "' Set default values\nWORDFILL(@settings, $1234, 50)\n",
                "description": "Initialize settings array with default value"
              }
            ],
            "notes": [
              "Fills memory efficiently using hub operations",
              "Each word is 2 bytes (16 bits)",
              "Address should be word-aligned for best performance",
              "Count of 0 fills no memory",
              "Only lower 16 bits of Value are used"
            ],
            "timing": {
              "description": "Varies based on count and hub timing",
              "cycles": "~8 + count clock cycles typical"
            },
            "related": [
              "BYTEFILL",
              "LONGFILL",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory initialization",
              "Hub RAM operations"
            ]
          },
          "POLLATN": {
            "method": "POLLATN",
            "type": "method",
            "description": "Check for attention signal without blocking\n",
            "category": "COG Management",
            "syntax": "result := POLLATN()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if ATN signal received, FALSE (0) if not"
            },
            "examples": [
              {
                "code": "' Non-blocking check for signal\nif POLLATN()\n  ' ATN signal received\n  process_signal()\n",
                "description": "Check for signal without blocking"
              },
              {
                "code": "' Main loop with signal handling\nrepeat\n  do_main_work()\n  if POLLATN()\n    handle_interrupt()\n",
                "description": "Interruptible main loop"
              },
              {
                "code": "' Timeout waiting for ATN\ntimeout := GETCT() + clkfreq\nrepeat\n  if POLLATN()\n    ' Got signal\n    quit\n  if POLLCT(timeout)\n    ' Timeout - no signal\n    return FALSE\n",
                "description": "ATN wait with timeout"
              }
            ],
            "notes": [
              "Non-blocking alternative to WAITATN",
              "Returns immediately with TRUE/FALSE",
              "Clears ATN flag if it was set",
              "Another cog uses COGATN to send the signal",
              "Useful for cooperative multitasking",
              "Can be used in main loop for interrupt-like behavior"
            ],
            "timing": {
              "description": "Immediate return",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "WAITATN",
              "COGATN",
              "POLLCT"
            ],
            "see_also": [
              "Cog communication",
              "Non-blocking operations",
              "Inter-cog signaling"
            ]
          },
          "XYPOL": {
            "method": "XYPOL",
            "type": "method",
            "description": "Convert Cartesian coordinates to polar using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "Rho, Theta := XYPOL(X, Y)",
            "parameters": [
              {
                "name": "X",
                "type": "long",
                "description": "X coordinate (32-bit signed)"
              },
              {
                "name": "Y",
                "type": "long",
                "description": "Y coordinate (32-bit signed)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns Rho (radius) and Theta (angle)"
            },
            "examples": [
              {
                "code": "' Convert Cartesian to polar\nrho, theta := XYPOL(100, 100)  \n' Result: rho \u2248 141, theta \u2248 $2000_0000 (45\u00b0)\n",
                "description": "Basic Cartesian to polar conversion"
              },
              {
                "code": "' Calculate distance and angle to target\ndx := target_x - current_x\ndy := target_y - current_y\ndistance, angle := XYPOL(dx, dy)\n",
                "description": "Find distance and direction to target"
              },
              {
                "code": "' Convert joystick X,Y to magnitude and direction\nmagnitude, direction := XYPOL(joy_x - 128, joy_y - 128)\nif magnitude > threshold\n  move_player(direction, magnitude)\n",
                "description": "Process joystick input"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Rho (radius) is always positive",
              "Theta covers full 360\u00b0 range based on quadrant",
              "Handles all four quadrants correctly",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "POLXY",
              "ROTXY",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Polar coordinates",
              "Coordinate conversion",
              "Distance calculation"
            ]
          },
          "BYTE": {
            "method": "BYTE",
            "type": "method",
            "description": "Declare byte data or access byte-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: BYTE [Count]\nAccess: BYTE[BaseAddress][Index]\nInline: BYTE(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label BYTE Value1 {, Value2, ...}",
                "description": "Declare byte data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name BYTE [Count]",
                "description": "Declare byte variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "BYTE[Address][Index]",
                "description": "Access byte at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "BYTE(Value1, Value2, ...)",
                "description": "Create inline byte sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_bytes  BYTE  $FF, $00, $55, $AA\n",
                "description": "Declare byte data in DAT section"
              },
              {
                "code": "VAR\n  buffer  BYTE[256]  ' 256-byte array\n",
                "description": "Declare byte array in VAR section"
              },
              {
                "code": "' Write byte to hub memory\nBYTE[$1000] := $42\n\n' Read byte from hub memory  \nvalue := BYTE[$1000]\n",
                "description": "Direct hub memory byte access"
              },
              {
                "code": "' Send byte sequence\nsend(BYTE($48, $65, $6C, $6C, $6F))  ' \"Hello\"\n",
                "description": "Inline byte data creation"
              }
            ],
            "notes": [
              "BYTE is 8 bits (0-255 unsigned, -128 to 127 signed)",
              "Hub memory is byte-addressable",
              "Arrays are zero-indexed",
              "Can use @ operator to get address of byte variable",
              "Alignment is automatic in VAR section"
            ],
            "related": [
              "WORD",
              "LONG",
              "BYTEFILL",
              "BYTEMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "WXPIN": {
            "method": "WXPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the X parameter register of one or more smart pins.\nThe X register typically controls timing, frequency, or configuration parameters.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "syntax": "WXPIN(PinField, XValue)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "XValue",
                "type": "long",
                "description": "32-bit value for X register.\nInterpretation depends on smart pin mode:\n- Timing periods for serial modes\n- Frequency values for NCO modes\n- Configuration bits for special modes\n"
              }
            ],
            "returns": "none",
            "x_register_usage_by_mode": {
              "serial_modes": "Baud rate timing:\nX = (CLKFREQ / baud_rate) - 1\n",
              "pwm_modes": "PWM period:\nX = period_in_clocks - 1\n",
              "nco_modes": "Frequency value:\nX = frequency * (2^32 / CLKFREQ)\n",
              "measurement": "Measurement window:\nX = measurement_period_clocks\n"
            },
            "examples": [
              {
                "code": "' Set UART baud rate to 115200\nbaud := 115200\nx_val := CLKFREQ / baud - 1\nWXPIN(30, x_val)\n",
                "description": "Configure UART baud rate"
              },
              {
                "code": "' Set PWM period to 1000 clocks\nWXPIN(56, 999)  ' 1000 - 1\n",
                "description": "Set PWM period"
              },
              {
                "code": "' Configure 1MHz NCO frequency\nfreq := 1_000_000\nx_val := freq * ($8000_0000 / (CLKFREQ / 2))\nWXPIN(pin, x_val)\n",
                "description": "Set NCO frequency"
              },
              {
                "code": "' Set measurement window to 1 second\nWXPIN(pin, CLKFREQ)\n",
                "description": "Configure measurement period"
              },
              {
                "code": "' Configure 16-bit SPI transfer\nWXPIN(spi_pin, %1_00111)  ' 16 bits, MSB first\n",
                "description": "SPI configuration"
              }
            ],
            "mode_specific_x_values": {
              "P_ASYNC_TX": "Bit period for transmit",
              "P_ASYNC_RX": "Bit period for receive",
              "P_PULSE": "High time period",
              "P_TRANSITION": "Transition period",
              "P_NCO_FREQ": "Frequency value",
              "P_NCO_DUTY": "Base period",
              "P_PWM_TRIANGLE": "Frame period",
              "P_PWM_SAWTOOTH": "Frame period",
              "P_QUADRATURE": "Filter period",
              "P_COUNT_RISES": "Measurement period",
              "P_COUNT_HIGHS": "Measurement period"
            },
            "calculation_examples": {
              "uart_baud": "' Calculate for any baud rate\nPUB set_baud(pin, baud)\n  x := CLKFREQ / baud - 1\n  WXPIN(pin, x)\n  \n",
              "pwm_frequency": "' Set PWM by frequency\nPUB set_pwm_freq(pin, freq)\n  x := CLKFREQ / freq - 1\n  WXPIN(pin, x)\n  \n",
              "measurement_time": "' Set measurement in milliseconds\nPUB set_measure_ms(pin, ms)\n  x := CLKFREQ / 1000 * ms\n  WXPIN(pin, x)\n"
            },
            "common_uses": [
              "Setting baud rates",
              "Configuring PWM periods",
              "Setting NCO frequencies",
              "Defining measurement windows",
              "Protocol timing configuration"
            ],
            "related_methods": [
              "WRPIN - Set smart pin mode",
              "WYPIN - Set Y parameter",
              "RDPIN - Read and acknowledge",
              "RQPIN - Read without acknowledge",
              "PINSTART - Complete setup"
            ],
            "timing_considerations": [
              "X value takes effect on next period",
              "Can be changed while pin is active",
              "Some modes latch X at specific times",
              "Check mode documentation for specifics"
            ],
            "notes": [
              "X register is mode-dependent",
              "Usually represents timing or period",
              "32-bit value allows wide range",
              "Can be updated during operation",
              "Value interpretation varies by mode"
            ],
            "warnings": [
              "Must set correct mode first with WRPIN",
              "Zero may disable some functions",
              "Very small values may not work",
              "Check mode limits in documentation"
            ],
            "see_also": [
              "language/spin2/methods/wrpin.yaml",
              "language/spin2/methods/wypin.yaml",
              "language/spin2/methods/rdpin.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "TASKRESUME": {
            "method": "TASKRESUME",
            "type": "method",
            "description": "Resume a halted task\n",
            "category": "Task Operations",
            "syntax": "TASKRESUME(TaskID)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID to resume (0-31)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Resume paused task\nTASKRESUME(3)  ' Resume task 3\n",
                "description": "Resume single task"
              },
              {
                "code": "' Synchronized resume\nTASKHALT(worker1)\nTASKHALT(worker2)\nprepare_data()\nTASKRESUME(worker1)\nTASKRESUME(worker2)\n",
                "description": "Synchronized task resumption"
              },
              {
                "code": "' Conditional resume\nif not buffer_full\n  TASKRESUME(producer_task)\n",
                "description": "Resume producer when buffer has space"
              }
            ],
            "notes": [
              "Resumes task halted with TASKHALT",
              "Task continues from where it was halted",
              "All state preserved during halt",
              "No effect if task not halted",
              "Also called TASKCONT in some docs",
              "Part of cooperative multitasking"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "TASKHALT",
              "TASKSPIN",
              "TASKSTOP",
              "TASKCHK"
            ],
            "see_also": [
              "Task synchronization",
              "Task resumption",
              "Cooperative multitasking"
            ]
          },
          "PINWRITE": {
            "method": "PINWRITE",
            "aliases": [
              "PINW"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) with data pattern.\nSets the direction bit(s) to output (DIR=1) and writes the data pattern to the pins (OUT=data).\nWhen multiple pins are specified, the data is written to them in parallel.\nLower bits of data correspond to lower-numbered pins in the field.\n",
            "syntax": "PINWRITE(PinField, Data)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Data",
                "type": "long",
                "description": "Data to write to the pins:\n- For single pin: 0 = low, non-zero = high\n- For multiple pins: Each bit maps to a pin\n- Bit 0 of data \u2192 lowest pin in field\n- Bit n of data \u2192 nth pin in field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINWRITE(56, 1)",
                "description": "Write high to pin 56"
              },
              {
                "code": "PINWRITE(56, 0)",
                "description": "Write low to pin 56"
              },
              {
                "code": "PINWRITE(0 ADDPINS 7, %10101010)",
                "description": "Write alternating pattern to pins 0-7"
              },
              {
                "code": "PINWRITE(7..0, $FF)",
                "description": "Write all high to pins 0-7 (reversed range)"
              },
              {
                "code": "VAR\n  BYTE pattern\nPUB animate()\n  pattern := %00000001\n  REPEAT 8\n    PINWRITE(0 ADDPINS 7, pattern)\n    pattern <<= 1\n    WAITMS(100)\n",
                "description": "Animate a moving bit pattern"
              },
              {
                "code": "' Write 4-bit value to pins 12-15\nvalue := 9  ' Binary 1001\nPINWRITE(12 ADDPINS 3, value)\n' Pin 12 = 1, Pin 13 = 0, Pin 14 = 0, Pin 15 = 1\n",
                "description": "Write multi-bit value to pin group"
              }
            ],
            "underlying_pasm": {
              "instructions": [
                "DIRH/DIRL",
                "OUTH/OUTL"
              ],
              "description": "Sets direction bits and output bits based on data"
            },
            "common_uses": [
              "Parallel data output",
              "LED pattern displays",
              "Bus data transmission",
              "7-segment display control",
              "Setting multiple control lines simultaneously",
              "Binary counter displays"
            ],
            "related_methods": [
              "PINREAD - Read data from pins",
              "PINHIGH - Drive all specified pins high",
              "PINLOW - Drive all specified pins low",
              "PINTOGGLE - Toggle pin states"
            ],
            "notes": [
              "All specified pins become outputs",
              "Overrides any smart pin modes on the pins",
              "Data is masked to the number of pins in field",
              "Unspecified bits in data are ignored",
              "Atomic operation - all pins change simultaneously",
              "Pin field order matters for multi-pin operations"
            ],
            "see_also": [
              "language/spin2/methods/pinread.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pinlow.yaml"
            ]
          },
          "GETMS": {
            "method": "GETMS",
            "type": "method",
            "description": "Get milliseconds elapsed since system boot\n",
            "category": "Timing Operations",
            "syntax": "ms := GETMS()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Milliseconds since boot (32-bit value)"
            },
            "examples": [
              {
                "code": "' Measure elapsed time\nstart_ms := GETMS()\n' Do some work...\nelapsed := GETMS() - start_ms\ndebug(\"Elapsed: \", udec(elapsed), \" ms\")\n",
                "description": "Measure operation duration"
              },
              {
                "code": "' Simple timeout\ntimeout_ms := GETMS() + 5000  ' 5 second timeout\nrepeat while GETMS() < timeout_ms\n  if check_condition()\n    quit\n",
                "description": "Implement millisecond timeout"
              },
              {
                "code": "' Display uptime\nms := GETMS()\nseconds := ms / 1000\nminutes := seconds / 60\nhours := minutes / 60\ndebug(\"Uptime: \", udec(hours), \":\", udec(minutes//60), \":\", udec(seconds//60))\n",
                "description": "Calculate and display system uptime"
              }
            ],
            "notes": [
              "Based on system counter divided by clkfreq/1000",
              "32-bit value wraps after ~49.7 days",
              "Resolution depends on clock frequency",
              "Less precise than GETCT for short intervals",
              "Good for human-scale timing (UI, timeouts)",
              "Handles clock frequency changes automatically"
            ],
            "timing": {
              "description": "Immediate calculation",
              "cycles": "~20-30 clock cycles"
            },
            "related": [
              "GETSEC",
              "GETCT",
              "WAITMS"
            ],
            "see_also": [
              "Time measurement",
              "System uptime",
              "Millisecond timing"
            ]
          },
          "GETSEC": {
            "method": "GETSEC",
            "type": "method",
            "description": "Get seconds elapsed since system boot\n",
            "category": "Timing Operations",
            "syntax": "seconds := GETSEC()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "Seconds since boot (32-bit value)"
            },
            "examples": [
              {
                "code": "' Display uptime in seconds\ndebug(\"System uptime: \", udec(GETSEC()), \" seconds\")\n",
                "description": "Show system uptime"
              },
              {
                "code": "' Long-running timer\nstart_sec := GETSEC()\n' ... much later ...\nelapsed_sec := GETSEC() - start_sec\ndebug(\"Process ran for \", udec(elapsed_sec), \" seconds\")\n",
                "description": "Measure long durations"
              },
              {
                "code": "' Periodic task every 10 seconds\nnext_run := GETSEC() + 10\nrepeat\n  if GETSEC() >= next_run\n    do_periodic_task()\n    next_run += 10\n",
                "description": "Schedule periodic tasks"
              }
            ],
            "notes": [
              "Based on system counter divided by clkfreq",
              "32-bit value wraps after ~136 years",
              "1-second resolution",
              "Good for long-duration timing",
              "More convenient than GETMS for human-readable times",
              "Handles clock frequency changes automatically"
            ],
            "timing": {
              "description": "Immediate calculation",
              "cycles": "~20-30 clock cycles"
            },
            "related": [
              "GETMS",
              "GETCT",
              "WAITMS"
            ],
            "see_also": [
              "Time measurement",
              "System uptime",
              "Long-duration timing"
            ]
          },
          "BYTECOMP": {
            "method": "BYTECOMP",
            "type": "method",
            "description": "Complement bytes within a long value",
            "category": "Memory Operations",
            "syntax": "result := BYTECOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of bytes to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all bytes match, FALSE (0) if any bytes differ"
            },
            "examples": [
              {
                "code": "' Compare two strings\nif BYTECOMP(@string1, @string2, 10)\n  ' First 10 bytes match\n",
                "description": "Compare fixed-length byte sequences"
              },
              {
                "code": "' Verify buffer contents\nif BYTECOMP(@buffer, @expected, 256)\n  ' Buffer matches expected data\n",
                "description": "Verify buffer against expected values"
              },
              {
                "code": "' Check for pattern\nif BYTECOMP(@data[offset], @pattern, 4)\n  ' Found 4-byte pattern at offset\n",
                "description": "Search for byte pattern in data"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all bytes match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Efficient block comparison operation",
              "Case-sensitive byte-by-byte comparison"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + count clock cycles typical"
            },
            "related": [
              "WORDCOMP",
              "LONGCOMP",
              "STRCOMP",
              "BYTEMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "String operations",
              "Pattern matching"
            ]
          },
          "WYPIN": {
            "method": "WYPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the Y parameter register of one or more smart pins.\nThe Y register typically holds data to transmit, duty cycle values, or count values.\nMeaning depends on the smart pin mode set by WRPIN.\n",
            "syntax": "WYPIN(PinField, YValue)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to write. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "YValue",
                "type": "long",
                "description": "32-bit value for Y register.\nInterpretation depends on smart pin mode:\n- Data byte/word/long for serial modes\n- Duty cycle for PWM modes\n- Count value for pulse modes\n"
              }
            ],
            "returns": "none",
            "y_register_usage_by_mode": {
              "serial_modes": "Data to transmit:\nY[7:0] = byte to send (UART)\nY[15:0] = word to send (sync serial)\nY[31:0] = long to send (32-bit modes)\n",
              "pwm_modes": "Duty cycle value:\nY = high_time (0 to X value)\n",
              "pulse_modes": "Number of pulses/cycles:\nY = pulse count\n",
              "dac_modes": "Output level:\nY[15:0] = 16-bit DAC value\n"
            },
            "examples": [
              {
                "code": "' Send byte via UART\nWYPIN(30, \"A\")  ' Send character 'A'\n",
                "description": "UART transmit character"
              },
              {
                "code": "' Set 50% PWM duty cycle\nperiod := 1000\nWXPIN(56, period - 1)\nWYPIN(56, period / 2)  ' 50% duty\n",
                "description": "Set PWM duty cycle"
              },
              {
                "code": "' Output 10 pulses\nWYPIN(pin, 10)\n",
                "description": "Generate pulse burst"
              },
              {
                "code": "' Set DAC to mid-level\nWYPIN(dac_pin, $8000)  ' 16-bit mid-scale\n",
                "description": "Set DAC output level"
              },
              {
                "code": "' Send 32-bit SPI data\nWYPIN(spi_pin, data_long)\n",
                "description": "SPI data transmission"
              }
            ],
            "mode_specific_y_values": {
              "P_ASYNC_TX": "Byte to transmit (bits 7:0)",
              "P_ASYNC_RX": "Not used for receive",
              "P_PULSE": "Number of pulses",
              "P_TRANSITION": "Number of transitions",
              "P_NCO_FREQ": "Not used",
              "P_NCO_DUTY": "High time value",
              "P_PWM_TRIANGLE": "Duty cycle (0 to X)",
              "P_PWM_SAWTOOTH": "Duty cycle (0 to X)",
              "P_DAC_DITHER": "16-bit DAC value",
              "P_REPOSITORY": "32-bit value to store"
            },
            "data_transmission": {
              "uart_send": "PUB send_byte(pin, data)\n  WYPIN(pin, data)\n  REPEAT UNTIL RDPIN(pin) & $100  ' Wait for completion\n  \n",
              "pwm_update": "PUB set_duty_percent(pin, percent)\n  period := X_VALUE  ' Previously set with WXPIN\n  duty := period * percent / 100\n  WYPIN(pin, duty)\n  \n",
              "burst_output": "PUB send_burst(pin, count)\n  WYPIN(pin, count)\n  ' Pin outputs 'count' pulses\n"
            },
            "common_uses": [
              "Transmitting serial data",
              "Setting PWM duty cycles",
              "Controlling DAC output",
              "Generating pulse counts",
              "Updating output values"
            ],
            "smart_pin_data_flow": {
              "write": "WYPIN writes to Y register",
              "process": "Smart pin uses Y based on mode",
              "status": "Check completion with RDPIN",
              "next": "Write new value to Y for next operation"
            },
            "related_methods": [
              "WRPIN - Set smart pin mode",
              "WXPIN - Set X parameter",
              "RDPIN - Read and acknowledge",
              "RQPIN - Read without acknowledge",
              "AKPIN - Acknowledge smart pin"
            ],
            "notes": [
              "Y register is mode-dependent",
              "Usually represents data or count",
              "Writing Y often triggers operation",
              "Can be updated during operation",
              "Some modes auto-reload from Y"
            ],
            "timing_notes": [
              "Write takes effect based on mode",
              "Serial modes: starts transmission",
              "PWM modes: updates on next cycle",
              "Pulse modes: starts immediately"
            ],
            "warnings": [
              "Must set correct mode first with WRPIN",
              "Writing Y may trigger immediate action",
              "Check if previous operation complete",
              "Some modes have Y value limits"
            ],
            "see_also": [
              "language/spin2/methods/wrpin.yaml",
              "language/spin2/methods/wxpin.yaml",
              "language/spin2/methods/rdpin.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "AKPIN": {
            "method": "AKPIN",
            "type": "method",
            "description": "Acknowledge smart pin by clearing its IN flag\n",
            "category": "Smart Pin Operations",
            "syntax": "AKPIN(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Acknowledge smart pin after processing\nvalue := RQPIN(16)  ' Read without acknowledge\nprocess(value)      ' Process the value\nAKPIN(16)          ' Now acknowledge\n",
                "description": "Separate read and acknowledge operations"
              },
              {
                "code": "' Clear multiple smart pin flags\nrepeat pin from 0 to 7\n  AKPIN(pin)\n",
                "description": "Acknowledge multiple smart pins"
              },
              {
                "code": "' Reset smart pin for next measurement\nif error_condition\n  AKPIN(sensor_pin)  ' Clear flag to restart\n",
                "description": "Clear flag to reset measurement"
              }
            ],
            "notes": [
              "Clears the smart pin's IN flag",
              "Allows smart pin to begin next measurement/operation",
              "Equivalent to the acknowledge part of RDPIN without reading",
              "Useful when you've already read with RQPIN",
              "Can acknowledge multiple pins using pin field ranges",
              "Smart pin must be configured and have IN flag set"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "RDPIN",
              "RQPIN",
              "WRPIN",
              "PINREAD"
            ],
            "see_also": [
              "Smart pin modes",
              "Smart pin acknowledgment",
              "Pin flag management"
            ]
          },
          "WAITCT": {
            "method": "WAITCT",
            "type": "method",
            "description": "Wait until system counter reaches specified tick value\n",
            "category": "Timing Operations",
            "syntax": "WAITCT(Tick)",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Wait for specific time\ntarget := GETCT() + clkfreq/10  ' 100ms from now\nWAITCT(target)\n",
                "description": "Wait for precise timing point"
              },
              {
                "code": "' Create periodic loop\nnext_time := GETCT()\nrepeat\n  next_time += clkfreq/1000  ' 1ms period\n  WAITCT(next_time)\n  ' Do periodic task\n",
                "description": "Precise periodic timing"
              },
              {
                "code": "' Synchronize multiple cogs\nsync_time := GETCT() + clkfreq\nWAITCT(sync_time)  ' All cogs wait for same time\n",
                "description": "Multi-cog synchronization"
              }
            ],
            "notes": [
              "Blocks execution until system counter matches Tick value",
              "System counter wraps every ~53 seconds at 80MHz",
              "More precise than WAITMS/WAITUS for exact timing",
              "Handles counter wraparound correctly",
              "Use GETCT() to read current counter value",
              "Resolution is 1 system clock cycle"
            ],
            "timing": {
              "description": "Waits until exact counter match",
              "cycles": "Variable based on target tick"
            },
            "related": [
              "GETCT",
              "POLLCT",
              "WAITMS",
              "WAITUS"
            ],
            "see_also": [
              "System counter",
              "Precise timing",
              "Synchronization"
            ]
          },
          "QEXP": {
            "method": "QEXP",
            "type": "method",
            "description": "Calculate exponential (e^x) using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := QEXP(Exponent)",
            "parameters": [
              {
                "name": "Exponent",
                "type": "long",
                "description": "Exponent value in 5.27 fixed-point format"
              }
            ],
            "returns": {
              "type": "long",
              "description": "e^x result (unsigned 32-bit)"
            },
            "examples": [
              {
                "code": "' Calculate e^1\nresult := QEXP($0800_0000)  ' e^1 in 5.27 format\n' Result \u2248 2.71828...\n",
                "description": "Basic exponential calculation"
              },
              {
                "code": "' Calculate power of 10\npower10 := QEXP(x * 22713 >> 13)  ' 10^x using e^(x*ln(10))\n",
                "description": "Calculate powers of 10"
              },
              {
                "code": "' Exponential growth/decay\nvalue := initial * QEXP(rate * time >> 10) >> 22\n",
                "description": "Model exponential growth"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Input in 5.27 fixed-point format",
              "Input range: -2.77 to 0.69 (in 5.27 format)",
              "Result is e^exponent",
              "Output range: 0.0625 to 2.0",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QLOG",
              "MULDIV64"
            ],
            "see_also": [
              "CORDIC operations",
              "Exponential functions",
              "Fixed-point math"
            ]
          },
          "STRING": {
            "method": "STRING",
            "type": "method",
            "description": "Create string constant and return its address\n",
            "category": "String Operations",
            "syntax": "address := STRING(StringLiteral)",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of null-terminated string"
            },
            "examples": [
              {
                "code": "' Get address of string constant\nmsg_addr := STRING(\"Hello, World!\")\n",
                "description": "Create string constant"
              },
              {
                "code": "' Pass string to method\nsend_message(STRING(\"Error: File not found\"))\n",
                "description": "Pass string directly to method"
              },
              {
                "code": "' Use in comparison\nif STRCOMP(@input, STRING(\"YES\"))\n  proceed()\n",
                "description": "Compare with string constant"
              },
              {
                "code": "' Build menu options\noption1 := STRING(\"1. Start\")\noption2 := STRING(\"2. Settings\")\noption3 := STRING(\"3. Quit\")\n",
                "description": "Create menu strings"
              }
            ],
            "notes": [
              "Creates null-terminated string in hub RAM",
              "String is stored in DAT section",
              "Returns starting address of string",
              "Automatically adds null terminator",
              "Escape sequences supported (\\n, \\t, etc.)",
              "Multiple identical strings may share storage",
              "Read-only string constant"
            ],
            "timing": {
              "description": "Immediate - compile time",
              "cycles": "2-9 clock cycles to load address"
            },
            "related": [
              "LSTRING",
              "STRCOMP",
              "STRCOPY",
              "BYTE"
            ],
            "see_also": [
              "String constants",
              "String operations",
              "DAT section"
            ]
          },
          "PINREAD": {
            "method": "PINREAD",
            "aliases": [
              "PINR"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Read the current state of specified pin(s).\nReads the input register (IN) for the specified pins regardless of their direction.\nReturns the pin states as a value where each bit represents a pin's state.\nFor single pin: returns 0 or 1. For multiple pins: returns multi-bit value.\n",
            "syntax": "PINREAD(PinField) : PinStates",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to read. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": {
              "name": "PinStates",
              "type": "long",
              "description": "Current state of the pin(s):\n- Single pin: 0 (low) or 1 (high)\n- Multiple pins: Each bit represents a pin\n- Bit 0 = lowest numbered pin in field\n- Bit n = nth pin in field\n"
            },
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "IF PINREAD(0)\n  ' Pin 0 is high\nELSE\n  ' Pin 0 is low\n",
                "description": "Read single pin as boolean"
              },
              {
                "code": "buttons := PINREAD(0 ADDPINS 7)",
                "description": "Read 8 buttons into a byte"
              },
              {
                "code": "' Read 4-bit DIP switch\nsetting := PINREAD(12 ADDPINS 3)\n' Returns 0-15 based on switch positions\n",
                "description": "Read multi-bit value from pins"
              },
              {
                "code": "' Wait for button press (active high)\nREPEAT UNTIL PINREAD(8)\n' Button is now pressed\n",
                "description": "Poll for pin state change"
              },
              {
                "code": "' Read and decode 3-bit address\naddress := PINREAD(5..3)\nCASE address\n  0: handle_device_0()\n  1: handle_device_1()\n  2..7: handle_others()\n",
                "description": "Read and decode pin pattern"
              }
            ],
            "underlying_pasm": {
              "instruction": "TESTP",
              "description": "Internally uses TESTP or direct IN register read"
            },
            "common_uses": [
              "Read button and switch states",
              "Monitor sensor outputs",
              "Read parallel data input",
              "Check communication line states",
              "Decode address or selection pins",
              "Poll for signal changes"
            ],
            "related_methods": [
              "PINWRITE - Write data to pins",
              "PINFLOAT - Set pins to input mode",
              "AKPIN - Acknowledge smart pin",
              "RDPIN - Read smart pin result"
            ],
            "notes": [
              "Works regardless of pin direction (input or output)",
              "When reading output pins, returns the driven state",
              "Does not affect pin configuration",
              "Can read pins configured as smart pins",
              "Atomic read - all pins sampled simultaneously",
              "No debouncing - returns instantaneous state"
            ],
            "see_also": [
              "language/pasm2/testp.yaml",
              "language/spin2/methods/pinwrite.yaml",
              "language/spin2/methods/pinfloat.yaml",
              "language/spin2/methods/rdpin.yaml"
            ]
          },
          "BYTESWAP": {
            "method": "BYTESWAP",
            "type": "method",
            "description": "Swap byte values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "BYTESWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing byte to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing byte to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two byte values\nBYTESWAP(@value1, @value2)\n",
                "description": "Exchange byte values between variables"
              },
              {
                "code": "' Reverse byte order in array\nrepeat i from 0 to size/2-1\n  BYTESWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using byte swapping"
              },
              {
                "code": "' Swap bytes at specific hub addresses\nBYTESWAP($1000, $2000)\n",
                "description": "Exchange bytes at hub memory locations"
              }
            ],
            "notes": [
              "Atomically exchanges the byte values",
              "Both addresses must be valid hub RAM locations",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "WORDSWAP",
              "LONGSWAP",
              "BYTEMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation"
            ]
          },
          "RECV": {
            "method": "RECV",
            "type": "method",
            "description": "Receive data byte using configured input method\n",
            "category": "Miscellaneous",
            "syntax": "byte := RECV()",
            "parameters": [],
            "returns": {
              "type": "byte",
              "description": "Received byte value (0-255)"
            },
            "examples": [
              {
                "code": "' Receive single byte\nchar := RECV()\n",
                "description": "Receive one byte"
              },
              {
                "code": "' Build string from input\nrepeat i from 0 to 79\n  buffer[i] := RECV()\n  if buffer[i] == 13  ' Enter key\n    buffer[i] := 0\n    quit\n",
                "description": "Receive string until Enter"
              },
              {
                "code": "' Echo received data\nrepeat\n  byte_in := RECV()\n  SEND(byte_in)\n",
                "description": "Echo loop"
              },
              {
                "code": "' Wait for specific character\nrepeat until RECV() == \"!\"\n' Got start character\n",
                "description": "Wait for start marker"
              }
            ],
            "notes": [
              "Input method must be configured first",
              "Typically used with serial drivers",
              "Blocking operation - waits for byte",
              "Returns single byte (0-255)",
              "Works with user-defined input methods",
              "Common for user input and data reception"
            ],
            "timing": {
              "description": "Depends on input method",
              "cycles": "Variable - blocks until data available"
            },
            "related": [
              "SEND",
              "DEBUG"
            ],
            "see_also": [
              "Serial communication",
              "User input",
              "Data reception"
            ]
          },
          "WORD": {
            "method": "WORD",
            "type": "method",
            "description": "Declare word data or access word-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: WORD [Count]\nAccess: WORD[BaseAddress][Index]\nInline: WORD(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label WORD Value1 {, Value2, ...}",
                "description": "Declare word data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name WORD [Count]",
                "description": "Declare word variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "WORD[Address][Index]",
                "description": "Access word at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "WORD(Value1, Value2, ...)",
                "description": "Create inline word sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_words  WORD  $1234, $5678, $ABCD\n",
                "description": "Declare word data in DAT section"
              },
              {
                "code": "VAR\n  samples  WORD[1024]  ' 1024-word array\n",
                "description": "Declare word array in VAR section"
              },
              {
                "code": "' Write word to hub memory\nWORD[$2000] := $1234\n\n' Read word from hub memory  \nvalue := WORD[$2000]\n",
                "description": "Direct hub memory word access"
              },
              {
                "code": "' Process word sequence\nprocess(WORD($1000, $2000, $3000))\n",
                "description": "Inline word data creation"
              }
            ],
            "notes": [
              "WORD is 16 bits (0-65535 unsigned, -32768 to 32767 signed)",
              "Word addresses must be word-aligned (even addresses)",
              "Arrays are zero-indexed",
              "Each array index represents 2 bytes in memory",
              "Can use @ operator to get address of word variable"
            ],
            "related": [
              "BYTE",
              "LONG",
              "WORDFILL",
              "WORDMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "TASKSPIN": {
            "method": "TASKSPIN",
            "type": "method",
            "description": "Start a new Spin2 task within the current cog\n",
            "category": "Task Operations",
            "syntax": "TASKSPIN(TaskID, Method({Parameters}), StackAddress)",
            "parameters": [
              {
                "name": "TaskID",
                "type": "integer",
                "description": "Task ID (0-31) or NEWTASK (-1) for next available"
              },
              {
                "name": "Method",
                "type": "method",
                "description": "Spin2 method to run as task with optional parameters"
              },
              {
                "name": "StackAddress",
                "type": "address",
                "description": "Address of stack space for the task"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Start a new task\nVAR\n  LONG task_stack[64]\n\nTASKSPIN(NEWTASK, background_process(), @task_stack)\n",
                "description": "Start background task"
              },
              {
                "code": "' Start specific task ID\nTASKSPIN(2, sensor_monitor(16, 1000), @sensor_stack)\n",
                "description": "Start task with ID 2"
              },
              {
                "code": "' Multiple tasks\nTASKSPIN(NEWTASK, task1(), @stack1)\nTASKSPIN(NEWTASK, task2(), @stack2)\nTASKSPIN(NEWTASK, task3(), @stack3)\n",
                "description": "Start multiple tasks"
              }
            ],
            "notes": [
              "Up to 32 tasks per cog (v47+ feature)",
              "Tasks share cog but have separate stacks",
              "Cooperative multitasking within cog",
              "NEWTASK (-1) auto-assigns next available ID",
              "Stack size depends on task complexity",
              "Tasks run in round-robin fashion"
            ],
            "timing": {
              "description": "Task switching overhead",
              "cycles": "~20-40 clock cycles per switch"
            },
            "related": [
              "TASKSTOP",
              "TASKHALT",
              "TASKRESUME",
              "TASKCHK"
            ],
            "see_also": [
              "Cooperative multitasking",
              "Task management",
              "Stack allocation"
            ]
          },
          "LONG": {
            "method": "LONG",
            "type": "method",
            "description": "Declare long data or access long-sized memory\n",
            "category": "Data Creation",
            "syntax": "Declaration: LONG [Count]\nAccess: LONG[BaseAddress][Index]\nInline: LONG(Value1, Value2, ...)\n",
            "contexts": [
              {
                "name": "DAT section declaration",
                "syntax": "Label LONG Value1 {, Value2, ...}",
                "description": "Declare long data in DAT section"
              },
              {
                "name": "VAR section declaration",
                "syntax": "Name LONG [Count]",
                "description": "Declare long variable(s) in VAR section"
              },
              {
                "name": "Memory access",
                "syntax": "LONG[Address][Index]",
                "description": "Access long at hub memory address"
              },
              {
                "name": "Inline data",
                "syntax": "LONG(Value1, Value2, ...)",
                "description": "Create inline long sequence"
              }
            ],
            "examples": [
              {
                "code": "DAT\n  my_longs  LONG  $12345678, $DEADBEEF, 1_000_000\n",
                "description": "Declare long data in DAT section"
              },
              {
                "code": "VAR\n  results  LONG[512]  ' 512-long array\n",
                "description": "Declare long array in VAR section"
              },
              {
                "code": "' Write long to hub memory\nLONG[$4000] := $12345678\n\n' Read long from hub memory  \nvalue := LONG[$4000]\n",
                "description": "Direct hub memory long access"
              },
              {
                "code": "' Pass long sequence to method\ncalculate(LONG(100_000, 200_000, 300_000))\n",
                "description": "Inline long data creation"
              }
            ],
            "notes": [
              "LONG is 32 bits (full range of P2 native word size)",
              "Long addresses must be long-aligned (addresses divisible by 4)",
              "Arrays are zero-indexed",
              "Each array index represents 4 bytes in memory",
              "Can use @ operator to get address of long variable",
              "Default data type for most P2 operations"
            ],
            "related": [
              "BYTE",
              "WORD",
              "LONGFILL",
              "LONGMOVE"
            ],
            "see_also": [
              "Data types",
              "Memory organization",
              "DAT section",
              "VAR section"
            ]
          },
          "WORDCOMP": {
            "method": "WORDCOMP",
            "type": "method",
            "description": "Complement words within a long value",
            "category": "Memory Operations",
            "syntax": "result := WORDCOMP(Address1, Address2, Count)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address for comparison (word-aligned)"
              },
              {
                "name": "Count",
                "type": "integer",
                "description": "Number of words to compare"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if all words match, FALSE (0) if any words differ"
            },
            "examples": [
              {
                "code": "' Compare two word arrays\nif WORDCOMP(@array1, @array2, 100)\n  ' Arrays match (100 words)\n",
                "description": "Compare word arrays"
              },
              {
                "code": "' Verify sensor data\nif WORDCOMP(@readings, @expected, 64)\n  ' All 64 sensor readings match expected\n",
                "description": "Verify 16-bit sensor data"
              },
              {
                "code": "' Check for word pattern\nif WORDCOMP(@data[i], @signature, 4)\n  ' Found 4-word signature at position i\n",
                "description": "Search for word pattern in data"
              }
            ],
            "notes": [
              "Returns TRUE (-1) if all words match",
              "Returns FALSE (0) on first mismatch",
              "Count of 0 always returns TRUE",
              "Addresses should be word-aligned for best performance",
              "Each word is 16 bits (2 bytes)",
              "Efficient block comparison operation"
            ],
            "timing": {
              "description": "Varies based on count",
              "cycles": "~8 + (count * 2) clock cycles typical"
            },
            "related": [
              "BYTECOMP",
              "LONGCOMP",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory comparison",
              "Array operations",
              "Pattern matching"
            ]
          },
          "COGCHK": {
            "method": "COGCHK",
            "category": "cog_management",
            "type": "method",
            "description": "Check if a specified cog is currently running.\nReturns -1 if the cog is running, or 0 if it's stopped.\nNon-invasive check that doesn't affect the cog's operation.\n",
            "syntax": "COGCHK(CogNum) : Running",
            "parameters": [
              {
                "name": "CogNum",
                "type": "long",
                "description": "Cog number to check (0-7).\nValues outside 0-7 return 0.\n"
              }
            ],
            "returns": {
              "name": "Running",
              "type": "long",
              "description": "- -1 (TRUE): Cog is running\n- 0 (FALSE): Cog is stopped or invalid number\n"
            },
            "timing": {
              "execution": "2-8 clock cycles",
              "non_blocking": "Yes - doesn't wait or stall"
            },
            "examples": [
              {
                "code": "VAR\n  LONG driver_cog\n  \nPUB ensure_driver_running()\n  IF NOT COGCHK(driver_cog)\n    driver_cog := COGINIT(NEWCOG, @driver, 0)\n",
                "description": "Restart driver if not running"
              },
              {
                "code": "PUB wait_for_cog_stop(n)\n  REPEAT WHILE COGCHK(n)\n    WAITMS(10)\n",
                "description": "Wait for cog to stop"
              },
              {
                "code": "PUB count_running_cogs() : count\n  count := 0\n  REPEAT n FROM 0 TO 7\n    IF COGCHK(n)\n      count++\n",
                "description": "Count how many cogs are running"
              },
              {
                "code": "PUB find_free_cog() : cog_num\n  REPEAT cog_num FROM 0 TO 7\n    IF NOT COGCHK(cog_num)\n      RETURN\n  RETURN -1  ' All cogs busy\n",
                "description": "Find first available cog"
              },
              {
                "code": "PUB monitor_cog_health()\n  REPEAT\n    IF NOT COGCHK(critical_cog)\n      ' Critical cog crashed!\n      handle_error()\n      restart_critical_cog()\n    WAITMS(100)\n",
                "description": "Monitor critical cog health"
              }
            ],
            "common_uses": [
              "Health monitoring",
              "Resource availability checking",
              "Graceful shutdown verification",
              "Startup synchronization",
              "Error detection",
              "Dynamic cog allocation"
            ],
            "return_value_usage": {
              "as_boolean": "IF COGCHK(n)      ' If running\nIF NOT COGCHK(n)  ' If stopped\n",
              "in_expressions": "running_count += COGCHK(n) & 1\nstatus := COGCHK(n) ? \"Running\" : \"Stopped\"\n"
            },
            "related_methods": [
              "COGID - Get current cog ID",
              "COGSTOP - Stop a cog",
              "COGINIT - Start PASM in a cog",
              "COGSPIN - Start Spin2 in a cog"
            ],
            "notes": [
              "Non-invasive - doesn't affect checked cog",
              "Can check current cog (always returns -1)",
              "Invalid cog numbers return 0 (stopped)",
              "Cannot determine what cog is running",
              "Just checks running/stopped state"
            ],
            "best_practices": [
              "Check before stopping to avoid unnecessary operations",
              "Verify startup success after COGINIT/COGSPIN",
              "Monitor critical cogs periodically",
              "Use for graceful shutdown sequences"
            ],
            "typical_patterns": [
              {
                "pattern": "Safe cog stop",
                "code": "IF COGCHK(n)\n  COGSTOP(n)\n"
              },
              {
                "pattern": "Wait for startup",
                "code": "cog := COGINIT(NEWCOG, @code, 0)\nREPEAT UNTIL COGCHK(cog)\n"
              },
              {
                "pattern": "Restart on failure",
                "code": "IF NOT COGCHK(driver_cog)\n  driver_cog := restart_driver()\n"
              }
            ],
            "see_also": [
              "language/spin2/methods/cogid.yaml",
              "language/spin2/methods/cogstop.yaml",
              "language/spin2/methods/coginit.yaml"
            ]
          },
          "LOOKDOWN": {
            "method": "LOOKDOWN",
            "type": "method",
            "description": "Find 1-based index of value in list\n",
            "category": "Lookup Operations",
            "syntax": "index := LOOKDOWN(Value : Match1, Match2, ..., MatchN)",
            "parameters": [
              {
                "name": "Value",
                "type": "long",
                "description": "Value to search for"
              },
              {
                "name": "Matches",
                "type": "list",
                "description": "Comma-separated list of values or ranges to match"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "1-based index of match, or 0 if not found"
            },
            "examples": [
              {
                "code": "' Find value position\npos := LOOKDOWN(30 : 10, 20, 30, 40, 50)\n' Returns 3 (30 is 3rd item)\n",
                "description": "Find value in list"
              },
              {
                "code": "' Character classification\ntype := LOOKDOWN(char : \"A\"..\"Z\", \"a\"..\"z\", \"0\"..\"9\")\n' Returns 1 for uppercase, 2 for lowercase, 3 for digit\n",
                "description": "Classify character type"
              },
              {
                "code": "' Command parsing\ncmd := LOOKDOWN(value : $01, $02, $04, $08, $10)\ncase cmd\n  1: handle_read()\n  2: handle_write()\n  3: handle_status()\n",
                "description": "Map value to command index"
              }
            ],
            "notes": [
              "Returns 1-based index (1 = first match)",
              "Returns 0 if value not found",
              "Supports ranges with .. operator",
              "Searches left to right, returns first match",
              "Inverse operation of LOOKUP",
              "Useful for classification and mapping"
            ],
            "related": [
              "LOOKDOWNZ",
              "LOOKUP",
              "LOOKUPZ"
            ],
            "see_also": [
              "Value searching",
              "Classification",
              "Reverse lookup"
            ]
          },
          "LONGMOVE": {
            "method": "LONGMOVE",
            "category": "memory_operations",
            "type": "method",
            "description": "Copy a specified number of longs (32-bit values) from source to destination in hub RAM.\nHandles overlapping regions correctly with automatic direction detection.\nMore efficient than BYTEMOVE for long-aligned data.\n",
            "syntax": "LONGMOVE(Destination, Source, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Source",
                "type": "address",
                "description": "Hub RAM source address.\nShould be long-aligned for best performance.\nMisalignment handled but slower.\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of longs to copy (not bytes).\nEach long is 4 bytes.\nCan be 0 (no operation).\n"
              }
            ],
            "returns": "none",
            "timing": {
              "aligned": "~8 + (count * 4) clock cycles",
              "misaligned": "Additional overhead for alignment",
              "optimization": "Uses 32-bit transfers when possible"
            },
            "examples": [
              {
                "code": "VAR\n  LONG data[100]\n  LONG backup[100]\n  \nPUB save_data()\n  LONGMOVE(@backup, @data, 100)\n",
                "description": "Backup array of longs"
              },
              {
                "code": "' Copy cog parameters\nDAT\n  params    LONG  0[8]\n  \nPUB setup_cog_params(src_params)\n  LONGMOVE(@params, src_params, 8)\n  COGINIT(NEWCOG, @cog_code, @params)\n",
                "description": "Copy parameter block for cog"
              },
              {
                "code": "' Shift array elements\nVAR\n  LONG array[50]\n  \nPUB remove_first()\n  result := array[0]\n  LONGMOVE(@array[0], @array[1], 49)\n  array[49] := 0\n",
                "description": "Remove first element, shift rest"
              },
              {
                "code": "' Copy structure\nVAR\n  LONG config[10]\n  LONG default_config[10]\n  \nPUB reset_config()\n  LONGMOVE(@config, @default_config, 10)\n",
                "description": "Reset configuration to defaults"
              },
              {
                "code": "' Stack manipulation\nVAR\n  LONG stack[64]\n  LONG stack_backup[64]\n  \nPUB save_stack_state()\n  LONGMOVE(@stack_backup, @stack, 64)\n",
                "description": "Save stack for debugging"
              }
            ],
            "common_uses": [
              "Array copying",
              "Parameter block transfer",
              "Structure copying",
              "Stack operations",
              "Buffer management",
              "Data structure initialization"
            ],
            "performance_benefits": {
              "vs_bytemove": "' BYTEMOVE for 100 longs (400 bytes)\nBYTEMOVE(@dest, @source, 400)  ' ~808 cycles\n\n' LONGMOVE for 100 longs\nLONGMOVE(@dest, @source, 100)  ' ~408 cycles\n' Nearly 2x faster for aligned data\n"
            },
            "alignment_impact": {
              "aligned": "Fastest - direct 32-bit transfers",
              "misaligned": "Works but requires byte-by-byte for edges",
              "recommendation": "Always align long data on 4-byte boundaries"
            },
            "related_methods": [
              "BYTEMOVE - Copy bytes",
              "WORDMOVE - Copy words",
              "LONGFILL - Fill with long value",
              "LONGCOMP - Compare longs",
              "LONGSWAP - Swap long regions"
            ],
            "notes": [
              "Count is in longs, not bytes",
              "Safe for overlapping regions",
              "Direction chosen automatically",
              "Alignment affects performance only",
              "Works with any hub RAM location"
            ],
            "conversion_note": "Bytes to longs: divide by 4\n100 bytes = 25 longs\nBYTEMOVE(@dest, @src, 100) equals\nLONGMOVE(@dest, @src, 25)\n",
            "warnings": [
              "Count is LONGS not BYTES",
              "Ensure destination has enough space",
              "Misalignment degrades performance",
              "Cannot copy to/from cog or LUT RAM directly"
            ],
            "see_also": [
              "language/spin2/methods/bytemove.yaml",
              "language/spin2/methods/wordmove.yaml",
              "language/spin2/methods/longfill.yaml"
            ]
          },
          "WORDSWAP": {
            "method": "WORDSWAP",
            "type": "method",
            "description": "Swap word values between two memory locations\n",
            "category": "Memory Operations",
            "syntax": "WORDSWAP(Address1, Address2)",
            "parameters": [
              {
                "name": "Address1",
                "type": "address",
                "description": "First hub RAM address containing word to swap"
              },
              {
                "name": "Address2",
                "type": "address",
                "description": "Second hub RAM address containing word to swap"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Swap two word values\nWORDSWAP(@value1, @value2)\n",
                "description": "Exchange word values between variables"
              },
              {
                "code": "' Reverse word order in array\nrepeat i from 0 to size/2-1\n  WORDSWAP(@array[i], @array[size-1-i])\n",
                "description": "Reverse array using word swapping"
              },
              {
                "code": "' Swap words for endian conversion\nWORDSWAP(@data[0], @data[1])\n",
                "description": "Swap words for byte order conversion"
              }
            ],
            "notes": [
              "Atomically exchanges the 16-bit word values",
              "Both addresses must be word-aligned (even addresses)",
              "No temporary variable needed for swap",
              "Efficient single-operation exchange",
              "Each word is 2 bytes"
            ],
            "timing": {
              "description": "Single hub operation",
              "cycles": "~8-16 clock cycles typical"
            },
            "related": [
              "BYTESWAP",
              "LONGSWAP",
              "WORDMOVE"
            ],
            "see_also": [
              "Memory operations",
              "Data manipulation",
              "Endian conversion"
            ]
          },
          "LSTRING": {
            "method": "LSTRING",
            "type": "method",
            "description": "Create length-prefixed string constant\n",
            "category": "String Operations",
            "syntax": "address := LSTRING(StringLiteral)",
            "parameters": [
              {
                "name": "StringLiteral",
                "type": "string_literal",
                "description": "String literal in quotes"
              }
            ],
            "returns": {
              "type": "address",
              "description": "Hub RAM address of length-prefixed string"
            },
            "examples": [
              {
                "code": "' Create length-prefixed string\nlstr := LSTRING(\"Hello, World!\")\n' First byte contains 13 (length)\n",
                "description": "Create length-prefixed string"
              },
              {
                "code": "' Read length-prefixed string\nlen := BYTE[lstr_addr]\nrepeat i from 1 to len\n  char := BYTE[lstr_addr][i]\n",
                "description": "Process length-prefixed string"
              },
              {
                "code": "' Send length-prefixed string\naddr := LSTRING(\"Command\")\nsend_bytes(addr, BYTE[addr] + 1)  ' Length + data\n",
                "description": "Send with length byte"
              }
            ],
            "notes": [
              "First byte contains string length",
              "String data follows length byte",
              "No null terminator added",
              "Maximum length is 255 characters",
              "Useful for binary protocols",
              "More efficient than null-terminated for known-length strings",
              "Stored in DAT section"
            ],
            "timing": {
              "description": "Immediate - compile time",
              "cycles": "2-9 clock cycles to load address"
            },
            "related": [
              "STRING",
              "BYTE",
              "STRSIZE"
            ],
            "see_also": [
              "Length-prefixed strings",
              "Binary protocols",
              "String formats"
            ]
          },
          "WRPIN": {
            "method": "WRPIN",
            "category": "smart_pin_operations",
            "type": "method",
            "description": "Write the mode configuration register of one or more smart pins.\nSets up the smart pin operating mode, input sources, and output options.\nThis is the primary method for configuring smart pin functionality.\n",
            "syntax": "WRPIN(PinField, Mode)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to configure. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              },
              {
                "name": "Mode",
                "type": "long",
                "description": "32-bit mode configuration value:\n- Bits 31-24: Filter/output options\n- Bits 23-16: Input selector B\n- Bits 15-8: Input selector A\n- Bits 7-6: Low level control\n- Bits 5-0: Smart pin mode (0-63)\n"
              }
            ],
            "returns": "none",
            "mode_register_format": {
              "bits_31_24": "Filter and output options:\n- Bit 31: Enable digital filter\n- Bit 30-28: Filter length\n- Bit 27-26: Output drive options\n",
              "bits_23_16": "Input B selector:\n- Relative pin selection (-3 to +3)\n- Special input sources\n",
              "bits_15_8": "Input A selector:\n- Relative pin selection (-3 to +3)\n- Special input sources\n",
              "bits_5_0": "Smart pin mode (0-63):\n- 00000: OFF (normal I/O)\n- 00001-11111: Various smart modes\n"
            },
            "examples": [
              {
                "code": "' Configure pin for UART TX (async serial)\nmode := %0000_0000_000_0000000000000_01_00111\nWRPIN(30, mode)\n",
                "description": "Setup UART transmit mode"
              },
              {
                "code": "' Configure for PWM output\nmode := %0000_0000_000_0000000000000_01_01001\nWRPIN(56, mode)\n",
                "description": "Setup PWM mode"
              },
              {
                "code": "' Configure quadrature encoder\nmode := %0000_0001_000_0000000000000_00_01011\nWRPIN(0, mode)\n",
                "description": "Setup quadrature decoder"
              },
              {
                "code": "' Configure ADC mode\nmode := %0000_0000_000_0000000000000_11_10011\nWRPIN(pin, mode)\n",
                "description": "Setup ADC conversion mode"
              },
              {
                "code": "' Reset to normal I/O\nWRPIN(pin, 0)\n",
                "description": "Disable smart pin mode"
              }
            ],
            "common_smart_modes": {
              "P_NORMAL": "%00000 - Normal I/O",
              "P_REPOSITORY": "%00001 - Long repository",
              "P_DAC_NOISE": "%00010 - DAC noise",
              "P_DAC_DITHER": "%00011 - DAC with dither",
              "P_PULSE": "%00100 - Pulse/cycle output",
              "P_TRANSITION": "%00101 - Transition output",
              "P_NCO_FREQ": "%00110 - NCO frequency",
              "P_NCO_DUTY": "%00111 - NCO duty",
              "P_PWM_TRIANGLE": "%01000 - PWM triangle",
              "P_PWM_SAWTOOTH": "%01001 - PWM sawtooth",
              "P_ASYNC_TX": "%00111 - Async serial transmit",
              "P_ASYNC_RX": "%01000 - Async serial receive",
              "P_QUADRATURE": "%01011 - Quadrature decode"
            },
            "smart_pin_workflow": {
              "1_configure": "WRPIN(pin, mode) - Set mode",
              "2_set_x": "WXPIN(pin, x_value) - Set timing/config",
              "3_set_y": "WYPIN(pin, y_value) - Set data/count",
              "4_enable": "DIRH(pin) - Enable smart pin",
              "5_operate": "Use RDPIN/RQPIN to read results"
            },
            "common_uses": [
              "UART serial communication",
              "PWM generation",
              "Frequency synthesis",
              "Quadrature encoder reading",
              "ADC/DAC operations",
              "Pulse measurement",
              "Protocol generation"
            ],
            "related_methods": [
              "WXPIN - Set X parameter",
              "WYPIN - Set Y parameter",
              "RDPIN - Read and acknowledge pin",
              "RQPIN - Read without acknowledge",
              "AKPIN - Acknowledge smart pin",
              "PINSTART - Complete pin setup",
              "PINCLEAR - Clear smart pin mode"
            ],
            "notes": [
              "Pin direction must be set after WRPIN",
              "Mode change takes effect immediately",
              "Mode 0 returns pin to normal I/O",
              "Some modes require X and Y configuration",
              "Smart pins operate independently of cog"
            ],
            "mode_persistence": [
              "Mode remains until changed or cog stopped",
              "Survives DIR changes",
              "Not affected by OUT changes",
              "Cleared by PINCLEAR or mode 0"
            ],
            "warnings": [
              "Configure mode before setting DIR",
              "Some modes conflict with normal I/O",
              "Mode bits must be valid for hardware",
              "Incorrect mode can damage external circuits"
            ],
            "see_also": [
              "language/spin2/methods/wxpin.yaml",
              "language/spin2/methods/wypin.yaml",
              "language/spin2/methods/pinstart.yaml",
              "architecture/smart-pins/*.yaml"
            ]
          },
          "REGEXEC": {
            "method": "REGEXEC",
            "type": "method",
            "description": "Load and execute PASM2 code from hub RAM\n",
            "category": "Miscellaneous",
            "syntax": "result := REGEXEC(HubAddress)",
            "parameters": [
              {
                "name": "HubAddress",
                "type": "address",
                "description": "Hub address of PASM2 code to load and execute"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value returned in result1 register"
            },
            "examples": [
              {
                "code": "' Execute PASM from hub\nresult := REGEXEC(@hub_pasm_code)\n\nDAT\nhub_pasm_code\n  ' PASM code here\n  mov result1, #123\n  ret\n",
                "description": "Execute hub-based PASM code"
              },
              {
                "code": "' Dynamic code execution\nbuild_pasm_code(@buffer)  ' Generate code\nresult := REGEXEC(@buffer)  ' Execute it\n",
                "description": "Execute dynamically generated code"
              },
              {
                "code": "' Large PASM routine\nresult := REGEXEC(@big_routine)\n\nDAT\nbig_routine\n  ' Can be > 512 longs\n  ' Loaded and executed in chunks\n",
                "description": "Execute large PASM routine"
              }
            ],
            "notes": [
              "Loads PASM from hub to cog then executes",
              "Can execute code larger than cog RAM",
              "Preserves Spin2 interpreter",
              "Result in result1 register",
              "PASM must end with RET",
              "Parameters via PTRA/PTRB",
              "More flexible than CALL"
            ],
            "timing": {
              "description": "Load time + execution time",
              "cycles": "Variable based on code size"
            },
            "related": [
              "CALL",
              "REGLOAD",
              "SETREGS"
            ],
            "see_also": [
              "Dynamic code execution",
              "PASM2 programming",
              "Hub execution"
            ]
          },
          "LOOKUP": {
            "method": "LOOKUP",
            "type": "method",
            "description": "Look up value in table using 1-based indexing",
            "category": "Lookup Operations",
            "syntax": "result := LOOKUP(Index : Value1, Value2, ..., ValueN)",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "1-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUP(3 : 10, 20, 30, 40, 50)\n' Returns 30 (3rd item)\n",
                "description": "Basic indexed lookup"
              },
              {
                "code": "' Menu selection\naddress := LOOKUP(choice : @option1, @option2, @option3)\n",
                "description": "Select address by menu choice"
              },
              {
                "code": "' Use ranges\nchar := LOOKUP(index : \"A\"..\"Z\", \"0\"..\"9\")\n",
                "description": "Lookup with character ranges"
              }
            ],
            "notes": [
              "Index is 1-based (1 = first item)",
              "Returns 0 if index < 1 or > count",
              "Supports ranges with .. operator",
              "Values evaluated at compile time if possible",
              "Efficient for small lookup tables"
            ],
            "related": [
              "LOOKUPZ",
              "LOOKDOWN",
              "LOOKDOWNZ"
            ],
            "see_also": [
              "Table lookups",
              "Indexed access",
              "Value selection"
            ]
          },
          "PINCLEAR": {
            "method": "PINCLEAR",
            "type": "method",
            "description": "Clear smart pin configuration and disable pin\n",
            "category": "Smart Pin Operations",
            "syntax": "PINCLEAR(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Pin number (0-63) or pin field expression"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Clear single smart pin\nPINCLEAR(16)\n",
                "description": "Reset pin 16 to default state"
              },
              {
                "code": "' Clear range of smart pins\nPINCLEAR(8 ADDPINS 7)  ' Clear pins 8-15\n",
                "description": "Clear multiple contiguous pins"
              },
              {
                "code": "' Reset smart pin before reconfiguration\nPINCLEAR(adc_pin)\nPINSTART(adc_pin, P_ADC, 0, 0)\n",
                "description": "Clear before setting new mode"
              }
            ],
            "notes": [
              "Sets DIR bit to 0 (disables pin output)",
              "Sets WRPIN mode register to 0 (disables smart pin mode)",
              "Resets pin to simple input state",
              "Clears all smart pin configuration",
              "Safe way to stop smart pin operation",
              "Should be called before reconfiguring a smart pin"
            ],
            "operations": [
              "DIR[pin] := 0 (disable output)",
              "WRPIN(pin, 0) (clear mode)"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "4-18 clock cycles"
            },
            "related": [
              "PINSTART",
              "WRPIN",
              "PINFLOAT"
            ],
            "see_also": [
              "Smart pin modes",
              "Pin initialization",
              "Pin state management"
            ]
          },
          "LOCKTRY": {
            "method": "LOCKTRY",
            "type": "method",
            "description": "Attempt to capture a lock without blocking\n",
            "category": "Lock Operations",
            "syntax": "result := LOCKTRY(LockID)",
            "parameters": [
              {
                "name": "LockID",
                "type": "integer",
                "description": "Lock ID to try capturing (0..15)"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if lock captured, FALSE (0) if already taken"
            },
            "examples": [
              {
                "code": "' Try to get lock\nif LOCKTRY(lock_id)\n  ' Got the lock, access resource\n  access_shared_resource()\n  LOCKREL(lock_id)\n",
                "description": "Non-blocking lock attempt"
              },
              {
                "code": "' Wait for lock with timeout\ntimeout := GETCT() + clkfreq  ' 1 second\nrepeat until LOCKTRY(lock_id) or POLLCT(timeout)\nif not LOCKTRY(lock_id)\n  ' Timeout - couldn't get lock\n  abort\n",
                "description": "Lock with timeout"
              },
              {
                "code": "' Blocking lock acquisition\nrepeat until LOCKTRY(lock_id)\n' Critical section\nLOCKREL(lock_id)\n",
                "description": "Wait until lock available"
              }
            ],
            "notes": [
              "Non-blocking operation",
              "Returns immediately with success/failure",
              "If successful, calling cog owns the lock",
              "Must call LOCKREL to release when done",
              "Can be used in polling loop for blocking behavior",
              "Lock must be allocated with LOCKNEW first"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKREL",
              "LOCKNEW",
              "LOCKRET",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Mutual exclusion",
              "Critical sections"
            ]
          },
          "GETRND": {
            "method": "GETRND",
            "type": "method",
            "description": "Get random number from hardware generator",
            "category": "Miscellaneous",
            "syntax": "random := GETRND()",
            "parameters": [],
            "returns": {
              "type": "long",
              "description": "32-bit hardware random number"
            },
            "examples": [
              {
                "code": "' Get random number\nvalue := GETRND()\n",
                "description": "Get 32-bit random value"
              },
              {
                "code": "' Random number in range 0-99\ndice := GETRND() +// 100\n",
                "description": "Random number with modulo"
              },
              {
                "code": "' Random delay\nWAITMS(GETRND() +// 1000)  ' 0-999ms random delay\n",
                "description": "Random timing"
              },
              {
                "code": "' Seed other generators\nseed := GETRND()\ninit_prng(seed)\n",
                "description": "Seed software PRNG"
              }
            ],
            "notes": [
              "Uses P2's hardware random number generator",
              "True random based on thermal noise",
              "Full 32-bit range",
              "No seeding required",
              "Each cog has independent access",
              "Use +// operator for scaled ranges"
            ],
            "timing": {
              "description": "Immediate",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "POLLCT",
              "GETCT"
            ],
            "see_also": [
              "Random number generation",
              "Hardware RNG",
              "Cryptographic operations"
            ]
          },
          "LOOKUPZ": {
            "method": "LOOKUPZ",
            "type": "method",
            "description": "Look up value in table using 0-based indexing",
            "category": "Lookup Operations",
            "syntax": "result := LOOKUPZ(Index : Value0, Value1, ..., ValueN)",
            "parameters": [
              {
                "name": "Index",
                "type": "integer",
                "description": "0-based index into value list"
              },
              {
                "name": "Values",
                "type": "list",
                "description": "Comma-separated list of values or ranges"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Value at index position, or 0 if out of range"
            },
            "examples": [
              {
                "code": "' Get value by index\nvalue := LOOKUPZ(2 : 10, 20, 30, 40, 50)\n' Returns 30 (index 2 = 3rd item)\n",
                "description": "Basic zero-indexed lookup"
              },
              {
                "code": "' Array-style access\nbaud := LOOKUPZ(setting : 9600, 19200, 38400, 57600, 115200)\n",
                "description": "Select baud rate by setting"
              },
              {
                "code": "' Pin mapping table\npin := LOOKUPZ(channel : 16, 17, 18, 19, 24, 25, 26, 27)\n",
                "description": "Map channel to pin number"
              },
              {
                "code": "' Use with ranges\nascii := LOOKUPZ(code : \"0\"..\"9\", \"A\"..\"F\")\n",
                "description": "Hex digit lookup table"
              }
            ],
            "notes": [
              "Index is 0-based (0 = first item)",
              "Returns 0 if index < 0 or >= count",
              "Supports ranges with .. operator",
              "More common than LOOKUP for array-like access",
              "Values evaluated at compile time if possible",
              "Efficient for small lookup tables"
            ],
            "related": [
              "LOOKUP",
              "LOOKDOWN",
              "LOOKDOWNZ"
            ],
            "see_also": [
              "Table lookups",
              "Zero-based indexing",
              "Array simulation"
            ]
          },
          "POLXY": {
            "method": "POLXY",
            "type": "method",
            "description": "Convert polar coordinates to Cartesian using CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "X, Y := POLXY(Rho, Theta)",
            "parameters": [
              {
                "name": "Rho",
                "type": "long",
                "description": "Radius/magnitude (32-bit unsigned)"
              },
              {
                "name": "Theta",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              }
            ],
            "returns": {
              "type": "multiple",
              "description": "Returns X and Y Cartesian coordinates"
            },
            "examples": [
              {
                "code": "' Convert polar to Cartesian\nx, y := POLXY(100, $4000_0000)  ' r=100, \u03b8=90\u00b0\n' Result: x \u2248 0, y \u2248 100\n",
                "description": "Basic polar to Cartesian conversion"
              },
              {
                "code": "' Draw circle using polar coordinates\nradius := 50\nrepeat angle from 0 to $FFFF_FFFF step $0400_0000\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n",
                "description": "Draw circle using polar coordinates"
              },
              {
                "code": "' Create spiral pattern\nangle := 0\nrepeat radius from 10 to 100\n  x, y := POLXY(radius, angle)\n  plot(center_x + x, center_y + y)\n  angle += $0800_0000  ' Increment angle\n",
                "description": "Generate spiral pattern"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0, $C000_0000 = 270\u00b0",
              "Full 32-bit precision maintained",
              "Rho (radius) is unsigned magnitude",
              "Result is scaled by CORDIC K factor (\u22481.647)",
              "38-clock cycle operation"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "XYPOL",
              "ROTXY",
              "QSIN",
              "QCOS"
            ],
            "see_also": [
              "CORDIC operations",
              "Polar coordinates",
              "Coordinate conversion"
            ]
          },
          "BYTEFILL": {
            "method": "BYTEFILL",
            "category": "memory_operations",
            "type": "method",
            "description": "Fill a specified region of hub RAM with a byte value.\nEfficiently sets multiple consecutive bytes to the same value.\nCommonly used for clearing buffers, initializing arrays, and drawing operations.\n",
            "syntax": "BYTEFILL(Destination, Value, Count)",
            "parameters": [
              {
                "name": "Destination",
                "type": "address",
                "description": "Hub RAM destination address.\nStarting address for the fill operation.\nCan be any valid hub address (0-524287).\n"
              },
              {
                "name": "Value",
                "type": "byte",
                "description": "Byte value to fill with (0-255).\nHigher bits are ignored if provided.\nCommon values: 0 (clear), 32 (space), 255 ($FF).\n"
              },
              {
                "name": "Count",
                "type": "long",
                "description": "Number of bytes to fill.\nCan be 0 (no operation).\nMaximum practical limit is available hub RAM.\n"
              }
            ],
            "returns": "none",
            "timing": {
              "small_fill": "~8 + count clock cycles",
              "large_fill": "Optimized for larger regions",
              "performance": "Faster than loop for count > 4"
            },
            "examples": [
              {
                "code": "VAR\n  BYTE buffer[256]\n  \nPUB clear_buffer()\n  BYTEFILL(@buffer, 0, 256)\n",
                "description": "Clear buffer to zeros"
              },
              {
                "code": "VAR\n  BYTE screen[80 * 25]\n  \nPUB clear_screen()\n  BYTEFILL(@screen, \" \", 80 * 25)\n",
                "description": "Clear text screen with spaces"
              },
              {
                "code": "VAR\n  BYTE line[100]\n  \nPUB draw_horizontal_line(char)\n  BYTEFILL(@line, char, 100)\n",
                "description": "Create line of characters"
              },
              {
                "code": "' Initialize lookup table\nVAR\n  BYTE lookup[256]\n  \nPUB init_table()\n  BYTEFILL(@lookup, $FF, 256)  ' All entries invalid\n  ' Then set specific valid entries\n  lookup[10] := 1\n  lookup[20] := 2\n",
                "description": "Initialize lookup table"
              },
              {
                "code": "' Create test pattern\nVAR\n  BYTE pattern[1000]\n  \nPUB create_pattern()\n  BYTEFILL(@pattern[0], $AA, 500)\n  BYTEFILL(@pattern[500], $55, 500)\n",
                "description": "Create alternating pattern"
              }
            ],
            "common_uses": [
              "Buffer initialization",
              "Memory clearing",
              "Screen/display clearing",
              "Array initialization",
              "Pattern generation",
              "Padding operations"
            ],
            "typical_values": {
              "0": "Clear/zero memory",
              "32": "ASCII space for text",
              "255": "All bits set ($FF)",
              "$AA": "Alternating bits (10101010)",
              "$55": "Alternating bits (01010101)"
            },
            "related_methods": [
              "WORDFILL - Fill with word value",
              "LONGFILL - Fill with long value",
              "BYTEMOVE - Copy bytes",
              "BYTECOMP - Compare bytes"
            ],
            "performance_comparison": {
              "manual_loop": "' Slower for large counts\nREPEAT i FROM 0 TO count-1\n  BYTE[dest][i] := value\n  \n",
              "bytefill": "' Optimized implementation\nBYTEFILL(dest, value, count)\n' 3-10x faster for count > 10\n"
            },
            "notes": [
              "Only uses lower 8 bits of value",
              "Count of 0 is safe (no operation)",
              "No bounds checking on addresses",
              "Cannot fill cog or LUT RAM",
              "Sequential fill only"
            ],
            "best_practices": [
              "Use for initialization, not computation",
              "Clear sensitive data after use",
              "Initialize buffers before first use",
              "Use appropriate fill value for data type"
            ],
            "warnings": [
              "Ensure destination has enough space",
              "Address validation is programmer's responsibility",
              "Overwrites existing data without backup"
            ],
            "see_also": [
              "language/spin2/methods/wordfill.yaml",
              "language/spin2/methods/longfill.yaml",
              "language/spin2/methods/bytemove.yaml"
            ]
          },
          "PINLOW": {
            "method": "PINLOW",
            "aliases": [
              "PINL"
            ],
            "category": "pin_control",
            "type": "method",
            "description": "Drive specified pin(s) low (output mode, logic 0).\nSets the direction bit(s) to output (DIR=1) and drives the pin(s) low (OUT=0).\nThis is equivalent to the PASM2 DIRL instruction.\n",
            "syntax": "PINLOW(PinField)",
            "parameters": [
              {
                "name": "PinField",
                "type": "pin_field",
                "description": "Specifies which pin(s) to drive low. Can be:\n- Single pin number (0-63)\n- Pin range using '..' operator (Bottom..Top)\n- Multiple pins using ADDPINS operator\n- Variable or expression that evaluates to a pin field\n"
              }
            ],
            "returns": "none",
            "timing": {
              "execution": "2 clock cycles in cog execution",
              "hub_access": "8-19 clock cycles when executed from hub"
            },
            "examples": [
              {
                "code": "PINLOW(56)",
                "description": "Drive pin 56 low (turn off LED)"
              },
              {
                "code": "PINLOW(0 ADDPINS 7)",
                "description": "Drive pins 0 through 7 low simultaneously"
              },
              {
                "code": "PINLOW(49..40)",
                "description": "Drive pins 40 through 49 low (wraps if needed)"
              },
              {
                "code": "VAR\n  LONG led_pin\nPUB main()\n  led_pin := 56\n  PINLOW(led_pin)\n",
                "description": "Use a variable for the pin number"
              }
            ],
            "underlying_pasm": {
              "instruction": "DIRL",
              "description": "Internally uses DIRL instruction which sets DIR=1 and OUT=0"
            },
            "common_uses": [
              "Turn off LEDs",
              "Pull signals to ground",
              "Assert active-low control signals",
              "Create logic 0 for communication"
            ],
            "related_methods": [
              "PINHIGH - Drive pin(s) high",
              "PINTOGGLE - Toggle pin state",
              "PINFLOAT - Release pin to high-impedance",
              "PINWRITE - Write specific value to pins"
            ],
            "notes": [
              "Pin becomes an output if it wasn't already",
              "Overrides any smart pin mode on the pin",
              "Pin will remain low until explicitly changed",
              "Multiple pins can be controlled simultaneously",
              "Useful for Charlieplexing one side of LED matrix"
            ],
            "see_also": [
              "language/pasm2/dirl.yaml",
              "language/spin2/methods/pinhigh.yaml",
              "language/spin2/methods/pintoggle.yaml"
            ]
          },
          "MULDIV64": {
            "method": "MULDIV64",
            "type": "method",
            "description": "Multiply then divide with 64-bit intermediate result\n",
            "category": "Math/CORDIC Operations",
            "syntax": "result := MULDIV64(Multiplier, Multiplicand, Divisor)",
            "parameters": [
              {
                "name": "Multiplier",
                "type": "long",
                "description": "First value to multiply (32-bit signed)"
              },
              {
                "name": "Multiplicand",
                "type": "long",
                "description": "Second value to multiply (32-bit signed)"
              },
              {
                "name": "Divisor",
                "type": "long",
                "description": "Value to divide by (32-bit signed, non-zero)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Result of (Multiplier \u00d7 Multiplicand) \u00f7 Divisor"
            },
            "examples": [
              {
                "code": "' Scale value without overflow\nscaled := MULDIV64(value, 1000, 1024)  ' value*1000/1024\n",
                "description": "Scale value precisely"
              },
              {
                "code": "' Calculate percentage\npercent := MULDIV64(part, 100, total)\n",
                "description": "Calculate percentage without overflow"
              },
              {
                "code": "' Frequency calculation\nfreq := MULDIV64(clkfreq, numerator, denominator)\n",
                "description": "Calculate precise frequency"
              },
              {
                "code": "' Fixed-point math\nresult := MULDIV64(a, b, $1_0000)  ' Multiply with 16.16 fixed point\n",
                "description": "Fixed-point multiplication"
              }
            ],
            "notes": [
              "Prevents overflow in intermediate calculation",
              "Uses 64-bit intermediate result",
              "All parameters are 32-bit signed",
              "Division by zero returns 0",
              "Useful for scaling and ratio calculations",
              "More precise than (a*b)/c for large values"
            ],
            "timing": {
              "description": "Multi-cycle operation",
              "cycles": "~50-60 clock cycles"
            },
            "related": [
              "QLOG",
              "QEXP"
            ],
            "see_also": [
              "Extended precision math",
              "Scaling operations",
              "Fixed-point arithmetic"
            ]
          },
          "POLLCT": {
            "method": "POLLCT",
            "type": "method",
            "description": "Check if system counter has passed specified tick value\n",
            "category": "Timing Operations",
            "syntax": "result := POLLCT(Tick)",
            "parameters": [
              {
                "name": "Tick",
                "type": "long",
                "description": "32-bit system counter target value to check"
              }
            ],
            "returns": {
              "type": "integer",
              "description": "TRUE (-1) if tick has passed, FALSE (0) if not yet"
            },
            "examples": [
              {
                "code": "' Non-blocking timeout check\ntimeout := GETCT() + clkfreq  ' 1 second timeout\nrepeat\n  ' Do work...\n  if POLLCT(timeout)\n    ' Timeout occurred\n    quit\n",
                "description": "Implement non-blocking timeout"
              },
              {
                "code": "' Check if delay has elapsed\nstart_time := GETCT()\nend_time := start_time + clkfreq/10\nrepeat while not POLLCT(end_time)\n  ' Do other work while waiting\n",
                "description": "Non-blocking delay with work"
              },
              {
                "code": "' Multiple timer management\nrepeat\n  if POLLCT(timer1)\n    handle_timer1()\n    timer1 += period1\n  if POLLCT(timer2)\n    handle_timer2()\n    timer2 += period2\n",
                "description": "Manage multiple software timers"
              }
            ],
            "notes": [
              "Non-blocking alternative to WAITCT",
              "Returns immediately with TRUE/FALSE result",
              "Handles counter wraparound correctly",
              "Useful for implementing timeouts",
              "Can check multiple timers in same loop",
              "TRUE means current counter >= target (accounting for wrap)"
            ],
            "timing": {
              "description": "Immediate return",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "WAITCT",
              "GETCT",
              "POLLATN"
            ],
            "see_also": [
              "System counter",
              "Non-blocking timing",
              "Timeout handling"
            ]
          },
          "STRCOPY": {
            "method": "STRCOPY",
            "type": "method",
            "description": "Copy null-terminated string with length limit\n",
            "category": "String Operations",
            "syntax": "STRCOPY(DestAddress, SourceAddress, MaxCount)",
            "parameters": [
              {
                "name": "DestAddress",
                "type": "address",
                "description": "Destination buffer address"
              },
              {
                "name": "SourceAddress",
                "type": "address",
                "description": "Source string address (null-terminated)"
              },
              {
                "name": "MaxCount",
                "type": "integer",
                "description": "Maximum characters to copy (including null)"
              }
            ],
            "returns": {
              "type": "void",
              "description": "No return value"
            },
            "examples": [
              {
                "code": "' Copy string with buffer limit\nSTRCOPY(@buffer, @source, 80)  ' Max 79 chars + null\n",
                "description": "Safe string copy with limit"
              },
              {
                "code": "' Copy user input\nSTRCOPY(@name, @input, 32)  ' Limit name to 31 chars\n",
                "description": "Copy with length protection"
              },
              {
                "code": "' Build compound string\nSTRCOPY(@message, STRING(\"Error: \"), 100)\n' Then append more...\n",
                "description": "Start building message"
              }
            ],
            "notes": [
              "Always null-terminates destination",
              "Stops at source null or MaxCount-1 characters",
              "MaxCount includes space for null terminator",
              "Prevents buffer overflow",
              "If MaxCount is 0, nothing is copied",
              "Destination buffer must be at least MaxCount bytes"
            ],
            "timing": {
              "description": "Varies with string length",
              "cycles": "~8 + (2 per character) clock cycles"
            },
            "related": [
              "STRCOMP",
              "STRSIZE",
              "BYTEMOVE",
              "STRING"
            ],
            "see_also": [
              "String operations",
              "Buffer management",
              "Safe string handling"
            ]
          },
          "LOCKNEW": {
            "method": "LOCKNEW",
            "type": "method",
            "description": "Allocate a new hardware lock for inter-cog synchronization\n",
            "category": "Lock Operations",
            "syntax": "lock_id := LOCKNEW()",
            "parameters": [],
            "returns": {
              "type": "integer",
              "description": "Lock ID (0..15) if successful, negative if no locks available"
            },
            "examples": [
              {
                "code": "' Allocate a new lock\nlock := LOCKNEW()\nif lock < 0\n  ' No locks available\n  abort\n",
                "description": "Allocate lock with error checking"
              },
              {
                "code": "' Initialize shared resource lock\nVAR\n  long buffer_lock\n\nPUB init()\n  buffer_lock := LOCKNEW()\n",
                "description": "Create lock for shared buffer"
              },
              {
                "code": "' Multiple locks for different resources\nspi_lock := LOCKNEW()\nuart_lock := LOCKNEW()\ni2c_lock := LOCKNEW()\n",
                "description": "Allocate multiple resource locks"
              }
            ],
            "notes": [
              "P2 has 16 hardware locks (0-15)",
              "Returns next available lock ID",
              "Returns negative value if all locks in use",
              "Lock is marked as allocated but not captured",
              "Must call LOCKRET when done to free lock",
              "Locks are shared across all cogs"
            ],
            "timing": {
              "description": "Hub operation",
              "cycles": "2-9 clock cycles"
            },
            "related": [
              "LOCKRET",
              "LOCKTRY",
              "LOCKREL",
              "LOCKCHK"
            ],
            "see_also": [
              "Hardware locks",
              "Inter-cog synchronization",
              "Resource sharing"
            ]
          },
          "QCOS": {
            "method": "QCOS",
            "type": "method",
            "description": "Calculate cosine of angle using hardware CORDIC\n",
            "category": "Math/CORDIC Operations",
            "syntax": "cosine := QCOS(Angle, Length)",
            "parameters": [
              {
                "name": "Angle",
                "type": "long",
                "description": "Angle in P2 angle units (0..$FFFFFFFF = 0..360\u00b0)"
              },
              {
                "name": "Length",
                "type": "long",
                "description": "Hypotenuse/radius length (scaling factor)"
              }
            ],
            "returns": {
              "type": "long",
              "description": "Cosine value scaled by Length"
            },
            "examples": [
              {
                "code": "' Calculate cosine of 60 degrees\ncosine := QCOS($2AAA_AAAA, 1000)  ' 60\u00b0 with scale 1000\n' Result: cosine \u2248 500\n",
                "description": "Basic cosine calculation"
              },
              {
                "code": "' Generate cosine wave\nrepeat angle from 0 to $FFFF_FFFF step $0100_0000\n  y := QCOS(angle, amplitude)\n  plot(x++, center_y + y)\n",
                "description": "Generate cosine wave plot"
              },
              {
                "code": "' Horizontal position for circular motion\nx_pos := center_x + QCOS(angle, radius)\n",
                "description": "Calculate X position on circle"
              }
            ],
            "notes": [
              "Uses P2's hardware CORDIC engine",
              "Angle units: $0000_0000 = 0\u00b0, $4000_0000 = 90\u00b0, $8000_0000 = 180\u00b0",
              "Result = Length \u00d7 cos(Angle)",
              "Full 32-bit precision",
              "38-clock cycle operation",
              "Handles all quadrants correctly"
            ],
            "timing": {
              "description": "CORDIC operation",
              "cycles": "38 clock cycles"
            },
            "related": [
              "QSIN",
              "ROTXY",
              "POLXY"
            ],
            "see_also": [
              "CORDIC operations",
              "Trigonometric functions",
              "Waveform generation"
            ]
          }
        }
      },
      "registers": {
        "count": 25,
        "elements": {
          "IRET3": {
            "register": "IRET3",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 return vector\n",
            "examples": [
              "IRET3 := saved_address"
            ],
            "address": "497",
            "access": "read_write"
          },
          "DIRB": {
            "register": "DIRB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register B (pins 32-63)\n",
            "examples": [
              "DIRB := $FF000000  // Set pins 56-63 as outputs"
            ],
            "address": "507",
            "access": "read_write"
          },
          "PR1": {
            "register": "PR1",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 1\n",
            "examples": [
              "PR1 := counter",
              "temp := PR1"
            ],
            "address": "497",
            "access": "read_write"
          },
          "OUTB": {
            "register": "OUTB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register B (pins 32-63)\n",
            "examples": [
              "OUTB := high_pin_states"
            ],
            "address": "509",
            "access": "read_write"
          },
          "PR0": {
            "register": "PR0",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 0\n",
            "examples": [
              "PR0 := value",
              "result := PR0"
            ],
            "address": "496",
            "access": "read_write"
          },
          "PTRA": {
            "register": "PTRA",
            "type": "register",
            "category": "Special Function",
            "description": "Pointer A register\n",
            "examples": [
              "PTRA := @buffer",
              "RDLONG value, PTRA++"
            ],
            "address": "504",
            "access": "read_write"
          },
          "TASKHLT": {
            "register": "TASKHLT",
            "type": "register",
            "category": "Task Management",
            "description": "Task halt register (v47+)\n",
            "examples": [
              "TASKHLT := task_flags"
            ],
            "address": "512",
            "access": "read_write"
          },
          "IRET2": {
            "register": "IRET2",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 return vector\n",
            "examples": [
              "IRET2 := return_point"
            ],
            "address": "499",
            "access": "read_write"
          },
          "PR7": {
            "register": "PR7",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 7\n",
            "examples": [
              "PR7 := working_value"
            ],
            "address": "503",
            "access": "read_write"
          },
          "PA": {
            "register": "PA",
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter A / call target\n",
            "examples": [
              "PA := @subroutine",
              "CALL PA"
            ],
            "address": "502",
            "access": "read_write"
          },
          "IJMP1": {
            "register": "IJMP1",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 jump vector\n",
            "examples": [
              "IJMP1 := @interrupt1_handler"
            ],
            "address": "500",
            "access": "read_write"
          },
          "PR6": {
            "register": "PR6",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 6\n",
            "examples": [
              "PR6 := state_machine"
            ],
            "address": "502",
            "access": "read_write"
          },
          "INB": {
            "register": "INB",
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register B (pins 32-63)\n",
            "examples": [
              "sensor_data := INB"
            ],
            "address": "511",
            "access": "read"
          },
          "IJMP3": {
            "register": "IJMP3",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 3 jump vector\n",
            "examples": [
              "IJMP3 := @interrupt3_handler"
            ],
            "address": "496",
            "access": "read_write"
          },
          "PR5": {
            "register": "PR5",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 5\n",
            "examples": [
              "PR5 := loop_count"
            ],
            "address": "501",
            "access": "read_write"
          },
          "INA": {
            "register": "INA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Input register A (pins 0-31)\n",
            "examples": [
              "button_state := INA[button_pin]"
            ],
            "address": "510",
            "access": "read"
          },
          "PR4": {
            "register": "PR4",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 4\n",
            "examples": [
              "PR4 := data_length"
            ],
            "address": "500",
            "access": "read_write"
          },
          "PB": {
            "register": "PB",
            "type": "register",
            "category": "Call Targets",
            "description": "Parameter B / call target\n",
            "examples": [
              "PB := @function",
              "CALL PB"
            ],
            "address": "503",
            "access": "read_write"
          },
          "IJMP2": {
            "register": "IJMP2",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 2 jump vector\n",
            "examples": [
              "IJMP2 := @interrupt2_handler"
            ],
            "address": "498",
            "access": "read_write"
          },
          "IRET1": {
            "register": "IRET1",
            "type": "register",
            "category": "Interrupt Vectors",
            "description": "Interrupt 1 return vector\n",
            "examples": [
              "IRET1 := stored_pc"
            ],
            "address": "501",
            "access": "read_write"
          },
          "OUTA": {
            "register": "OUTA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Output register A (pins 0-31)\n",
            "examples": [
              "OUTA := led_pattern",
              "!OUTA[led_pin]"
            ],
            "address": "508",
            "access": "read_write"
          },
          "PR3": {
            "register": "PR3",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 3\n",
            "examples": [
              "PR3 := status_flags"
            ],
            "address": "499",
            "access": "read_write"
          },
          "PTRB": {
            "register": "PTRB",
            "type": "register",
            "category": "Special Function",
            "description": "Pointer B register\n",
            "examples": [
              "PTRB := @array",
              "WRLONG data, PTRB++"
            ],
            "address": "505",
            "access": "read_write"
          },
          "DIRA": {
            "register": "DIRA",
            "type": "register",
            "category": "I/O Registers",
            "description": "Direction register A (pins 0-31)\n",
            "examples": [
              "DIRA := %11111111  // Set pins 0-7 as outputs"
            ],
            "address": "506",
            "access": "read_write"
          },
          "PR2": {
            "register": "PR2",
            "type": "register",
            "category": "General Purpose",
            "description": "General purpose register 2\n",
            "examples": [
              "PR2 := buffer_ptr"
            ],
            "address": "498",
            "access": "read_write"
          }
        }
      },
      "assembly_directives": {
        "count": 12,
        "elements": {
          "ALIGNL": {
            "directive": "ALIGNL",
            "type": "assembly_directive",
            "description": "ALIGNL aligns the next data element to the beginning of the next long of Hub RAM. ALIGNL is important to use when code requires certain data to begin on a long boundary (for access convenience and speed). The directive causes up to three zero ($00) bytes to emit after the current data to automatically pad and align the next data element to a long boundary.",
            "brief_description": "T2        WORD $2222",
            "syntax": "ALIGNL",
            "category": "Directive - Align to next long in Hub RAM",
            "parameters": [
              "No parameters - This directive takes no arguments"
            ],
            "usage_notes": "ALIGNL is only allowed in DAT blocks, not in in-line PASM.\n\nWhen data elements are naturally packed in memory, they may not align to convenient boundaries.\nIf code that accesses data expects it to align with a long boundary (for convenience or speed),\nthe ALIGNL directive achieves this by emitting 0-3 zero bytes as padding.\n\nNote that elements after the ALIGNL are still packed right after each other, which may require\nfurther alignment directives depending on the needs of the code accessing them.\n",
            "examples": [
              {
                "code": "DAT\n  T1        BYTE $11\n            ALIGNL          ' Pad to next long boundary\n  T2        WORD $2222\n            LONG $33333333\n",
                "comment": "Aligns T2 to start at a long boundary by padding after T1"
              },
              {
                "code": "DAT\n  Buffer    BYTE 0[13]      ' 13-byte buffer\n            ALIGNL          ' Ensure next data is long-aligned\n  LongData  LONG $12345678\n",
                "comment": "Ensures LongData starts on a long boundary for faster access"
              }
            ],
            "memory_layout_example": "Without ALIGNL:\n  L0                          L1                          L2\n  W0        W1        W2        W3        W4        W5\n  B0    B1    B2    B3    B4    B5    B6    B7    B8    B9    B10   B11\n  $11   $22   $22   $33   $33   $33   $33   --    --    --    --    --\n\nWith ALIGNL after BYTE $11:\n  L0                          L1                          L2  \n  W0        W1        W2        W3        W4        W5\n  B0    B1    B2    B3    B4    B5    B6    B7    B8    B9    B10   B11\n  $11   $00   $00   $00   $22   $22   $33   $33   $33   $33   --    --\n       [<-- padding -->]\n",
            "group": "Assembly",
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive",
            "related": [
              "ALIGNW",
              "BYTE",
              "WORD",
              "LONG"
            ],
            "last_updated": "2025-09-19",
            "manual_extraction_date": "2025-01-19"
          },
          "FIT": {
            "directive": "FIT",
            "type": "assembly_directive",
            "description": "Ensure code fits in specified limit\n",
            "syntax": "['FIT limit']",
            "examples": [
              "FIT $1F0  // Must fit in COG space"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.648005"
          },
          "ORGH": {
            "directive": "ORGH",
            "type": "assembly_directive",
            "description": "Set origin address for hub RAM\n",
            "syntax": "['ORGH address']",
            "examples": [
              "ORGH $400  // Start at hub address $400"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.648610"
          },
          "DITTO": {
            "directive": "DITTO",
            "type": "assembly_directive",
            "description": "Repeat last instruction (v50+)\n",
            "syntax": "['DITTO']",
            "examples": [
              "DITTO  // Repeat previous instruction"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.649232"
          },
          "Include Binary File": {
            "directive": "FILE",
            "name": "Include Binary File",
            "description": "Include the contents of an external binary file into Hub memory at assembly time",
            "syntax": "FILE \"filename\"",
            "examples": [
              "FILE  \"image.bmp\"      ; Include bitmap file",
              "FILE  \"data.bin\"       ; Include binary data",
              "FILE  \"font8x8.dat\"    ; Include font data",
              "datastart  FILE \"config.dat\"  ; Label the included data"
            ],
            "usage": "FILE is used in DAT sections to include the entire contents of an external\nbinary file directly into Hub memory. The file path is relative to the\nsource file location. This is useful for including images, fonts, lookup\ntables, or other pre-compiled binary data. The data is inserted byte-for-byte\nexactly as it appears in the file.\n",
            "alignment": "File data begins at the current assembly position without automatic alignment.\nUse ALIGNL or ALIGNW before FILE if specific alignment is needed for the data.\n",
            "limitations": [
              "File must exist at compile time",
              "Entire file contents are included",
              "No partial file inclusion available"
            ],
            "see_also": [
              "BYTE",
              "WORD",
              "LONG",
              "ALIGNL"
            ],
            "documentation_source": "PASM2 Manual 2022-11-01",
            "created_date": "2025-09-19",
            "group": "Data Declaration",
            "last_updated": "2025-09-19T16:04:17.650517"
          },
          "ALIGNW": {
            "directive": "ALIGNW",
            "type": "assembly_directive",
            "description": "ALIGNW aligns the next data element to the beginning of the next word of Hub RAM. ALIGNW is important to use when code requires certain data to begin on a word boundary (for access convenience and speed). The directive causes zero or one byte ($00) to emit after the current data to automatically pad and align the next data element to a word boundary.",
            "brief_description": "T2        WORD $2222",
            "syntax": "ALIGNW",
            "category": "Directive - Align to next word in Hub RAM",
            "parameters": [
              "No parameters - This directive takes no arguments"
            ],
            "usage_notes": "ALIGNW is only allowed in DAT blocks, not in in-line PASM.\n\nWhen data elements are naturally packed in memory, they may not align to convenient boundaries.\nIf code that accesses data expects it to align with a word boundary (for convenience or speed),\nthe ALIGNW directive achieves this by emitting 0-1 zero bytes as padding.\n\nNote that elements after the ALIGNW are still packed right after each other, which may require\nfurther alignment directives depending on the needs of the code accessing them.\n",
            "examples": [
              {
                "code": "DAT\n  T1        BYTE $11\n            ALIGNW          ' Pad to next word boundary\n  T2        WORD $2222\n            LONG $33333333\n",
                "comment": "Aligns T2 to start at a word boundary by padding after T1"
              },
              {
                "code": "DAT\n  Buffer    BYTE 0[7]       ' 7-byte buffer\n            ALIGNW          ' Ensure next data is word-aligned  \n  WordData  WORD $1234\n",
                "comment": "Ensures WordData starts on a word boundary for faster access"
              }
            ],
            "memory_layout_example": "Without ALIGNW:\n  L0                          L1                          L2\n  W0        W1        W2        W3        W4        W5\n  B0    B1    B2    B3    B4    B5    B6    B7    B8    B9    B10   B11\n  $11   $22   $22   $33   $33   $33   $33   --    --    --    --    --\n\nWith ALIGNW after BYTE $11:\n  L0                          L1                          L2\n  W0        W1        W2        W3        W4        W5  \n  B0    B1    B2    B3    B4    B5    B6    B7    B8    B9    B10   B11\n  $11   $00   $22   $22   $33   $33   $33   $33   --    --    --    --\n       [pad]\n",
            "group": "Assembly",
            "documentation_source": "PASM2 Manual 2022/11/01 Pages 31-147",
            "documentation_level": "comprehensive",
            "related": [
              "ALIGNL",
              "BYTE",
              "WORD",
              "LONG"
            ],
            "last_updated": "2025-09-19",
            "manual_extraction_date": "2025-01-19"
          },
          "Insert Byte Data": {
            "directive": "BYTE",
            "name": "Insert Byte Data",
            "description": "Insert byte data into Hub memory at assembly time",
            "syntax": "BYTE value1 {, value2, ...}",
            "examples": [
              "BYTE  $FF              ; Single byte value",
              "BYTE  10, 20, 30       ; Multiple byte values",
              "BYTE  \"Hello\", 0       ; String with null terminator",
              "BYTE  value[16]        ; Duplicate value 16 times"
            ],
            "usage": "BYTE is used in DAT sections to define byte-sized data values that will\nbe stored in Hub memory. Multiple values can be specified separated by commas.\nStrings are automatically converted to their byte values.\n",
            "alignment": "Bytes are packed sequentially without padding",
            "see_also": [
              "WORD",
              "LONG",
              "ALIGNL",
              "ALIGNW"
            ],
            "documentation_source": "PASM2 Manual 2022-11-01",
            "created_date": "2025-09-19",
            "group": "Data Declaration",
            "last_updated": "2025-09-19T16:04:17.652869"
          },
          "Insert Word Data": {
            "directive": "WORD",
            "name": "Insert Word Data",
            "description": "Insert word (16-bit) data into Hub memory at assembly time",
            "syntax": "WORD value1 {, value2, ...}",
            "examples": [
              "WORD  $1234            ; Single word value",
              "WORD  1000, 2000, 3000 ; Multiple word values",
              "WORD  value[8]          ; Duplicate value 8 times",
              "WORD  (@label - @base) >> 1  ; Address calculation"
            ],
            "usage": "WORD is used in DAT sections to define word-sized (16-bit) data values that\nwill be stored in Hub memory. Multiple values can be specified separated by\ncommas. Words are stored in little-endian format.\n",
            "alignment": "Words may not be aligned unless preceded by ALIGNW. Using ALIGNW before\nWORD data ensures proper word alignment for efficient access.\n",
            "see_also": [
              "BYTE",
              "LONG",
              "ALIGNW",
              "ALIGNL"
            ],
            "documentation_source": "PASM2 Manual 2022-11-01",
            "created_date": "2025-09-19",
            "group": "Data Declaration",
            "last_updated": "2025-09-19T16:04:17.654277"
          },
          "ORGF": {
            "directive": "ORGF",
            "type": "assembly_directive",
            "description": "Set origin address with forced alignment\n",
            "syntax": "['ORGF address']",
            "examples": [
              "ORGF $100  // Align to address $100"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.655294"
          },
          "Insert Long Data": {
            "directive": "LONG",
            "name": "Insert Long Data",
            "description": "Insert long (32-bit) data into Hub memory at assembly time",
            "syntax": "LONG value1 {, value2, ...}",
            "examples": [
              "LONG  $12345678        ; Single long value",
              "LONG  -1, 0, 1         ; Multiple long values",
              "LONG  value[4]          ; Duplicate value 4 times",
              "LONG  @label            ; Address of label",
              "LONG  %%3210            ; Quaternary literal"
            ],
            "usage": "LONG is used in DAT sections to define long-sized (32-bit) data values that\nwill be stored in Hub memory. Multiple values can be specified separated by\ncommas. This is the native data size for P2 operations. Longs are stored\nin little-endian format.\n",
            "alignment": "Longs may not be aligned unless preceded by ALIGNL. Using ALIGNL before\nLONG data ensures proper long alignment for efficient access and is\nespecially important for data that will be accessed as longs.\n",
            "see_also": [
              "BYTE",
              "WORD",
              "ALIGNL",
              "RES"
            ],
            "documentation_source": "PASM2 Manual 2022-11-01",
            "created_date": "2025-09-19",
            "group": "Data Declaration",
            "last_updated": "2025-09-19T16:04:17.656499"
          },
          "RES": {
            "directive": "RES",
            "type": "assembly_directive",
            "description": "Reserve space (advance origin)\n",
            "syntax": "['RES count']",
            "examples": [
              "RES 16  // Reserve 16 locations"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.657587"
          },
          "ORG": {
            "directive": "ORG",
            "type": "assembly_directive",
            "description": "Set origin address for COG RAM\n",
            "syntax": "['ORG address']",
            "examples": [
              "ORG 0  // Start at COG address 0"
            ],
            "group": "Assembly",
            "last_updated": "2025-09-19T16:04:17.658205"
          }
        }
      },
      "debug_commands": {
        "count": 23,
        "elements": {
          "SDEC_BYTE": {
            "command": "SDEC_BYTE",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal byte format\n",
            "syntax": "['SDEC_BYTE(value)']",
            "examples": [
              "DEBUG(SDEC_BYTE(offset))"
            ]
          },
          "UDEC_LONG": {
            "command": "UDEC_LONG",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal long format\n",
            "syntax": "['UDEC_LONG(value)']",
            "examples": [
              "DEBUG(UDEC_LONG(timestamp))"
            ]
          },
          "UDEC_WORD": {
            "command": "UDEC_WORD",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal word format\n",
            "syntax": "['UDEC_WORD(value)']",
            "examples": [
              "DEBUG(UDEC_WORD(address))"
            ]
          },
          "UBIN": {
            "command": "UBIN",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary format\n",
            "syntax": "['UBIN(value)']",
            "examples": [
              "DEBUG(UBIN(mask))"
            ]
          },
          "PC_KEY": {
            "command": "PC_KEY",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC keyboard input\n",
            "syntax": "['PC_KEY']",
            "examples": [
              "DEBUG(PC_KEY)"
            ]
          },
          "BOOL": {
            "command": "BOOL",
            "type": "debug_command",
            "category": "Boolean Format",
            "description": "Boolean format (v44+)\n",
            "syntax": "['BOOL(value)']",
            "examples": [
              "DEBUG(BOOL(flag))"
            ]
          },
          "SDEC_WORD": {
            "command": "SDEC_WORD",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal word format\n",
            "syntax": "['SDEC_WORD(value)']",
            "examples": [
              "DEBUG(SDEC_WORD(delta))"
            ]
          },
          "UDEC_BYTE": {
            "command": "UDEC_BYTE",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal byte format\n",
            "syntax": "['UDEC_BYTE(value)']",
            "examples": [
              "DEBUG(UDEC_BYTE(status))"
            ]
          },
          "DLY": {
            "command": "DLY",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug delay command\n",
            "syntax": "['DLY(milliseconds)']",
            "examples": [
              "DEBUG(DLY(100))"
            ]
          },
          "SDEC": {
            "command": "SDEC",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal format\n",
            "syntax": "['SDEC(value)']",
            "examples": [
              "DEBUG(SDEC(temperature))"
            ]
          },
          "SDEC_LONG": {
            "command": "SDEC_LONG",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Signed decimal long format\n",
            "syntax": "['SDEC_LONG(value)']",
            "examples": [
              "DEBUG(SDEC_LONG(position))"
            ]
          },
          "UHEX": {
            "command": "UHEX",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal format\n",
            "syntax": "['UHEX(value)']",
            "examples": [
              "DEBUG(UHEX(address))"
            ]
          },
          "PC_MOUSE": {
            "command": "PC_MOUSE",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "PC mouse input\n",
            "syntax": "['PC_MOUSE']",
            "examples": [
              "DEBUG(PC_MOUSE)"
            ]
          },
          "DEBUG": {
            "command": "DEBUG",
            "type": "debug_command",
            "category": "Debug Control",
            "description": "Debug output statement\n",
            "syntax": "['DEBUG (expressions)']",
            "examples": [
              "DEBUG(\"Value:\", value)"
            ]
          },
          "UDEC": {
            "command": "UDEC",
            "type": "debug_command",
            "category": "Decimal Format",
            "description": "Unsigned decimal format\n",
            "syntax": "['UDEC(value)']",
            "examples": [
              "DEBUG(UDEC(counter))"
            ]
          },
          "LSTR": {
            "command": "LSTR",
            "type": "debug_command",
            "category": "String Format",
            "description": "Length-prefixed string\n",
            "syntax": "['LSTR(string_ptr)']",
            "examples": [
              "DEBUG(LSTR(@buffer))"
            ]
          },
          "UBIN_BYTE": {
            "command": "UBIN_BYTE",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary byte format\n",
            "syntax": "['UBIN_BYTE(value)']",
            "examples": [
              "DEBUG(UBIN_BYTE(pattern))"
            ]
          },
          "ZSTR": {
            "command": "ZSTR",
            "type": "debug_command",
            "category": "String Format",
            "description": "Zero-terminated string\n",
            "syntax": "['ZSTR(string_ptr)']",
            "examples": [
              "DEBUG(ZSTR(@message))"
            ]
          },
          "UHEX_BYTE": {
            "command": "UHEX_BYTE",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal byte format\n",
            "syntax": "['UHEX_BYTE(value)']",
            "examples": [
              "DEBUG(UHEX_BYTE(flags))"
            ]
          },
          "UBIN_WORD": {
            "command": "UBIN_WORD",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary word format\n",
            "syntax": "['UBIN_WORD(value)']",
            "examples": [
              "DEBUG(UBIN_WORD(config))"
            ]
          },
          "UBIN_LONG": {
            "command": "UBIN_LONG",
            "type": "debug_command",
            "category": "Binary Format",
            "description": "Unsigned binary long format\n",
            "syntax": "['UBIN_LONG(value)']",
            "examples": [
              "DEBUG(UBIN_LONG(bitfield))"
            ]
          },
          "UHEX_LONG": {
            "command": "UHEX_LONG",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal long format\n",
            "syntax": "['UHEX_LONG(value)']",
            "examples": [
              "DEBUG(UHEX_LONG(register))"
            ]
          },
          "UHEX_WORD": {
            "command": "UHEX_WORD",
            "type": "debug_command",
            "category": "Hexadecimal Format",
            "description": "Unsigned hexadecimal word format\n",
            "syntax": "['UHEX_WORD(value)']",
            "examples": [
              "DEBUG(UHEX_WORD(port))"
            ]
          }
        }
      },
      "special_symbols": {
        "count": 12,
        "elements": {
          ".": {
            "symbol": ".",
            "type": "special_symbol",
            "category": "Special",
            "description": "Decimal point or object method access\n",
            "examples": [
              "float_val := 3.14",
              "obj.method()"
            ]
          },
          "`": {
            "symbol": "`",
            "type": "special_symbol",
            "category": "Special",
            "description": "Tick operator for special formatting\n",
            "examples": [
              "`expression"
            ]
          },
          "@@": {
            "symbol": "@@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Absolute address operator - get absolute hub address\n",
            "examples": [
              "hub_addr := @@variable"
            ]
          },
          "..": {
            "symbol": "..",
            "type": "special_symbol",
            "category": "Special",
            "description": "Range operator for CASE statements\n",
            "examples": [
              "CASE value\n  1..10: low_range()\n  11..20: high_range()"
            ]
          },
          "^@": {
            "symbol": "^@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Object address operator - address within object\n",
            "examples": [
              "obj_addr := ^@method"
            ]
          },
          "~": {
            "symbol": "~",
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-clear operator - use value then clear\n",
            "examples": [
              "value := ~flag  // use flag then clear it"
            ]
          },
          "@": {
            "symbol": "@",
            "type": "special_symbol",
            "category": "Special",
            "description": "Address-of operator - get memory address\n",
            "examples": [
              "ptr := @variable",
              "COGINIT(0, @assembly_code, @params)"
            ]
          },
          "%": {
            "symbol": "%",
            "type": "special_symbol",
            "category": "Special",
            "description": "Binary number prefix\n",
            "examples": [
              "mask := %11110000",
              "pattern := %1010_1010"
            ]
          },
          "_": {
            "symbol": "_",
            "type": "special_symbol",
            "category": "Special",
            "description": "Digit separator in numeric literals\n",
            "examples": [
              "freq := 80_000_000",
              "mask := %1111_0000_1111_0000"
            ]
          },
          "$$": {
            "symbol": "$$",
            "type": "special_symbol",
            "category": "Special",
            "description": "Current assembly address\n",
            "examples": [
              "distance := target - $$"
            ]
          },
          "~~": {
            "symbol": "~~",
            "type": "special_symbol",
            "category": "Special",
            "description": "Post-set operator - use value then set to -1\n",
            "examples": [
              "value := ~~flag  // use flag then set to -1"
            ]
          },
          "$": {
            "symbol": "$",
            "type": "special_symbol",
            "category": "Special",
            "description": "Hexadecimal number prefix\n",
            "examples": [
              "value := $FF",
              "address := $1000"
            ]
          }
        }
      },
      "system_variables": {
        "count": 3,
        "elements": {
          "CLKFREQ": {
            "variable": "CLKFREQ",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "System clock frequency in Hz\n",
            "access": "read_write",
            "examples": [
              "CLKFREQ := 80_000_000  // 80MHz"
            ]
          },
          "VARBASE": {
            "variable": "VARBASE",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "Base address of VAR section\n",
            "access": "read",
            "examples": [
              "var_start := VARBASE"
            ]
          },
          "CLKMODE": {
            "variable": "CLKMODE",
            "type": "system_variable",
            "data_type": "Unknown",
            "description": "System clock mode configuration\n",
            "access": "read_write",
            "examples": [
              "CLKMODE := %0_0000_01_101_111_1_1  // 80MHz"
            ]
          }
        }
      }
    },
    "statistics": {
      "total_elements": 272,
      "by_category": {
        "keywords": 36,
        "operators": 74,
        "methods": 87,
        "registers": 25,
        "assembly_directives": 12,
        "debug_commands": 23,
        "special_symbols": 12,
        "system_variables": 3
      }
    }
  }
}